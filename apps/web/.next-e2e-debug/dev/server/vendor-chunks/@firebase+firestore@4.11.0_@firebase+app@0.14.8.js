"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@firebase+firestore@4.11.0_@firebase+app@0.14.8";
exports.ids = ["vendor-chunks/@firebase+firestore@4.11.0_@firebase+app@0.14.8"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@firebase+firestore@4.11.0_@firebase+app@0.14.8/node_modules/@firebase/firestore/dist/common-270e6a50.node.mjs":
/*!***********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@firebase+firestore@4.11.0_@firebase+app@0.14.8/node_modules/@firebase/firestore/dist/common-270e6a50.node.mjs ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ parseUpdateVarargs),\n/* harmony export */   A: () => (/* binding */ AbstractUserDataWriter),\n/* harmony export */   B: () => (/* binding */ Bytes),\n/* harmony export */   C: () => (/* binding */ CompositeFilter),\n/* harmony export */   D: () => (/* binding */ DocumentReference),\n/* harmony export */   E: () => (/* binding */ cast),\n/* harmony export */   F: () => (/* binding */ Firestore),\n/* harmony export */   G: () => (/* binding */ ensureFirestoreConfigured),\n/* harmony export */   H: () => (/* binding */ mapToArray),\n/* harmony export */   I: () => (/* binding */ firestoreClientRunAggregateQuery),\n/* harmony export */   J: () => (/* binding */ ExpUserDataWriter),\n/* harmony export */   K: () => (/* binding */ validateJSON),\n/* harmony export */   L: () => (/* binding */ newSerializer),\n/* harmony export */   M: () => (/* binding */ createBundleReaderSync),\n/* harmony export */   N: () => (/* binding */ BundleLoader),\n/* harmony export */   O: () => (/* binding */ ObjectValue),\n/* harmony export */   P: () => (/* binding */ fromDocument),\n/* harmony export */   Q: () => (/* binding */ Query),\n/* harmony export */   R: () => (/* binding */ ResourcePath),\n/* harmony export */   S: () => (/* binding */ AutoId),\n/* harmony export */   T: () => (/* binding */ fromBundledQuery),\n/* harmony export */   U: () => (/* binding */ DocumentSet),\n/* harmony export */   V: () => (/* binding */ ViewSnapshot),\n/* harmony export */   W: () => (/* binding */ documentKeySet),\n/* harmony export */   X: () => (/* binding */ fail),\n/* harmony export */   Y: () => (/* binding */ parseSetData),\n/* harmony export */   Z: () => (/* binding */ Precondition),\n/* harmony export */   _: () => (/* binding */ FieldPath),\n/* harmony export */   a: () => (/* binding */ FirebaseAuthCredentialsProvider),\n/* harmony export */   a$: () => (/* binding */ disableNetwork),\n/* harmony export */   a0: () => (/* binding */ parseUpdateData),\n/* harmony export */   a1: () => (/* binding */ DeleteMutation),\n/* harmony export */   a2: () => (/* binding */ firestoreClientTransaction),\n/* harmony export */   a3: () => (/* binding */ firestoreClientGetDocumentViaSnapshotListener),\n/* harmony export */   a4: () => (/* binding */ firestoreClientGetDocumentFromLocalCache),\n/* harmony export */   a5: () => (/* binding */ firestoreClientGetDocumentsViaSnapshotListener),\n/* harmony export */   a6: () => (/* binding */ firestoreClientGetDocumentsFromLocalCache),\n/* harmony export */   a7: () => (/* binding */ doc),\n/* harmony export */   a8: () => (/* binding */ newQueryForPath),\n/* harmony export */   a9: () => (/* binding */ firestoreClientListen),\n/* harmony export */   aA: () => (/* binding */ toTimestamp),\n/* harmony export */   aB: () => (/* binding */ toQueryTarget),\n/* harmony export */   aC: () => (/* binding */ queryToTarget),\n/* harmony export */   aD: () => (/* binding */ parseObject),\n/* harmony export */   aE: () => (/* binding */ CACHE_SIZE_UNLIMITED),\n/* harmony export */   aF: () => (/* binding */ CollectionReference),\n/* harmony export */   aG: () => (/* binding */ FieldValue),\n/* harmony export */   aH: () => (/* binding */ GeoPoint),\n/* harmony export */   aI: () => (/* binding */ LoadBundleTask),\n/* harmony export */   aJ: () => (/* binding */ VectorValue),\n/* harmony export */   aK: () => (/* binding */ ByteString),\n/* harmony export */   aL: () => (/* binding */ DatabaseId),\n/* harmony export */   aM: () => (/* binding */ EmptyAppCheckTokenProvider),\n/* harmony export */   aN: () => (/* binding */ EmptyAuthCredentialsProvider),\n/* harmony export */   aO: () => (/* binding */ FieldPath$1),\n/* harmony export */   aP: () => (/* binding */ debugAssert),\n/* harmony export */   aQ: () => (/* binding */ _internalAggregationQueryToProtoRunAggregationQueryRequest),\n/* harmony export */   aR: () => (/* binding */ _internalQueryToProtoQueryTarget),\n/* harmony export */   aS: () => (/* binding */ isBase64Available),\n/* harmony export */   aT: () => (/* binding */ validateIsNotUsedTogether),\n/* harmony export */   aU: () => (/* binding */ arrayRemove),\n/* harmony export */   aV: () => (/* binding */ arrayUnion),\n/* harmony export */   aW: () => (/* binding */ clearIndexedDbPersistence),\n/* harmony export */   aX: () => (/* binding */ collection),\n/* harmony export */   aY: () => (/* binding */ collectionGroup),\n/* harmony export */   aZ: () => (/* binding */ connectFirestoreEmulator),\n/* harmony export */   a_: () => (/* binding */ deleteField),\n/* harmony export */   aa: () => (/* binding */ firestoreClientAddSnapshotsInSyncListener),\n/* harmony export */   ab: () => (/* binding */ firestoreClientWrite),\n/* harmony export */   ac: () => (/* binding */ logWarn),\n/* harmony export */   ad: () => (/* binding */ firestoreClientSetIndexConfiguration),\n/* harmony export */   ae: () => (/* binding */ fieldPathFromDotSeparatedString),\n/* harmony export */   af: () => (/* binding */ FieldIndex),\n/* harmony export */   ag: () => (/* binding */ IndexState),\n/* harmony export */   ah: () => (/* binding */ firestoreClientDeleteAllFieldIndexes),\n/* harmony export */   ai: () => (/* binding */ logDebug),\n/* harmony export */   aj: () => (/* binding */ firestoreClientSetPersistentCacheIndexAutoCreationEnabled),\n/* harmony export */   ak: () => (/* binding */ OrderBy),\n/* harmony export */   al: () => (/* binding */ AggregateImpl),\n/* harmony export */   am: () => (/* binding */ OnlineComponentProvider),\n/* harmony export */   an: () => (/* binding */ LruGcMemoryOfflineComponentProvider),\n/* harmony export */   ao: () => (/* binding */ MemoryOfflineComponentProvider),\n/* harmony export */   ap: () => (/* binding */ IndexedDbOfflineComponentProvider),\n/* harmony export */   aq: () => (/* binding */ MultiTabOfflineComponentProvider),\n/* harmony export */   ar: () => (/* binding */ loadBundle),\n/* harmony export */   as: () => (/* binding */ namedQuery),\n/* harmony export */   at: () => (/* binding */ IndexSegment),\n/* harmony export */   au: () => (/* binding */ setTestingHooksSpi),\n/* harmony export */   av: () => (/* binding */ Timestamp),\n/* harmony export */   aw: () => (/* binding */ JsonProtoSerializer),\n/* harmony export */   ax: () => (/* binding */ UserDataReader),\n/* harmony export */   ay: () => (/* binding */ fromTimestamp),\n/* harmony export */   az: () => (/* binding */ toName),\n/* harmony export */   b: () => (/* binding */ FirebaseAppCheckTokenProvider),\n/* harmony export */   b0: () => (/* binding */ documentId),\n/* harmony export */   b1: () => (/* binding */ enableIndexedDbPersistence),\n/* harmony export */   b2: () => (/* binding */ enableMultiTabIndexedDbPersistence),\n/* harmony export */   b3: () => (/* binding */ enableNetwork),\n/* harmony export */   b4: () => (/* binding */ getFirestore),\n/* harmony export */   b5: () => (/* binding */ increment),\n/* harmony export */   b6: () => (/* binding */ initializeFirestore),\n/* harmony export */   b7: () => (/* binding */ refEqual),\n/* harmony export */   b8: () => (/* binding */ serverTimestamp),\n/* harmony export */   b9: () => (/* binding */ setLogLevel),\n/* harmony export */   ba: () => (/* binding */ terminate),\n/* harmony export */   bb: () => (/* binding */ vector),\n/* harmony export */   bc: () => (/* binding */ waitForPendingWrites),\n/* harmony export */   bd: () => (/* binding */ isString),\n/* harmony export */   be: () => (/* binding */ DOCUMENT_KEY_NAME),\n/* harmony export */   bf: () => (/* binding */ hardAssert),\n/* harmony export */   bg: () => (/* binding */ parseData),\n/* harmony export */   bh: () => (/* binding */ toStringValue),\n/* harmony export */   bi: () => (/* binding */ isCollectionReference),\n/* harmony export */   bj: () => (/* binding */ isOptionalEqual),\n/* harmony export */   bk: () => (/* binding */ firestoreClientExecutePipeline),\n/* harmony export */   bl: () => (/* binding */ isPlainObject),\n/* harmony export */   bm: () => (/* binding */ isDocumentQuery$1),\n/* harmony export */   bn: () => (/* binding */ OptionsUtil),\n/* harmony export */   bo: () => (/* binding */ isNumber$1),\n/* harmony export */   bp: () => (/* binding */ StructuredPipelineOptions),\n/* harmony export */   bq: () => (/* binding */ toMapValue),\n/* harmony export */   br: () => (/* binding */ toNumber),\n/* harmony export */   bs: () => (/* binding */ toPipelineValue),\n/* harmony export */   bt: () => (/* binding */ isUserData),\n/* harmony export */   bu: () => (/* binding */ StructuredPipeline),\n/* harmony export */   bv: () => (/* binding */ _internalPipelineToExecutePipelineRequestProto),\n/* harmony export */   c: () => (/* binding */ newUserDataReader),\n/* harmony export */   d: () => (/* binding */ databaseIdFromApp),\n/* harmony export */   e: () => (/* binding */ queryWithAddedOrderBy),\n/* harmony export */   f: () => (/* binding */ fieldPathFromArgument),\n/* harmony export */   g: () => (/* binding */ queryWithLimit),\n/* harmony export */   h: () => (/* binding */ queryWithStartAt),\n/* harmony export */   i: () => (/* binding */ queryWithEndAt),\n/* harmony export */   j: () => (/* binding */ FirestoreError),\n/* harmony export */   k: () => (/* binding */ Code),\n/* harmony export */   l: () => (/* binding */ parseQueryValue),\n/* harmony export */   m: () => (/* binding */ FieldFilter),\n/* harmony export */   n: () => (/* binding */ newTextEncoder),\n/* harmony export */   o: () => (/* binding */ queryNormalizedOrderBy),\n/* harmony export */   p: () => (/* binding */ property),\n/* harmony export */   q: () => (/* binding */ queryWithAddedFilter),\n/* harmony export */   r: () => (/* binding */ refValue),\n/* harmony export */   s: () => (/* binding */ setSDKVersion),\n/* harmony export */   t: () => (/* binding */ isServerTimestamp),\n/* harmony export */   u: () => (/* binding */ Bound),\n/* harmony export */   v: () => (/* binding */ validatePositiveNumber),\n/* harmony export */   w: () => (/* binding */ isCollectionGroupQuery),\n/* harmony export */   x: () => (/* binding */ DocumentKey),\n/* harmony export */   y: () => (/* binding */ valueDescription),\n/* harmony export */   z: () => (/* binding */ queryEqual)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/../../node_modules/.pnpm/@firebase+app@0.14.8/node_modules/@firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/../../node_modules/.pnpm/@firebase+util@1.13.0/node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/webchannel-wrapper/bloom-blob */ \"(ssr)/../../node_modules/.pnpm/@firebase+webchannel-wrapper@1.0.5/node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/../../node_modules/.pnpm/@firebase+logger@0.5.0/node_modules/@firebase/logger/dist/esm/index.esm.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @grpc/grpc-js */ \"(ssr)/../../node_modules/.pnpm/@grpc+grpc-js@1.9.15/node_modules/@grpc/grpc-js/build/src/index.js\");\n/* harmony import */ var _grpc_proto_loader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @grpc/proto-loader */ \"(ssr)/../../node_modules/.pnpm/@grpc+proto-loader@0.7.15/node_modules/@grpc/proto-loader/build/src/index.js\");\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Simple wrapper around a nullable UID. Mostly exists to make code more\n * readable.\n */\nclass User {\n    constructor(uid) {\n        this.uid = uid;\n    }\n    isAuthenticated() {\n        return this.uid != null;\n    }\n    /**\n     * Returns a key representing this user, suitable for inclusion in a\n     * dictionary.\n     */\n    toKey() {\n        if (this.isAuthenticated()) {\n            return 'uid:' + this.uid;\n        }\n        else {\n            return 'anonymous-user';\n        }\n    }\n    isEqual(otherUser) {\n        return otherUser.uid === this.uid;\n    }\n}\n/** A user with a null UID. */\nUser.UNAUTHENTICATED = new User(null);\n// TODO(mikelehen): Look into getting a proper uid-equivalent for\n// non-FirebaseAuth providers.\nUser.GOOGLE_CREDENTIALS = new User('google-credentials-uid');\nUser.FIRST_PARTY = new User('first-party-uid');\nUser.MOCK_USER = new User('mock-user');\n\nconst version = \"12.9.0\";\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet SDK_VERSION = version;\nfunction setSDKVersion(version) {\n    SDK_VERSION = version;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Formats an object as a JSON string, suitable for logging. */\nfunction formatJSON(value) {\n    // util.inspect() results in much more readable output than JSON.stringify()\n    return (0,util__WEBPACK_IMPORTED_MODULE_4__.inspect)(value, { depth: 100 });\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.Logger('@firebase/firestore');\n// Helper methods are needed because variables can't be exported as read/write\nfunction getLogLevel() {\n    return logClient.logLevel;\n}\n/**\n * Sets the verbosity of Cloud Firestore logs (debug, error, or silent).\n *\n * @param logLevel - The verbosity you set for activity and error logging. Can\n *   be any of the following values:\n *\n *   <ul>\n *     <li>`debug` for the most verbose logging level, primarily for\n *     debugging.</li>\n *     <li>`error` to log errors only.</li>\n *     <li><code>`silent` to turn off logging.</li>\n *   </ul>\n */\nfunction setLogLevel(logLevel) {\n    logClient.setLogLevel(logLevel);\n}\nfunction logDebug(msg, ...obj) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.DEBUG) {\n        const args = obj.map(argToString);\n        logClient.debug(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n    }\n}\nfunction logError(msg, ...obj) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.ERROR) {\n        const args = obj.map(argToString);\n        logClient.error(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n    }\n}\n/**\n * @internal\n */\nfunction logWarn(msg, ...obj) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.WARN) {\n        const args = obj.map(argToString);\n        logClient.warn(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n    }\n}\n/**\n * Converts an additional log parameter to a string representation.\n */\nfunction argToString(obj) {\n    if (typeof obj === 'string') {\n        return obj;\n    }\n    else {\n        try {\n            return formatJSON(obj);\n        }\n        catch (e) {\n            // Converting to JSON failed, just log the object directly\n            return obj;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction fail(id, messageOrContext, context) {\n    let message = 'Unexpected state';\n    if (typeof messageOrContext === 'string') {\n        message = messageOrContext;\n    }\n    else {\n        context = messageOrContext;\n    }\n    _fail(id, message, context);\n}\nfunction _fail(id, failure, context) {\n    // Log the failure in addition to throw an exception, just in case the\n    // exception is swallowed.\n    let message = `FIRESTORE (${SDK_VERSION}) INTERNAL ASSERTION FAILED: ${failure} (ID: ${id.toString(16)})`;\n    if (context !== undefined) {\n        try {\n            const stringContext = JSON.stringify(context);\n            message += ' CONTEXT: ' + stringContext;\n        }\n        catch (e) {\n            message += ' CONTEXT: ' + context;\n        }\n    }\n    logError(message);\n    // NOTE: We don't use FirestoreError here because these are internal failures\n    // that cannot be handled by the user. (Also it would create a circular\n    // dependency between the error and assert modules which doesn't work.)\n    throw new Error(message);\n}\nfunction hardAssert(assertion, id, messageOrContext, context) {\n    let message = 'Unexpected state';\n    if (typeof messageOrContext === 'string') {\n        message = messageOrContext;\n    }\n    else {\n        context = messageOrContext;\n    }\n    if (!assertion) {\n        _fail(id, message, context);\n    }\n}\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * The code of callsites invoking this function are stripped out in production\n * builds. Any side-effects of code within the debugAssert() invocation will not\n * happen in this case.\n *\n * @internal\n */\nfunction debugAssert(assertion, message) {\n    if (!assertion) {\n        fail(0xdeb6, message);\n    }\n}\n/**\n * Casts `obj` to `T`. In non-production builds, verifies that `obj` is an\n * instance of `T` before casting.\n */\nfunction debugCast(obj, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconstructor) {\n    return obj;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst Code = {\n    // Causes are copied from:\n    // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n    /** Not an error; returned on success. */\n    OK: 'ok',\n    /** The operation was cancelled (typically by the caller). */\n    CANCELLED: 'cancelled',\n    /** Unknown error or an error from a different error domain. */\n    UNKNOWN: 'unknown',\n    /**\n     * Client specified an invalid argument. Note that this differs from\n     * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\n     * problematic regardless of the state of the system (e.g., a malformed file\n     * name).\n     */\n    INVALID_ARGUMENT: 'invalid-argument',\n    /**\n     * Deadline expired before operation could complete. For operations that\n     * change the state of the system, this error may be returned even if the\n     * operation has completed successfully. For example, a successful response\n     * from a server could have been delayed long enough for the deadline to\n     * expire.\n     */\n    DEADLINE_EXCEEDED: 'deadline-exceeded',\n    /** Some requested entity (e.g., file or directory) was not found. */\n    NOT_FOUND: 'not-found',\n    /**\n     * Some entity that we attempted to create (e.g., file or directory) already\n     * exists.\n     */\n    ALREADY_EXISTS: 'already-exists',\n    /**\n     * The caller does not have permission to execute the specified operation.\n     * PERMISSION_DENIED must not be used for rejections caused by exhausting\n     * some resource (use RESOURCE_EXHAUSTED instead for those errors).\n     * PERMISSION_DENIED must not be used if the caller cannot be identified\n     * (use UNAUTHENTICATED instead for those errors).\n     */\n    PERMISSION_DENIED: 'permission-denied',\n    /**\n     * The request does not have valid authentication credentials for the\n     * operation.\n     */\n    UNAUTHENTICATED: 'unauthenticated',\n    /**\n     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the\n     * entire file system is out of space.\n     */\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\n    /**\n     * Operation was rejected because the system is not in a state required for\n     * the operation's execution. For example, directory to be deleted may be\n     * non-empty, an rmdir operation is applied to a non-directory, etc.\n     *\n     * A litmus test that may help a service implementor in deciding\n     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n     *  (a) Use UNAVAILABLE if the client can retry just the failing call.\n     *  (b) Use ABORTED if the client should retry at a higher-level\n     *      (e.g., restarting a read-modify-write sequence).\n     *  (c) Use FAILED_PRECONDITION if the client should not retry until\n     *      the system state has been explicitly fixed. E.g., if an \"rmdir\"\n     *      fails because the directory is non-empty, FAILED_PRECONDITION\n     *      should be returned since the client should not retry unless\n     *      they have first fixed up the directory by deleting files from it.\n     *  (d) Use FAILED_PRECONDITION if the client performs conditional\n     *      REST Get/Update/Delete on a resource and the resource on the\n     *      server does not match the condition. E.g., conflicting\n     *      read-modify-write on the same resource.\n     */\n    FAILED_PRECONDITION: 'failed-precondition',\n    /**\n     * The operation was aborted, typically due to a concurrency issue like\n     * sequencer check failures, transaction aborts, etc.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    ABORTED: 'aborted',\n    /**\n     * Operation was attempted past the valid range. E.g., seeking or reading\n     * past end of file.\n     *\n     * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\n     * if the system state changes. For example, a 32-bit file system will\n     * generate INVALID_ARGUMENT if asked to read at an offset that is not in the\n     * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\n     * an offset past the current file size.\n     *\n     * There is a fair bit of overlap between FAILED_PRECONDITION and\n     * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n     * when it applies so that callers who are iterating through a space can\n     * easily look for an OUT_OF_RANGE error to detect when they are done.\n     */\n    OUT_OF_RANGE: 'out-of-range',\n    /** Operation is not implemented or not supported/enabled in this service. */\n    UNIMPLEMENTED: 'unimplemented',\n    /**\n     * Internal errors. Means some invariants expected by underlying System has\n     * been broken. If you see one of these errors, Something is very broken.\n     */\n    INTERNAL: 'internal',\n    /**\n     * The service is currently unavailable. This is a most likely a transient\n     * condition and may be corrected by retrying with a backoff.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    UNAVAILABLE: 'unavailable',\n    /** Unrecoverable data loss or corruption. */\n    DATA_LOSS: 'data-loss'\n};\n/** An error returned by a Firestore operation. */\nclass FirestoreError extends _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError {\n    /** @hideconstructor */\n    constructor(\n    /**\n     * The backend error code associated with this error.\n     */\n    code, \n    /**\n     * A custom error description.\n     */\n    message) {\n        super(code, message);\n        this.code = code;\n        this.message = message;\n        // HACK: We write a toString property directly because Error is not a real\n        // class and so inheritance does not work correctly. We could alternatively\n        // do the same \"back-door inheritance\" trick that FirebaseError does.\n        this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass OAuthToken {\n    constructor(value, user) {\n        this.user = user;\n        this.type = 'OAuth';\n        this.headers = new Map();\n        this.headers.set('Authorization', `Bearer ${value}`);\n    }\n}\n/**\n * A CredentialsProvider that always yields an empty token.\n * @internal\n */\nclass EmptyAuthCredentialsProvider {\n    getToken() {\n        return Promise.resolve(null);\n    }\n    invalidateToken() { }\n    start(asyncQueue, changeListener) {\n        // Fire with initial user.\n        asyncQueue.enqueueRetryable(() => changeListener(User.UNAUTHENTICATED));\n    }\n    shutdown() { }\n}\n/**\n * A CredentialsProvider that always returns a constant token. Used for\n * emulator token mocking.\n */\nclass EmulatorAuthCredentialsProvider {\n    constructor(token) {\n        this.token = token;\n        /**\n         * Stores the listener registered with setChangeListener()\n         * This isn't actually necessary since the UID never changes, but we use this\n         * to verify the listen contract is adhered to in tests.\n         */\n        this.changeListener = null;\n    }\n    getToken() {\n        return Promise.resolve(this.token);\n    }\n    invalidateToken() { }\n    start(asyncQueue, changeListener) {\n        this.changeListener = changeListener;\n        // Fire with initial user.\n        asyncQueue.enqueueRetryable(() => changeListener(this.token.user));\n    }\n    shutdown() {\n        this.changeListener = null;\n    }\n}\nclass FirebaseAuthCredentialsProvider {\n    constructor(authProvider) {\n        this.authProvider = authProvider;\n        /** Tracks the current User. */\n        this.currentUser = User.UNAUTHENTICATED;\n        /**\n         * Counter used to detect if the token changed while a getToken request was\n         * outstanding.\n         */\n        this.tokenCounter = 0;\n        this.forceRefresh = false;\n        this.auth = null;\n    }\n    start(asyncQueue, changeListener) {\n        hardAssert(this.tokenListener === undefined, 0xa540);\n        let lastTokenId = this.tokenCounter;\n        // A change listener that prevents double-firing for the same token change.\n        const guardedChangeListener = user => {\n            if (this.tokenCounter !== lastTokenId) {\n                lastTokenId = this.tokenCounter;\n                return changeListener(user);\n            }\n            else {\n                return Promise.resolve();\n            }\n        };\n        // A promise that can be waited on to block on the next token change.\n        // This promise is re-created after each change.\n        let nextToken = new Deferred();\n        this.tokenListener = () => {\n            this.tokenCounter++;\n            this.currentUser = this.getUser();\n            nextToken.resolve();\n            nextToken = new Deferred();\n            asyncQueue.enqueueRetryable(() => guardedChangeListener(this.currentUser));\n        };\n        const awaitNextToken = () => {\n            const currentTokenAttempt = nextToken;\n            asyncQueue.enqueueRetryable(async () => {\n                await currentTokenAttempt.promise;\n                await guardedChangeListener(this.currentUser);\n            });\n        };\n        const registerAuth = (auth) => {\n            logDebug('FirebaseAuthCredentialsProvider', 'Auth detected');\n            this.auth = auth;\n            if (this.tokenListener) {\n                this.auth.addAuthTokenListener(this.tokenListener);\n                awaitNextToken();\n            }\n        };\n        this.authProvider.onInit(auth => registerAuth(auth));\n        // Our users can initialize Auth right after Firestore, so we give it\n        // a chance to register itself with the component framework before we\n        // determine whether to start up in unauthenticated mode.\n        setTimeout(() => {\n            if (!this.auth) {\n                const auth = this.authProvider.getImmediate({ optional: true });\n                if (auth) {\n                    registerAuth(auth);\n                }\n                else {\n                    // If auth is still not available, proceed with `null` user\n                    logDebug('FirebaseAuthCredentialsProvider', 'Auth not yet detected');\n                    nextToken.resolve();\n                    nextToken = new Deferred();\n                }\n            }\n        }, 0);\n        awaitNextToken();\n    }\n    getToken() {\n        // Take note of the current value of the tokenCounter so that this method\n        // can fail (with an ABORTED error) if there is a token change while the\n        // request is outstanding.\n        const initialTokenCounter = this.tokenCounter;\n        const forceRefresh = this.forceRefresh;\n        this.forceRefresh = false;\n        if (!this.auth) {\n            return Promise.resolve(null);\n        }\n        return this.auth.getToken(forceRefresh).then(tokenData => {\n            // Cancel the request since the token changed while the request was\n            // outstanding so the response is potentially for a previous user (which\n            // user, we can't be sure).\n            if (this.tokenCounter !== initialTokenCounter) {\n                logDebug('FirebaseAuthCredentialsProvider', 'getToken aborted due to token change.');\n                return this.getToken();\n            }\n            else {\n                if (tokenData) {\n                    hardAssert(typeof tokenData.accessToken === 'string', 0x7c5d, { tokenData });\n                    return new OAuthToken(tokenData.accessToken, this.currentUser);\n                }\n                else {\n                    return null;\n                }\n            }\n        });\n    }\n    invalidateToken() {\n        this.forceRefresh = true;\n    }\n    shutdown() {\n        if (this.auth && this.tokenListener) {\n            this.auth.removeAuthTokenListener(this.tokenListener);\n        }\n        this.tokenListener = undefined;\n    }\n    // Auth.getUid() can return null even with a user logged in. It is because\n    // getUid() is synchronous, but the auth code populating Uid is asynchronous.\n    // This method should only be called in the AuthTokenListener callback\n    // to guarantee to get the actual user.\n    getUser() {\n        const currentUid = this.auth && this.auth.getUid();\n        hardAssert(currentUid === null || typeof currentUid === 'string', 0x0807, { currentUid });\n        return new User(currentUid);\n    }\n}\n/*\n * FirstPartyToken provides a fresh token each time its value\n * is requested, because if the token is too old, requests will be rejected.\n * Technically this may no longer be necessary since the SDK should gracefully\n * recover from unauthenticated errors (see b/33147818 for context), but it's\n * safer to keep the implementation as-is.\n */\nclass FirstPartyToken {\n    constructor(sessionIndex, iamToken, authTokenFactory) {\n        this.sessionIndex = sessionIndex;\n        this.iamToken = iamToken;\n        this.authTokenFactory = authTokenFactory;\n        this.type = 'FirstParty';\n        this.user = User.FIRST_PARTY;\n        this._headers = new Map();\n    }\n    /**\n     * Gets an authorization token, using a provided factory function, or return\n     * null.\n     */\n    getAuthToken() {\n        if (this.authTokenFactory) {\n            return this.authTokenFactory();\n        }\n        else {\n            return null;\n        }\n    }\n    get headers() {\n        this._headers.set('X-Goog-AuthUser', this.sessionIndex);\n        // Use array notation to prevent minification\n        const authHeaderTokenValue = this.getAuthToken();\n        if (authHeaderTokenValue) {\n            this._headers.set('Authorization', authHeaderTokenValue);\n        }\n        if (this.iamToken) {\n            this._headers.set('X-Goog-Iam-Authorization-Token', this.iamToken);\n        }\n        return this._headers;\n    }\n}\n/*\n * Provides user credentials required for the Firestore JavaScript SDK\n * to authenticate the user, using technique that is only available\n * to applications hosted by Google.\n */\nclass FirstPartyAuthCredentialsProvider {\n    constructor(sessionIndex, iamToken, authTokenFactory) {\n        this.sessionIndex = sessionIndex;\n        this.iamToken = iamToken;\n        this.authTokenFactory = authTokenFactory;\n    }\n    getToken() {\n        return Promise.resolve(new FirstPartyToken(this.sessionIndex, this.iamToken, this.authTokenFactory));\n    }\n    start(asyncQueue, changeListener) {\n        // Fire with initial uid.\n        asyncQueue.enqueueRetryable(() => changeListener(User.FIRST_PARTY));\n    }\n    shutdown() { }\n    invalidateToken() { }\n}\nclass AppCheckToken {\n    constructor(value) {\n        this.value = value;\n        this.type = 'AppCheck';\n        this.headers = new Map();\n        if (value && value.length > 0) {\n            this.headers.set('x-firebase-appcheck', this.value);\n        }\n    }\n}\nclass FirebaseAppCheckTokenProvider {\n    constructor(app, appCheckProvider) {\n        this.appCheckProvider = appCheckProvider;\n        this.forceRefresh = false;\n        this.appCheck = null;\n        this.latestAppCheckToken = null;\n        this.serverAppAppCheckToken = null;\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(app) && app.settings.appCheckToken) {\n            this.serverAppAppCheckToken = app.settings.appCheckToken;\n        }\n    }\n    start(asyncQueue, changeListener) {\n        hardAssert(this.tokenListener === undefined, 0x0db8);\n        const onTokenChanged = tokenResult => {\n            if (tokenResult.error != null) {\n                logDebug('FirebaseAppCheckTokenProvider', `Error getting App Check token; using placeholder token instead. Error: ${tokenResult.error.message}`);\n            }\n            const tokenUpdated = tokenResult.token !== this.latestAppCheckToken;\n            this.latestAppCheckToken = tokenResult.token;\n            logDebug('FirebaseAppCheckTokenProvider', `Received ${tokenUpdated ? 'new' : 'existing'} token.`);\n            return tokenUpdated\n                ? changeListener(tokenResult.token)\n                : Promise.resolve();\n        };\n        this.tokenListener = (tokenResult) => {\n            asyncQueue.enqueueRetryable(() => onTokenChanged(tokenResult));\n        };\n        const registerAppCheck = (appCheck) => {\n            logDebug('FirebaseAppCheckTokenProvider', 'AppCheck detected');\n            this.appCheck = appCheck;\n            if (this.tokenListener) {\n                this.appCheck.addTokenListener(this.tokenListener);\n            }\n        };\n        this.appCheckProvider.onInit(appCheck => registerAppCheck(appCheck));\n        // Our users can initialize AppCheck after Firestore, so we give it\n        // a chance to register itself with the component framework.\n        setTimeout(() => {\n            if (!this.appCheck) {\n                const appCheck = this.appCheckProvider.getImmediate({ optional: true });\n                if (appCheck) {\n                    registerAppCheck(appCheck);\n                }\n                else {\n                    // If AppCheck is still not available, proceed without it.\n                    logDebug('FirebaseAppCheckTokenProvider', 'AppCheck not yet detected');\n                }\n            }\n        }, 0);\n    }\n    getToken() {\n        if (this.serverAppAppCheckToken) {\n            return Promise.resolve(new AppCheckToken(this.serverAppAppCheckToken));\n        }\n        const forceRefresh = this.forceRefresh;\n        this.forceRefresh = false;\n        if (!this.appCheck) {\n            return Promise.resolve(null);\n        }\n        return this.appCheck.getToken(forceRefresh).then(tokenResult => {\n            if (tokenResult) {\n                hardAssert(typeof tokenResult.token === 'string', 0xae0e, { tokenResult });\n                this.latestAppCheckToken = tokenResult.token;\n                return new AppCheckToken(tokenResult.token);\n            }\n            else {\n                return null;\n            }\n        });\n    }\n    invalidateToken() {\n        this.forceRefresh = true;\n    }\n    shutdown() {\n        if (this.appCheck && this.tokenListener) {\n            this.appCheck.removeTokenListener(this.tokenListener);\n        }\n        this.tokenListener = undefined;\n    }\n}\n/**\n * An AppCheck token provider that always yields an empty token.\n * @internal\n */\nclass EmptyAppCheckTokenProvider {\n    getToken() {\n        return Promise.resolve(new AppCheckToken(''));\n    }\n    invalidateToken() { }\n    start(asyncQueue, changeListener) { }\n    shutdown() { }\n}\n/**\n * Builds a CredentialsProvider depending on the type of\n * the credentials passed in.\n */\nfunction makeAuthCredentialsProvider(credentials) {\n    if (!credentials) {\n        return new EmptyAuthCredentialsProvider();\n    }\n    switch (credentials['type']) {\n        case 'firstParty':\n            return new FirstPartyAuthCredentialsProvider(credentials['sessionIndex'] || '0', credentials['iamToken'] || null, credentials['authTokenFactory'] || null);\n        case 'provider':\n            return credentials['client'];\n        default:\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeAuthCredentialsProvider failed due to invalid credential type');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Generates `nBytes` of random bytes.\n *\n * If `nBytes < 0` , an error will be thrown.\n */\nfunction randomBytes(nBytes) {\n    return (0,crypto__WEBPACK_IMPORTED_MODULE_5__.randomBytes)(nBytes);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A utility class for generating unique alphanumeric IDs of a specified length.\n *\n * @internal\n * Exported internally for testing purposes.\n */\nclass AutoId {\n    static newId() {\n        // Alphanumeric characters\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        // The largest byte value that is a multiple of `char.length`.\n        const maxMultiple = Math.floor(256 / chars.length) * chars.length;\n        let autoId = '';\n        const targetLength = 20;\n        while (autoId.length < targetLength) {\n            const bytes = randomBytes(40);\n            for (let i = 0; i < bytes.length; ++i) {\n                // Only accept values that are [0, maxMultiple), this ensures they can\n                // be evenly mapped to indices of `chars` via a modulo operation.\n                if (autoId.length < targetLength && bytes[i] < maxMultiple) {\n                    autoId += chars.charAt(bytes[i] % chars.length);\n                }\n            }\n        }\n        return autoId;\n    }\n}\nfunction primitiveComparator(left, right) {\n    if (left < right) {\n        return -1;\n    }\n    if (left > right) {\n        return 1;\n    }\n    return 0;\n}\n/** Compare strings in UTF-8 encoded byte order */\nfunction compareUtf8Strings(left, right) {\n    // Find the first differing character (a.k.a. \"UTF-16 code unit\") in the two strings and,\n    // if found, use that character to determine the relative ordering of the two strings as a\n    // whole. Comparing UTF-16 strings in UTF-8 byte order can be done simply and efficiently by\n    // comparing the UTF-16 code units (chars). This serendipitously works because of the way UTF-8\n    // and UTF-16 happen to represent Unicode code points.\n    //\n    // After finding the first pair of differing characters, there are two cases:\n    //\n    // Case 1: Both characters are non-surrogates (code points less than or equal to 0xFFFF) or\n    // both are surrogates from a surrogate pair (that collectively represent code points greater\n    // than 0xFFFF). In this case their numeric order as UTF-16 code units is the same as the\n    // lexicographical order of their corresponding UTF-8 byte sequences. A direct comparison is\n    // sufficient.\n    //\n    // Case 2: One character is a surrogate and the other is not. In this case the surrogate-\n    // containing string is always ordered after the non-surrogate. This is because surrogates are\n    // used to represent code points greater than 0xFFFF which have 4-byte UTF-8 representations\n    // and are lexicographically greater than the 1, 2, or 3-byte representations of code points\n    // less than or equal to 0xFFFF.\n    //\n    // An example of why Case 2 is required is comparing the following two Unicode code points:\n    //\n    // |-----------------------|------------|---------------------|-----------------|\n    // | Name                  | Code Point | UTF-8 Encoding      | UTF-16 Encoding |\n    // |-----------------------|------------|---------------------|-----------------|\n    // | Replacement Character | U+FFFD     | 0xEF 0xBF 0xBD      | 0xFFFD          |\n    // | Grinning Face         | U+1F600    | 0xF0 0x9F 0x98 0x80 | 0xD83D 0xDE00   |\n    // |-----------------------|------------|---------------------|-----------------|\n    //\n    // A lexicographical comparison of the UTF-8 encodings of these code points would order\n    // \"Replacement Character\" _before_ \"Grinning Face\" because 0xEF is less than 0xF0. However, a\n    // direct comparison of the UTF-16 code units, as would be done in case 1, would erroneously\n    // produce the _opposite_ ordering, because 0xFFFD is _greater than_ 0xD83D. As it turns out,\n    // this relative ordering holds for all comparisons of UTF-16 code points requiring a surrogate\n    // pair with those that do not.\n    const length = Math.min(left.length, right.length);\n    for (let i = 0; i < length; i++) {\n        const leftChar = left.charAt(i);\n        const rightChar = right.charAt(i);\n        if (leftChar !== rightChar) {\n            return isSurrogate(leftChar) === isSurrogate(rightChar)\n                ? primitiveComparator(leftChar, rightChar)\n                : isSurrogate(leftChar)\n                    ? 1\n                    : -1;\n        }\n    }\n    // Use the lengths of the strings to determine the overall comparison result since either the\n    // strings were equal or one is a prefix of the other.\n    return primitiveComparator(left.length, right.length);\n}\nconst MIN_SURROGATE$1 = 0xd800;\nconst MAX_SURROGATE$1 = 0xdfff;\nfunction isSurrogate(s) {\n    const c = s.charCodeAt(0);\n    return c >= MIN_SURROGATE$1 && c <= MAX_SURROGATE$1;\n}\n/** Helper to compare arrays using isEqual(). */\nfunction arrayEquals(left, right, comparator) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    return left.every((value, index) => comparator(value, right[index]));\n}\n/**\n * Verifies equality for an optional value.\n */\nfunction isOptionalEqual(left, right, equalityTest) {\n    if (left === undefined && right === undefined) {\n        return true;\n    }\n    if (left === undefined || right === undefined) {\n        return false;\n    }\n    return equalityTest(left, right);\n}\n/**\n * Returns the immediate lexicographically-following string. This is useful to\n * construct an inclusive range for indexeddb iterators.\n */\nfunction immediateSuccessor(s) {\n    // Return the input string, with an additional NUL byte appended.\n    return s + '\\0';\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DOCUMENT_KEY_NAME = '__name__';\n/**\n * Path represents an ordered sequence of string segments.\n */\nclass BasePath {\n    constructor(segments, offset, length) {\n        if (offset === undefined) {\n            offset = 0;\n        }\n        else if (offset > segments.length) {\n            fail(0x027d, {\n                offset,\n                range: segments.length\n            });\n        }\n        if (length === undefined) {\n            length = segments.length - offset;\n        }\n        else if (length > segments.length - offset) {\n            fail(0x06d2, {\n                length,\n                range: segments.length - offset\n            });\n        }\n        this.segments = segments;\n        this.offset = offset;\n        this.len = length;\n    }\n    get length() {\n        return this.len;\n    }\n    isEqual(other) {\n        return BasePath.comparator(this, other) === 0;\n    }\n    child(nameOrPath) {\n        const segments = this.segments.slice(this.offset, this.limit());\n        if (nameOrPath instanceof BasePath) {\n            nameOrPath.forEach(segment => {\n                segments.push(segment);\n            });\n        }\n        else {\n            segments.push(nameOrPath);\n        }\n        return this.construct(segments);\n    }\n    /** The index of one past the last segment of the path. */\n    limit() {\n        return this.offset + this.length;\n    }\n    popFirst(size) {\n        size = size === undefined ? 1 : size;\n        return this.construct(this.segments, this.offset + size, this.length - size);\n    }\n    popLast() {\n        return this.construct(this.segments, this.offset, this.length - 1);\n    }\n    firstSegment() {\n        return this.segments[this.offset];\n    }\n    lastSegment() {\n        return this.get(this.length - 1);\n    }\n    get(index) {\n        return this.segments[this.offset + index];\n    }\n    isEmpty() {\n        return this.length === 0;\n    }\n    isPrefixOf(other) {\n        if (other.length < this.length) {\n            return false;\n        }\n        for (let i = 0; i < this.length; i++) {\n            if (this.get(i) !== other.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isImmediateParentOf(potentialChild) {\n        if (this.length + 1 !== potentialChild.length) {\n            return false;\n        }\n        for (let i = 0; i < this.length; i++) {\n            if (this.get(i) !== potentialChild.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    forEach(fn) {\n        for (let i = this.offset, end = this.limit(); i < end; i++) {\n            fn(this.segments[i]);\n        }\n    }\n    toArray() {\n        return this.segments.slice(this.offset, this.limit());\n    }\n    /**\n     * Compare 2 paths segment by segment, prioritizing numeric IDs\n     * (e.g., \"__id123__\") in numeric ascending order, followed by string\n     * segments in lexicographical order.\n     */\n    static comparator(p1, p2) {\n        const len = Math.min(p1.length, p2.length);\n        for (let i = 0; i < len; i++) {\n            const comparison = BasePath.compareSegments(p1.get(i), p2.get(i));\n            if (comparison !== 0) {\n                return comparison;\n            }\n        }\n        return primitiveComparator(p1.length, p2.length);\n    }\n    static compareSegments(lhs, rhs) {\n        const isLhsNumeric = BasePath.isNumericId(lhs);\n        const isRhsNumeric = BasePath.isNumericId(rhs);\n        if (isLhsNumeric && !isRhsNumeric) {\n            // Only lhs is numeric\n            return -1;\n        }\n        else if (!isLhsNumeric && isRhsNumeric) {\n            // Only rhs is numeric\n            return 1;\n        }\n        else if (isLhsNumeric && isRhsNumeric) {\n            // both numeric\n            return BasePath.extractNumericId(lhs).compare(BasePath.extractNumericId(rhs));\n        }\n        else {\n            // both non-numeric\n            return compareUtf8Strings(lhs, rhs);\n        }\n    }\n    // Checks if a segment is a numeric ID (starts with \"__id\" and ends with \"__\").\n    static isNumericId(segment) {\n        return segment.startsWith('__id') && segment.endsWith('__');\n    }\n    static extractNumericId(segment) {\n        return _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_2__.Integer.fromString(segment.substring(4, segment.length - 2));\n    }\n}\n/**\n * A slash-separated path for navigating resources (documents and collections)\n * within Firestore.\n *\n * @internal\n */\nclass ResourcePath extends BasePath {\n    construct(segments, offset, length) {\n        return new ResourcePath(segments, offset, length);\n    }\n    canonicalString() {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        return this.toArray().join('/');\n    }\n    toString() {\n        return this.canonicalString();\n    }\n    /**\n     * Returns a string representation of this path\n     * where each path segment has been encoded with\n     * `encodeURIComponent`.\n     */\n    toUriEncodedString() {\n        return this.toArray().map(encodeURIComponent).join('/');\n    }\n    /**\n     * Creates a resource path from the given slash-delimited string. If multiple\n     * arguments are provided, all components are combined. Leading and trailing\n     * slashes from all components are ignored.\n     */\n    static fromString(...pathComponents) {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        const segments = [];\n        for (const path of pathComponents) {\n            if (path.indexOf('//') >= 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid segment (${path}). Paths must not contain // in them.`);\n            }\n            // Strip leading and trailing slashed.\n            segments.push(...path.split('/').filter(segment => segment.length > 0));\n        }\n        return new ResourcePath(segments);\n    }\n    static emptyPath() {\n        return new ResourcePath([]);\n    }\n}\nconst identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n/**\n * A dot-separated path for navigating sub-objects within a document.\n * @internal\n */\nclass FieldPath$1 extends BasePath {\n    construct(segments, offset, length) {\n        return new FieldPath$1(segments, offset, length);\n    }\n    /**\n     * Returns true if the string could be used as a segment in a field path\n     * without escaping.\n     */\n    static isValidIdentifier(segment) {\n        return identifierRegExp.test(segment);\n    }\n    canonicalString() {\n        return this.toArray()\n            .map(str => {\n            str = str.replace(/\\\\/g, '\\\\\\\\').replace(/`/g, '\\\\`');\n            if (!FieldPath$1.isValidIdentifier(str)) {\n                str = '`' + str + '`';\n            }\n            return str;\n        })\n            .join('.');\n    }\n    toString() {\n        return this.canonicalString();\n    }\n    /**\n     * Returns true if this field references the key of a document.\n     */\n    isKeyField() {\n        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\n    }\n    /**\n     * The field designating the key of a document.\n     */\n    static keyField() {\n        return new FieldPath$1([DOCUMENT_KEY_NAME]);\n    }\n    /**\n     * Parses a field string from the given server-formatted string.\n     *\n     * - Splitting the empty string is not allowed (for now at least).\n     * - Empty segments within the string (e.g. if there are two consecutive\n     *   separators) are not allowed.\n     *\n     * TODO(b/37244157): we should make this more strict. Right now, it allows\n     * non-identifier path components, even if they aren't escaped.\n     */\n    static fromServerFormat(path) {\n        const segments = [];\n        let current = '';\n        let i = 0;\n        const addCurrentSegment = () => {\n            if (current.length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field path (${path}). Paths must not be empty, begin ` +\n                    `with '.', end with '.', or contain '..'`);\n            }\n            segments.push(current);\n            current = '';\n        };\n        let inBackticks = false;\n        while (i < path.length) {\n            const c = path[i];\n            if (c === '\\\\') {\n                if (i + 1 === path.length) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);\n                }\n                const next = path[i + 1];\n                if (!(next === '\\\\' || next === '.' || next === '`')) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);\n                }\n                current += next;\n                i += 2;\n            }\n            else if (c === '`') {\n                inBackticks = !inBackticks;\n                i++;\n            }\n            else if (c === '.' && !inBackticks) {\n                addCurrentSegment();\n                i++;\n            }\n            else {\n                current += c;\n                i++;\n            }\n        }\n        addCurrentSegment();\n        if (inBackticks) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);\n        }\n        return new FieldPath$1(segments);\n    }\n    static emptyPath() {\n        return new FieldPath$1([]);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @internal\n */\nclass DocumentKey {\n    constructor(path) {\n        this.path = path;\n    }\n    static fromPath(path) {\n        return new DocumentKey(ResourcePath.fromString(path));\n    }\n    static fromName(name) {\n        return new DocumentKey(ResourcePath.fromString(name).popFirst(5));\n    }\n    static empty() {\n        return new DocumentKey(ResourcePath.emptyPath());\n    }\n    get collectionGroup() {\n        return this.path.popLast().lastSegment();\n    }\n    /** Returns true if the document is in the specified collectionId. */\n    hasCollectionId(collectionId) {\n        return (this.path.length >= 2 &&\n            this.path.get(this.path.length - 2) === collectionId);\n    }\n    /** Returns the collection group (i.e. the name of the parent collection) for this key. */\n    getCollectionGroup() {\n        return this.path.get(this.path.length - 2);\n    }\n    /** Returns the fully qualified path to the parent collection. */\n    getCollectionPath() {\n        return this.path.popLast();\n    }\n    isEqual(other) {\n        return (other !== null && ResourcePath.comparator(this.path, other.path) === 0);\n    }\n    toString() {\n        return this.path.toString();\n    }\n    static comparator(k1, k2) {\n        return ResourcePath.comparator(k1.path, k2.path);\n    }\n    static isDocumentKey(path) {\n        return path.length % 2 === 0;\n    }\n    /**\n     * Creates and returns a new document key with the given segments.\n     *\n     * @param segments - The segments of the path to the document\n     * @returns A new instance of DocumentKey\n     */\n    static fromSegments(segments) {\n        return new DocumentKey(new ResourcePath(segments.slice()));\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction validateNonEmptyArgument(functionName, argumentName, argument) {\n    if (!argument) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() cannot be called with an empty ${argumentName}.`);\n    }\n}\n/**\n * Validates that two boolean options are not set at the same time.\n * @internal\n */\nfunction validateIsNotUsedTogether(optionName1, argument1, optionName2, argument2) {\n    if (argument1 === true && argument2 === true) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `${optionName1} and ${optionName2} cannot be used together.`);\n    }\n}\n/**\n * Validates that `path` refers to a document (indicated by the fact it contains\n * an even numbers of segments).\n */\nfunction validateDocumentPath(path) {\n    if (!DocumentKey.isDocumentKey(path)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${path} has ${path.length}.`);\n    }\n}\n/**\n * Validates that `path` refers to a collection (indicated by the fact it\n * contains an odd numbers of segments).\n */\nfunction validateCollectionPath(path) {\n    if (DocumentKey.isDocumentKey(path)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${path} has ${path.length}.`);\n    }\n}\n/**\n * Returns true if it's a non-null object without a custom prototype\n * (i.e. excludes Array, Date, etc.).\n */\nfunction isPlainObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        (Object.getPrototypeOf(input) === Object.prototype ||\n            Object.getPrototypeOf(input) === null));\n}\n/** Returns a string describing the type / value of the provided input. */\nfunction valueDescription(input) {\n    if (input === undefined) {\n        return 'undefined';\n    }\n    else if (input === null) {\n        return 'null';\n    }\n    else if (typeof input === 'string') {\n        if (input.length > 20) {\n            input = `${input.substring(0, 20)}...`;\n        }\n        return JSON.stringify(input);\n    }\n    else if (typeof input === 'number' || typeof input === 'boolean') {\n        return '' + input;\n    }\n    else if (typeof input === 'object') {\n        if (input instanceof Array) {\n            return 'an array';\n        }\n        else {\n            const customObjectName = tryGetCustomObjectType(input);\n            if (customObjectName) {\n                return `a custom ${customObjectName} object`;\n            }\n            else {\n                return 'an object';\n            }\n        }\n    }\n    else if (typeof input === 'function') {\n        return 'a function';\n    }\n    else {\n        return fail(0x3029, { type: typeof input });\n    }\n}\n/** try to get the constructor name for an object. */\nfunction tryGetCustomObjectType(input) {\n    if (input.constructor) {\n        return input.constructor.name;\n    }\n    return null;\n}\n/**\n * Casts `obj` to `T`, optionally unwrapping Compat types to expose the\n * underlying instance. Throws if  `obj` is not an instance of `T`.\n *\n * This cast is used in the Lite and Full SDK to verify instance types for\n * arguments passed to the public API.\n * @internal\n */\nfunction cast(obj, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconstructor) {\n    if ('_delegate' in obj) {\n        // Unwrap Compat types\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        obj = obj._delegate;\n    }\n    if (!(obj instanceof constructor)) {\n        if (constructor.name === obj.constructor.name) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Type does not match the expected instance. Did you pass a ' +\n                `reference from a different Firestore SDK?`);\n        }\n        else {\n            const description = valueDescription(obj);\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Expected type '${constructor.name}', but it was: ${description}`);\n        }\n    }\n    return obj;\n}\nfunction validatePositiveNumber(functionName, n) {\n    if (n <= 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() requires a positive number, but it was: ${n}.`);\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Helper function to define a JSON schema {@link Property}.\n * @private\n * @internal\n */\nfunction property(typeString, optionalValue) {\n    const result = {\n        typeString\n    };\n    if (optionalValue) {\n        result.value = optionalValue;\n    }\n    return result;\n}\n/**\n * Validates the JSON object based on the provided schema, and narrows the type to the provided\n * JSON schema.\n * @private\n * @internal\n *\n * @param json - A JSON object to validate.\n * @param scheme - a {@link JsonSchema} that defines the properties to validate.\n * @returns true if the JSON schema exists within the object. Throws a FirestoreError otherwise.\n */\nfunction validateJSON(json, schema) {\n    if (!isPlainObject(json)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'JSON must be an object');\n    }\n    let error = undefined;\n    for (const key in schema) {\n        if (schema[key]) {\n            const typeString = schema[key].typeString;\n            const value = 'value' in schema[key] ? { value: schema[key].value } : undefined;\n            if (!(key in json)) {\n                error = `JSON missing required field: '${key}'`;\n                break;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const fieldValue = json[key];\n            if (typeString && typeof fieldValue !== typeString) {\n                error = `JSON field '${key}' must be a ${typeString}.`;\n                break;\n            }\n            else if (value !== undefined && fieldValue !== value.value) {\n                error = `Expected '${key}' field to equal '${value.value}'`;\n                break;\n            }\n        }\n    }\n    if (error) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, error);\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// The earliest date supported by Firestore timestamps (0001-01-01T00:00:00Z).\nconst MIN_SECONDS = -62135596800;\n// Number of nanoseconds in a millisecond.\nconst MS_TO_NANOS = 1e6;\n/**\n * A `Timestamp` represents a point in time independent of any time zone or\n * calendar, represented as seconds and fractions of seconds at nanosecond\n * resolution in UTC Epoch time.\n *\n * It is encoded using the Proleptic Gregorian Calendar which extends the\n * Gregorian calendar backwards to year one. It is encoded assuming all minutes\n * are 60 seconds long, i.e. leap seconds are \"smeared\" so that no leap second\n * table is needed for interpretation. Range is from 0001-01-01T00:00:00Z to\n * 9999-12-31T23:59:59.999999999Z.\n *\n * For examples and further specifications, refer to the\n * {@link https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto | Timestamp definition}.\n */\nclass Timestamp {\n    /**\n     * Creates a new timestamp with the current date, with millisecond precision.\n     *\n     * @returns a new timestamp representing the current date.\n     */\n    static now() {\n        return Timestamp.fromMillis(Date.now());\n    }\n    /**\n     * Creates a new timestamp from the given date.\n     *\n     * @param date - The date to initialize the `Timestamp` from.\n     * @returns A new `Timestamp` representing the same point in time as the given\n     *     date.\n     */\n    static fromDate(date) {\n        return Timestamp.fromMillis(date.getTime());\n    }\n    /**\n     * Creates a new timestamp from the given number of milliseconds.\n     *\n     * @param milliseconds - Number of milliseconds since Unix epoch\n     *     1970-01-01T00:00:00Z.\n     * @returns A new `Timestamp` representing the same point in time as the given\n     *     number of milliseconds.\n     */\n    static fromMillis(milliseconds) {\n        const seconds = Math.floor(milliseconds / 1000);\n        const nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);\n        return new Timestamp(seconds, nanos);\n    }\n    /**\n     * Creates a new timestamp.\n     *\n     * @param seconds - The number of seconds of UTC time since Unix epoch\n     *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     *     9999-12-31T23:59:59Z inclusive.\n     * @param nanoseconds - The non-negative fractions of a second at nanosecond\n     *     resolution. Negative second values with fractions must still have\n     *     non-negative nanoseconds values that count forward in time. Must be\n     *     from 0 to 999,999,999 inclusive.\n     */\n    constructor(\n    /**\n     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\n     */\n    seconds, \n    /**\n     * The fractions of a second at nanosecond resolution.*\n     */\n    nanoseconds) {\n        this.seconds = seconds;\n        this.nanoseconds = nanoseconds;\n        if (nanoseconds < 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);\n        }\n        if (nanoseconds >= 1e9) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);\n        }\n        if (seconds < MIN_SECONDS) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);\n        }\n        // This will break in the year 10,000.\n        if (seconds >= 253402300800) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);\n        }\n    }\n    /**\n     * Converts a `Timestamp` to a JavaScript `Date` object. This conversion\n     * causes a loss of precision since `Date` objects only support millisecond\n     * precision.\n     *\n     * @returns JavaScript `Date` object representing the same point in time as\n     *     this `Timestamp`, with millisecond precision.\n     */\n    toDate() {\n        return new Date(this.toMillis());\n    }\n    /**\n     * Converts a `Timestamp` to a numeric timestamp (in milliseconds since\n     * epoch). This operation causes a loss of precision.\n     *\n     * @returns The point in time corresponding to this timestamp, represented as\n     *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\n     */\n    toMillis() {\n        return this.seconds * 1000 + this.nanoseconds / MS_TO_NANOS;\n    }\n    _compareTo(other) {\n        if (this.seconds === other.seconds) {\n            return primitiveComparator(this.nanoseconds, other.nanoseconds);\n        }\n        return primitiveComparator(this.seconds, other.seconds);\n    }\n    /**\n     * Returns true if this `Timestamp` is equal to the provided one.\n     *\n     * @param other - The `Timestamp` to compare against.\n     * @returns true if this `Timestamp` is equal to the provided one.\n     */\n    isEqual(other) {\n        return (other.seconds === this.seconds && other.nanoseconds === this.nanoseconds);\n    }\n    /** Returns a textual representation of this `Timestamp`. */\n    toString() {\n        return ('Timestamp(seconds=' +\n            this.seconds +\n            ', nanoseconds=' +\n            this.nanoseconds +\n            ')');\n    }\n    /**\n     * Returns a JSON-serializable representation of this `Timestamp`.\n     */\n    toJSON() {\n        return {\n            type: Timestamp._jsonSchemaVersion,\n            seconds: this.seconds,\n            nanoseconds: this.nanoseconds\n        };\n    }\n    /**\n     * Builds a `Timestamp` instance from a JSON object created by {@link Timestamp.toJSON}.\n     */\n    static fromJSON(json) {\n        if (validateJSON(json, Timestamp._jsonSchema)) {\n            return new Timestamp(json.seconds, json.nanoseconds);\n        }\n    }\n    /**\n     * Converts this object to a primitive string, which allows `Timestamp` objects\n     * to be compared using the `>`, `<=`, `>=` and `>` operators.\n     */\n    valueOf() {\n        // This method returns a string of the form <seconds>.<nanoseconds> where\n        // <seconds> is translated to have a non-negative value and both <seconds>\n        // and <nanoseconds> are left-padded with zeroes to be a consistent length.\n        // Strings with this format then have a lexicographical ordering that matches\n        // the expected ordering. The <seconds> translation is done to avoid having\n        // a leading negative sign (i.e. a leading '-' character) in its string\n        // representation, which would affect its lexicographical ordering.\n        const adjustedSeconds = this.seconds - MIN_SECONDS;\n        // Note: Up to 12 decimal digits are required to represent all valid\n        // 'seconds' values.\n        const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\n        const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\n        return formattedSeconds + '.' + formattedNanoseconds;\n    }\n}\nTimestamp._jsonSchemaVersion = 'firestore/timestamp/1.0';\nTimestamp._jsonSchema = {\n    type: property('string', Timestamp._jsonSchemaVersion),\n    seconds: property('number'),\n    nanoseconds: property('number')\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A version of a document in Firestore. This corresponds to the version\n * timestamp, such as update_time or read_time.\n */\nclass SnapshotVersion {\n    static fromTimestamp(value) {\n        return new SnapshotVersion(value);\n    }\n    static min() {\n        return new SnapshotVersion(new Timestamp(0, 0));\n    }\n    static max() {\n        return new SnapshotVersion(new Timestamp(253402300799, 1e9 - 1));\n    }\n    constructor(timestamp) {\n        this.timestamp = timestamp;\n    }\n    compareTo(other) {\n        return this.timestamp._compareTo(other.timestamp);\n    }\n    isEqual(other) {\n        return this.timestamp.isEqual(other.timestamp);\n    }\n    /** Returns a number representation of the version for use in spec tests. */\n    toMicroseconds() {\n        // Convert to microseconds.\n        return this.timestamp.seconds * 1e6 + this.timestamp.nanoseconds / 1000;\n    }\n    toString() {\n        return 'SnapshotVersion(' + this.timestamp.toString() + ')';\n    }\n    toTimestamp() {\n        return this.timestamp;\n    }\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The initial mutation batch id for each index. Gets updated during index\n * backfill.\n */\nconst INITIAL_LARGEST_BATCH_ID = -1;\n/**\n * The initial sequence number for each index. Gets updated during index\n * backfill.\n */\nconst INITIAL_SEQUENCE_NUMBER = 0;\n/**\n * An index definition for field indexes in Firestore.\n *\n * Every index is associated with a collection. The definition contains a list\n * of fields and their index kind (which can be `ASCENDING`, `DESCENDING` or\n * `CONTAINS` for ArrayContains/ArrayContainsAny queries).\n *\n * Unlike the backend, the SDK does not differentiate between collection or\n * collection group-scoped indices. Every index can be used for both single\n * collection and collection group queries.\n */\nclass FieldIndex {\n    constructor(\n    /**\n     * The index ID. Returns -1 if the index ID is not available (e.g. the index\n     * has not yet been persisted).\n     */\n    indexId, \n    /** The collection ID this index applies to. */\n    collectionGroup, \n    /** The field segments for this index. */\n    fields, \n    /** Shows how up-to-date the index is for the current user. */\n    indexState) {\n        this.indexId = indexId;\n        this.collectionGroup = collectionGroup;\n        this.fields = fields;\n        this.indexState = indexState;\n    }\n}\n/** An ID for an index that has not yet been added to persistence.  */\nFieldIndex.UNKNOWN_ID = -1;\n/** Returns the ArrayContains/ArrayContainsAny segment for this index. */\nfunction fieldIndexGetArraySegment(fieldIndex) {\n    return fieldIndex.fields.find(s => s.kind === 2 /* IndexKind.CONTAINS */);\n}\n/** Returns all directional (ascending/descending) segments for this index. */\nfunction fieldIndexGetDirectionalSegments(fieldIndex) {\n    return fieldIndex.fields.filter(s => s.kind !== 2 /* IndexKind.CONTAINS */);\n}\n/**\n * Returns the order of the document key component for the given index.\n *\n * PORTING NOTE: This is only used in the Web IndexedDb implementation.\n */\nfunction fieldIndexGetKeyOrder(fieldIndex) {\n    const directionalSegments = fieldIndexGetDirectionalSegments(fieldIndex);\n    return directionalSegments.length === 0\n        ? 0 /* IndexKind.ASCENDING */\n        : directionalSegments[directionalSegments.length - 1].kind;\n}\n/**\n * Compares indexes by collection group and segments. Ignores update time and\n * index ID.\n */\nfunction fieldIndexSemanticComparator(left, right) {\n    let cmp = primitiveComparator(left.collectionGroup, right.collectionGroup);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    for (let i = 0; i < Math.min(left.fields.length, right.fields.length); ++i) {\n        cmp = indexSegmentComparator(left.fields[i], right.fields[i]);\n        if (cmp !== 0) {\n            return cmp;\n        }\n    }\n    return primitiveComparator(left.fields.length, right.fields.length);\n}\n/** Returns a debug representation of the field index */\nfunction fieldIndexToString(fieldIndex) {\n    return `id=${fieldIndex.indexId}|cg=${fieldIndex.collectionGroup}|f=${fieldIndex.fields.map(f => `${f.fieldPath}:${f.kind}`).join(',')}`;\n}\n/** An index component consisting of field path and index type.  */\nclass IndexSegment {\n    constructor(\n    /** The field path of the component. */\n    fieldPath, \n    /** The fields sorting order. */\n    kind) {\n        this.fieldPath = fieldPath;\n        this.kind = kind;\n    }\n}\nfunction indexSegmentComparator(left, right) {\n    const cmp = FieldPath$1.comparator(left.fieldPath, right.fieldPath);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return primitiveComparator(left.kind, right.kind);\n}\n/**\n * Stores the \"high water mark\" that indicates how updated the Index is for the\n * current user.\n */\nclass IndexState {\n    constructor(\n    /**\n     * Indicates when the index was last updated (relative to other indexes).\n     */\n    sequenceNumber, \n    /** The the latest indexed read time, document and batch id. */\n    offset) {\n        this.sequenceNumber = sequenceNumber;\n        this.offset = offset;\n    }\n    /** The state of an index that has not yet been backfilled. */\n    static empty() {\n        return new IndexState(INITIAL_SEQUENCE_NUMBER, IndexOffset.min());\n    }\n}\n/**\n * Creates an offset that matches all documents with a read time higher than\n * `readTime`.\n */\nfunction newIndexOffsetSuccessorFromReadTime(readTime, largestBatchId) {\n    // We want to create an offset that matches all documents with a read time\n    // greater than the provided read time. To do so, we technically need to\n    // create an offset for `(readTime, MAX_DOCUMENT_KEY)`. While we could use\n    // Unicode codepoints to generate MAX_DOCUMENT_KEY, it is much easier to use\n    // `(readTime + 1, DocumentKey.empty())` since `> DocumentKey.empty()` matches\n    // all valid document IDs.\n    const successorSeconds = readTime.toTimestamp().seconds;\n    const successorNanos = readTime.toTimestamp().nanoseconds + 1;\n    const successor = SnapshotVersion.fromTimestamp(successorNanos === 1e9\n        ? new Timestamp(successorSeconds + 1, 0)\n        : new Timestamp(successorSeconds, successorNanos));\n    return new IndexOffset(successor, DocumentKey.empty(), largestBatchId);\n}\n/** Creates a new offset based on the provided document. */\nfunction newIndexOffsetFromDocument(document) {\n    return new IndexOffset(document.readTime, document.key, INITIAL_LARGEST_BATCH_ID);\n}\n/**\n * Stores the latest read time, document and batch ID that were processed for an\n * index.\n */\nclass IndexOffset {\n    constructor(\n    /**\n     * The latest read time version that has been indexed by Firestore for this\n     * field index.\n     */\n    readTime, \n    /**\n     * The key of the last document that was indexed for this query. Use\n     * `DocumentKey.empty()` if no document has been indexed.\n     */\n    documentKey, \n    /*\n     * The largest mutation batch id that's been processed by Firestore.\n     */\n    largestBatchId) {\n        this.readTime = readTime;\n        this.documentKey = documentKey;\n        this.largestBatchId = largestBatchId;\n    }\n    /** Returns an offset that sorts before all regular offsets. */\n    static min() {\n        return new IndexOffset(SnapshotVersion.min(), DocumentKey.empty(), INITIAL_LARGEST_BATCH_ID);\n    }\n    /** Returns an offset that sorts after all regular offsets. */\n    static max() {\n        return new IndexOffset(SnapshotVersion.max(), DocumentKey.empty(), INITIAL_LARGEST_BATCH_ID);\n    }\n}\nfunction indexOffsetComparator(left, right) {\n    let cmp = left.readTime.compareTo(right.readTime);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = DocumentKey.comparator(left.documentKey, right.documentKey);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return primitiveComparator(left.largestBatchId, right.largestBatchId);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst PRIMARY_LEASE_LOST_ERROR_MSG = 'The current tab is not in the required state to perform this operation. ' +\n    'It might be necessary to refresh the browser tab.';\n/**\n * A base class representing a persistence transaction, encapsulating both the\n * transaction's sequence numbers as well as a list of onCommitted listeners.\n *\n * When you call Persistence.runTransaction(), it will create a transaction and\n * pass it to your callback. You then pass it to any method that operates\n * on persistence.\n */\nclass PersistenceTransaction {\n    constructor() {\n        this.onCommittedListeners = [];\n    }\n    addOnCommittedListener(listener) {\n        this.onCommittedListeners.push(listener);\n    }\n    raiseOnCommittedEvent() {\n        this.onCommittedListeners.forEach(listener => listener());\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Verifies the error thrown by a LocalStore operation. If a LocalStore\n * operation fails because the primary lease has been taken by another client,\n * we ignore the error (the persistence layer will immediately call\n * `applyPrimaryLease` to propagate the primary state change). All other errors\n * are re-thrown.\n *\n * @param err - An error returned by a LocalStore operation.\n * @returns A Promise that resolves after we recovered, or the original error.\n */\nasync function ignoreIfPrimaryLeaseLoss(err) {\n    if (err.code === Code.FAILED_PRECONDITION &&\n        err.message === PRIMARY_LEASE_LOST_ERROR_MSG) {\n        logDebug('LocalStore', 'Unexpectedly lost primary lease');\n    }\n    else {\n        throw err;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * PersistencePromise is essentially a re-implementation of Promise except\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\n * are executed synchronously when a PersistencePromise resolves rather than\n * asynchronously (Promise implementations use setImmediate() or similar).\n *\n * This is necessary to interoperate with IndexedDB which will automatically\n * commit transactions if control is returned to the event loop without\n * synchronously initiating another operation on the transaction.\n *\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\n * Promises.\n */\nclass PersistencePromise {\n    constructor(callback) {\n        // NOTE: next/catchCallback will always point to our own wrapper functions,\n        // not the user's raw next() or catch() callbacks.\n        this.nextCallback = null;\n        this.catchCallback = null;\n        // When the operation resolves, we'll set result or error and mark isDone.\n        this.result = undefined;\n        this.error = undefined;\n        this.isDone = false;\n        // Set to true when .then() or .catch() are called and prevents additional\n        // chaining.\n        this.callbackAttached = false;\n        callback(value => {\n            this.isDone = true;\n            this.result = value;\n            if (this.nextCallback) {\n                // value should be defined unless T is Void, but we can't express\n                // that in the type system.\n                this.nextCallback(value);\n            }\n        }, error => {\n            this.isDone = true;\n            this.error = error;\n            if (this.catchCallback) {\n                this.catchCallback(error);\n            }\n        });\n    }\n    catch(fn) {\n        return this.next(undefined, fn);\n    }\n    next(nextFn, catchFn) {\n        if (this.callbackAttached) {\n            fail(0xe830);\n        }\n        this.callbackAttached = true;\n        if (this.isDone) {\n            if (!this.error) {\n                return this.wrapSuccess(nextFn, this.result);\n            }\n            else {\n                return this.wrapFailure(catchFn, this.error);\n            }\n        }\n        else {\n            return new PersistencePromise((resolve, reject) => {\n                this.nextCallback = (value) => {\n                    this.wrapSuccess(nextFn, value).next(resolve, reject);\n                };\n                this.catchCallback = (error) => {\n                    this.wrapFailure(catchFn, error).next(resolve, reject);\n                };\n            });\n        }\n    }\n    toPromise() {\n        return new Promise((resolve, reject) => {\n            this.next(resolve, reject);\n        });\n    }\n    wrapUserFunction(fn) {\n        try {\n            const result = fn();\n            if (result instanceof PersistencePromise) {\n                return result;\n            }\n            else {\n                return PersistencePromise.resolve(result);\n            }\n        }\n        catch (e) {\n            return PersistencePromise.reject(e);\n        }\n    }\n    wrapSuccess(nextFn, value) {\n        if (nextFn) {\n            return this.wrapUserFunction(() => nextFn(value));\n        }\n        else {\n            // If there's no nextFn, then R must be the same as T\n            return PersistencePromise.resolve(value);\n        }\n    }\n    wrapFailure(catchFn, error) {\n        if (catchFn) {\n            return this.wrapUserFunction(() => catchFn(error));\n        }\n        else {\n            return PersistencePromise.reject(error);\n        }\n    }\n    static resolve(result) {\n        return new PersistencePromise((resolve, reject) => {\n            resolve(result);\n        });\n    }\n    static reject(error) {\n        return new PersistencePromise((resolve, reject) => {\n            reject(error);\n        });\n    }\n    static waitFor(\n    // Accept all Promise types in waitFor().\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    all) {\n        return new PersistencePromise((resolve, reject) => {\n            let expectedCount = 0;\n            let resolvedCount = 0;\n            let done = false;\n            all.forEach(element => {\n                ++expectedCount;\n                element.next(() => {\n                    ++resolvedCount;\n                    if (done && resolvedCount === expectedCount) {\n                        resolve();\n                    }\n                }, err => reject(err));\n            });\n            done = true;\n            if (resolvedCount === expectedCount) {\n                resolve();\n            }\n        });\n    }\n    /**\n     * Given an array of predicate functions that asynchronously evaluate to a\n     * boolean, implements a short-circuiting `or` between the results. Predicates\n     * will be evaluated until one of them returns `true`, then stop. The final\n     * result will be whether any of them returned `true`.\n     */\n    static or(predicates) {\n        let p = PersistencePromise.resolve(false);\n        for (const predicate of predicates) {\n            p = p.next(isTrue => {\n                if (isTrue) {\n                    return PersistencePromise.resolve(isTrue);\n                }\n                else {\n                    return predicate();\n                }\n            });\n        }\n        return p;\n    }\n    static forEach(collection, f) {\n        const promises = [];\n        collection.forEach((r, s) => {\n            promises.push(f.call(this, r, s));\n        });\n        return this.waitFor(promises);\n    }\n    /**\n     * Concurrently map all array elements through asynchronous function.\n     */\n    static mapArray(array, f) {\n        return new PersistencePromise((resolve, reject) => {\n            const expectedCount = array.length;\n            const results = new Array(expectedCount);\n            let resolvedCount = 0;\n            for (let i = 0; i < expectedCount; i++) {\n                const current = i;\n                f(array[current]).next(result => {\n                    results[current] = result;\n                    ++resolvedCount;\n                    if (resolvedCount === expectedCount) {\n                        resolve(results);\n                    }\n                }, err => reject(err));\n            }\n        });\n    }\n    /**\n     * An alternative to recursive PersistencePromise calls, that avoids\n     * potential memory problems from unbounded chains of promises.\n     *\n     * The `action` will be called repeatedly while `condition` is true.\n     */\n    static doWhile(condition, action) {\n        return new PersistencePromise((resolve, reject) => {\n            const process = () => {\n                if (condition() === true) {\n                    action().next(() => {\n                        process();\n                    }, reject);\n                }\n                else {\n                    resolve();\n                }\n            };\n            process();\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// References to `indexedDB` are guarded by SimpleDb.isAvailable() and getGlobal()\n/* eslint-disable no-restricted-globals */\nconst LOG_TAG$i = 'SimpleDb';\n/**\n * The maximum number of retry attempts for an IndexedDb transaction that fails\n * with a DOMException.\n */\nconst TRANSACTION_RETRY_COUNT = 3;\n/**\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\n * specific object store.\n */\nclass SimpleDbTransaction {\n    static open(db, action, mode, objectStoreNames) {\n        try {\n            return new SimpleDbTransaction(action, db.transaction(objectStoreNames, mode));\n        }\n        catch (e) {\n            throw new IndexedDbTransactionError(action, e);\n        }\n    }\n    constructor(action, transaction) {\n        this.action = action;\n        this.transaction = transaction;\n        this.aborted = false;\n        /**\n         * A `Promise` that resolves with the result of the IndexedDb transaction.\n         */\n        this.completionDeferred = new Deferred();\n        this.transaction.oncomplete = () => {\n            this.completionDeferred.resolve();\n        };\n        this.transaction.onabort = () => {\n            if (transaction.error) {\n                this.completionDeferred.reject(new IndexedDbTransactionError(action, transaction.error));\n            }\n            else {\n                this.completionDeferred.resolve();\n            }\n        };\n        this.transaction.onerror = (event) => {\n            const error = checkForAndReportiOSError(event.target.error);\n            this.completionDeferred.reject(new IndexedDbTransactionError(action, error));\n        };\n    }\n    get completionPromise() {\n        return this.completionDeferred.promise;\n    }\n    abort(error) {\n        if (error) {\n            this.completionDeferred.reject(error);\n        }\n        if (!this.aborted) {\n            logDebug(LOG_TAG$i, 'Aborting transaction:', error ? error.message : 'Client-initiated abort');\n            this.aborted = true;\n            this.transaction.abort();\n        }\n    }\n    maybeCommit() {\n        // If the browser supports V3 IndexedDB, we invoke commit() explicitly to\n        // speed up index DB processing if the event loop remains blocks.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const maybeV3IndexedDb = this.transaction;\n        if (!this.aborted && typeof maybeV3IndexedDb.commit === 'function') {\n            maybeV3IndexedDb.commit();\n        }\n    }\n    /**\n     * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\n     * operations performed on the SimpleDbStore happen within the context of this\n     * transaction and it cannot be used anymore once the transaction is\n     * completed.\n     *\n     * Note that we can't actually enforce that the KeyType and ValueType are\n     * correct, but they allow type safety through the rest of the consuming code.\n     */\n    store(storeName) {\n        const store = this.transaction.objectStore(storeName);\n        return new SimpleDbStore(store);\n    }\n}\n/**\n * Provides a wrapper around IndexedDb with a simplified interface that uses\n * Promise-like return values to chain operations. Real promises cannot be used\n * since .then() continuations are executed asynchronously (e.g. via\n * .setImmediate), which would cause IndexedDB to end the transaction.\n * See PersistencePromise for more details.\n */\nclass SimpleDb {\n    /** Deletes the specified database. */\n    static delete(name) {\n        logDebug(LOG_TAG$i, 'Removing database:', name);\n        const globals = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getGlobal)();\n        return wrapRequest(globals.indexedDB.deleteDatabase(name)).toPromise();\n    }\n    /** Returns true if IndexedDB is available in the current environment. */\n    static isAvailable() {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isIndexedDBAvailable)()) {\n            return false;\n        }\n        if (SimpleDb.isMockPersistence()) {\n            return true;\n        }\n        // We extensively use indexed array values and compound keys,\n        // which IE and Edge do not support. However, they still have indexedDB\n        // defined on the window, so we need to check for them here and make sure\n        // to return that persistence is not enabled for those browsers.\n        // For tracking support of this feature, see here:\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\n        // Check the UA string to find out the browser.\n        const ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)();\n        // IE 10\n        // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n        // IE 11\n        // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n        // Edge\n        // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\n        // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n        // iOS Safari: Disable for users running iOS version < 10.\n        const iOSVersion = SimpleDb.getIOSVersion(ua);\n        const isUnsupportedIOS = 0 < iOSVersion && iOSVersion < 10;\n        // Android browser: Disable for users running version < 4.5.\n        const androidVersion = getAndroidVersion(ua);\n        const isUnsupportedAndroid = 0 < androidVersion && androidVersion < 4.5;\n        if (ua.indexOf('MSIE ') > 0 ||\n            ua.indexOf('Trident/') > 0 ||\n            ua.indexOf('Edge/') > 0 ||\n            isUnsupportedIOS ||\n            isUnsupportedAndroid) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    /**\n     * Returns true if the backing IndexedDB store is the Node IndexedDBShim\n     * (see https://github.com/axemclion/IndexedDBShim).\n     */\n    static isMockPersistence() {\n        return (typeof process !== 'undefined' &&\n            process.env?.USE_MOCK_PERSISTENCE === 'YES');\n    }\n    /** Helper to get a typed SimpleDbStore from a transaction. */\n    static getStore(txn, store) {\n        return txn.store(store);\n    }\n    // visible for testing\n    /** Parse User Agent to determine iOS version. Returns -1 if not found. */\n    static getIOSVersion(ua) {\n        const iOSVersionRegex = ua.match(/i(?:phone|pad|pod) os ([\\d_]+)/i);\n        const version = iOSVersionRegex\n            ? iOSVersionRegex[1].split('_').slice(0, 2).join('.')\n            : '-1';\n        return Number(version);\n    }\n    /*\n     * Creates a new SimpleDb wrapper for IndexedDb database `name`.\n     *\n     * Note that `version` must not be a downgrade. IndexedDB does not support\n     * downgrading the schema version. We currently do not support any way to do\n     * versioning outside of IndexedDB's versioning mechanism, as only\n     * version-upgrade transactions are allowed to do things like create\n     * objectstores.\n     */\n    constructor(name, version, schemaConverter) {\n        this.name = name;\n        this.version = version;\n        this.schemaConverter = schemaConverter;\n        this.lastClosedDbVersion = null;\n        const iOSVersion = SimpleDb.getIOSVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)());\n        // NOTE: According to https://bugs.webkit.org/show_bug.cgi?id=197050, the\n        // bug we're checking for should exist in iOS >= 12.2 and < 13, but for\n        // whatever reason it's much harder to hit after 12.2 so we only proactively\n        // log on 12.2.\n        if (iOSVersion === 12.2) {\n            logError('Firestore persistence suffers from a bug in iOS 12.2 ' +\n                'Safari that may cause your app to stop working. See ' +\n                'https://stackoverflow.com/q/56496296/110915 for details ' +\n                'and a potential workaround.');\n        }\n    }\n    /**\n     * Opens the specified database, creating or upgrading it if necessary.\n     */\n    async ensureDb(action) {\n        if (!this.db) {\n            logDebug(LOG_TAG$i, 'Opening database:', this.name);\n            this.db = await new Promise((resolve, reject) => {\n                // TODO(mikelehen): Investigate browser compatibility.\n                // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\n                // suggests IE9 and older WebKit browsers handle upgrade\n                // differently. They expect setVersion, as described here:\n                // https://developer.mozilla.org/en-US/docs/Web/API/IDBVersionChangeRequest/setVersion\n                const request = indexedDB.open(this.name, this.version);\n                request.onsuccess = (event) => {\n                    const db = event.target.result;\n                    resolve(db);\n                };\n                request.onblocked = () => {\n                    reject(new IndexedDbTransactionError(action, 'Cannot upgrade IndexedDB schema while another tab is open. ' +\n                        'Close all tabs that access Firestore and reload this page to proceed.'));\n                };\n                request.onerror = (event) => {\n                    const error = event.target.error;\n                    if (error.name === 'VersionError') {\n                        reject(new FirestoreError(Code.FAILED_PRECONDITION, 'A newer version of the Firestore SDK was previously used and so the persisted ' +\n                            'data is not compatible with the version of the SDK you are now using. The SDK ' +\n                            'will operate with persistence disabled. If you need persistence, please ' +\n                            're-upgrade to a newer version of the SDK or else clear the persisted IndexedDB ' +\n                            'data for your app to start fresh.'));\n                    }\n                    else if (error.name === 'InvalidStateError') {\n                        reject(new FirestoreError(Code.FAILED_PRECONDITION, 'Unable to open an IndexedDB connection. This could be due to running in a ' +\n                            'private browsing session on a browser whose private browsing sessions do not ' +\n                            'support IndexedDB: ' +\n                            error));\n                    }\n                    else {\n                        reject(new IndexedDbTransactionError(action, error));\n                    }\n                };\n                request.onupgradeneeded = (event) => {\n                    logDebug(LOG_TAG$i, 'Database \"' + this.name + '\" requires upgrade from version:', event.oldVersion);\n                    const db = event.target.result;\n                    this.schemaConverter\n                        .createOrUpgrade(db, request.transaction, event.oldVersion, this.version)\n                        .next(() => {\n                        logDebug(LOG_TAG$i, 'Database upgrade to version ' + this.version + ' complete');\n                    });\n                };\n            });\n        }\n        if (this.versionchangelistener) {\n            this.db.onversionchange = event => this.versionchangelistener(event);\n        }\n        return this.db;\n    }\n    setVersionChangeListener(versionChangeListener) {\n        this.versionchangelistener = versionChangeListener;\n        if (this.db) {\n            this.db.onversionchange = (event) => {\n                return versionChangeListener(event);\n            };\n        }\n    }\n    async runTransaction(action, mode, objectStores, transactionFn) {\n        const readonly = mode === 'readonly';\n        let attemptNumber = 0;\n        while (true) {\n            ++attemptNumber;\n            try {\n                this.db = await this.ensureDb(action);\n                const transaction = SimpleDbTransaction.open(this.db, action, readonly ? 'readonly' : 'readwrite', objectStores);\n                const transactionFnResult = transactionFn(transaction)\n                    .next(result => {\n                    transaction.maybeCommit();\n                    return result;\n                })\n                    .catch(error => {\n                    // Abort the transaction if there was an error.\n                    transaction.abort(error);\n                    // We cannot actually recover, and calling `abort()` will cause the transaction's\n                    // completion promise to be rejected. This in turn means that we won't use\n                    // `transactionFnResult` below. We return a rejection here so that we don't add the\n                    // possibility of returning `void` to the type of `transactionFnResult`.\n                    return PersistencePromise.reject(error);\n                })\n                    .toPromise();\n                // As noted above, errors are propagated by aborting the transaction. So\n                // we swallow any error here to avoid the browser logging it as unhandled.\n                transactionFnResult.catch(() => { });\n                // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\n                // fire), but still return the original transactionFnResult back to the\n                // caller.\n                await transaction.completionPromise;\n                return transactionFnResult;\n            }\n            catch (e) {\n                const error = e;\n                // TODO(schmidt-sebastian): We could probably be smarter about this and\n                // not retry exceptions that are likely unrecoverable (such as quota\n                // exceeded errors).\n                // Note: We cannot use an instanceof check for FirestoreException, since the\n                // exception is wrapped in a generic error by our async/await handling.\n                const retryable = error.name !== 'FirebaseError' &&\n                    attemptNumber < TRANSACTION_RETRY_COUNT;\n                logDebug(LOG_TAG$i, 'Transaction failed with error:', error.message, 'Retrying:', retryable);\n                this.close();\n                if (!retryable) {\n                    return Promise.reject(error);\n                }\n            }\n        }\n    }\n    close() {\n        if (this.db) {\n            this.db.close();\n        }\n        this.db = undefined;\n    }\n}\n/** Parse User Agent to determine Android version. Returns -1 if not found. */\nfunction getAndroidVersion(ua) {\n    const androidVersionRegex = ua.match(/Android ([\\d.]+)/i);\n    const version = androidVersionRegex\n        ? androidVersionRegex[1].split('.').slice(0, 2).join('.')\n        : '-1';\n    return Number(version);\n}\n/**\n * A controller for iterating over a key range or index. It allows an iterate\n * callback to delete the currently-referenced object, or jump to a new key\n * within the key range or index.\n */\nclass IterationController {\n    constructor(dbCursor) {\n        this.dbCursor = dbCursor;\n        this.shouldStop = false;\n        this.nextKey = null;\n    }\n    get isDone() {\n        return this.shouldStop;\n    }\n    get skipToKey() {\n        return this.nextKey;\n    }\n    set cursor(value) {\n        this.dbCursor = value;\n    }\n    /**\n     * This function can be called to stop iteration at any point.\n     */\n    done() {\n        this.shouldStop = true;\n    }\n    /**\n     * This function can be called to skip to that next key, which could be\n     * an index or a primary key.\n     */\n    skip(key) {\n        this.nextKey = key;\n    }\n    /**\n     * Delete the current cursor value from the object store.\n     *\n     * NOTE: You CANNOT do this with a keysOnly query.\n     */\n    delete() {\n        return wrapRequest(this.dbCursor.delete());\n    }\n}\n/** An error that wraps exceptions that thrown during IndexedDB execution. */\nclass IndexedDbTransactionError extends FirestoreError {\n    constructor(actionName, cause) {\n        super(Code.UNAVAILABLE, `IndexedDB transaction '${actionName}' failed: ${cause}`);\n        this.name = 'IndexedDbTransactionError';\n    }\n}\n/** Verifies whether `e` is an IndexedDbTransactionError. */\nfunction isIndexedDbTransactionError(e) {\n    // Use name equality, as instanceof checks on errors don't work with errors\n    // that wrap other errors.\n    return e.name === 'IndexedDbTransactionError';\n}\n/**\n * A wrapper around an IDBObjectStore providing an API that:\n *\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\n * methods for acting against the object store.\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\n * method return a PersistencePromise instead.\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\n */\nclass SimpleDbStore {\n    constructor(store) {\n        this.store = store;\n    }\n    put(keyOrValue, value) {\n        let request;\n        if (value !== undefined) {\n            logDebug(LOG_TAG$i, 'PUT', this.store.name, keyOrValue, value);\n            request = this.store.put(value, keyOrValue);\n        }\n        else {\n            logDebug(LOG_TAG$i, 'PUT', this.store.name, '<auto-key>', keyOrValue);\n            request = this.store.put(keyOrValue);\n        }\n        return wrapRequest(request);\n    }\n    /**\n     * Adds a new value into an Object Store and returns the new key. Similar to\n     * IndexedDb's `add()`, this method will fail on primary key collisions.\n     *\n     * @param value - The object to write.\n     * @returns The key of the value to add.\n     */\n    add(value) {\n        logDebug(LOG_TAG$i, 'ADD', this.store.name, value, value);\n        const request = this.store.add(value);\n        return wrapRequest(request);\n    }\n    /**\n     * Gets the object with the specified key from the specified store, or null\n     * if no object exists with the specified key.\n     *\n     * @key The key of the object to get.\n     * @returns The object with the specified key or null if no object exists.\n     */\n    get(key) {\n        const request = this.store.get(key);\n        // We're doing an unsafe cast to ValueType.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return wrapRequest(request).next(result => {\n            // Normalize nonexistence to null.\n            if (result === undefined) {\n                result = null;\n            }\n            logDebug(LOG_TAG$i, 'GET', this.store.name, key, result);\n            return result;\n        });\n    }\n    delete(key) {\n        logDebug(LOG_TAG$i, 'DELETE', this.store.name, key);\n        const request = this.store.delete(key);\n        return wrapRequest(request);\n    }\n    /**\n     * If we ever need more of the count variants, we can add overloads. For now,\n     * all we need is to count everything in a store.\n     *\n     * Returns the number of rows in the store.\n     */\n    count() {\n        logDebug(LOG_TAG$i, 'COUNT', this.store.name);\n        const request = this.store.count();\n        return wrapRequest(request);\n    }\n    loadAll(indexOrRange, range) {\n        const iterateOptions = this.options(indexOrRange, range);\n        // Use `getAll()` if the browser supports IndexedDB v3, as it is roughly\n        // 20% faster.\n        const store = iterateOptions.index\n            ? this.store.index(iterateOptions.index)\n            : this.store;\n        if (typeof store.getAll === 'function') {\n            const request = store.getAll(iterateOptions.range);\n            return new PersistencePromise((resolve, reject) => {\n                request.onerror = (event) => {\n                    reject(event.target.error);\n                };\n                request.onsuccess = (event) => {\n                    resolve(event.target.result);\n                };\n            });\n        }\n        else {\n            const cursor = this.cursor(iterateOptions);\n            const results = [];\n            return this.iterateCursor(cursor, (key, value) => {\n                results.push(value);\n            }).next(() => {\n                return results;\n            });\n        }\n    }\n    /**\n     * Loads the first `count` elements from the provided index range. Loads all\n     * elements if no limit is provided.\n     */\n    loadFirst(range, count) {\n        const request = this.store.getAll(range, count === null ? undefined : count);\n        return new PersistencePromise((resolve, reject) => {\n            request.onerror = (event) => {\n                reject(event.target.error);\n            };\n            request.onsuccess = (event) => {\n                resolve(event.target.result);\n            };\n        });\n    }\n    deleteAll(indexOrRange, range) {\n        logDebug(LOG_TAG$i, 'DELETE ALL', this.store.name);\n        const options = this.options(indexOrRange, range);\n        options.keysOnly = false;\n        const cursor = this.cursor(options);\n        return this.iterateCursor(cursor, (key, value, control) => {\n            // NOTE: Calling delete() on a cursor is documented as more efficient than\n            // calling delete() on an object store with a single key\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\n            // however, this requires us *not* to use a keysOnly cursor\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\n            // may want to compare the performance of each method.\n            return control.delete();\n        });\n    }\n    iterate(optionsOrCallback, callback) {\n        let options;\n        if (!callback) {\n            options = {};\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        const cursor = this.cursor(options);\n        return this.iterateCursor(cursor, callback);\n    }\n    /**\n     * Iterates over a store, but waits for the given callback to complete for\n     * each entry before iterating the next entry. This allows the callback to do\n     * asynchronous work to determine if this iteration should continue.\n     *\n     * The provided callback should return `true` to continue iteration, and\n     * `false` otherwise.\n     */\n    iterateSerial(callback) {\n        const cursorRequest = this.cursor({});\n        return new PersistencePromise((resolve, reject) => {\n            cursorRequest.onerror = (event) => {\n                const error = checkForAndReportiOSError(event.target.error);\n                reject(error);\n            };\n            cursorRequest.onsuccess = (event) => {\n                const cursor = event.target.result;\n                if (!cursor) {\n                    resolve();\n                    return;\n                }\n                callback(cursor.primaryKey, cursor.value).next(shouldContinue => {\n                    if (shouldContinue) {\n                        cursor.continue();\n                    }\n                    else {\n                        resolve();\n                    }\n                });\n            };\n        });\n    }\n    iterateCursor(cursorRequest, fn) {\n        const results = [];\n        return new PersistencePromise((resolve, reject) => {\n            cursorRequest.onerror = (event) => {\n                reject(event.target.error);\n            };\n            cursorRequest.onsuccess = (event) => {\n                const cursor = event.target.result;\n                if (!cursor) {\n                    resolve();\n                    return;\n                }\n                const controller = new IterationController(cursor);\n                const userResult = fn(cursor.primaryKey, cursor.value, controller);\n                if (userResult instanceof PersistencePromise) {\n                    const userPromise = userResult.catch(err => {\n                        controller.done();\n                        return PersistencePromise.reject(err);\n                    });\n                    results.push(userPromise);\n                }\n                if (controller.isDone) {\n                    resolve();\n                }\n                else if (controller.skipToKey === null) {\n                    cursor.continue();\n                }\n                else {\n                    cursor.continue(controller.skipToKey);\n                }\n            };\n        }).next(() => PersistencePromise.waitFor(results));\n    }\n    options(indexOrRange, range) {\n        let indexName = undefined;\n        if (indexOrRange !== undefined) {\n            if (typeof indexOrRange === 'string') {\n                indexName = indexOrRange;\n            }\n            else {\n                range = indexOrRange;\n            }\n        }\n        return { index: indexName, range };\n    }\n    cursor(options) {\n        let direction = 'next';\n        if (options.reverse) {\n            direction = 'prev';\n        }\n        if (options.index) {\n            const index = this.store.index(options.index);\n            if (options.keysOnly) {\n                return index.openKeyCursor(options.range, direction);\n            }\n            else {\n                return index.openCursor(options.range, direction);\n            }\n        }\n        else {\n            return this.store.openCursor(options.range, direction);\n        }\n    }\n}\n/**\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\n * handlers to resolve / reject the PersistencePromise as appropriate.\n */\nfunction wrapRequest(request) {\n    return new PersistencePromise((resolve, reject) => {\n        request.onsuccess = (event) => {\n            const result = event.target.result;\n            resolve(result);\n        };\n        request.onerror = (event) => {\n            const error = checkForAndReportiOSError(event.target.error);\n            reject(error);\n        };\n    });\n}\n// Guard so we only report the error once.\nlet reportedIOSError = false;\nfunction checkForAndReportiOSError(error) {\n    const iOSVersion = SimpleDb.getIOSVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)());\n    if (iOSVersion >= 12.2 && iOSVersion < 13) {\n        const IOS_ERROR = 'An internal error was encountered in the Indexed Database server';\n        if (error.message.indexOf(IOS_ERROR) >= 0) {\n            // Wrap error in a more descriptive one.\n            const newError = new FirestoreError('internal', `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${IOS_ERROR}'. This is likely ` +\n                `due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 ` +\n                `for details and a potential workaround.`);\n            if (!reportedIOSError) {\n                reportedIOSError = true;\n                // Throw a global exception outside of this promise chain, for the user to\n                // potentially catch.\n                setTimeout(() => {\n                    throw newError;\n                }, 0);\n            }\n            return newError;\n        }\n    }\n    return error;\n}\n\nconst LOG_TAG$h = 'IndexBackfiller';\n/** How long we wait to try running index backfill after SDK initialization. */\nconst INITIAL_BACKFILL_DELAY_MS = 15 * 1000;\n/** Minimum amount of time between backfill checks, after the first one. */\nconst REGULAR_BACKFILL_DELAY_MS = 60 * 1000;\n/** The maximum number of documents to process each time backfill() is called. */\nconst MAX_DOCUMENTS_TO_PROCESS = 50;\n/** This class is responsible for the scheduling of Index Backfiller. */\nclass IndexBackfillerScheduler {\n    constructor(asyncQueue, backfiller) {\n        this.asyncQueue = asyncQueue;\n        this.backfiller = backfiller;\n        this.task = null;\n    }\n    start() {\n        this.schedule(INITIAL_BACKFILL_DELAY_MS);\n    }\n    stop() {\n        if (this.task) {\n            this.task.cancel();\n            this.task = null;\n        }\n    }\n    get started() {\n        return this.task !== null;\n    }\n    schedule(delay) {\n        logDebug(LOG_TAG$h, `Scheduled in ${delay}ms`);\n        this.task = this.asyncQueue.enqueueAfterDelay(\"index_backfill\" /* TimerId.IndexBackfill */, delay, async () => {\n            this.task = null;\n            try {\n                const documentsProcessed = await this.backfiller.backfill();\n                logDebug(LOG_TAG$h, `Documents written: ${documentsProcessed}`);\n            }\n            catch (e) {\n                if (isIndexedDbTransactionError(e)) {\n                    logDebug(LOG_TAG$h, 'Ignoring IndexedDB error during index backfill: ', e);\n                }\n                else {\n                    await ignoreIfPrimaryLeaseLoss(e);\n                }\n            }\n            await this.schedule(REGULAR_BACKFILL_DELAY_MS);\n        });\n    }\n}\n/** Implements the steps for backfilling indexes. */\nclass IndexBackfiller {\n    constructor(\n    /**\n     * LocalStore provides access to IndexManager and LocalDocumentView.\n     * These properties will update when the user changes. Consequently,\n     * making a local copy of IndexManager and LocalDocumentView will require\n     * updates over time. The simpler solution is to rely on LocalStore to have\n     * an up-to-date references to IndexManager and LocalDocumentStore.\n     */\n    localStore, persistence) {\n        this.localStore = localStore;\n        this.persistence = persistence;\n    }\n    async backfill(maxDocumentsToProcess = MAX_DOCUMENTS_TO_PROCESS) {\n        return this.persistence.runTransaction('Backfill Indexes', 'readwrite-primary', txn => this.writeIndexEntries(txn, maxDocumentsToProcess));\n    }\n    /** Writes index entries until the cap is reached. Returns the number of documents processed. */\n    writeIndexEntries(transaction, maxDocumentsToProcess) {\n        const processedCollectionGroups = new Set();\n        let documentsRemaining = maxDocumentsToProcess;\n        let continueLoop = true;\n        return PersistencePromise.doWhile(() => continueLoop === true && documentsRemaining > 0, () => {\n            return this.localStore.indexManager\n                .getNextCollectionGroupToUpdate(transaction)\n                .next((collectionGroup) => {\n                if (collectionGroup === null ||\n                    processedCollectionGroups.has(collectionGroup)) {\n                    continueLoop = false;\n                }\n                else {\n                    logDebug(LOG_TAG$h, `Processing collection: ${collectionGroup}`);\n                    return this.writeEntriesForCollectionGroup(transaction, collectionGroup, documentsRemaining).next(documentsProcessed => {\n                        documentsRemaining -= documentsProcessed;\n                        processedCollectionGroups.add(collectionGroup);\n                    });\n                }\n            });\n        }).next(() => maxDocumentsToProcess - documentsRemaining);\n    }\n    /**\n     * Writes entries for the provided collection group. Returns the number of documents processed.\n     */\n    writeEntriesForCollectionGroup(transaction, collectionGroup, documentsRemainingUnderCap) {\n        // Use the earliest offset of all field indexes to query the local cache.\n        return this.localStore.indexManager\n            .getMinOffsetFromCollectionGroup(transaction, collectionGroup)\n            .next(existingOffset => this.localStore.localDocuments\n            .getNextDocuments(transaction, collectionGroup, existingOffset, documentsRemainingUnderCap)\n            .next(nextBatch => {\n            const docs = nextBatch.changes;\n            return this.localStore.indexManager\n                .updateIndexEntries(transaction, docs)\n                .next(() => this.getNewOffset(existingOffset, nextBatch))\n                .next(newOffset => {\n                logDebug(LOG_TAG$h, `Updating offset: ${newOffset}`);\n                return this.localStore.indexManager.updateCollectionGroup(transaction, collectionGroup, newOffset);\n            })\n                .next(() => docs.size);\n        }));\n    }\n    /** Returns the next offset based on the provided documents. */\n    getNewOffset(existingOffset, lookupResult) {\n        let maxOffset = existingOffset;\n        lookupResult.changes.forEach((key, document) => {\n            const newOffset = newIndexOffsetFromDocument(document);\n            if (indexOffsetComparator(newOffset, maxOffset) > 0) {\n                maxOffset = newOffset;\n            }\n        });\n        return new IndexOffset(maxOffset.readTime, maxOffset.documentKey, Math.max(lookupResult.batchId, existingOffset.largestBatchId));\n    }\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * `ListenSequence` is a monotonic sequence. It is initialized with a minimum value to\n * exceed. All subsequent calls to next will return increasing values. If provided with a\n * `SequenceNumberSyncer`, it will additionally bump its next value when told of a new value, as\n * well as write out sequence numbers that it produces via `next()`.\n */\nclass ListenSequence {\n    constructor(previousValue, sequenceNumberSyncer) {\n        this.previousValue = previousValue;\n        if (sequenceNumberSyncer) {\n            sequenceNumberSyncer.sequenceNumberHandler = sequenceNumber => this.setPreviousValue(sequenceNumber);\n            this.writeNewSequenceNumber = sequenceNumber => sequenceNumberSyncer.writeSequenceNumber(sequenceNumber);\n        }\n    }\n    setPreviousValue(externalPreviousValue) {\n        this.previousValue = Math.max(externalPreviousValue, this.previousValue);\n        return this.previousValue;\n    }\n    next() {\n        const nextValue = ++this.previousValue;\n        if (this.writeNewSequenceNumber) {\n            this.writeNewSequenceNumber(nextValue);\n        }\n        return nextValue;\n    }\n}\nListenSequence.INVALID = -1;\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst escapeChar = '\\u0001';\nconst encodedSeparatorChar = '\\u0001';\nconst encodedNul = '\\u0010';\nconst encodedEscape = '\\u0011';\n/**\n * Encodes a resource path into a IndexedDb-compatible string form.\n */\nfunction encodeResourcePath(path) {\n    let result = '';\n    for (let i = 0; i < path.length; i++) {\n        if (result.length > 0) {\n            result = encodeSeparator(result);\n        }\n        result = encodeSegment(path.get(i), result);\n    }\n    return encodeSeparator(result);\n}\n/** Encodes a single segment of a resource path into the given result */\nfunction encodeSegment(segment, resultBuf) {\n    let result = resultBuf;\n    const length = segment.length;\n    for (let i = 0; i < length; i++) {\n        const c = segment.charAt(i);\n        switch (c) {\n            case '\\0':\n                result += escapeChar + encodedNul;\n                break;\n            case escapeChar:\n                result += escapeChar + encodedEscape;\n                break;\n            default:\n                result += c;\n        }\n    }\n    return result;\n}\n/** Encodes a path separator into the given result */\nfunction encodeSeparator(result) {\n    return result + escapeChar + encodedSeparatorChar;\n}\n/**\n * Decodes the given IndexedDb-compatible string form of a resource path into\n * a ResourcePath instance. Note that this method is not suitable for use with\n * decoding resource names from the server; those are One Platform format\n * strings.\n */\nfunction decodeResourcePath(path) {\n    // Event the empty path must encode as a path of at least length 2. A path\n    // with exactly 2 must be the empty path.\n    const length = path.length;\n    hardAssert(length >= 2, 0xfb98, { path });\n    if (length === 2) {\n        hardAssert(path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar, 0xdb51, { path });\n        return ResourcePath.emptyPath();\n    }\n    // Escape characters cannot exist past the second-to-last position in the\n    // source value.\n    const lastReasonableEscapeIndex = length - 2;\n    const segments = [];\n    let segmentBuilder = '';\n    for (let start = 0; start < length;) {\n        // The last two characters of a valid encoded path must be a separator, so\n        // there must be an end to this segment.\n        const end = path.indexOf(escapeChar, start);\n        if (end < 0 || end > lastReasonableEscapeIndex) {\n            fail(0xc553, { path });\n        }\n        const next = path.charAt(end + 1);\n        switch (next) {\n            case encodedSeparatorChar:\n                const currentPiece = path.substring(start, end);\n                let segment;\n                if (segmentBuilder.length === 0) {\n                    // Avoid copying for the common case of a segment that excludes \\0\n                    // and \\001\n                    segment = currentPiece;\n                }\n                else {\n                    segmentBuilder += currentPiece;\n                    segment = segmentBuilder;\n                    segmentBuilder = '';\n                }\n                segments.push(segment);\n                break;\n            case encodedNul:\n                segmentBuilder += path.substring(start, end);\n                segmentBuilder += '\\0';\n                break;\n            case encodedEscape:\n                // The escape character can be used in the output to encode itself.\n                segmentBuilder += path.substring(start, end + 1);\n                break;\n            default:\n                fail(0xeeef, { path });\n        }\n        start = end + 2;\n    }\n    return new ResourcePath(segments);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DbRemoteDocumentStore$1 = 'remoteDocuments';\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Name of the IndexedDb object store.\n *\n * Note that the name 'owner' is chosen to ensure backwards compatibility with\n * older clients that only supported single locked access to the persistence\n * layer.\n */\nconst DbPrimaryClientStore = 'owner';\n/**\n * The key string used for the single object that exists in the\n * DbPrimaryClient store.\n */\nconst DbPrimaryClientKey = 'owner';\n/** Name of the IndexedDb object store.  */\nconst DbMutationQueueStore = 'mutationQueues';\n/** Keys are automatically assigned via the userId property. */\nconst DbMutationQueueKeyPath = 'userId';\n/** Name of the IndexedDb object store.  */\nconst DbMutationBatchStore = 'mutations';\n/** Keys are automatically assigned via the userId, batchId properties. */\nconst DbMutationBatchKeyPath = 'batchId';\n/** The index name for lookup of mutations by user. */\nconst DbMutationBatchUserMutationsIndex = 'userMutationsIndex';\n/** The user mutations index is keyed by [userId, batchId] pairs. */\nconst DbMutationBatchUserMutationsKeyPath = ['userId', 'batchId'];\n/**\n * Creates a [userId] key for use in the DbDocumentMutations index to iterate\n * over all of a user's document mutations.\n */\nfunction newDbDocumentMutationPrefixForUser(userId) {\n    return [userId];\n}\n/**\n * Creates a [userId, encodedPath] key for use in the DbDocumentMutations\n * index to iterate over all at document mutations for a given path or lower.\n */\nfunction newDbDocumentMutationPrefixForPath(userId, path) {\n    return [userId, encodeResourcePath(path)];\n}\n/**\n * Creates a full index key of [userId, encodedPath, batchId] for inserting\n * and deleting into the DbDocumentMutations index.\n */\nfunction newDbDocumentMutationKey(userId, path, batchId) {\n    return [userId, encodeResourcePath(path), batchId];\n}\n/**\n * Because we store all the useful information for this store in the key,\n * there is no useful information to store as the value. The raw (unencoded)\n * path cannot be stored because IndexedDb doesn't store prototype\n * information.\n */\nconst DbDocumentMutationPlaceholder = {};\nconst DbDocumentMutationStore = 'documentMutations';\nconst DbRemoteDocumentStore = 'remoteDocumentsV14';\n/**\n * The primary key of the remote documents store, which allows for efficient\n * access by collection path and read time.\n */\nconst DbRemoteDocumentKeyPath = [\n    'prefixPath',\n    'collectionGroup',\n    'readTime',\n    'documentId'\n];\n/** An index that provides access to documents by key. */\nconst DbRemoteDocumentDocumentKeyIndex = 'documentKeyIndex';\nconst DbRemoteDocumentDocumentKeyIndexPath = [\n    'prefixPath',\n    'collectionGroup',\n    'documentId'\n];\n/**\n * An index that provides access to documents by collection group and read\n * time.\n *\n * This index is used by the index backfiller.\n */\nconst DbRemoteDocumentCollectionGroupIndex = 'collectionGroupIndex';\nconst DbRemoteDocumentCollectionGroupIndexPath = [\n    'collectionGroup',\n    'readTime',\n    'prefixPath',\n    'documentId'\n];\nconst DbRemoteDocumentGlobalStore = 'remoteDocumentGlobal';\nconst DbRemoteDocumentGlobalKey = 'remoteDocumentGlobalKey';\nconst DbTargetStore = 'targets';\n/** Keys are automatically assigned via the targetId property. */\nconst DbTargetKeyPath = 'targetId';\n/** The name of the queryTargets index. */\nconst DbTargetQueryTargetsIndexName = 'queryTargetsIndex';\n/**\n * The index of all canonicalIds to the targets that they match. This is not\n * a unique mapping because canonicalId does not promise a unique name for all\n * possible queries, so we append the targetId to make the mapping unique.\n */\nconst DbTargetQueryTargetsKeyPath = ['canonicalId', 'targetId'];\n/** Name of the IndexedDb object store.  */\nconst DbTargetDocumentStore = 'targetDocuments';\n/** Keys are automatically assigned via the targetId, path properties. */\nconst DbTargetDocumentKeyPath = ['targetId', 'path'];\n/** The index name for the reverse index. */\nconst DbTargetDocumentDocumentTargetsIndex = 'documentTargetsIndex';\n/** We also need to create the reverse index for these properties. */\nconst DbTargetDocumentDocumentTargetsKeyPath = ['path', 'targetId'];\n/**\n * The key string used for the single object that exists in the\n * DbTargetGlobal store.\n */\nconst DbTargetGlobalKey = 'targetGlobalKey';\nconst DbTargetGlobalStore = 'targetGlobal';\n/** Name of the IndexedDb object store. */\nconst DbCollectionParentStore = 'collectionParents';\n/** Keys are automatically assigned via the collectionId, parent properties. */\nconst DbCollectionParentKeyPath = ['collectionId', 'parent'];\n/** Name of the IndexedDb object store. */\nconst DbClientMetadataStore = 'clientMetadata';\n/** Keys are automatically assigned via the clientId properties. */\nconst DbClientMetadataKeyPath = 'clientId';\n/** Name of the IndexedDb object store. */\nconst DbBundleStore = 'bundles';\nconst DbBundleKeyPath = 'bundleId';\n/** Name of the IndexedDb object store. */\nconst DbNamedQueryStore = 'namedQueries';\nconst DbNamedQueryKeyPath = 'name';\n/** Name of the IndexedDb object store. */\nconst DbIndexConfigurationStore = 'indexConfiguration';\nconst DbIndexConfigurationKeyPath = 'indexId';\n/**\n * An index that provides access to the index configurations by collection\n * group.\n *\n * PORTING NOTE: iOS and Android maintain this index in-memory, but this is\n * not possible here as the Web client supports concurrent access to\n * persistence via multi-tab.\n */\nconst DbIndexConfigurationCollectionGroupIndex = 'collectionGroupIndex';\nconst DbIndexConfigurationCollectionGroupIndexPath = 'collectionGroup';\n/** Name of the IndexedDb object store. */\nconst DbIndexStateStore = 'indexState';\nconst DbIndexStateKeyPath = ['indexId', 'uid'];\n/**\n * An index that provides access to documents in a collection sorted by last\n * update time. Used by the backfiller.\n *\n * PORTING NOTE: iOS and Android maintain this index in-memory, but this is\n * not possible here as the Web client supports concurrent access to\n * persistence via multi-tab.\n */\nconst DbIndexStateSequenceNumberIndex = 'sequenceNumberIndex';\nconst DbIndexStateSequenceNumberIndexPath = ['uid', 'sequenceNumber'];\n/** Name of the IndexedDb object store. */\nconst DbIndexEntryStore = 'indexEntries';\nconst DbIndexEntryKeyPath = [\n    'indexId',\n    'uid',\n    'arrayValue',\n    'directionalValue',\n    'orderedDocumentKey',\n    'documentKey'\n];\nconst DbIndexEntryDocumentKeyIndex = 'documentKeyIndex';\nconst DbIndexEntryDocumentKeyIndexPath = [\n    'indexId',\n    'uid',\n    'orderedDocumentKey'\n];\n/** Name of the IndexedDb object store. */\nconst DbDocumentOverlayStore = 'documentOverlays';\nconst DbDocumentOverlayKeyPath = [\n    'userId',\n    'collectionPath',\n    'documentId'\n];\nconst DbDocumentOverlayCollectionPathOverlayIndex = 'collectionPathOverlayIndex';\nconst DbDocumentOverlayCollectionPathOverlayIndexPath = [\n    'userId',\n    'collectionPath',\n    'largestBatchId'\n];\nconst DbDocumentOverlayCollectionGroupOverlayIndex = 'collectionGroupOverlayIndex';\nconst DbDocumentOverlayCollectionGroupOverlayIndexPath = [\n    'userId',\n    'collectionGroup',\n    'largestBatchId'\n];\n/** Name of the IndexedDb object store. */\nconst DbGlobalsStore = 'globals';\nconst DbGlobalsKeyPath = 'name';\n// Visible for testing\nconst V1_STORES = [\n    DbMutationQueueStore,\n    DbMutationBatchStore,\n    DbDocumentMutationStore,\n    DbRemoteDocumentStore$1,\n    DbTargetStore,\n    DbPrimaryClientStore,\n    DbTargetGlobalStore,\n    DbTargetDocumentStore\n];\n// Visible for testing\nconst V3_STORES = V1_STORES;\n// Note: DbRemoteDocumentChanges is no longer used and dropped with v9.\nconst V4_STORES = [...V3_STORES, DbClientMetadataStore];\nconst V6_STORES = [...V4_STORES, DbRemoteDocumentGlobalStore];\nconst V8_STORES = [...V6_STORES, DbCollectionParentStore];\nconst V11_STORES = [...V8_STORES, DbBundleStore, DbNamedQueryStore];\nconst V12_STORES = [...V11_STORES, DbDocumentOverlayStore];\nconst V13_STORES = [\n    DbMutationQueueStore,\n    DbMutationBatchStore,\n    DbDocumentMutationStore,\n    DbRemoteDocumentStore,\n    DbTargetStore,\n    DbPrimaryClientStore,\n    DbTargetGlobalStore,\n    DbTargetDocumentStore,\n    DbClientMetadataStore,\n    DbRemoteDocumentGlobalStore,\n    DbCollectionParentStore,\n    DbBundleStore,\n    DbNamedQueryStore,\n    DbDocumentOverlayStore\n];\nconst V14_STORES = V13_STORES;\nconst V15_STORES = [\n    ...V14_STORES,\n    DbIndexConfigurationStore,\n    DbIndexStateStore,\n    DbIndexEntryStore\n];\nconst V16_STORES = V15_STORES;\nconst V17_STORES = [...V15_STORES, DbGlobalsStore];\nconst V18_STORES = V17_STORES;\n/** Returns the object stores for the provided schema. */\nfunction getObjectStores(schemaVersion) {\n    if (schemaVersion === 18) {\n        return V18_STORES;\n    }\n    else if (schemaVersion === 17) {\n        return V17_STORES;\n    }\n    else if (schemaVersion === 16) {\n        return V16_STORES;\n    }\n    else if (schemaVersion === 15) {\n        return V15_STORES;\n    }\n    else if (schemaVersion === 14) {\n        return V14_STORES;\n    }\n    else if (schemaVersion === 13) {\n        return V13_STORES;\n    }\n    else if (schemaVersion === 12) {\n        return V12_STORES;\n    }\n    else if (schemaVersion === 11) {\n        return V11_STORES;\n    }\n    else {\n        fail(0xeb55);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass IndexedDbTransaction extends PersistenceTransaction {\n    constructor(simpleDbTransaction, currentSequenceNumber) {\n        super();\n        this.simpleDbTransaction = simpleDbTransaction;\n        this.currentSequenceNumber = currentSequenceNumber;\n    }\n}\nfunction getStore(txn, store) {\n    const indexedDbTransaction = debugCast(txn);\n    return SimpleDb.getStore(indexedDbTransaction.simpleDbTransaction, store);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction objectSize(obj) {\n    let count = 0;\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            count++;\n        }\n    }\n    return count;\n}\nfunction forEach(obj, fn) {\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            fn(key, obj[key]);\n        }\n    }\n}\nfunction mapToArray(obj, fn) {\n    const result = [];\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            result.push(fn(obj[key], key, obj));\n        }\n    }\n    return result;\n}\nfunction isEmpty(obj) {\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\n// tree.\nclass SortedMap {\n    constructor(comparator, root) {\n        this.comparator = comparator;\n        this.root = root ? root : LLRBNode.EMPTY;\n    }\n    // Returns a copy of the map, with the specified key/value added or replaced.\n    insert(key, value) {\n        return new SortedMap(this.comparator, this.root\n            .insert(key, value, this.comparator)\n            .copy(null, null, LLRBNode.BLACK, null, null));\n    }\n    // Returns a copy of the map, with the specified key removed.\n    remove(key) {\n        return new SortedMap(this.comparator, this.root\n            .remove(key, this.comparator)\n            .copy(null, null, LLRBNode.BLACK, null, null));\n    }\n    // Returns the value of the node with the given key, or null.\n    get(key) {\n        let node = this.root;\n        while (!node.isEmpty()) {\n            const cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return node.value;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else if (cmp > 0) {\n                node = node.right;\n            }\n        }\n        return null;\n    }\n    // Returns the index of the element in this sorted map, or -1 if it doesn't\n    // exist.\n    indexOf(key) {\n        // Number of nodes that were pruned when descending right\n        let prunedNodes = 0;\n        let node = this.root;\n        while (!node.isEmpty()) {\n            const cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return prunedNodes + node.left.size;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else {\n                // Count all nodes left of the node plus the node itself\n                prunedNodes += node.left.size + 1;\n                node = node.right;\n            }\n        }\n        // Node not found\n        return -1;\n    }\n    isEmpty() {\n        return this.root.isEmpty();\n    }\n    // Returns the total number of nodes in the map.\n    get size() {\n        return this.root.size;\n    }\n    // Returns the minimum key in the map.\n    minKey() {\n        return this.root.minKey();\n    }\n    // Returns the maximum key in the map.\n    maxKey() {\n        return this.root.maxKey();\n    }\n    // Traverses the map in key order and calls the specified action function\n    // for each key/value pair. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    inorderTraversal(action) {\n        return this.root.inorderTraversal(action);\n    }\n    forEach(fn) {\n        this.inorderTraversal((k, v) => {\n            fn(k, v);\n            return false;\n        });\n    }\n    toString() {\n        const descriptions = [];\n        this.inorderTraversal((k, v) => {\n            descriptions.push(`${k}:${v}`);\n            return false;\n        });\n        return `{${descriptions.join(', ')}}`;\n    }\n    // Traverses the map in reverse key order and calls the specified action\n    // function for each key/value pair. If action returns true, traversal is\n    // aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    reverseTraversal(action) {\n        return this.root.reverseTraversal(action);\n    }\n    // Returns an iterator over the SortedMap.\n    getIterator() {\n        return new SortedMapIterator(this.root, null, this.comparator, false);\n    }\n    getIteratorFrom(key) {\n        return new SortedMapIterator(this.root, key, this.comparator, false);\n    }\n    getReverseIterator() {\n        return new SortedMapIterator(this.root, null, this.comparator, true);\n    }\n    getReverseIteratorFrom(key) {\n        return new SortedMapIterator(this.root, key, this.comparator, true);\n    }\n} // end SortedMap\n// An iterator over an LLRBNode.\nclass SortedMapIterator {\n    constructor(node, startKey, comparator, isReverse) {\n        this.isReverse = isReverse;\n        this.nodeStack = [];\n        let cmp = 1;\n        while (!node.isEmpty()) {\n            cmp = startKey ? comparator(node.key, startKey) : 1;\n            // flip the comparison if we're going in reverse\n            if (startKey && isReverse) {\n                cmp *= -1;\n            }\n            if (cmp < 0) {\n                // This node is less than our start key. ignore it\n                if (this.isReverse) {\n                    node = node.left;\n                }\n                else {\n                    node = node.right;\n                }\n            }\n            else if (cmp === 0) {\n                // This node is exactly equal to our start key. Push it on the stack,\n                // but stop iterating;\n                this.nodeStack.push(node);\n                break;\n            }\n            else {\n                // This node is greater than our start key, add it to the stack and move\n                // to the next one\n                this.nodeStack.push(node);\n                if (this.isReverse) {\n                    node = node.right;\n                }\n                else {\n                    node = node.left;\n                }\n            }\n        }\n    }\n    getNext() {\n        let node = this.nodeStack.pop();\n        const result = { key: node.key, value: node.value };\n        if (this.isReverse) {\n            node = node.left;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.right;\n            }\n        }\n        else {\n            node = node.right;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.left;\n            }\n        }\n        return result;\n    }\n    hasNext() {\n        return this.nodeStack.length > 0;\n    }\n    peek() {\n        if (this.nodeStack.length === 0) {\n            return null;\n        }\n        const node = this.nodeStack[this.nodeStack.length - 1];\n        return { key: node.key, value: node.value };\n    }\n} // end SortedMapIterator\n// Represents a node in a Left-leaning Red-Black tree.\nclass LLRBNode {\n    constructor(key, value, color, left, right) {\n        this.key = key;\n        this.value = value;\n        this.color = color != null ? color : LLRBNode.RED;\n        this.left = left != null ? left : LLRBNode.EMPTY;\n        this.right = right != null ? right : LLRBNode.EMPTY;\n        this.size = this.left.size + 1 + this.right.size;\n    }\n    // Returns a copy of the current node, optionally replacing pieces of it.\n    copy(key, value, color, left, right) {\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\n    }\n    isEmpty() {\n        return false;\n    }\n    // Traverses the tree in key order and calls the specified action function\n    // for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    inorderTraversal(action) {\n        return (this.left.inorderTraversal(action) ||\n            action(this.key, this.value) ||\n            this.right.inorderTraversal(action));\n    }\n    // Traverses the tree in reverse key order and calls the specified action\n    // function for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    reverseTraversal(action) {\n        return (this.right.reverseTraversal(action) ||\n            action(this.key, this.value) ||\n            this.left.reverseTraversal(action));\n    }\n    // Returns the minimum node in the tree.\n    min() {\n        if (this.left.isEmpty()) {\n            return this;\n        }\n        else {\n            return this.left.min();\n        }\n    }\n    // Returns the maximum key in the tree.\n    minKey() {\n        return this.min().key;\n    }\n    // Returns the maximum key in the tree.\n    maxKey() {\n        if (this.right.isEmpty()) {\n            return this.key;\n        }\n        else {\n            return this.right.maxKey();\n        }\n    }\n    // Returns new tree, with the key/value added.\n    insert(key, value, comparator) {\n        let n = this;\n        const cmp = comparator(key, n.key);\n        if (cmp < 0) {\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n        }\n        else if (cmp === 0) {\n            n = n.copy(null, value, null, null, null);\n        }\n        else {\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\n        }\n        return n.fixUp();\n    }\n    removeMin() {\n        if (this.left.isEmpty()) {\n            return LLRBNode.EMPTY;\n        }\n        let n = this;\n        if (!n.left.isRed() && !n.left.left.isRed()) {\n            n = n.moveRedLeft();\n        }\n        n = n.copy(null, null, null, n.left.removeMin(), null);\n        return n.fixUp();\n    }\n    // Returns new tree, with the specified item removed.\n    remove(key, comparator) {\n        let smallest;\n        let n = this;\n        if (comparator(key, n.key) < 0) {\n            if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\n                n = n.moveRedLeft();\n            }\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n        }\n        else {\n            if (n.left.isRed()) {\n                n = n.rotateRight();\n            }\n            if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\n                n = n.moveRedRight();\n            }\n            if (comparator(key, n.key) === 0) {\n                if (n.right.isEmpty()) {\n                    return LLRBNode.EMPTY;\n                }\n                else {\n                    smallest = n.right.min();\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());\n                }\n            }\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n        }\n        return n.fixUp();\n    }\n    isRed() {\n        return this.color;\n    }\n    // Returns new tree after performing any needed rotations.\n    fixUp() {\n        let n = this;\n        if (n.right.isRed() && !n.left.isRed()) {\n            n = n.rotateLeft();\n        }\n        if (n.left.isRed() && n.left.left.isRed()) {\n            n = n.rotateRight();\n        }\n        if (n.left.isRed() && n.right.isRed()) {\n            n = n.colorFlip();\n        }\n        return n;\n    }\n    moveRedLeft() {\n        let n = this.colorFlip();\n        if (n.right.left.isRed()) {\n            n = n.copy(null, null, null, null, n.right.rotateRight());\n            n = n.rotateLeft();\n            n = n.colorFlip();\n        }\n        return n;\n    }\n    moveRedRight() {\n        let n = this.colorFlip();\n        if (n.left.left.isRed()) {\n            n = n.rotateRight();\n            n = n.colorFlip();\n        }\n        return n;\n    }\n    rotateLeft() {\n        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n        return this.right.copy(null, null, this.color, nl, null);\n    }\n    rotateRight() {\n        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n        return this.left.copy(null, null, this.color, null, nr);\n    }\n    colorFlip() {\n        const left = this.left.copy(null, null, !this.left.color, null, null);\n        const right = this.right.copy(null, null, !this.right.color, null, null);\n        return this.copy(null, null, !this.color, left, right);\n    }\n    // For testing.\n    checkMaxDepth() {\n        const blackDepth = this.check();\n        if (Math.pow(2.0, blackDepth) <= this.size + 1) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    // In a balanced RB tree, the black-depth (number of black nodes) from root to\n    // leaves is equal on both sides.  This function verifies that or asserts.\n    check() {\n        if (this.isRed() && this.left.isRed()) {\n            throw fail(0xaad2, {\n                key: this.key,\n                value: this.value\n            });\n        }\n        if (this.right.isRed()) {\n            throw fail(0x3721, {\n                key: this.key,\n                value: this.value\n            });\n        }\n        const blackDepth = this.left.check();\n        if (blackDepth !== this.right.check()) {\n            throw fail(0x6d2d);\n        }\n        else {\n            return blackDepth + (this.isRed() ? 0 : 1);\n        }\n    }\n} // end LLRBNode\n// Empty node is shared between all LLRB trees.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nLLRBNode.EMPTY = null;\nLLRBNode.RED = true;\nLLRBNode.BLACK = false;\n// Represents an empty node (a leaf node in the Red-Black Tree).\nclass LLRBEmptyNode {\n    constructor() {\n        this.size = 0;\n    }\n    get key() {\n        throw fail(0xe1a6);\n    }\n    get value() {\n        throw fail(0x3f0d);\n    }\n    get color() {\n        throw fail(0x4157);\n    }\n    get left() {\n        throw fail(0x741e);\n    }\n    get right() {\n        throw fail(0x901e);\n    }\n    // Returns a copy of the current node.\n    copy(key, value, color, left, right) {\n        return this;\n    }\n    // Returns a copy of the tree, with the specified key/value added.\n    insert(key, value, comparator) {\n        return new LLRBNode(key, value);\n    }\n    // Returns a copy of the tree, with the specified key removed.\n    remove(key, comparator) {\n        return this;\n    }\n    isEmpty() {\n        return true;\n    }\n    inorderTraversal(action) {\n        return false;\n    }\n    reverseTraversal(action) {\n        return false;\n    }\n    minKey() {\n        return null;\n    }\n    maxKey() {\n        return null;\n    }\n    isRed() {\n        return false;\n    }\n    // For testing.\n    checkMaxDepth() {\n        return true;\n    }\n    check() {\n        return 0;\n    }\n} // end LLRBEmptyNode\nLLRBNode.EMPTY = new LLRBEmptyNode();\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * SortedSet is an immutable (copy-on-write) collection that holds elements\n * in order specified by the provided comparator.\n *\n * NOTE: if provided comparator returns 0 for two elements, we consider them to\n * be equal!\n */\nclass SortedSet {\n    constructor(comparator) {\n        this.comparator = comparator;\n        this.data = new SortedMap(this.comparator);\n    }\n    has(elem) {\n        return this.data.get(elem) !== null;\n    }\n    first() {\n        return this.data.minKey();\n    }\n    last() {\n        return this.data.maxKey();\n    }\n    get size() {\n        return this.data.size;\n    }\n    indexOf(elem) {\n        return this.data.indexOf(elem);\n    }\n    /** Iterates elements in order defined by \"comparator\" */\n    forEach(cb) {\n        this.data.inorderTraversal((k, v) => {\n            cb(k);\n            return false;\n        });\n    }\n    /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */\n    forEachInRange(range, cb) {\n        const iter = this.data.getIteratorFrom(range[0]);\n        while (iter.hasNext()) {\n            const elem = iter.getNext();\n            if (this.comparator(elem.key, range[1]) >= 0) {\n                return;\n            }\n            cb(elem.key);\n        }\n    }\n    /**\n     * Iterates over `elem`s such that: start &lt;= elem until false is returned.\n     */\n    forEachWhile(cb, start) {\n        let iter;\n        if (start !== undefined) {\n            iter = this.data.getIteratorFrom(start);\n        }\n        else {\n            iter = this.data.getIterator();\n        }\n        while (iter.hasNext()) {\n            const elem = iter.getNext();\n            const result = cb(elem.key);\n            if (!result) {\n                return;\n            }\n        }\n    }\n    /** Finds the least element greater than or equal to `elem`. */\n    firstAfterOrEqual(elem) {\n        const iter = this.data.getIteratorFrom(elem);\n        return iter.hasNext() ? iter.getNext().key : null;\n    }\n    getIterator() {\n        return new SortedSetIterator(this.data.getIterator());\n    }\n    getIteratorFrom(key) {\n        return new SortedSetIterator(this.data.getIteratorFrom(key));\n    }\n    /** Inserts or updates an element */\n    add(elem) {\n        return this.copy(this.data.remove(elem).insert(elem, true));\n    }\n    /** Deletes an element */\n    delete(elem) {\n        if (!this.has(elem)) {\n            return this;\n        }\n        return this.copy(this.data.remove(elem));\n    }\n    isEmpty() {\n        return this.data.isEmpty();\n    }\n    unionWith(other) {\n        let result = this;\n        // Make sure `result` always refers to the larger one of the two sets.\n        if (result.size < other.size) {\n            result = other;\n            other = this;\n        }\n        other.forEach(elem => {\n            result = result.add(elem);\n        });\n        return result;\n    }\n    isEqual(other) {\n        if (!(other instanceof SortedSet)) {\n            return false;\n        }\n        if (this.size !== other.size) {\n            return false;\n        }\n        const thisIt = this.data.getIterator();\n        const otherIt = other.data.getIterator();\n        while (thisIt.hasNext()) {\n            const thisElem = thisIt.getNext().key;\n            const otherElem = otherIt.getNext().key;\n            if (this.comparator(thisElem, otherElem) !== 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    toArray() {\n        const res = [];\n        this.forEach(targetId => {\n            res.push(targetId);\n        });\n        return res;\n    }\n    toString() {\n        const result = [];\n        this.forEach(elem => result.push(elem));\n        return 'SortedSet(' + result.toString() + ')';\n    }\n    copy(data) {\n        const result = new SortedSet(this.comparator);\n        result.data = data;\n        return result;\n    }\n}\nclass SortedSetIterator {\n    constructor(iter) {\n        this.iter = iter;\n    }\n    getNext() {\n        return this.iter.getNext().key;\n    }\n    hasNext() {\n        return this.iter.hasNext();\n    }\n}\n/**\n * Compares two sorted sets for equality using their natural ordering. The\n * method computes the intersection and invokes `onAdd` for every element that\n * is in `after` but not `before`. `onRemove` is invoked for every element in\n * `before` but missing from `after`.\n *\n * The method creates a copy of both `before` and `after` and runs in O(n log\n * n), where n is the size of the two lists.\n *\n * @param before - The elements that exist in the original set.\n * @param after - The elements to diff against the original set.\n * @param comparator - The comparator for the elements in before and after.\n * @param onAdd - A function to invoke for every element that is part of `\n * after` but not `before`.\n * @param onRemove - A function to invoke for every element that is part of\n * `before` but not `after`.\n */\nfunction diffSortedSets(before, after, comparator, onAdd, onRemove) {\n    const beforeIt = before.getIterator();\n    const afterIt = after.getIterator();\n    let beforeValue = advanceIterator(beforeIt);\n    let afterValue = advanceIterator(afterIt);\n    // Walk through the two sets at the same time, using the ordering defined by\n    // `comparator`.\n    while (beforeValue || afterValue) {\n        let added = false;\n        let removed = false;\n        if (beforeValue && afterValue) {\n            const cmp = comparator(beforeValue, afterValue);\n            if (cmp < 0) {\n                // The element was removed if the next element in our ordered\n                // walkthrough is only in `before`.\n                removed = true;\n            }\n            else if (cmp > 0) {\n                // The element was added if the next element in our ordered walkthrough\n                // is only in `after`.\n                added = true;\n            }\n        }\n        else if (beforeValue != null) {\n            removed = true;\n        }\n        else {\n            added = true;\n        }\n        if (added) {\n            onAdd(afterValue);\n            afterValue = advanceIterator(afterIt);\n        }\n        else if (removed) {\n            onRemove(beforeValue);\n            beforeValue = advanceIterator(beforeIt);\n        }\n        else {\n            beforeValue = advanceIterator(beforeIt);\n            afterValue = advanceIterator(afterIt);\n        }\n    }\n}\n/**\n * Returns the next element from the iterator or `undefined` if none available.\n */\nfunction advanceIterator(it) {\n    return it.hasNext() ? it.getNext() : undefined;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides a set of fields that can be used to partially patch a document.\n * FieldMask is used in conjunction with ObjectValue.\n * Examples:\n *   foo - Overwrites foo entirely with the provided value. If foo is not\n *         present in the companion ObjectValue, the field is deleted.\n *   foo.bar - Overwrites only the field bar of the object foo.\n *             If foo is not an object, foo is replaced with an object\n *             containing foo\n */\nclass FieldMask {\n    constructor(fields) {\n        this.fields = fields;\n        // TODO(dimond): validation of FieldMask\n        // Sort the field mask to support `FieldMask.isEqual()` and assert below.\n        fields.sort(FieldPath$1.comparator);\n    }\n    static empty() {\n        return new FieldMask([]);\n    }\n    /**\n     * Returns a new FieldMask object that is the result of adding all the given\n     * fields paths to this field mask.\n     */\n    unionWith(extraFields) {\n        let mergedMaskSet = new SortedSet(FieldPath$1.comparator);\n        for (const fieldPath of this.fields) {\n            mergedMaskSet = mergedMaskSet.add(fieldPath);\n        }\n        for (const fieldPath of extraFields) {\n            mergedMaskSet = mergedMaskSet.add(fieldPath);\n        }\n        return new FieldMask(mergedMaskSet.toArray());\n    }\n    /**\n     * Verifies that `fieldPath` is included by at least one field in this field\n     * mask.\n     *\n     * This is an O(n) operation, where `n` is the size of the field mask.\n     */\n    covers(fieldPath) {\n        for (const fieldMaskPath of this.fields) {\n            if (fieldMaskPath.isPrefixOf(fieldPath)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isEqual(other) {\n        return arrayEquals(this.fields, other.fields, (l, r) => l.isEqual(r));\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Converts a Base64 encoded string to a binary string. */\nfunction decodeBase64(encoded) {\n    // Note: We used to validate the base64 string here via a regular expression.\n    // This was removed to improve the performance of indexing.\n    return Buffer.from(encoded, 'base64').toString('binary');\n}\n/** Converts a binary string to a Base64 encoded string. */\nfunction encodeBase64(raw) {\n    return Buffer.from(raw, 'binary').toString('base64');\n}\n/** True if and only if the Base64 conversion functions are available. */\nfunction isBase64Available() {\n    return true;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Immutable class that represents a \"proto\" byte string.\n *\n * Proto byte strings can either be Base64-encoded strings or Uint8Arrays when\n * sent on the wire. This class abstracts away this differentiation by holding\n * the proto byte string in a common class that must be converted into a string\n * before being sent as a proto.\n * @internal\n */\nclass ByteString {\n    constructor(binaryString) {\n        this.binaryString = binaryString;\n    }\n    static fromBase64String(base64) {\n        const binaryString = decodeBase64(base64);\n        return new ByteString(binaryString);\n    }\n    static fromUint8Array(array) {\n        // TODO(indexing); Remove the copy of the byte string here as this method\n        // is frequently called during indexing.\n        const binaryString = binaryStringFromUint8Array(array);\n        return new ByteString(binaryString);\n    }\n    [Symbol.iterator]() {\n        let i = 0;\n        return {\n            next: () => {\n                if (i < this.binaryString.length) {\n                    return { value: this.binaryString.charCodeAt(i++), done: false };\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n    }\n    toBase64() {\n        return encodeBase64(this.binaryString);\n    }\n    toUint8Array() {\n        return uint8ArrayFromBinaryString(this.binaryString);\n    }\n    approximateByteSize() {\n        return this.binaryString.length * 2;\n    }\n    compareTo(other) {\n        return primitiveComparator(this.binaryString, other.binaryString);\n    }\n    isEqual(other) {\n        return this.binaryString === other.binaryString;\n    }\n}\nByteString.EMPTY_BYTE_STRING = new ByteString('');\n/**\n * Helper function to convert an Uint8array to a binary string.\n */\nfunction binaryStringFromUint8Array(array) {\n    let binaryString = '';\n    for (let i = 0; i < array.length; ++i) {\n        binaryString += String.fromCharCode(array[i]);\n    }\n    return binaryString;\n}\n/**\n * Helper function to convert a binary string to an Uint8Array.\n */\nfunction uint8ArrayFromBinaryString(binaryString) {\n    const buffer = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n        buffer[i] = binaryString.charCodeAt(i);\n    }\n    return buffer;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// A RegExp matching ISO 8601 UTC timestamps with optional fraction.\nconst ISO_TIMESTAMP_REG_EXP = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\n/**\n * Converts the possible Proto values for a timestamp value into a \"seconds and\n * nanos\" representation.\n */\nfunction normalizeTimestamp(date) {\n    hardAssert(!!date, 0x986a);\n    // The json interface (for the browser) will return an iso timestamp string,\n    // while the proto js library (for node) will return a\n    // google.protobuf.Timestamp instance.\n    if (typeof date === 'string') {\n        // The date string can have higher precision (nanos) than the Date class\n        // (millis), so we do some custom parsing here.\n        // Parse the nanos right out of the string.\n        let nanos = 0;\n        const fraction = ISO_TIMESTAMP_REG_EXP.exec(date);\n        hardAssert(!!fraction, 0xb5de, {\n            timestamp: date\n        });\n        if (fraction[1]) {\n            // Pad the fraction out to 9 digits (nanos).\n            let nanoStr = fraction[1];\n            nanoStr = (nanoStr + '000000000').substr(0, 9);\n            nanos = Number(nanoStr);\n        }\n        // Parse the date to get the seconds.\n        const parsedDate = new Date(date);\n        const seconds = Math.floor(parsedDate.getTime() / 1000);\n        return { seconds, nanos };\n    }\n    else {\n        // TODO(b/37282237): Use strings for Proto3 timestamps\n        // assert(!this.options.useProto3Json,\n        //   'The timestamp instance format requires Proto JS.');\n        const seconds = normalizeNumber(date.seconds);\n        const nanos = normalizeNumber(date.nanos);\n        return { seconds, nanos };\n    }\n}\n/**\n * Converts the possible Proto types for numbers into a JavaScript number.\n * Returns 0 if the value is not numeric.\n */\nfunction normalizeNumber(value) {\n    // TODO(bjornick): Handle int64 greater than 53 bits.\n    if (typeof value === 'number') {\n        return value;\n    }\n    else if (typeof value === 'string') {\n        return Number(value);\n    }\n    else {\n        return 0;\n    }\n}\n/** Converts the possible Proto types for Blobs into a ByteString. */\nfunction normalizeByteString(blob) {\n    if (typeof blob === 'string') {\n        return ByteString.fromBase64String(blob);\n    }\n    else {\n        return ByteString.fromUint8Array(blob);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a locally-applied ServerTimestamp.\n *\n * Server Timestamps are backed by MapValues that contain an internal field\n * `__type__` with a value of `server_timestamp`. The previous value and local\n * write time are stored in its `__previous_value__` and `__local_write_time__`\n * fields respectively.\n *\n * Notes:\n * - ServerTimestampValue instances are created as the result of applying a\n *   transform. They can only exist in the local view of a document. Therefore\n *   they do not need to be parsed or serialized.\n * - When evaluated locally (e.g. for snapshot.data()), they by default\n *   evaluate to `null`. This behavior can be configured by passing custom\n *   FieldValueOptions to value().\n * - With respect to other ServerTimestampValues, they sort by their\n *   localWriteTime.\n */\nconst SERVER_TIMESTAMP_SENTINEL = 'server_timestamp';\nconst TYPE_KEY$1 = '__type__';\nconst PREVIOUS_VALUE_KEY = '__previous_value__';\nconst LOCAL_WRITE_TIME_KEY = '__local_write_time__';\nfunction isServerTimestamp(value) {\n    const type = (value?.mapValue?.fields || {})[TYPE_KEY$1]?.stringValue;\n    return type === SERVER_TIMESTAMP_SENTINEL;\n}\n/**\n * Creates a new ServerTimestamp proto value (using the internal format).\n */\nfunction serverTimestamp$1(localWriteTime, previousValue) {\n    const mapValue = {\n        fields: {\n            [TYPE_KEY$1]: {\n                stringValue: SERVER_TIMESTAMP_SENTINEL\n            },\n            [LOCAL_WRITE_TIME_KEY]: {\n                timestampValue: {\n                    seconds: localWriteTime.seconds,\n                    nanos: localWriteTime.nanoseconds\n                }\n            }\n        }\n    };\n    // We should avoid storing deeply nested server timestamp map values\n    // because we never use the intermediate \"previous values\".\n    // For example:\n    // previous: 42L, add: t1, result: t1 -> 42L\n    // previous: t1,  add: t2, result: t2 -> 42L (NOT t2 -> t1 -> 42L)\n    // previous: t2,  add: t3, result: t3 -> 42L (NOT t3 -> t2 -> t1 -> 42L)\n    // `getPreviousValue` recursively traverses server timestamps to find the\n    // least recent Value.\n    if (previousValue && isServerTimestamp(previousValue)) {\n        previousValue = getPreviousValue(previousValue);\n    }\n    if (previousValue) {\n        mapValue.fields[PREVIOUS_VALUE_KEY] = previousValue;\n    }\n    return { mapValue };\n}\n/**\n * Returns the value of the field before this ServerTimestamp was set.\n *\n * Preserving the previous values allows the user to display the last resoled\n * value until the backend responds with the timestamp.\n */\nfunction getPreviousValue(value) {\n    const previousValue = value.mapValue.fields[PREVIOUS_VALUE_KEY];\n    if (isServerTimestamp(previousValue)) {\n        return getPreviousValue(previousValue);\n    }\n    return previousValue;\n}\n/**\n * Returns the local time at which this timestamp was first set.\n */\nfunction getLocalWriteTime(value) {\n    const localWriteTime = normalizeTimestamp(value.mapValue.fields[LOCAL_WRITE_TIME_KEY].timestampValue);\n    return new Timestamp(localWriteTime.seconds, localWriteTime.nanos);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass DatabaseInfo {\n    /**\n     * Constructs a DatabaseInfo using the provided host, databaseId and\n     * persistenceKey.\n     *\n     * @param databaseId - The database to use.\n     * @param appId - The Firebase App Id.\n     * @param persistenceKey - A unique identifier for this Firestore's local\n     * storage (used in conjunction with the databaseId).\n     * @param host - The Firestore backend host to connect to.\n     * @param ssl - Whether to use SSL when connecting.\n     * @param forceLongPolling - Whether to use the forceLongPolling option\n     * when using WebChannel as the network transport.\n     * @param autoDetectLongPolling - Whether to use the detectBufferingProxy\n     * option when using WebChannel as the network transport.\n     * @param longPollingOptions - Options that configure long-polling.\n     * @param useFetchStreams - Whether to use the Fetch API instead of\n     * XMLHTTPRequest\n     */\n    constructor(databaseId, appId, persistenceKey, host, ssl, forceLongPolling, autoDetectLongPolling, longPollingOptions, useFetchStreams, isUsingEmulator, apiKey) {\n        this.databaseId = databaseId;\n        this.appId = appId;\n        this.persistenceKey = persistenceKey;\n        this.host = host;\n        this.ssl = ssl;\n        this.forceLongPolling = forceLongPolling;\n        this.autoDetectLongPolling = autoDetectLongPolling;\n        this.longPollingOptions = longPollingOptions;\n        this.useFetchStreams = useFetchStreams;\n        this.isUsingEmulator = isUsingEmulator;\n        this.apiKey = apiKey;\n    }\n}\n/** The default database name for a project. */\nconst DEFAULT_DATABASE_NAME = '(default)';\n/**\n * Represents the database ID a Firestore client is associated with.\n * @internal\n */\nclass DatabaseId {\n    constructor(projectId, database) {\n        this.projectId = projectId;\n        this.database = database ? database : DEFAULT_DATABASE_NAME;\n    }\n    static empty() {\n        return new DatabaseId('', '');\n    }\n    get isDefaultDatabase() {\n        return this.database === DEFAULT_DATABASE_NAME;\n    }\n    isEqual(other) {\n        return (other instanceof DatabaseId &&\n            other.projectId === this.projectId &&\n            other.database === this.database);\n    }\n}\nfunction databaseIdFromApp(app, database) {\n    if (!Object.prototype.hasOwnProperty.apply(app.options, ['projectId'])) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\n    }\n    return new DatabaseId(app.options.projectId, database);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Sentinel value that sorts before any Mutation Batch ID. */\nconst BATCHID_UNKNOWN = -1;\n/**\n * Returns whether a variable is either undefined or null.\n */\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/** Returns whether the value represents -0. */\nfunction isNegativeZero(value) {\n    // Detect if the value is -0.0. Based on polyfill from\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n    return value === 0 && 1 / value === 1 / -0;\n}\nfunction isNumber$1(value) {\n    return typeof value === 'number';\n}\n/**\n * Returns whether a value is an integer and in the safe integer range\n * @param value - The value to test for being an integer and in the safe range\n */\nfunction isSafeInteger(value) {\n    return (typeof value === 'number' &&\n        Number.isInteger(value) &&\n        !isNegativeZero(value) &&\n        value <= Number.MAX_SAFE_INTEGER &&\n        value >= Number.MIN_SAFE_INTEGER);\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst TYPE_KEY = '__type__';\nconst MAX_VALUE_TYPE = '__max__';\nconst MAX_VALUE = {\n    mapValue: {\n        fields: {\n            '__type__': { stringValue: MAX_VALUE_TYPE }\n        }\n    }\n};\nconst VECTOR_VALUE_SENTINEL = '__vector__';\nconst VECTOR_MAP_VECTORS_KEY = 'value';\nconst MIN_VALUE = {\n    nullValue: 'NULL_VALUE'\n};\n/** Extracts the backend's type order for the provided value. */\nfunction typeOrder(value) {\n    if ('nullValue' in value) {\n        return 0 /* TypeOrder.NullValue */;\n    }\n    else if ('booleanValue' in value) {\n        return 1 /* TypeOrder.BooleanValue */;\n    }\n    else if ('integerValue' in value || 'doubleValue' in value) {\n        return 2 /* TypeOrder.NumberValue */;\n    }\n    else if ('timestampValue' in value) {\n        return 3 /* TypeOrder.TimestampValue */;\n    }\n    else if ('stringValue' in value) {\n        return 5 /* TypeOrder.StringValue */;\n    }\n    else if ('bytesValue' in value) {\n        return 6 /* TypeOrder.BlobValue */;\n    }\n    else if ('referenceValue' in value) {\n        return 7 /* TypeOrder.RefValue */;\n    }\n    else if ('geoPointValue' in value) {\n        return 8 /* TypeOrder.GeoPointValue */;\n    }\n    else if ('arrayValue' in value) {\n        return 9 /* TypeOrder.ArrayValue */;\n    }\n    else if ('mapValue' in value) {\n        if (isServerTimestamp(value)) {\n            return 4 /* TypeOrder.ServerTimestampValue */;\n        }\n        else if (isMaxValue(value)) {\n            return 9007199254740991 /* TypeOrder.MaxValue */;\n        }\n        else if (isVectorValue(value)) {\n            return 10 /* TypeOrder.VectorValue */;\n        }\n        return 11 /* TypeOrder.ObjectValue */;\n    }\n    else {\n        return fail(0x6e87, { value });\n    }\n}\n/** Tests `left` and `right` for equality based on the backend semantics. */\nfunction valueEquals(left, right) {\n    if (left === right) {\n        return true;\n    }\n    const leftType = typeOrder(left);\n    const rightType = typeOrder(right);\n    if (leftType !== rightType) {\n        return false;\n    }\n    switch (leftType) {\n        case 0 /* TypeOrder.NullValue */:\n            return true;\n        case 1 /* TypeOrder.BooleanValue */:\n            return left.booleanValue === right.booleanValue;\n        case 4 /* TypeOrder.ServerTimestampValue */:\n            return getLocalWriteTime(left).isEqual(getLocalWriteTime(right));\n        case 3 /* TypeOrder.TimestampValue */:\n            return timestampEquals(left, right);\n        case 5 /* TypeOrder.StringValue */:\n            return left.stringValue === right.stringValue;\n        case 6 /* TypeOrder.BlobValue */:\n            return blobEquals(left, right);\n        case 7 /* TypeOrder.RefValue */:\n            return left.referenceValue === right.referenceValue;\n        case 8 /* TypeOrder.GeoPointValue */:\n            return geoPointEquals(left, right);\n        case 2 /* TypeOrder.NumberValue */:\n            return numberEquals(left, right);\n        case 9 /* TypeOrder.ArrayValue */:\n            return arrayEquals(left.arrayValue.values || [], right.arrayValue.values || [], valueEquals);\n        case 10 /* TypeOrder.VectorValue */:\n        case 11 /* TypeOrder.ObjectValue */:\n            return objectEquals(left, right);\n        case 9007199254740991 /* TypeOrder.MaxValue */:\n            return true;\n        default:\n            return fail(0xcbf8, { left });\n    }\n}\nfunction timestampEquals(left, right) {\n    if (typeof left.timestampValue === 'string' &&\n        typeof right.timestampValue === 'string' &&\n        left.timestampValue.length === right.timestampValue.length) {\n        // Use string equality for ISO 8601 timestamps\n        return left.timestampValue === right.timestampValue;\n    }\n    const leftTimestamp = normalizeTimestamp(left.timestampValue);\n    const rightTimestamp = normalizeTimestamp(right.timestampValue);\n    return (leftTimestamp.seconds === rightTimestamp.seconds &&\n        leftTimestamp.nanos === rightTimestamp.nanos);\n}\nfunction geoPointEquals(left, right) {\n    return (normalizeNumber(left.geoPointValue.latitude) ===\n        normalizeNumber(right.geoPointValue.latitude) &&\n        normalizeNumber(left.geoPointValue.longitude) ===\n            normalizeNumber(right.geoPointValue.longitude));\n}\nfunction blobEquals(left, right) {\n    return normalizeByteString(left.bytesValue).isEqual(normalizeByteString(right.bytesValue));\n}\nfunction numberEquals(left, right) {\n    if ('integerValue' in left && 'integerValue' in right) {\n        return (normalizeNumber(left.integerValue) === normalizeNumber(right.integerValue));\n    }\n    else if ('doubleValue' in left && 'doubleValue' in right) {\n        const n1 = normalizeNumber(left.doubleValue);\n        const n2 = normalizeNumber(right.doubleValue);\n        if (n1 === n2) {\n            return isNegativeZero(n1) === isNegativeZero(n2);\n        }\n        else {\n            return isNaN(n1) && isNaN(n2);\n        }\n    }\n    return false;\n}\nfunction objectEquals(left, right) {\n    const leftMap = left.mapValue.fields || {};\n    const rightMap = right.mapValue.fields || {};\n    if (objectSize(leftMap) !== objectSize(rightMap)) {\n        return false;\n    }\n    for (const key in leftMap) {\n        if (leftMap.hasOwnProperty(key)) {\n            if (rightMap[key] === undefined ||\n                !valueEquals(leftMap[key], rightMap[key])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/** Returns true if the ArrayValue contains the specified element. */\nfunction arrayValueContains(haystack, needle) {\n    return ((haystack.values || []).find(v => valueEquals(v, needle)) !== undefined);\n}\nfunction valueCompare(left, right) {\n    if (left === right) {\n        return 0;\n    }\n    const leftType = typeOrder(left);\n    const rightType = typeOrder(right);\n    if (leftType !== rightType) {\n        return primitiveComparator(leftType, rightType);\n    }\n    switch (leftType) {\n        case 0 /* TypeOrder.NullValue */:\n        case 9007199254740991 /* TypeOrder.MaxValue */:\n            return 0;\n        case 1 /* TypeOrder.BooleanValue */:\n            return primitiveComparator(left.booleanValue, right.booleanValue);\n        case 2 /* TypeOrder.NumberValue */:\n            return compareNumbers(left, right);\n        case 3 /* TypeOrder.TimestampValue */:\n            return compareTimestamps(left.timestampValue, right.timestampValue);\n        case 4 /* TypeOrder.ServerTimestampValue */:\n            return compareTimestamps(getLocalWriteTime(left), getLocalWriteTime(right));\n        case 5 /* TypeOrder.StringValue */:\n            return compareUtf8Strings(left.stringValue, right.stringValue);\n        case 6 /* TypeOrder.BlobValue */:\n            return compareBlobs(left.bytesValue, right.bytesValue);\n        case 7 /* TypeOrder.RefValue */:\n            return compareReferences(left.referenceValue, right.referenceValue);\n        case 8 /* TypeOrder.GeoPointValue */:\n            return compareGeoPoints(left.geoPointValue, right.geoPointValue);\n        case 9 /* TypeOrder.ArrayValue */:\n            return compareArrays(left.arrayValue, right.arrayValue);\n        case 10 /* TypeOrder.VectorValue */:\n            return compareVectors(left.mapValue, right.mapValue);\n        case 11 /* TypeOrder.ObjectValue */:\n            return compareMaps(left.mapValue, right.mapValue);\n        default:\n            throw fail(0x5ae0, { leftType });\n    }\n}\nfunction compareNumbers(left, right) {\n    const leftNumber = normalizeNumber(left.integerValue || left.doubleValue);\n    const rightNumber = normalizeNumber(right.integerValue || right.doubleValue);\n    if (leftNumber < rightNumber) {\n        return -1;\n    }\n    else if (leftNumber > rightNumber) {\n        return 1;\n    }\n    else if (leftNumber === rightNumber) {\n        return 0;\n    }\n    else {\n        // one or both are NaN.\n        if (isNaN(leftNumber)) {\n            return isNaN(rightNumber) ? 0 : -1;\n        }\n        else {\n            return 1;\n        }\n    }\n}\nfunction compareTimestamps(left, right) {\n    if (typeof left === 'string' &&\n        typeof right === 'string' &&\n        left.length === right.length) {\n        return primitiveComparator(left, right);\n    }\n    const leftTimestamp = normalizeTimestamp(left);\n    const rightTimestamp = normalizeTimestamp(right);\n    const comparison = primitiveComparator(leftTimestamp.seconds, rightTimestamp.seconds);\n    if (comparison !== 0) {\n        return comparison;\n    }\n    return primitiveComparator(leftTimestamp.nanos, rightTimestamp.nanos);\n}\nfunction compareReferences(leftPath, rightPath) {\n    const leftSegments = leftPath.split('/');\n    const rightSegments = rightPath.split('/');\n    for (let i = 0; i < leftSegments.length && i < rightSegments.length; i++) {\n        const comparison = primitiveComparator(leftSegments[i], rightSegments[i]);\n        if (comparison !== 0) {\n            return comparison;\n        }\n    }\n    return primitiveComparator(leftSegments.length, rightSegments.length);\n}\nfunction compareGeoPoints(left, right) {\n    const comparison = primitiveComparator(normalizeNumber(left.latitude), normalizeNumber(right.latitude));\n    if (comparison !== 0) {\n        return comparison;\n    }\n    return primitiveComparator(normalizeNumber(left.longitude), normalizeNumber(right.longitude));\n}\nfunction compareBlobs(left, right) {\n    const leftBytes = normalizeByteString(left);\n    const rightBytes = normalizeByteString(right);\n    return leftBytes.compareTo(rightBytes);\n}\nfunction compareArrays(left, right) {\n    const leftArray = left.values || [];\n    const rightArray = right.values || [];\n    for (let i = 0; i < leftArray.length && i < rightArray.length; ++i) {\n        const compare = valueCompare(leftArray[i], rightArray[i]);\n        if (compare) {\n            return compare;\n        }\n    }\n    return primitiveComparator(leftArray.length, rightArray.length);\n}\nfunction compareVectors(left, right) {\n    const leftMap = left.fields || {};\n    const rightMap = right.fields || {};\n    // The vector is a map, but only vector value is compared.\n    const leftArrayValue = leftMap[VECTOR_MAP_VECTORS_KEY]?.arrayValue;\n    const rightArrayValue = rightMap[VECTOR_MAP_VECTORS_KEY]?.arrayValue;\n    const lengthCompare = primitiveComparator(leftArrayValue?.values?.length || 0, rightArrayValue?.values?.length || 0);\n    if (lengthCompare !== 0) {\n        return lengthCompare;\n    }\n    return compareArrays(leftArrayValue, rightArrayValue);\n}\nfunction compareMaps(left, right) {\n    if (left === MAX_VALUE.mapValue && right === MAX_VALUE.mapValue) {\n        return 0;\n    }\n    else if (left === MAX_VALUE.mapValue) {\n        return 1;\n    }\n    else if (right === MAX_VALUE.mapValue) {\n        return -1;\n    }\n    const leftMap = left.fields || {};\n    const leftKeys = Object.keys(leftMap);\n    const rightMap = right.fields || {};\n    const rightKeys = Object.keys(rightMap);\n    // Even though MapValues are likely sorted correctly based on their insertion\n    // order (e.g. when received from the backend), local modifications can bring\n    // elements out of order. We need to re-sort the elements to ensure that\n    // canonical IDs are independent of insertion order.\n    leftKeys.sort();\n    rightKeys.sort();\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; ++i) {\n        const keyCompare = compareUtf8Strings(leftKeys[i], rightKeys[i]);\n        if (keyCompare !== 0) {\n            return keyCompare;\n        }\n        const compare = valueCompare(leftMap[leftKeys[i]], rightMap[rightKeys[i]]);\n        if (compare !== 0) {\n            return compare;\n        }\n    }\n    return primitiveComparator(leftKeys.length, rightKeys.length);\n}\n/**\n * Generates the canonical ID for the provided field value (as used in Target\n * serialization).\n */\nfunction canonicalId(value) {\n    return canonifyValue(value);\n}\nfunction canonifyValue(value) {\n    if ('nullValue' in value) {\n        return 'null';\n    }\n    else if ('booleanValue' in value) {\n        return '' + value.booleanValue;\n    }\n    else if ('integerValue' in value) {\n        return '' + value.integerValue;\n    }\n    else if ('doubleValue' in value) {\n        return '' + value.doubleValue;\n    }\n    else if ('timestampValue' in value) {\n        return canonifyTimestamp(value.timestampValue);\n    }\n    else if ('stringValue' in value) {\n        return value.stringValue;\n    }\n    else if ('bytesValue' in value) {\n        return canonifyByteString(value.bytesValue);\n    }\n    else if ('referenceValue' in value) {\n        return canonifyReference(value.referenceValue);\n    }\n    else if ('geoPointValue' in value) {\n        return canonifyGeoPoint(value.geoPointValue);\n    }\n    else if ('arrayValue' in value) {\n        return canonifyArray(value.arrayValue);\n    }\n    else if ('mapValue' in value) {\n        return canonifyMap(value.mapValue);\n    }\n    else {\n        return fail(0xee4d, { value });\n    }\n}\nfunction canonifyByteString(byteString) {\n    return normalizeByteString(byteString).toBase64();\n}\nfunction canonifyTimestamp(timestamp) {\n    const normalizedTimestamp = normalizeTimestamp(timestamp);\n    return `time(${normalizedTimestamp.seconds},${normalizedTimestamp.nanos})`;\n}\nfunction canonifyGeoPoint(geoPoint) {\n    return `geo(${geoPoint.latitude},${geoPoint.longitude})`;\n}\nfunction canonifyReference(referenceValue) {\n    return DocumentKey.fromName(referenceValue).toString();\n}\nfunction canonifyMap(mapValue) {\n    // Iteration order in JavaScript is not guaranteed. To ensure that we generate\n    // matching canonical IDs for identical maps, we need to sort the keys.\n    const sortedKeys = Object.keys(mapValue.fields || {}).sort();\n    let result = '{';\n    let first = true;\n    for (const key of sortedKeys) {\n        if (!first) {\n            result += ',';\n        }\n        else {\n            first = false;\n        }\n        result += `${key}:${canonifyValue(mapValue.fields[key])}`;\n    }\n    return result + '}';\n}\nfunction canonifyArray(arrayValue) {\n    let result = '[';\n    let first = true;\n    for (const value of arrayValue.values || []) {\n        if (!first) {\n            result += ',';\n        }\n        else {\n            first = false;\n        }\n        result += canonifyValue(value);\n    }\n    return result + ']';\n}\n/**\n * Returns an approximate (and wildly inaccurate) in-memory size for the field\n * value.\n *\n * The memory size takes into account only the actual user data as it resides\n * in memory and ignores object overhead.\n */\nfunction estimateByteSize(value) {\n    switch (typeOrder(value)) {\n        case 0 /* TypeOrder.NullValue */:\n            return 4;\n        case 1 /* TypeOrder.BooleanValue */:\n            return 4;\n        case 2 /* TypeOrder.NumberValue */:\n            return 8;\n        case 3 /* TypeOrder.TimestampValue */:\n            // Timestamps are made up of two distinct numbers (seconds + nanoseconds)\n            return 16;\n        case 4 /* TypeOrder.ServerTimestampValue */:\n            const previousValue = getPreviousValue(value);\n            return previousValue ? 16 + estimateByteSize(previousValue) : 16;\n        case 5 /* TypeOrder.StringValue */:\n            // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures:\n            // \"JavaScript's String type is [...] a set of elements of 16-bit unsigned\n            // integer values\"\n            return value.stringValue.length * 2;\n        case 6 /* TypeOrder.BlobValue */:\n            return normalizeByteString(value.bytesValue).approximateByteSize();\n        case 7 /* TypeOrder.RefValue */:\n            return value.referenceValue.length;\n        case 8 /* TypeOrder.GeoPointValue */:\n            // GeoPoints are made up of two distinct numbers (latitude + longitude)\n            return 16;\n        case 9 /* TypeOrder.ArrayValue */:\n            return estimateArrayByteSize(value.arrayValue);\n        case 10 /* TypeOrder.VectorValue */:\n        case 11 /* TypeOrder.ObjectValue */:\n            return estimateMapByteSize(value.mapValue);\n        default:\n            throw fail(0x34ae, { value });\n    }\n}\nfunction estimateMapByteSize(mapValue) {\n    let size = 0;\n    forEach(mapValue.fields, (key, val) => {\n        size += key.length + estimateByteSize(val);\n    });\n    return size;\n}\nfunction estimateArrayByteSize(arrayValue) {\n    return (arrayValue.values || []).reduce((previousSize, value) => previousSize + estimateByteSize(value), 0);\n}\n/** Returns a reference value for the provided database and key. */\nfunction refValue(databaseId, key) {\n    return {\n        referenceValue: `projects/${databaseId.projectId}/databases/${databaseId.database}/documents/${key.path.canonicalString()}`\n    };\n}\n/** Returns true if `value` is an IntegerValue . */\nfunction isInteger(value) {\n    return !!value && 'integerValue' in value;\n}\n/** Returns true if `value` is a DoubleValue. */\nfunction isDouble(value) {\n    return !!value && 'doubleValue' in value;\n}\n/** Returns true if `value` is either an IntegerValue or a DoubleValue. */\nfunction isNumber(value) {\n    return isInteger(value) || isDouble(value);\n}\n/** Returns true if `value` is an ArrayValue. */\nfunction isArray(value) {\n    return !!value && 'arrayValue' in value;\n}\n/** Returns true if `value` is a NullValue. */\nfunction isNullValue(value) {\n    return !!value && 'nullValue' in value;\n}\n/** Returns true if `value` is NaN. */\nfunction isNanValue(value) {\n    return !!value && 'doubleValue' in value && isNaN(Number(value.doubleValue));\n}\n/** Returns true if `value` is a MapValue. */\nfunction isMapValue(value) {\n    return !!value && 'mapValue' in value;\n}\n/** Returns true if `value` is a VetorValue. */\nfunction isVectorValue(value) {\n    const type = (value?.mapValue?.fields || {})[TYPE_KEY]?.stringValue;\n    return type === VECTOR_VALUE_SENTINEL;\n}\n/** Creates a deep copy of `source`. */\nfunction deepClone(source) {\n    if (source.geoPointValue) {\n        return { geoPointValue: { ...source.geoPointValue } };\n    }\n    else if (source.timestampValue &&\n        typeof source.timestampValue === 'object') {\n        return { timestampValue: { ...source.timestampValue } };\n    }\n    else if (source.mapValue) {\n        const target = { mapValue: { fields: {} } };\n        forEach(source.mapValue.fields, (key, val) => (target.mapValue.fields[key] = deepClone(val)));\n        return target;\n    }\n    else if (source.arrayValue) {\n        const target = { arrayValue: { values: [] } };\n        for (let i = 0; i < (source.arrayValue.values || []).length; ++i) {\n            target.arrayValue.values[i] = deepClone(source.arrayValue.values[i]);\n        }\n        return target;\n    }\n    else {\n        return { ...source };\n    }\n}\n/** Returns true if the Value represents the canonical {@link #MAX_VALUE} . */\nfunction isMaxValue(value) {\n    return ((((value.mapValue || {}).fields || {})['__type__'] || {}).stringValue ===\n        MAX_VALUE_TYPE);\n}\nconst MIN_VECTOR_VALUE = {\n    mapValue: {\n        fields: {\n            [TYPE_KEY]: { stringValue: VECTOR_VALUE_SENTINEL },\n            [VECTOR_MAP_VECTORS_KEY]: {\n                arrayValue: {}\n            }\n        }\n    }\n};\n/** Returns the lowest value for the given value type (inclusive). */\nfunction valuesGetLowerBound(value) {\n    if ('nullValue' in value) {\n        return MIN_VALUE;\n    }\n    else if ('booleanValue' in value) {\n        return { booleanValue: false };\n    }\n    else if ('integerValue' in value || 'doubleValue' in value) {\n        return { doubleValue: NaN };\n    }\n    else if ('timestampValue' in value) {\n        return { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } };\n    }\n    else if ('stringValue' in value) {\n        return { stringValue: '' };\n    }\n    else if ('bytesValue' in value) {\n        return { bytesValue: '' };\n    }\n    else if ('referenceValue' in value) {\n        return refValue(DatabaseId.empty(), DocumentKey.empty());\n    }\n    else if ('geoPointValue' in value) {\n        return { geoPointValue: { latitude: -90, longitude: -180 } };\n    }\n    else if ('arrayValue' in value) {\n        return { arrayValue: {} };\n    }\n    else if ('mapValue' in value) {\n        if (isVectorValue(value)) {\n            return MIN_VECTOR_VALUE;\n        }\n        return { mapValue: {} };\n    }\n    else {\n        return fail(0x8c66, { value });\n    }\n}\n/** Returns the largest value for the given value type (exclusive). */\nfunction valuesGetUpperBound(value) {\n    if ('nullValue' in value) {\n        return { booleanValue: false };\n    }\n    else if ('booleanValue' in value) {\n        return { doubleValue: NaN };\n    }\n    else if ('integerValue' in value || 'doubleValue' in value) {\n        return { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } };\n    }\n    else if ('timestampValue' in value) {\n        return { stringValue: '' };\n    }\n    else if ('stringValue' in value) {\n        return { bytesValue: '' };\n    }\n    else if ('bytesValue' in value) {\n        return refValue(DatabaseId.empty(), DocumentKey.empty());\n    }\n    else if ('referenceValue' in value) {\n        return { geoPointValue: { latitude: -90, longitude: -180 } };\n    }\n    else if ('geoPointValue' in value) {\n        return { arrayValue: {} };\n    }\n    else if ('arrayValue' in value) {\n        return MIN_VECTOR_VALUE;\n    }\n    else if ('mapValue' in value) {\n        if (isVectorValue(value)) {\n            return { mapValue: {} };\n        }\n        return MAX_VALUE;\n    }\n    else {\n        return fail(0xf207, { value });\n    }\n}\nfunction lowerBoundCompare(left, right) {\n    const cmp = valueCompare(left.value, right.value);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    if (left.inclusive && !right.inclusive) {\n        return -1;\n    }\n    else if (!left.inclusive && right.inclusive) {\n        return 1;\n    }\n    return 0;\n}\nfunction upperBoundCompare(left, right) {\n    const cmp = valueCompare(left.value, right.value);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    if (left.inclusive && !right.inclusive) {\n        return 1;\n    }\n    else if (!left.inclusive && right.inclusive) {\n        return -1;\n    }\n    return 0;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An ObjectValue represents a MapValue in the Firestore Proto and offers the\n * ability to add and remove fields (via the ObjectValueBuilder).\n */\nclass ObjectValue {\n    constructor(value) {\n        this.value = value;\n    }\n    static empty() {\n        return new ObjectValue({ mapValue: {} });\n    }\n    /**\n     * Returns the value at the given path or null.\n     *\n     * @param path - the path to search\n     * @returns The value at the path or null if the path is not set.\n     */\n    field(path) {\n        if (path.isEmpty()) {\n            return this.value;\n        }\n        else {\n            let currentLevel = this.value;\n            for (let i = 0; i < path.length - 1; ++i) {\n                currentLevel = (currentLevel.mapValue.fields || {})[path.get(i)];\n                if (!isMapValue(currentLevel)) {\n                    return null;\n                }\n            }\n            currentLevel = (currentLevel.mapValue.fields || {})[path.lastSegment()];\n            return currentLevel || null;\n        }\n    }\n    /**\n     * Sets the field to the provided value.\n     *\n     * @param path - The field path to set.\n     * @param value - The value to set.\n     */\n    set(path, value) {\n        const fieldsMap = this.getFieldsMap(path.popLast());\n        fieldsMap[path.lastSegment()] = deepClone(value);\n    }\n    /**\n     * Sets the provided fields to the provided values.\n     *\n     * @param data - A map of fields to values (or null for deletes).\n     */\n    setAll(data) {\n        let parent = FieldPath$1.emptyPath();\n        let upserts = {};\n        let deletes = [];\n        data.forEach((value, path) => {\n            if (!parent.isImmediateParentOf(path)) {\n                // Insert the accumulated changes at this parent location\n                const fieldsMap = this.getFieldsMap(parent);\n                this.applyChanges(fieldsMap, upserts, deletes);\n                upserts = {};\n                deletes = [];\n                parent = path.popLast();\n            }\n            if (value) {\n                upserts[path.lastSegment()] = deepClone(value);\n            }\n            else {\n                deletes.push(path.lastSegment());\n            }\n        });\n        const fieldsMap = this.getFieldsMap(parent);\n        this.applyChanges(fieldsMap, upserts, deletes);\n    }\n    /**\n     * Removes the field at the specified path. If there is no field at the\n     * specified path, nothing is changed.\n     *\n     * @param path - The field path to remove.\n     */\n    delete(path) {\n        const nestedValue = this.field(path.popLast());\n        if (isMapValue(nestedValue) && nestedValue.mapValue.fields) {\n            delete nestedValue.mapValue.fields[path.lastSegment()];\n        }\n    }\n    isEqual(other) {\n        return valueEquals(this.value, other.value);\n    }\n    /**\n     * Returns the map that contains the leaf element of `path`. If the parent\n     * entry does not yet exist, or if it is not a map, a new map will be created.\n     */\n    getFieldsMap(path) {\n        let current = this.value;\n        if (!current.mapValue.fields) {\n            current.mapValue = { fields: {} };\n        }\n        for (let i = 0; i < path.length; ++i) {\n            let next = current.mapValue.fields[path.get(i)];\n            if (!isMapValue(next) || !next.mapValue.fields) {\n                next = { mapValue: { fields: {} } };\n                current.mapValue.fields[path.get(i)] = next;\n            }\n            current = next;\n        }\n        return current.mapValue.fields;\n    }\n    /**\n     * Modifies `fieldsMap` by adding, replacing or deleting the specified\n     * entries.\n     */\n    applyChanges(fieldsMap, inserts, deletes) {\n        forEach(inserts, (key, val) => (fieldsMap[key] = val));\n        for (const field of deletes) {\n            delete fieldsMap[field];\n        }\n    }\n    clone() {\n        return new ObjectValue(deepClone(this.value));\n    }\n}\n/**\n * Returns a FieldMask built from all fields in a MapValue.\n */\nfunction extractFieldMask(value) {\n    const fields = [];\n    forEach(value.fields, (key, value) => {\n        const currentPath = new FieldPath$1([key]);\n        if (isMapValue(value)) {\n            const nestedMask = extractFieldMask(value.mapValue);\n            const nestedFields = nestedMask.fields;\n            if (nestedFields.length === 0) {\n                // Preserve the empty map by adding it to the FieldMask.\n                fields.push(currentPath);\n            }\n            else {\n                // For nested and non-empty ObjectValues, add the FieldPath of the\n                // leaf nodes.\n                for (const nestedPath of nestedFields) {\n                    fields.push(currentPath.child(nestedPath));\n                }\n            }\n        }\n        else {\n            // For nested and non-empty ObjectValues, add the FieldPath of the leaf\n            // nodes.\n            fields.push(currentPath);\n        }\n    });\n    return new FieldMask(fields);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a document in Firestore with a key, version, data and whether it\n * has local mutations applied to it.\n *\n * Documents can transition between states via `convertToFoundDocument()`,\n * `convertToNoDocument()` and `convertToUnknownDocument()`. If a document does\n * not transition to one of these states even after all mutations have been\n * applied, `isValidDocument()` returns false and the document should be removed\n * from all views.\n */\nclass MutableDocument {\n    constructor(key, documentType, version, readTime, createTime, data, documentState) {\n        this.key = key;\n        this.documentType = documentType;\n        this.version = version;\n        this.readTime = readTime;\n        this.createTime = createTime;\n        this.data = data;\n        this.documentState = documentState;\n    }\n    /**\n     * Creates a document with no known version or data, but which can serve as\n     * base document for mutations.\n     */\n    static newInvalidDocument(documentKey) {\n        return new MutableDocument(documentKey, 0 /* DocumentType.INVALID */, \n        /* version */ SnapshotVersion.min(), \n        /* readTime */ SnapshotVersion.min(), \n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 0 /* DocumentState.SYNCED */);\n    }\n    /**\n     * Creates a new document that is known to exist with the given data at the\n     * given version.\n     */\n    static newFoundDocument(documentKey, version, createTime, value) {\n        return new MutableDocument(documentKey, 1 /* DocumentType.FOUND_DOCUMENT */, \n        /* version */ version, \n        /* readTime */ SnapshotVersion.min(), \n        /* createTime */ createTime, value, 0 /* DocumentState.SYNCED */);\n    }\n    /** Creates a new document that is known to not exist at the given version. */\n    static newNoDocument(documentKey, version) {\n        return new MutableDocument(documentKey, 2 /* DocumentType.NO_DOCUMENT */, \n        /* version */ version, \n        /* readTime */ SnapshotVersion.min(), \n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 0 /* DocumentState.SYNCED */);\n    }\n    /**\n     * Creates a new document that is known to exist at the given version but\n     * whose data is not known (e.g. a document that was updated without a known\n     * base document).\n     */\n    static newUnknownDocument(documentKey, version) {\n        return new MutableDocument(documentKey, 3 /* DocumentType.UNKNOWN_DOCUMENT */, \n        /* version */ version, \n        /* readTime */ SnapshotVersion.min(), \n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */);\n    }\n    /**\n     * Changes the document type to indicate that it exists and that its version\n     * and data are known.\n     */\n    convertToFoundDocument(version, value) {\n        // If a document is switching state from being an invalid or deleted\n        // document to a valid (FOUND_DOCUMENT) document, either due to receiving an\n        // update from Watch or due to applying a local set mutation on top\n        // of a deleted document, our best guess about its createTime would be the\n        // version at which the document transitioned to a FOUND_DOCUMENT.\n        if (this.createTime.isEqual(SnapshotVersion.min()) &&\n            (this.documentType === 2 /* DocumentType.NO_DOCUMENT */ ||\n                this.documentType === 0 /* DocumentType.INVALID */)) {\n            this.createTime = version;\n        }\n        this.version = version;\n        this.documentType = 1 /* DocumentType.FOUND_DOCUMENT */;\n        this.data = value;\n        this.documentState = 0 /* DocumentState.SYNCED */;\n        return this;\n    }\n    /**\n     * Changes the document type to indicate that it doesn't exist at the given\n     * version.\n     */\n    convertToNoDocument(version) {\n        this.version = version;\n        this.documentType = 2 /* DocumentType.NO_DOCUMENT */;\n        this.data = ObjectValue.empty();\n        this.documentState = 0 /* DocumentState.SYNCED */;\n        return this;\n    }\n    /**\n     * Changes the document type to indicate that it exists at a given version but\n     * that its data is not known (e.g. a document that was updated without a known\n     * base document).\n     */\n    convertToUnknownDocument(version) {\n        this.version = version;\n        this.documentType = 3 /* DocumentType.UNKNOWN_DOCUMENT */;\n        this.data = ObjectValue.empty();\n        this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\n        return this;\n    }\n    setHasCommittedMutations() {\n        this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\n        return this;\n    }\n    setHasLocalMutations() {\n        this.documentState = 1 /* DocumentState.HAS_LOCAL_MUTATIONS */;\n        this.version = SnapshotVersion.min();\n        return this;\n    }\n    setReadTime(readTime) {\n        this.readTime = readTime;\n        return this;\n    }\n    get hasLocalMutations() {\n        return this.documentState === 1 /* DocumentState.HAS_LOCAL_MUTATIONS */;\n    }\n    get hasCommittedMutations() {\n        return this.documentState === 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\n    }\n    get hasPendingWrites() {\n        return this.hasLocalMutations || this.hasCommittedMutations;\n    }\n    isValidDocument() {\n        return this.documentType !== 0 /* DocumentType.INVALID */;\n    }\n    isFoundDocument() {\n        return this.documentType === 1 /* DocumentType.FOUND_DOCUMENT */;\n    }\n    isNoDocument() {\n        return this.documentType === 2 /* DocumentType.NO_DOCUMENT */;\n    }\n    isUnknownDocument() {\n        return this.documentType === 3 /* DocumentType.UNKNOWN_DOCUMENT */;\n    }\n    isEqual(other) {\n        return (other instanceof MutableDocument &&\n            this.key.isEqual(other.key) &&\n            this.version.isEqual(other.version) &&\n            this.documentType === other.documentType &&\n            this.documentState === other.documentState &&\n            this.data.isEqual(other.data));\n    }\n    mutableCopy() {\n        return new MutableDocument(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);\n    }\n    toString() {\n        return (`Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, ` +\n            `{createTime: ${this.createTime}}), ` +\n            `{documentType: ${this.documentType}}), ` +\n            `{documentState: ${this.documentState}})`);\n    }\n}\n/**\n * Compares the value for field `field` in the provided documents. Throws if\n * the field does not exist in both documents.\n */\nfunction compareDocumentsByField(field, d1, d2) {\n    const v1 = d1.data.field(field);\n    const v2 = d2.data.field(field);\n    if (v1 !== null && v2 !== null) {\n        return valueCompare(v1, v2);\n    }\n    else {\n        return fail(0xa786);\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a bound of a query.\n *\n * The bound is specified with the given components representing a position and\n * whether it's just before or just after the position (relative to whatever the\n * query order is).\n *\n * The position represents a logical index position for a query. It's a prefix\n * of values for the (potentially implicit) order by clauses of a query.\n *\n * Bound provides a function to determine whether a document comes before or\n * after a bound. This is influenced by whether the position is just before or\n * just after the provided values.\n */\nclass Bound {\n    constructor(position, inclusive) {\n        this.position = position;\n        this.inclusive = inclusive;\n    }\n}\nfunction boundCompareToDocument(bound, orderBy, doc) {\n    let comparison = 0;\n    for (let i = 0; i < bound.position.length; i++) {\n        const orderByComponent = orderBy[i];\n        const component = bound.position[i];\n        if (orderByComponent.field.isKeyField()) {\n            comparison = DocumentKey.comparator(DocumentKey.fromName(component.referenceValue), doc.key);\n        }\n        else {\n            const docValue = doc.data.field(orderByComponent.field);\n            comparison = valueCompare(component, docValue);\n        }\n        if (orderByComponent.dir === \"desc\" /* Direction.DESCENDING */) {\n            comparison = comparison * -1;\n        }\n        if (comparison !== 0) {\n            break;\n        }\n    }\n    return comparison;\n}\n/**\n * Returns true if a document sorts after a bound using the provided sort\n * order.\n */\nfunction boundSortsAfterDocument(bound, orderBy, doc) {\n    const comparison = boundCompareToDocument(bound, orderBy, doc);\n    return bound.inclusive ? comparison >= 0 : comparison > 0;\n}\n/**\n * Returns true if a document sorts before a bound using the provided sort\n * order.\n */\nfunction boundSortsBeforeDocument(bound, orderBy, doc) {\n    const comparison = boundCompareToDocument(bound, orderBy, doc);\n    return bound.inclusive ? comparison <= 0 : comparison < 0;\n}\nfunction boundEquals(left, right) {\n    if (left === null) {\n        return right === null;\n    }\n    else if (right === null) {\n        return false;\n    }\n    if (left.inclusive !== right.inclusive ||\n        left.position.length !== right.position.length) {\n        return false;\n    }\n    for (let i = 0; i < left.position.length; i++) {\n        const leftPosition = left.position[i];\n        const rightPosition = right.position[i];\n        if (!valueEquals(leftPosition, rightPosition)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\n */\nclass OrderBy {\n    constructor(field, dir = \"asc\" /* Direction.ASCENDING */) {\n        this.field = field;\n        this.dir = dir;\n    }\n}\nfunction canonifyOrderBy(orderBy) {\n    // TODO(b/29183165): Make this collision robust.\n    return orderBy.field.canonicalString() + orderBy.dir;\n}\nfunction stringifyOrderBy(orderBy) {\n    return `${orderBy.field.canonicalString()} (${orderBy.dir})`;\n}\nfunction orderByEquals(left, right) {\n    return left.dir === right.dir && left.field.isEqual(right.field);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Filter {\n}\nclass FieldFilter extends Filter {\n    constructor(field, op, value) {\n        super();\n        this.field = field;\n        this.op = op;\n        this.value = value;\n    }\n    /**\n     * Creates a filter based on the provided arguments.\n     */\n    static create(field, op, value) {\n        if (field.isKeyField()) {\n            if (op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */) {\n                return this.createKeyFieldInFilter(field, op, value);\n            }\n            else {\n                return new KeyFieldFilter(field, op, value);\n            }\n        }\n        else if (op === \"array-contains\" /* Operator.ARRAY_CONTAINS */) {\n            return new ArrayContainsFilter(field, value);\n        }\n        else if (op === \"in\" /* Operator.IN */) {\n            return new InFilter(field, value);\n        }\n        else if (op === \"not-in\" /* Operator.NOT_IN */) {\n            return new NotInFilter(field, value);\n        }\n        else if (op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\n            return new ArrayContainsAnyFilter(field, value);\n        }\n        else {\n            return new FieldFilter(field, op, value);\n        }\n    }\n    static createKeyFieldInFilter(field, op, value) {\n        return op === \"in\" /* Operator.IN */\n            ? new KeyFieldInFilter(field, value)\n            : new KeyFieldNotInFilter(field, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        // Types do not have to match in NOT_EQUAL filters.\n        if (this.op === \"!=\" /* Operator.NOT_EQUAL */) {\n            return (other !== null &&\n                other.nullValue === undefined &&\n                this.matchesComparison(valueCompare(other, this.value)));\n        }\n        // Only compare types with matching backend order (such as double and int).\n        return (other !== null &&\n            typeOrder(this.value) === typeOrder(other) &&\n            this.matchesComparison(valueCompare(other, this.value)));\n    }\n    matchesComparison(comparison) {\n        switch (this.op) {\n            case \"<\" /* Operator.LESS_THAN */:\n                return comparison < 0;\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\n                return comparison <= 0;\n            case \"==\" /* Operator.EQUAL */:\n                return comparison === 0;\n            case \"!=\" /* Operator.NOT_EQUAL */:\n                return comparison !== 0;\n            case \">\" /* Operator.GREATER_THAN */:\n                return comparison > 0;\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\n                return comparison >= 0;\n            default:\n                return fail(0xb8a2, {\n                    operator: this.op\n                });\n        }\n    }\n    isInequality() {\n        return ([\n            \"<\" /* Operator.LESS_THAN */,\n            \"<=\" /* Operator.LESS_THAN_OR_EQUAL */,\n            \">\" /* Operator.GREATER_THAN */,\n            \">=\" /* Operator.GREATER_THAN_OR_EQUAL */,\n            \"!=\" /* Operator.NOT_EQUAL */,\n            \"not-in\" /* Operator.NOT_IN */\n        ].indexOf(this.op) >= 0);\n    }\n    getFlattenedFilters() {\n        return [this];\n    }\n    getFilters() {\n        return [this];\n    }\n}\nclass CompositeFilter extends Filter {\n    constructor(filters, op) {\n        super();\n        this.filters = filters;\n        this.op = op;\n        this.memoizedFlattenedFilters = null;\n    }\n    /**\n     * Creates a filter based on the provided arguments.\n     */\n    static create(filters, op) {\n        return new CompositeFilter(filters, op);\n    }\n    matches(doc) {\n        if (compositeFilterIsConjunction(this)) {\n            // For conjunctions, all filters must match, so return false if any filter doesn't match.\n            return this.filters.find(filter => !filter.matches(doc)) === undefined;\n        }\n        else {\n            // For disjunctions, at least one filter should match.\n            return this.filters.find(filter => filter.matches(doc)) !== undefined;\n        }\n    }\n    getFlattenedFilters() {\n        if (this.memoizedFlattenedFilters !== null) {\n            return this.memoizedFlattenedFilters;\n        }\n        this.memoizedFlattenedFilters = this.filters.reduce((result, subfilter) => {\n            return result.concat(subfilter.getFlattenedFilters());\n        }, []);\n        return this.memoizedFlattenedFilters;\n    }\n    // Returns a mutable copy of `this.filters`\n    getFilters() {\n        return Object.assign([], this.filters);\n    }\n}\nfunction compositeFilterIsConjunction(compositeFilter) {\n    return compositeFilter.op === \"and\" /* CompositeOperator.AND */;\n}\nfunction compositeFilterIsDisjunction(compositeFilter) {\n    return compositeFilter.op === \"or\" /* CompositeOperator.OR */;\n}\n/**\n * Returns true if this filter is a conjunction of field filters only. Returns false otherwise.\n */\nfunction compositeFilterIsFlatConjunction(compositeFilter) {\n    return (compositeFilterIsFlat(compositeFilter) &&\n        compositeFilterIsConjunction(compositeFilter));\n}\n/**\n * Returns true if this filter does not contain any composite filters. Returns false otherwise.\n */\nfunction compositeFilterIsFlat(compositeFilter) {\n    for (const filter of compositeFilter.filters) {\n        if (filter instanceof CompositeFilter) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction canonifyFilter(filter) {\n    if (filter instanceof FieldFilter) {\n        // TODO(b/29183165): Technically, this won't be unique if two values have\n        // the same description, such as the int 3 and the string \"3\". So we should\n        // add the types in here somehow, too.\n        return (filter.field.canonicalString() +\n            filter.op.toString() +\n            canonicalId(filter.value));\n    }\n    else if (compositeFilterIsFlatConjunction(filter)) {\n        // Older SDK versions use an implicit AND operation between their filters.\n        // In the new SDK versions, the developer may use an explicit AND filter.\n        // To stay consistent with the old usages, we add a special case to ensure\n        // the canonical ID for these two are the same. For example:\n        // `col.whereEquals(\"a\", 1).whereEquals(\"b\", 2)` should have the same\n        // canonical ID as `col.where(and(equals(\"a\",1), equals(\"b\",2)))`.\n        return filter.filters.map(filter => canonifyFilter(filter)).join(',');\n    }\n    else {\n        // filter instanceof CompositeFilter\n        const canonicalIdsString = filter.filters\n            .map(filter => canonifyFilter(filter))\n            .join(',');\n        return `${filter.op}(${canonicalIdsString})`;\n    }\n}\nfunction filterEquals(f1, f2) {\n    if (f1 instanceof FieldFilter) {\n        return fieldFilterEquals(f1, f2);\n    }\n    else if (f1 instanceof CompositeFilter) {\n        return compositeFilterEquals(f1, f2);\n    }\n    else {\n        fail(0x4bef);\n    }\n}\nfunction fieldFilterEquals(f1, f2) {\n    return (f2 instanceof FieldFilter &&\n        f1.op === f2.op &&\n        f1.field.isEqual(f2.field) &&\n        valueEquals(f1.value, f2.value));\n}\nfunction compositeFilterEquals(f1, f2) {\n    if (f2 instanceof CompositeFilter &&\n        f1.op === f2.op &&\n        f1.filters.length === f2.filters.length) {\n        const subFiltersMatch = f1.filters.reduce((result, f1Filter, index) => result && filterEquals(f1Filter, f2.filters[index]), true);\n        return subFiltersMatch;\n    }\n    return false;\n}\n/**\n * Returns a new composite filter that contains all filter from\n * `compositeFilter` plus all the given filters in `otherFilters`.\n */\nfunction compositeFilterWithAddedFilters(compositeFilter, otherFilters) {\n    const mergedFilters = compositeFilter.filters.concat(otherFilters);\n    return CompositeFilter.create(mergedFilters, compositeFilter.op);\n}\n/** Returns a debug description for `filter`. */\nfunction stringifyFilter(filter) {\n    if (filter instanceof FieldFilter) {\n        return stringifyFieldFilter(filter);\n    }\n    else if (filter instanceof CompositeFilter) {\n        return stringifyCompositeFilter(filter);\n    }\n    else {\n        return 'Filter';\n    }\n}\nfunction stringifyCompositeFilter(filter) {\n    return (filter.op.toString() +\n        ` {` +\n        filter.getFilters().map(stringifyFilter).join(' ,') +\n        '}');\n}\nfunction stringifyFieldFilter(filter) {\n    return `${filter.field.canonicalString()} ${filter.op} ${canonicalId(filter.value)}`;\n}\n/** Filter that matches on key fields (i.e. '__name__'). */\nclass KeyFieldFilter extends FieldFilter {\n    constructor(field, op, value) {\n        super(field, op, value);\n        this.key = DocumentKey.fromName(value.referenceValue);\n    }\n    matches(doc) {\n        const comparison = DocumentKey.comparator(doc.key, this.key);\n        return this.matchesComparison(comparison);\n    }\n}\n/** Filter that matches on key fields within an array. */\nclass KeyFieldInFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"in\" /* Operator.IN */, value);\n        this.keys = extractDocumentKeysFromArrayValue(\"in\" /* Operator.IN */, value);\n    }\n    matches(doc) {\n        return this.keys.some(key => key.isEqual(doc.key));\n    }\n}\n/** Filter that matches on key fields not present within an array. */\nclass KeyFieldNotInFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"not-in\" /* Operator.NOT_IN */, value);\n        this.keys = extractDocumentKeysFromArrayValue(\"not-in\" /* Operator.NOT_IN */, value);\n    }\n    matches(doc) {\n        return !this.keys.some(key => key.isEqual(doc.key));\n    }\n}\nfunction extractDocumentKeysFromArrayValue(op, value) {\n    return (value.arrayValue?.values || []).map(v => {\n        return DocumentKey.fromName(v.referenceValue);\n    });\n}\n/** A Filter that implements the array-contains operator. */\nclass ArrayContainsFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"array-contains\" /* Operator.ARRAY_CONTAINS */, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        return isArray(other) && arrayValueContains(other.arrayValue, this.value);\n    }\n}\n/** A Filter that implements the IN operator. */\nclass InFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"in\" /* Operator.IN */, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        return other !== null && arrayValueContains(this.value.arrayValue, other);\n    }\n}\n/** A Filter that implements the not-in operator. */\nclass NotInFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"not-in\" /* Operator.NOT_IN */, value);\n    }\n    matches(doc) {\n        if (arrayValueContains(this.value.arrayValue, { nullValue: 'NULL_VALUE' })) {\n            return false;\n        }\n        const other = doc.data.field(this.field);\n        return (other !== null &&\n            other.nullValue === undefined &&\n            !arrayValueContains(this.value.arrayValue, other));\n    }\n}\n/** A Filter that implements the array-contains-any operator. */\nclass ArrayContainsAnyFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        if (!isArray(other) || !other.arrayValue.values) {\n            return false;\n        }\n        return other.arrayValue.values.some(val => arrayValueContains(this.value.arrayValue, val));\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Visible for testing\nclass TargetImpl {\n    constructor(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) {\n        this.path = path;\n        this.collectionGroup = collectionGroup;\n        this.orderBy = orderBy;\n        this.filters = filters;\n        this.limit = limit;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.memoizedCanonicalId = null;\n    }\n}\n/**\n * Initializes a Target with a path and optional additional query constraints.\n * Path must currently be empty if this is a collection group query.\n *\n * NOTE: you should always construct `Target` from `Query.toTarget` instead of\n * using this factory method, because `Query` provides an implicit `orderBy`\n * property.\n */\nfunction newTarget(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) {\n    return new TargetImpl(path, collectionGroup, orderBy, filters, limit, startAt, endAt);\n}\nfunction canonifyTarget(target) {\n    const targetImpl = debugCast(target);\n    if (targetImpl.memoizedCanonicalId === null) {\n        let str = targetImpl.path.canonicalString();\n        if (targetImpl.collectionGroup !== null) {\n            str += '|cg:' + targetImpl.collectionGroup;\n        }\n        str += '|f:';\n        str += targetImpl.filters.map(f => canonifyFilter(f)).join(',');\n        str += '|ob:';\n        str += targetImpl.orderBy.map(o => canonifyOrderBy(o)).join(',');\n        if (!isNullOrUndefined(targetImpl.limit)) {\n            str += '|l:';\n            str += targetImpl.limit;\n        }\n        if (targetImpl.startAt) {\n            str += '|lb:';\n            str += targetImpl.startAt.inclusive ? 'b:' : 'a:';\n            str += targetImpl.startAt.position.map(p => canonicalId(p)).join(',');\n        }\n        if (targetImpl.endAt) {\n            str += '|ub:';\n            str += targetImpl.endAt.inclusive ? 'a:' : 'b:';\n            str += targetImpl.endAt.position.map(p => canonicalId(p)).join(',');\n        }\n        targetImpl.memoizedCanonicalId = str;\n    }\n    return targetImpl.memoizedCanonicalId;\n}\nfunction stringifyTarget(target) {\n    let str = target.path.canonicalString();\n    if (target.collectionGroup !== null) {\n        str += ' collectionGroup=' + target.collectionGroup;\n    }\n    if (target.filters.length > 0) {\n        str += `, filters: [${target.filters\n            .map(f => stringifyFilter(f))\n            .join(', ')}]`;\n    }\n    if (!isNullOrUndefined(target.limit)) {\n        str += ', limit: ' + target.limit;\n    }\n    if (target.orderBy.length > 0) {\n        str += `, orderBy: [${target.orderBy\n            .map(o => stringifyOrderBy(o))\n            .join(', ')}]`;\n    }\n    if (target.startAt) {\n        str += ', startAt: ';\n        str += target.startAt.inclusive ? 'b:' : 'a:';\n        str += target.startAt.position.map(p => canonicalId(p)).join(',');\n    }\n    if (target.endAt) {\n        str += ', endAt: ';\n        str += target.endAt.inclusive ? 'a:' : 'b:';\n        str += target.endAt.position.map(p => canonicalId(p)).join(',');\n    }\n    return `Target(${str})`;\n}\nfunction targetEquals(left, right) {\n    if (left.limit !== right.limit) {\n        return false;\n    }\n    if (left.orderBy.length !== right.orderBy.length) {\n        return false;\n    }\n    for (let i = 0; i < left.orderBy.length; i++) {\n        if (!orderByEquals(left.orderBy[i], right.orderBy[i])) {\n            return false;\n        }\n    }\n    if (left.filters.length !== right.filters.length) {\n        return false;\n    }\n    for (let i = 0; i < left.filters.length; i++) {\n        if (!filterEquals(left.filters[i], right.filters[i])) {\n            return false;\n        }\n    }\n    if (left.collectionGroup !== right.collectionGroup) {\n        return false;\n    }\n    if (!left.path.isEqual(right.path)) {\n        return false;\n    }\n    if (!boundEquals(left.startAt, right.startAt)) {\n        return false;\n    }\n    return boundEquals(left.endAt, right.endAt);\n}\nfunction targetIsDocumentTarget(target) {\n    return (DocumentKey.isDocumentKey(target.path) &&\n        target.collectionGroup === null &&\n        target.filters.length === 0);\n}\n/** Returns the field filters that target the given field path. */\nfunction targetGetFieldFiltersForPath(target, path) {\n    return target.filters.filter(f => f instanceof FieldFilter && f.field.isEqual(path));\n}\n/**\n * Returns the values that are used in ARRAY_CONTAINS or ARRAY_CONTAINS_ANY\n * filters. Returns `null` if there are no such filters.\n */\nfunction targetGetArrayValues(target, fieldIndex) {\n    const segment = fieldIndexGetArraySegment(fieldIndex);\n    if (segment === undefined) {\n        return null;\n    }\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, segment.fieldPath)) {\n        switch (fieldFilter.op) {\n            case \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */:\n                return fieldFilter.value.arrayValue.values || [];\n            case \"array-contains\" /* Operator.ARRAY_CONTAINS */:\n                return [fieldFilter.value];\n            // Remaining filters are not array filters.\n        }\n    }\n    return null;\n}\n/**\n * Returns the list of values that are used in != or NOT_IN filters. Returns\n * `null` if there are no such filters.\n */\nfunction targetGetNotInValues(target, fieldIndex) {\n    const values = new Map();\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n        for (const fieldFilter of targetGetFieldFiltersForPath(target, segment.fieldPath)) {\n            switch (fieldFilter.op) {\n                case \"==\" /* Operator.EQUAL */:\n                case \"in\" /* Operator.IN */:\n                    // Encode equality prefix, which is encoded in the index value before\n                    // the inequality (e.g. `a == 'a' && b != 'b'` is encoded to\n                    // `value != 'ab'`).\n                    values.set(segment.fieldPath.canonicalString(), fieldFilter.value);\n                    break;\n                case \"not-in\" /* Operator.NOT_IN */:\n                case \"!=\" /* Operator.NOT_EQUAL */:\n                    // NotIn/NotEqual is always a suffix. There cannot be any remaining\n                    // segments and hence we can return early here.\n                    values.set(segment.fieldPath.canonicalString(), fieldFilter.value);\n                    return Array.from(values.values());\n                // Remaining filters cannot be used as notIn bounds.\n            }\n        }\n    }\n    return null;\n}\n/**\n * Returns a lower bound of field values that can be used as a starting point to\n * scan the index defined by `fieldIndex`. Returns `MIN_VALUE` if no lower bound\n * exists.\n */\nfunction targetGetLowerBound(target, fieldIndex) {\n    const values = [];\n    let inclusive = true;\n    // For each segment, retrieve a lower bound if there is a suitable filter or\n    // startAt.\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n        const segmentBound = segment.kind === 0 /* IndexKind.ASCENDING */\n            ? targetGetAscendingBound(target, segment.fieldPath, target.startAt)\n            : targetGetDescendingBound(target, segment.fieldPath, target.startAt);\n        values.push(segmentBound.value);\n        inclusive && (inclusive = segmentBound.inclusive);\n    }\n    return new Bound(values, inclusive);\n}\n/**\n * Returns an upper bound of field values that can be used as an ending point\n * when scanning the index defined by `fieldIndex`. Returns `MAX_VALUE` if no\n * upper bound exists.\n */\nfunction targetGetUpperBound(target, fieldIndex) {\n    const values = [];\n    let inclusive = true;\n    // For each segment, retrieve an upper bound if there is a suitable filter or\n    // endAt.\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n        const segmentBound = segment.kind === 0 /* IndexKind.ASCENDING */\n            ? targetGetDescendingBound(target, segment.fieldPath, target.endAt)\n            : targetGetAscendingBound(target, segment.fieldPath, target.endAt);\n        values.push(segmentBound.value);\n        inclusive && (inclusive = segmentBound.inclusive);\n    }\n    return new Bound(values, inclusive);\n}\n/**\n * Returns the value to use as the lower bound for ascending index segment at\n * the provided `fieldPath` (or the upper bound for an descending segment).\n */\nfunction targetGetAscendingBound(target, fieldPath, bound) {\n    let value = MIN_VALUE;\n    let inclusive = true;\n    // Process all filters to find a value for the current field segment\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, fieldPath)) {\n        let filterValue = MIN_VALUE;\n        let filterInclusive = true;\n        switch (fieldFilter.op) {\n            case \"<\" /* Operator.LESS_THAN */:\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\n                filterValue = valuesGetLowerBound(fieldFilter.value);\n                break;\n            case \"==\" /* Operator.EQUAL */:\n            case \"in\" /* Operator.IN */:\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\n                filterValue = fieldFilter.value;\n                break;\n            case \">\" /* Operator.GREATER_THAN */:\n                filterValue = fieldFilter.value;\n                filterInclusive = false;\n                break;\n            case \"!=\" /* Operator.NOT_EQUAL */:\n            case \"not-in\" /* Operator.NOT_IN */:\n                filterValue = MIN_VALUE;\n                break;\n            // Remaining filters cannot be used as lower bounds.\n        }\n        if (lowerBoundCompare({ value, inclusive }, { value: filterValue, inclusive: filterInclusive }) < 0) {\n            value = filterValue;\n            inclusive = filterInclusive;\n        }\n    }\n    // If there is an additional bound, compare the values against the existing\n    // range to see if we can narrow the scope.\n    if (bound !== null) {\n        for (let i = 0; i < target.orderBy.length; ++i) {\n            const orderBy = target.orderBy[i];\n            if (orderBy.field.isEqual(fieldPath)) {\n                const cursorValue = bound.position[i];\n                if (lowerBoundCompare({ value, inclusive }, { value: cursorValue, inclusive: bound.inclusive }) < 0) {\n                    value = cursorValue;\n                    inclusive = bound.inclusive;\n                }\n                break;\n            }\n        }\n    }\n    return { value, inclusive };\n}\n/**\n * Returns the value to use as the upper bound for ascending index segment at\n * the provided `fieldPath` (or the lower bound for a descending segment).\n */\nfunction targetGetDescendingBound(target, fieldPath, bound) {\n    let value = MAX_VALUE;\n    let inclusive = true;\n    // Process all filters to find a value for the current field segment\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, fieldPath)) {\n        let filterValue = MAX_VALUE;\n        let filterInclusive = true;\n        switch (fieldFilter.op) {\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\n            case \">\" /* Operator.GREATER_THAN */:\n                filterValue = valuesGetUpperBound(fieldFilter.value);\n                filterInclusive = false;\n                break;\n            case \"==\" /* Operator.EQUAL */:\n            case \"in\" /* Operator.IN */:\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\n                filterValue = fieldFilter.value;\n                break;\n            case \"<\" /* Operator.LESS_THAN */:\n                filterValue = fieldFilter.value;\n                filterInclusive = false;\n                break;\n            case \"!=\" /* Operator.NOT_EQUAL */:\n            case \"not-in\" /* Operator.NOT_IN */:\n                filterValue = MAX_VALUE;\n                break;\n            // Remaining filters cannot be used as upper bounds.\n        }\n        if (upperBoundCompare({ value, inclusive }, { value: filterValue, inclusive: filterInclusive }) > 0) {\n            value = filterValue;\n            inclusive = filterInclusive;\n        }\n    }\n    // If there is an additional bound, compare the values against the existing\n    // range to see if we can narrow the scope.\n    if (bound !== null) {\n        for (let i = 0; i < target.orderBy.length; ++i) {\n            const orderBy = target.orderBy[i];\n            if (orderBy.field.isEqual(fieldPath)) {\n                const cursorValue = bound.position[i];\n                if (upperBoundCompare({ value, inclusive }, { value: cursorValue, inclusive: bound.inclusive }) > 0) {\n                    value = cursorValue;\n                    inclusive = bound.inclusive;\n                }\n                break;\n            }\n        }\n    }\n    return { value, inclusive };\n}\n/** Returns the number of segments of a perfect index for this target. */\nfunction targetGetSegmentCount(target) {\n    let fields = new SortedSet(FieldPath$1.comparator);\n    let hasArraySegment = false;\n    for (const filter of target.filters) {\n        for (const subFilter of filter.getFlattenedFilters()) {\n            // __name__ is not an explicit segment of any index, so we don't need to\n            // count it.\n            if (subFilter.field.isKeyField()) {\n                continue;\n            }\n            // ARRAY_CONTAINS or ARRAY_CONTAINS_ANY filters must be counted separately.\n            // For instance, it is possible to have an index for \"a ARRAY a ASC\". Even\n            // though these are on the same field, they should be counted as two\n            // separate segments in an index.\n            if (subFilter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\n                subFilter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\n                hasArraySegment = true;\n            }\n            else {\n                fields = fields.add(subFilter.field);\n            }\n        }\n    }\n    for (const orderBy of target.orderBy) {\n        // __name__ is not an explicit segment of any index, so we don't need to\n        // count it.\n        if (!orderBy.field.isKeyField()) {\n            fields = fields.add(orderBy.field);\n        }\n    }\n    return fields.size + (hasArraySegment ? 1 : 0);\n}\nfunction targetHasLimit(target) {\n    return target.limit !== null;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Query encapsulates all the query attributes we support in the SDK. It can\n * be run against the LocalStore, as well as be converted to a `Target` to\n * query the RemoteStore results.\n *\n * Visible for testing.\n */\nclass QueryImpl {\n    /**\n     * Initializes a Query with a path and optional additional query constraints.\n     * Path must currently be empty if this is a collection group query.\n     */\n    constructor(path, collectionGroup = null, explicitOrderBy = [], filters = [], limit = null, limitType = \"F\" /* LimitType.First */, startAt = null, endAt = null) {\n        this.path = path;\n        this.collectionGroup = collectionGroup;\n        this.explicitOrderBy = explicitOrderBy;\n        this.filters = filters;\n        this.limit = limit;\n        this.limitType = limitType;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.memoizedNormalizedOrderBy = null;\n        // The corresponding `Target` of this `Query` instance, for use with\n        // non-aggregate queries.\n        this.memoizedTarget = null;\n        // The corresponding `Target` of this `Query` instance, for use with\n        // aggregate queries. Unlike targets for non-aggregate queries,\n        // aggregate query targets do not contain normalized order-bys, they only\n        // contain explicit order-bys.\n        this.memoizedAggregateTarget = null;\n        if (this.startAt) ;\n        if (this.endAt) ;\n    }\n}\n/** Creates a new Query instance with the options provided. */\nfunction newQuery(path, collectionGroup, explicitOrderBy, filters, limit, limitType, startAt, endAt) {\n    return new QueryImpl(path, collectionGroup, explicitOrderBy, filters, limit, limitType, startAt, endAt);\n}\n/** Creates a new Query for a query that matches all documents at `path` */\nfunction newQueryForPath(path) {\n    return new QueryImpl(path);\n}\n/**\n * Helper to convert a collection group query into a collection query at a\n * specific path. This is used when executing collection group queries, since\n * we have to split the query into a set of collection queries at multiple\n * paths.\n */\nfunction asCollectionQueryAtPath(query, path) {\n    return new QueryImpl(path, \n    /*collectionGroup=*/ null, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, query.startAt, query.endAt);\n}\n/**\n * Returns true if this query does not specify any query constraints that\n * could remove results.\n */\nfunction queryMatchesAllDocuments(query) {\n    return (query.filters.length === 0 &&\n        query.limit === null &&\n        query.startAt == null &&\n        query.endAt == null &&\n        (query.explicitOrderBy.length === 0 ||\n            (query.explicitOrderBy.length === 1 &&\n                query.explicitOrderBy[0].field.isKeyField())));\n}\n// Returns the sorted set of inequality filter fields used in this query.\nfunction getInequalityFilterFields(query) {\n    let result = new SortedSet(FieldPath$1.comparator);\n    query.filters.forEach((filter) => {\n        const subFilters = filter.getFlattenedFilters();\n        subFilters.forEach((filter) => {\n            if (filter.isInequality()) {\n                result = result.add(filter.field);\n            }\n        });\n    });\n    return result;\n}\n/**\n * Creates a new Query for a collection group query that matches all documents\n * within the provided collection group.\n */\nfunction newQueryForCollectionGroup(collectionId) {\n    return new QueryImpl(ResourcePath.emptyPath(), collectionId);\n}\n/**\n * Returns whether the query matches a single document by path (rather than a\n * collection).\n */\nfunction isDocumentQuery$1(query) {\n    return (DocumentKey.isDocumentKey(query.path) &&\n        query.collectionGroup === null &&\n        query.filters.length === 0);\n}\n/**\n * Returns whether the query matches a collection group rather than a specific\n * collection.\n */\nfunction isCollectionGroupQuery(query) {\n    return query.collectionGroup !== null;\n}\n/**\n * Returns the normalized order-by constraint that is used to execute the Query,\n * which can be different from the order-by constraints the user provided (e.g.\n * the SDK and backend always orders by `__name__`). The normalized order-by\n * includes implicit order-bys in addition to the explicit user provided\n * order-bys.\n */\nfunction queryNormalizedOrderBy(query) {\n    const queryImpl = debugCast(query);\n    if (queryImpl.memoizedNormalizedOrderBy === null) {\n        queryImpl.memoizedNormalizedOrderBy = [];\n        const fieldsNormalized = new Set();\n        // Any explicit order by fields should be added as is.\n        for (const orderBy of queryImpl.explicitOrderBy) {\n            queryImpl.memoizedNormalizedOrderBy.push(orderBy);\n            fieldsNormalized.add(orderBy.field.canonicalString());\n        }\n        // The order of the implicit ordering always matches the last explicit order by.\n        const lastDirection = queryImpl.explicitOrderBy.length > 0\n            ? queryImpl.explicitOrderBy[queryImpl.explicitOrderBy.length - 1].dir\n            : \"asc\" /* Direction.ASCENDING */;\n        // Any inequality fields not explicitly ordered should be implicitly ordered in a lexicographical\n        // order. When there are multiple inequality filters on the same field, the field should be added\n        // only once.\n        // Note: `SortedSet<FieldPath>` sorts the key field before other fields. However, we want the key\n        // field to be sorted last.\n        const inequalityFields = getInequalityFilterFields(queryImpl);\n        inequalityFields.forEach(field => {\n            if (!fieldsNormalized.has(field.canonicalString()) &&\n                !field.isKeyField()) {\n                queryImpl.memoizedNormalizedOrderBy.push(new OrderBy(field, lastDirection));\n            }\n        });\n        // Add the document key field to the last if it is not explicitly ordered.\n        if (!fieldsNormalized.has(FieldPath$1.keyField().canonicalString())) {\n            queryImpl.memoizedNormalizedOrderBy.push(new OrderBy(FieldPath$1.keyField(), lastDirection));\n        }\n    }\n    return queryImpl.memoizedNormalizedOrderBy;\n}\n/**\n * Converts this `Query` instance to its corresponding `Target` representation.\n */\nfunction queryToTarget(query) {\n    const queryImpl = debugCast(query);\n    if (!queryImpl.memoizedTarget) {\n        queryImpl.memoizedTarget = _queryToTarget(queryImpl, queryNormalizedOrderBy(query));\n    }\n    return queryImpl.memoizedTarget;\n}\n/**\n * Converts this `Query` instance to its corresponding `Target` representation,\n * for use within an aggregate query. Unlike targets for non-aggregate queries,\n * aggregate query targets do not contain normalized order-bys, they only\n * contain explicit order-bys.\n */\nfunction queryToAggregateTarget(query) {\n    const queryImpl = debugCast(query);\n    if (!queryImpl.memoizedAggregateTarget) {\n        // Do not include implicit order-bys for aggregate queries.\n        queryImpl.memoizedAggregateTarget = _queryToTarget(queryImpl, query.explicitOrderBy);\n    }\n    return queryImpl.memoizedAggregateTarget;\n}\nfunction _queryToTarget(queryImpl, orderBys) {\n    if (queryImpl.limitType === \"F\" /* LimitType.First */) {\n        return newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, queryImpl.startAt, queryImpl.endAt);\n    }\n    else {\n        // Flip the orderBy directions since we want the last results\n        orderBys = orderBys.map(orderBy => {\n            const dir = orderBy.dir === \"desc\" /* Direction.DESCENDING */\n                ? \"asc\" /* Direction.ASCENDING */\n                : \"desc\" /* Direction.DESCENDING */;\n            return new OrderBy(orderBy.field, dir);\n        });\n        // We need to swap the cursors to match the now-flipped query ordering.\n        const startAt = queryImpl.endAt\n            ? new Bound(queryImpl.endAt.position, queryImpl.endAt.inclusive)\n            : null;\n        const endAt = queryImpl.startAt\n            ? new Bound(queryImpl.startAt.position, queryImpl.startAt.inclusive)\n            : null;\n        // Now return as a LimitType.First query.\n        return newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, startAt, endAt);\n    }\n}\nfunction queryWithAddedFilter(query, filter) {\n    const newFilters = query.filters.concat([filter]);\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), newFilters, query.limit, query.limitType, query.startAt, query.endAt);\n}\nfunction queryWithAddedOrderBy(query, orderBy) {\n    // TODO(dimond): validate that orderBy does not list the same key twice.\n    const newOrderBy = query.explicitOrderBy.concat([orderBy]);\n    return new QueryImpl(query.path, query.collectionGroup, newOrderBy, query.filters.slice(), query.limit, query.limitType, query.startAt, query.endAt);\n}\nfunction queryWithLimit(query, limit, limitType) {\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), limit, limitType, query.startAt, query.endAt);\n}\nfunction queryWithStartAt(query, bound) {\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, bound, query.endAt);\n}\nfunction queryWithEndAt(query, bound) {\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, query.startAt, bound);\n}\nfunction queryEquals(left, right) {\n    return (targetEquals(queryToTarget(left), queryToTarget(right)) &&\n        left.limitType === right.limitType);\n}\n// TODO(b/29183165): This is used to get a unique string from a query to, for\n// example, use as a dictionary key, but the implementation is subject to\n// collisions. Make it collision-free.\nfunction canonifyQuery(query) {\n    return `${canonifyTarget(queryToTarget(query))}|lt:${query.limitType}`;\n}\nfunction stringifyQuery(query) {\n    return `Query(target=${stringifyTarget(queryToTarget(query))}; limitType=${query.limitType})`;\n}\n/** Returns whether `doc` matches the constraints of `query`. */\nfunction queryMatches(query, doc) {\n    return (doc.isFoundDocument() &&\n        queryMatchesPathAndCollectionGroup(query, doc) &&\n        queryMatchesOrderBy(query, doc) &&\n        queryMatchesFilters(query, doc) &&\n        queryMatchesBounds(query, doc));\n}\nfunction queryMatchesPathAndCollectionGroup(query, doc) {\n    const docPath = doc.key.path;\n    if (query.collectionGroup !== null) {\n        // NOTE: this.path is currently always empty since we don't expose Collection\n        // Group queries rooted at a document path yet.\n        return (doc.key.hasCollectionId(query.collectionGroup) &&\n            query.path.isPrefixOf(docPath));\n    }\n    else if (DocumentKey.isDocumentKey(query.path)) {\n        // exact match for document queries\n        return query.path.isEqual(docPath);\n    }\n    else {\n        // shallow ancestor queries by default\n        return query.path.isImmediateParentOf(docPath);\n    }\n}\n/**\n * A document must have a value for every ordering clause in order to show up\n * in the results.\n */\nfunction queryMatchesOrderBy(query, doc) {\n    // We must use `queryNormalizedOrderBy()` to get the list of all orderBys (both implicit and explicit).\n    // Note that for OR queries, orderBy applies to all disjunction terms and implicit orderBys must\n    // be taken into account. For example, the query \"a > 1 || b==1\" has an implicit \"orderBy a\" due\n    // to the inequality, and is evaluated as \"a > 1 orderBy a || b==1 orderBy a\".\n    // A document with content of {b:1} matches the filters, but does not match the orderBy because\n    // it's missing the field 'a'.\n    for (const orderBy of queryNormalizedOrderBy(query)) {\n        // order-by key always matches\n        if (!orderBy.field.isKeyField() && doc.data.field(orderBy.field) === null) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction queryMatchesFilters(query, doc) {\n    for (const filter of query.filters) {\n        if (!filter.matches(doc)) {\n            return false;\n        }\n    }\n    return true;\n}\n/** Makes sure a document is within the bounds, if provided. */\nfunction queryMatchesBounds(query, doc) {\n    if (query.startAt &&\n        !boundSortsBeforeDocument(query.startAt, queryNormalizedOrderBy(query), doc)) {\n        return false;\n    }\n    if (query.endAt &&\n        !boundSortsAfterDocument(query.endAt, queryNormalizedOrderBy(query), doc)) {\n        return false;\n    }\n    return true;\n}\n/**\n * Returns the collection group that this query targets.\n *\n * PORTING NOTE: This is only used in the Web SDK to facilitate multi-tab\n * synchronization for query results.\n */\nfunction queryCollectionGroup(query) {\n    return (query.collectionGroup ||\n        (query.path.length % 2 === 1\n            ? query.path.lastSegment()\n            : query.path.get(query.path.length - 2)));\n}\n/**\n * Returns a new comparator function that can be used to compare two documents\n * based on the Query's ordering constraint.\n */\nfunction newQueryComparator(query) {\n    return (d1, d2) => {\n        let comparedOnKeyField = false;\n        for (const orderBy of queryNormalizedOrderBy(query)) {\n            const comp = compareDocs(orderBy, d1, d2);\n            if (comp !== 0) {\n                return comp;\n            }\n            comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();\n        }\n        return 0;\n    };\n}\nfunction compareDocs(orderBy, d1, d2) {\n    const comparison = orderBy.field.isKeyField()\n        ? DocumentKey.comparator(d1.key, d2.key)\n        : compareDocumentsByField(orderBy.field, d1, d2);\n    switch (orderBy.dir) {\n        case \"asc\" /* Direction.ASCENDING */:\n            return comparison;\n        case \"desc\" /* Direction.DESCENDING */:\n            return -1 * comparison;\n        default:\n            return fail(0x4d4e, { direction: orderBy.dir });\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A map implementation that uses objects as keys. Objects must have an\n * associated equals function and must be immutable. Entries in the map are\n * stored together with the key being produced from the mapKeyFn. This map\n * automatically handles collisions of keys.\n */\nclass ObjectMap {\n    constructor(mapKeyFn, equalsFn) {\n        this.mapKeyFn = mapKeyFn;\n        this.equalsFn = equalsFn;\n        /**\n         * The inner map for a key/value pair. Due to the possibility of collisions we\n         * keep a list of entries that we do a linear search through to find an actual\n         * match. Note that collisions should be rare, so we still expect near\n         * constant time lookups in practice.\n         */\n        this.inner = {};\n        /** The number of entries stored in the map */\n        this.innerSize = 0;\n    }\n    /** Get a value for this key, or undefined if it does not exist. */\n    get(key) {\n        const id = this.mapKeyFn(key);\n        const matches = this.inner[id];\n        if (matches === undefined) {\n            return undefined;\n        }\n        for (const [otherKey, value] of matches) {\n            if (this.equalsFn(otherKey, key)) {\n                return value;\n            }\n        }\n        return undefined;\n    }\n    has(key) {\n        return this.get(key) !== undefined;\n    }\n    /** Put this key and value in the map. */\n    set(key, value) {\n        const id = this.mapKeyFn(key);\n        const matches = this.inner[id];\n        if (matches === undefined) {\n            this.inner[id] = [[key, value]];\n            this.innerSize++;\n            return;\n        }\n        for (let i = 0; i < matches.length; i++) {\n            if (this.equalsFn(matches[i][0], key)) {\n                // This is updating an existing entry and does not increase `innerSize`.\n                matches[i] = [key, value];\n                return;\n            }\n        }\n        matches.push([key, value]);\n        this.innerSize++;\n    }\n    /**\n     * Remove this key from the map. Returns a boolean if anything was deleted.\n     */\n    delete(key) {\n        const id = this.mapKeyFn(key);\n        const matches = this.inner[id];\n        if (matches === undefined) {\n            return false;\n        }\n        for (let i = 0; i < matches.length; i++) {\n            if (this.equalsFn(matches[i][0], key)) {\n                if (matches.length === 1) {\n                    delete this.inner[id];\n                }\n                else {\n                    matches.splice(i, 1);\n                }\n                this.innerSize--;\n                return true;\n            }\n        }\n        return false;\n    }\n    forEach(fn) {\n        forEach(this.inner, (_, entries) => {\n            for (const [k, v] of entries) {\n                fn(k, v);\n            }\n        });\n    }\n    isEmpty() {\n        return isEmpty(this.inner);\n    }\n    size() {\n        return this.innerSize;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EMPTY_MUTABLE_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\nfunction mutableDocumentMap() {\n    return EMPTY_MUTABLE_DOCUMENT_MAP;\n}\nconst EMPTY_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\nfunction documentMap(...docs) {\n    let map = EMPTY_DOCUMENT_MAP;\n    for (const doc of docs) {\n        map = map.insert(doc.key, doc);\n    }\n    return map;\n}\nfunction newOverlayedDocumentMap() {\n    return newDocumentKeyMap();\n}\nfunction convertOverlayedDocumentMapToDocumentMap(collection) {\n    let documents = EMPTY_DOCUMENT_MAP;\n    collection.forEach((k, v) => (documents = documents.insert(k, v.overlayedDocument)));\n    return documents;\n}\nfunction newOverlayMap() {\n    return newDocumentKeyMap();\n}\nfunction newMutationMap() {\n    return newDocumentKeyMap();\n}\nfunction newDocumentKeyMap() {\n    return new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\n}\nconst EMPTY_DOCUMENT_VERSION_MAP = new SortedMap(DocumentKey.comparator);\nfunction documentVersionMap() {\n    return EMPTY_DOCUMENT_VERSION_MAP;\n}\nconst EMPTY_DOCUMENT_KEY_SET = new SortedSet(DocumentKey.comparator);\nfunction documentKeySet(...keys) {\n    let set = EMPTY_DOCUMENT_KEY_SET;\n    for (const key of keys) {\n        set = set.add(key);\n    }\n    return set;\n}\nconst EMPTY_TARGET_ID_SET = new SortedSet(primitiveComparator);\nfunction targetIdSet() {\n    return EMPTY_TARGET_ID_SET;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns an DoubleValue for `value` that is encoded based the serializer's\n * `useProto3Json` setting.\n */\nfunction toDouble(serializer, value) {\n    if (serializer.useProto3Json) {\n        if (isNaN(value)) {\n            return { doubleValue: 'NaN' };\n        }\n        else if (value === Infinity) {\n            return { doubleValue: 'Infinity' };\n        }\n        else if (value === -Infinity) {\n            return { doubleValue: '-Infinity' };\n        }\n    }\n    return { doubleValue: isNegativeZero(value) ? '-0' : value };\n}\n/**\n * Returns an IntegerValue for `value`.\n */\nfunction toInteger(value) {\n    return { integerValue: '' + value };\n}\n/**\n * Returns a value for a number that's appropriate to put into a proto.\n * The return value is an IntegerValue if it can safely represent the value,\n * otherwise a DoubleValue is returned.\n */\nfunction toNumber(serializer, value) {\n    return isSafeInteger(value) ? toInteger(value) : toDouble(serializer, value);\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Used to represent a field transform on a mutation. */\nclass TransformOperation {\n    constructor() {\n        // Make sure that the structural type of `TransformOperation` is unique.\n        // See https://github.com/microsoft/TypeScript/issues/5451\n        this._ = undefined;\n    }\n}\n/**\n * Computes the local transform result against the provided `previousValue`,\n * optionally using the provided localWriteTime.\n */\nfunction applyTransformOperationToLocalView(transform, previousValue, localWriteTime) {\n    if (transform instanceof ServerTimestampTransform) {\n        return serverTimestamp$1(localWriteTime, previousValue);\n    }\n    else if (transform instanceof ArrayUnionTransformOperation) {\n        return applyArrayUnionTransformOperation(transform, previousValue);\n    }\n    else if (transform instanceof ArrayRemoveTransformOperation) {\n        return applyArrayRemoveTransformOperation(transform, previousValue);\n    }\n    else {\n        return applyNumericIncrementTransformOperationToLocalView(transform, previousValue);\n    }\n}\n/**\n * Computes a final transform result after the transform has been acknowledged\n * by the server, potentially using the server-provided transformResult.\n */\nfunction applyTransformOperationToRemoteDocument(transform, previousValue, transformResult) {\n    // The server just sends null as the transform result for array operations,\n    // so we have to calculate a result the same as we do for local\n    // applications.\n    if (transform instanceof ArrayUnionTransformOperation) {\n        return applyArrayUnionTransformOperation(transform, previousValue);\n    }\n    else if (transform instanceof ArrayRemoveTransformOperation) {\n        return applyArrayRemoveTransformOperation(transform, previousValue);\n    }\n    return transformResult;\n}\n/**\n * If this transform operation is not idempotent, returns the base value to\n * persist for this transform. If a base value is returned, the transform\n * operation is always applied to this base value, even if document has\n * already been updated.\n *\n * Base values provide consistent behavior for non-idempotent transforms and\n * allow us to return the same latency-compensated value even if the backend\n * has already applied the transform operation. The base value is null for\n * idempotent transforms, as they can be re-played even if the backend has\n * already applied them.\n *\n * @returns a base value to store along with the mutation, or null for\n * idempotent transforms.\n */\nfunction computeTransformOperationBaseValue(transform, previousValue) {\n    if (transform instanceof NumericIncrementTransformOperation) {\n        return isNumber(previousValue) ? previousValue : { integerValue: 0 };\n    }\n    return null;\n}\nfunction transformOperationEquals(left, right) {\n    if (left instanceof ArrayUnionTransformOperation &&\n        right instanceof ArrayUnionTransformOperation) {\n        return arrayEquals(left.elements, right.elements, valueEquals);\n    }\n    else if (left instanceof ArrayRemoveTransformOperation &&\n        right instanceof ArrayRemoveTransformOperation) {\n        return arrayEquals(left.elements, right.elements, valueEquals);\n    }\n    else if (left instanceof NumericIncrementTransformOperation &&\n        right instanceof NumericIncrementTransformOperation) {\n        return valueEquals(left.operand, right.operand);\n    }\n    return (left instanceof ServerTimestampTransform &&\n        right instanceof ServerTimestampTransform);\n}\n/** Transforms a value into a server-generated timestamp. */\nclass ServerTimestampTransform extends TransformOperation {\n}\n/** Transforms an array value via a union operation. */\nclass ArrayUnionTransformOperation extends TransformOperation {\n    constructor(elements) {\n        super();\n        this.elements = elements;\n    }\n}\nfunction applyArrayUnionTransformOperation(transform, previousValue) {\n    const values = coercedFieldValuesArray(previousValue);\n    for (const toUnion of transform.elements) {\n        if (!values.some(element => valueEquals(element, toUnion))) {\n            values.push(toUnion);\n        }\n    }\n    return { arrayValue: { values } };\n}\n/** Transforms an array value via a remove operation. */\nclass ArrayRemoveTransformOperation extends TransformOperation {\n    constructor(elements) {\n        super();\n        this.elements = elements;\n    }\n}\nfunction applyArrayRemoveTransformOperation(transform, previousValue) {\n    let values = coercedFieldValuesArray(previousValue);\n    for (const toRemove of transform.elements) {\n        values = values.filter(element => !valueEquals(element, toRemove));\n    }\n    return { arrayValue: { values } };\n}\n/**\n * Implements the backend semantics for locally computed NUMERIC_ADD (increment)\n * transforms. Converts all field values to integers or doubles, but unlike the\n * backend does not cap integer values at 2^63. Instead, JavaScript number\n * arithmetic is used and precision loss can occur for values greater than 2^53.\n */\nclass NumericIncrementTransformOperation extends TransformOperation {\n    constructor(serializer, operand) {\n        super();\n        this.serializer = serializer;\n        this.operand = operand;\n    }\n}\nfunction applyNumericIncrementTransformOperationToLocalView(transform, previousValue) {\n    // PORTING NOTE: Since JavaScript's integer arithmetic is limited to 53 bit\n    // precision and resolves overflows by reducing precision, we do not\n    // manually cap overflows at 2^63.\n    const baseValue = computeTransformOperationBaseValue(transform, previousValue);\n    const sum = asNumber(baseValue) + asNumber(transform.operand);\n    if (isInteger(baseValue) && isInteger(transform.operand)) {\n        return toInteger(sum);\n    }\n    else {\n        return toDouble(transform.serializer, sum);\n    }\n}\nfunction asNumber(value) {\n    return normalizeNumber(value.integerValue || value.doubleValue);\n}\nfunction coercedFieldValuesArray(value) {\n    return isArray(value) && value.arrayValue.values\n        ? value.arrayValue.values.slice()\n        : [];\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** A field path and the TransformOperation to perform upon it. */\nclass FieldTransform {\n    constructor(field, transform) {\n        this.field = field;\n        this.transform = transform;\n    }\n}\nfunction fieldTransformEquals(left, right) {\n    return (left.field.isEqual(right.field) &&\n        transformOperationEquals(left.transform, right.transform));\n}\nfunction fieldTransformsAreEqual(left, right) {\n    if (left === undefined && right === undefined) {\n        return true;\n    }\n    if (left && right) {\n        return arrayEquals(left, right, (l, r) => fieldTransformEquals(l, r));\n    }\n    return false;\n}\n/** The result of successfully applying a mutation to the backend. */\nclass MutationResult {\n    constructor(\n    /**\n     * The version at which the mutation was committed:\n     *\n     * - For most operations, this is the updateTime in the WriteResult.\n     * - For deletes, the commitTime of the WriteResponse (because deletes are\n     *   not stored and have no updateTime).\n     *\n     * Note that these versions can be different: No-op writes will not change\n     * the updateTime even though the commitTime advances.\n     */\n    version, \n    /**\n     * The resulting fields returned from the backend after a mutation\n     * containing field transforms has been committed. Contains one FieldValue\n     * for each FieldTransform that was in the mutation.\n     *\n     * Will be empty if the mutation did not contain any field transforms.\n     */\n    transformResults) {\n        this.version = version;\n        this.transformResults = transformResults;\n    }\n}\n/**\n * Encodes a precondition for a mutation. This follows the model that the\n * backend accepts with the special case of an explicit \"empty\" precondition\n * (meaning no precondition).\n */\nclass Precondition {\n    constructor(updateTime, exists) {\n        this.updateTime = updateTime;\n        this.exists = exists;\n    }\n    /** Creates a new empty Precondition. */\n    static none() {\n        return new Precondition();\n    }\n    /** Creates a new Precondition with an exists flag. */\n    static exists(exists) {\n        return new Precondition(undefined, exists);\n    }\n    /** Creates a new Precondition based on a version a document exists at. */\n    static updateTime(version) {\n        return new Precondition(version);\n    }\n    /** Returns whether this Precondition is empty. */\n    get isNone() {\n        return this.updateTime === undefined && this.exists === undefined;\n    }\n    isEqual(other) {\n        return (this.exists === other.exists &&\n            (this.updateTime\n                ? !!other.updateTime && this.updateTime.isEqual(other.updateTime)\n                : !other.updateTime));\n    }\n}\n/** Returns true if the preconditions is valid for the given document. */\nfunction preconditionIsValidForDocument(precondition, document) {\n    if (precondition.updateTime !== undefined) {\n        return (document.isFoundDocument() &&\n            document.version.isEqual(precondition.updateTime));\n    }\n    else if (precondition.exists !== undefined) {\n        return precondition.exists === document.isFoundDocument();\n    }\n    else {\n        return true;\n    }\n}\n/**\n * A mutation describes a self-contained change to a document. Mutations can\n * create, replace, delete, and update subsets of documents.\n *\n * Mutations not only act on the value of the document but also its version.\n *\n * For local mutations (mutations that haven't been committed yet), we preserve\n * the existing version for Set and Patch mutations. For Delete mutations, we\n * reset the version to 0.\n *\n * Here's the expected transition table.\n *\n * MUTATION           APPLIED TO            RESULTS IN\n *\n * SetMutation        Document(v3)          Document(v3)\n * SetMutation        NoDocument(v3)        Document(v0)\n * SetMutation        InvalidDocument(v0)   Document(v0)\n * PatchMutation      Document(v3)          Document(v3)\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\n * PatchMutation      InvalidDocument(v0)   UnknownDocument(v3)\n * DeleteMutation     Document(v3)          NoDocument(v0)\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\n * DeleteMutation     InvalidDocument(v0)   NoDocument(v0)\n *\n * For acknowledged mutations, we use the updateTime of the WriteResponse as\n * the resulting version for Set and Patch mutations. As deletes have no\n * explicit update time, we use the commitTime of the WriteResponse for\n * Delete mutations.\n *\n * If a mutation is acknowledged by the backend but fails the precondition check\n * locally, we transition to an `UnknownDocument` and rely on Watch to send us\n * the updated version.\n *\n * Field transforms are used only with Patch and Set Mutations. We use the\n * `updateTransforms` message to store transforms, rather than the `transforms`s\n * messages.\n *\n * ## Subclassing Notes\n *\n * Every type of mutation needs to implement its own applyToRemoteDocument() and\n * applyToLocalView() to implement the actual behavior of applying the mutation\n * to some source document (see `setMutationApplyToRemoteDocument()` for an\n * example).\n */\nclass Mutation {\n}\n/**\n * A utility method to calculate a `Mutation` representing the overlay from the\n * final state of the document, and a `FieldMask` representing the fields that\n * are mutated by the local mutations.\n */\nfunction calculateOverlayMutation(doc, mask) {\n    if (!doc.hasLocalMutations || (mask && mask.fields.length === 0)) {\n        return null;\n    }\n    // mask is null when sets or deletes are applied to the current document.\n    if (mask === null) {\n        if (doc.isNoDocument()) {\n            return new DeleteMutation(doc.key, Precondition.none());\n        }\n        else {\n            return new SetMutation(doc.key, doc.data, Precondition.none());\n        }\n    }\n    else {\n        const docValue = doc.data;\n        const patchValue = ObjectValue.empty();\n        let maskSet = new SortedSet(FieldPath$1.comparator);\n        for (let path of mask.fields) {\n            if (!maskSet.has(path)) {\n                let value = docValue.field(path);\n                // If we are deleting a nested field, we take the immediate parent as\n                // the mask used to construct the resulting mutation.\n                // Justification: Nested fields can create parent fields implicitly. If\n                // only a leaf entry is deleted in later mutations, the parent field\n                // should still remain, but we may have lost this information.\n                // Consider mutation (foo.bar 1), then mutation (foo.bar delete()).\n                // This leaves the final result (foo, {}). Despite the fact that `doc`\n                // has the correct result, `foo` is not in `mask`, and the resulting\n                // mutation would miss `foo`.\n                if (value === null && path.length > 1) {\n                    path = path.popLast();\n                    value = docValue.field(path);\n                }\n                if (value === null) {\n                    patchValue.delete(path);\n                }\n                else {\n                    patchValue.set(path, value);\n                }\n                maskSet = maskSet.add(path);\n            }\n        }\n        return new PatchMutation(doc.key, patchValue, new FieldMask(maskSet.toArray()), Precondition.none());\n    }\n}\n/**\n * Applies this mutation to the given document for the purposes of computing a\n * new remote document. If the input document doesn't match the expected state\n * (e.g. it is invalid or outdated), the document type may transition to\n * unknown.\n *\n * @param mutation - The mutation to apply.\n * @param document - The document to mutate. The input document can be an\n *     invalid document if the client has no knowledge of the pre-mutation state\n *     of the document.\n * @param mutationResult - The result of applying the mutation from the backend.\n */\nfunction mutationApplyToRemoteDocument(mutation, document, mutationResult) {\n    if (mutation instanceof SetMutation) {\n        setMutationApplyToRemoteDocument(mutation, document, mutationResult);\n    }\n    else if (mutation instanceof PatchMutation) {\n        patchMutationApplyToRemoteDocument(mutation, document, mutationResult);\n    }\n    else {\n        deleteMutationApplyToRemoteDocument(mutation, document, mutationResult);\n    }\n}\n/**\n * Applies this mutation to the given document for the purposes of computing\n * the new local view of a document. If the input document doesn't match the\n * expected state, the document is not modified.\n *\n * @param mutation - The mutation to apply.\n * @param document - The document to mutate. The input document can be an\n *     invalid document if the client has no knowledge of the pre-mutation state\n *     of the document.\n * @param previousMask - The fields that have been updated before applying this mutation.\n * @param localWriteTime - A timestamp indicating the local write time of the\n *     batch this mutation is a part of.\n * @returns A `FieldMask` representing the fields that are changed by applying this mutation.\n */\nfunction mutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\n    if (mutation instanceof SetMutation) {\n        return setMutationApplyToLocalView(mutation, document, previousMask, localWriteTime);\n    }\n    else if (mutation instanceof PatchMutation) {\n        return patchMutationApplyToLocalView(mutation, document, previousMask, localWriteTime);\n    }\n    else {\n        return deleteMutationApplyToLocalView(mutation, document, previousMask);\n    }\n}\n/**\n * If this mutation is not idempotent, returns the base value to persist with\n * this mutation. If a base value is returned, the mutation is always applied\n * to this base value, even if document has already been updated.\n *\n * The base value is a sparse object that consists of only the document\n * fields for which this mutation contains a non-idempotent transformation\n * (e.g. a numeric increment). The provided value guarantees consistent\n * behavior for non-idempotent transforms and allow us to return the same\n * latency-compensated value even if the backend has already applied the\n * mutation. The base value is null for idempotent mutations, as they can be\n * re-played even if the backend has already applied them.\n *\n * @returns a base value to store along with the mutation, or null for\n * idempotent mutations.\n */\nfunction mutationExtractBaseValue(mutation, document) {\n    let baseObject = null;\n    for (const fieldTransform of mutation.fieldTransforms) {\n        const existingValue = document.data.field(fieldTransform.field);\n        const coercedValue = computeTransformOperationBaseValue(fieldTransform.transform, existingValue || null);\n        if (coercedValue != null) {\n            if (baseObject === null) {\n                baseObject = ObjectValue.empty();\n            }\n            baseObject.set(fieldTransform.field, coercedValue);\n        }\n    }\n    return baseObject ? baseObject : null;\n}\nfunction mutationEquals(left, right) {\n    if (left.type !== right.type) {\n        return false;\n    }\n    if (!left.key.isEqual(right.key)) {\n        return false;\n    }\n    if (!left.precondition.isEqual(right.precondition)) {\n        return false;\n    }\n    if (!fieldTransformsAreEqual(left.fieldTransforms, right.fieldTransforms)) {\n        return false;\n    }\n    if (left.type === 0 /* MutationType.Set */) {\n        return left.value.isEqual(right.value);\n    }\n    if (left.type === 1 /* MutationType.Patch */) {\n        return (left.data.isEqual(right.data) &&\n            left.fieldMask.isEqual(right.fieldMask));\n    }\n    return true;\n}\n/**\n * A mutation that creates or replaces the document at the given key with the\n * object value contents.\n */\nclass SetMutation extends Mutation {\n    constructor(key, value, precondition, fieldTransforms = []) {\n        super();\n        this.key = key;\n        this.value = value;\n        this.precondition = precondition;\n        this.fieldTransforms = fieldTransforms;\n        this.type = 0 /* MutationType.Set */;\n    }\n    getFieldMask() {\n        return null;\n    }\n}\nfunction setMutationApplyToRemoteDocument(mutation, document, mutationResult) {\n    // Unlike setMutationApplyToLocalView, if we're applying a mutation to a\n    // remote document the server has accepted the mutation so the precondition\n    // must have held.\n    const newData = mutation.value.clone();\n    const transformResults = serverTransformResults(mutation.fieldTransforms, document, mutationResult.transformResults);\n    newData.setAll(transformResults);\n    document\n        .convertToFoundDocument(mutationResult.version, newData)\n        .setHasCommittedMutations();\n}\nfunction setMutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\n        // The mutation failed to apply (e.g. a document ID created with add()\n        // caused a name collision).\n        return previousMask;\n    }\n    const newData = mutation.value.clone();\n    const transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document);\n    newData.setAll(transformResults);\n    document\n        .convertToFoundDocument(document.version, newData)\n        .setHasLocalMutations();\n    return null; // SetMutation overwrites all fields.\n}\n/**\n * A mutation that modifies fields of the document at the given key with the\n * given values. The values are applied through a field mask:\n *\n *  * When a field is in both the mask and the values, the corresponding field\n *    is updated.\n *  * When a field is in neither the mask nor the values, the corresponding\n *    field is unmodified.\n *  * When a field is in the mask but not in the values, the corresponding field\n *    is deleted.\n *  * When a field is not in the mask but is in the values, the values map is\n *    ignored.\n */\nclass PatchMutation extends Mutation {\n    constructor(key, data, fieldMask, precondition, fieldTransforms = []) {\n        super();\n        this.key = key;\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.precondition = precondition;\n        this.fieldTransforms = fieldTransforms;\n        this.type = 1 /* MutationType.Patch */;\n    }\n    getFieldMask() {\n        return this.fieldMask;\n    }\n}\nfunction patchMutationApplyToRemoteDocument(mutation, document, mutationResult) {\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\n        // Since the mutation was not rejected, we know that the precondition\n        // matched on the backend. We therefore must not have the expected version\n        // of the document in our cache and convert to an UnknownDocument with a\n        // known updateTime.\n        document.convertToUnknownDocument(mutationResult.version);\n        return;\n    }\n    const transformResults = serverTransformResults(mutation.fieldTransforms, document, mutationResult.transformResults);\n    const newData = document.data;\n    newData.setAll(getPatch(mutation));\n    newData.setAll(transformResults);\n    document\n        .convertToFoundDocument(mutationResult.version, newData)\n        .setHasCommittedMutations();\n}\nfunction patchMutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\n        return previousMask;\n    }\n    const transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document);\n    const newData = document.data;\n    newData.setAll(getPatch(mutation));\n    newData.setAll(transformResults);\n    document\n        .convertToFoundDocument(document.version, newData)\n        .setHasLocalMutations();\n    if (previousMask === null) {\n        return null;\n    }\n    return previousMask\n        .unionWith(mutation.fieldMask.fields)\n        .unionWith(mutation.fieldTransforms.map(transform => transform.field));\n}\n/**\n * Returns a FieldPath/Value map with the content of the PatchMutation.\n */\nfunction getPatch(mutation) {\n    const result = new Map();\n    mutation.fieldMask.fields.forEach(fieldPath => {\n        if (!fieldPath.isEmpty()) {\n            const newValue = mutation.data.field(fieldPath);\n            result.set(fieldPath, newValue);\n        }\n    });\n    return result;\n}\n/**\n * Creates a list of \"transform results\" (a transform result is a field value\n * representing the result of applying a transform) for use after a mutation\n * containing transforms has been acknowledged by the server.\n *\n * @param fieldTransforms - The field transforms to apply the result to.\n * @param mutableDocument - The current state of the document after applying all\n * previous mutations.\n * @param serverTransformResults - The transform results received by the server.\n * @returns The transform results list.\n */\nfunction serverTransformResults(fieldTransforms, mutableDocument, serverTransformResults) {\n    const transformResults = new Map();\n    hardAssert(fieldTransforms.length === serverTransformResults.length, 0x7f90, {\n        serverTransformResultCount: serverTransformResults.length,\n        fieldTransformCount: fieldTransforms.length\n    });\n    for (let i = 0; i < serverTransformResults.length; i++) {\n        const fieldTransform = fieldTransforms[i];\n        const transform = fieldTransform.transform;\n        const previousValue = mutableDocument.data.field(fieldTransform.field);\n        transformResults.set(fieldTransform.field, applyTransformOperationToRemoteDocument(transform, previousValue, serverTransformResults[i]));\n    }\n    return transformResults;\n}\n/**\n * Creates a list of \"transform results\" (a transform result is a field value\n * representing the result of applying a transform) for use when applying a\n * transform locally.\n *\n * @param fieldTransforms - The field transforms to apply the result to.\n * @param localWriteTime - The local time of the mutation (used to\n *     generate ServerTimestampValues).\n * @param mutableDocument - The document to apply transforms on.\n * @returns The transform results list.\n */\nfunction localTransformResults(fieldTransforms, localWriteTime, mutableDocument) {\n    const transformResults = new Map();\n    for (const fieldTransform of fieldTransforms) {\n        const transform = fieldTransform.transform;\n        const previousValue = mutableDocument.data.field(fieldTransform.field);\n        transformResults.set(fieldTransform.field, applyTransformOperationToLocalView(transform, previousValue, localWriteTime));\n    }\n    return transformResults;\n}\n/** A mutation that deletes the document at the given key. */\nclass DeleteMutation extends Mutation {\n    constructor(key, precondition) {\n        super();\n        this.key = key;\n        this.precondition = precondition;\n        this.type = 2 /* MutationType.Delete */;\n        this.fieldTransforms = [];\n    }\n    getFieldMask() {\n        return null;\n    }\n}\nfunction deleteMutationApplyToRemoteDocument(mutation, document, mutationResult) {\n    // Unlike applyToLocalView, if we're applying a mutation to a remote\n    // document the server has accepted the mutation so the precondition must\n    // have held.\n    document\n        .convertToNoDocument(mutationResult.version)\n        .setHasCommittedMutations();\n}\nfunction deleteMutationApplyToLocalView(mutation, document, previousMask) {\n    if (preconditionIsValidForDocument(mutation.precondition, document)) {\n        document.convertToNoDocument(document.version).setHasLocalMutations();\n        return null;\n    }\n    return previousMask;\n}\n/**\n * A mutation that verifies the existence of the document at the given key with\n * the provided precondition.\n *\n * The `verify` operation is only used in Transactions, and this class serves\n * primarily to facilitate serialization into protos.\n */\nclass VerifyMutation extends Mutation {\n    constructor(key, precondition) {\n        super();\n        this.key = key;\n        this.precondition = precondition;\n        this.type = 3 /* MutationType.Verify */;\n        this.fieldTransforms = [];\n    }\n    getFieldMask() {\n        return null;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A batch of mutations that will be sent as one unit to the backend.\n */\nclass MutationBatch {\n    /**\n     * @param batchId - The unique ID of this mutation batch.\n     * @param localWriteTime - The original write time of this mutation.\n     * @param baseMutations - Mutations that are used to populate the base\n     * values when this mutation is applied locally. This can be used to locally\n     * overwrite values that are persisted in the remote document cache. Base\n     * mutations are never sent to the backend.\n     * @param mutations - The user-provided mutations in this mutation batch.\n     * User-provided mutations are applied both locally and remotely on the\n     * backend.\n     */\n    constructor(batchId, localWriteTime, baseMutations, mutations) {\n        this.batchId = batchId;\n        this.localWriteTime = localWriteTime;\n        this.baseMutations = baseMutations;\n        this.mutations = mutations;\n    }\n    /**\n     * Applies all the mutations in this MutationBatch to the specified document\n     * to compute the state of the remote document\n     *\n     * @param document - The document to apply mutations to.\n     * @param batchResult - The result of applying the MutationBatch to the\n     * backend.\n     */\n    applyToRemoteDocument(document, batchResult) {\n        const mutationResults = batchResult.mutationResults;\n        for (let i = 0; i < this.mutations.length; i++) {\n            const mutation = this.mutations[i];\n            if (mutation.key.isEqual(document.key)) {\n                const mutationResult = mutationResults[i];\n                mutationApplyToRemoteDocument(mutation, document, mutationResult);\n            }\n        }\n    }\n    /**\n     * Computes the local view of a document given all the mutations in this\n     * batch.\n     *\n     * @param document - The document to apply mutations to.\n     * @param mutatedFields - Fields that have been updated before applying this mutation batch.\n     * @returns A `FieldMask` representing all the fields that are mutated.\n     */\n    applyToLocalView(document, mutatedFields) {\n        // First, apply the base state. This allows us to apply non-idempotent\n        // transform against a consistent set of values.\n        for (const mutation of this.baseMutations) {\n            if (mutation.key.isEqual(document.key)) {\n                mutatedFields = mutationApplyToLocalView(mutation, document, mutatedFields, this.localWriteTime);\n            }\n        }\n        // Second, apply all user-provided mutations.\n        for (const mutation of this.mutations) {\n            if (mutation.key.isEqual(document.key)) {\n                mutatedFields = mutationApplyToLocalView(mutation, document, mutatedFields, this.localWriteTime);\n            }\n        }\n        return mutatedFields;\n    }\n    /**\n     * Computes the local view for all provided documents given the mutations in\n     * this batch. Returns a `DocumentKey` to `Mutation` map which can be used to\n     * replace all the mutation applications.\n     */\n    applyToLocalDocumentSet(documentMap, documentsWithoutRemoteVersion) {\n        // TODO(mrschmidt): This implementation is O(n^2). If we apply the mutations\n        // directly (as done in `applyToLocalView()`), we can reduce the complexity\n        // to O(n).\n        const overlays = newMutationMap();\n        this.mutations.forEach(m => {\n            const overlayedDocument = documentMap.get(m.key);\n            // TODO(mutabledocuments): This method should take a MutableDocumentMap\n            // and we should remove this cast.\n            const mutableDocument = overlayedDocument.overlayedDocument;\n            let mutatedFields = this.applyToLocalView(mutableDocument, overlayedDocument.mutatedFields);\n            // Set mutatedFields to null if the document is only from local mutations.\n            // This creates a Set or Delete mutation, instead of trying to create a\n            // patch mutation as the overlay.\n            mutatedFields = documentsWithoutRemoteVersion.has(m.key)\n                ? null\n                : mutatedFields;\n            const overlay = calculateOverlayMutation(mutableDocument, mutatedFields);\n            if (overlay !== null) {\n                overlays.set(m.key, overlay);\n            }\n            if (!mutableDocument.isValidDocument()) {\n                mutableDocument.convertToNoDocument(SnapshotVersion.min());\n            }\n        });\n        return overlays;\n    }\n    keys() {\n        return this.mutations.reduce((keys, m) => keys.add(m.key), documentKeySet());\n    }\n    isEqual(other) {\n        return (this.batchId === other.batchId &&\n            arrayEquals(this.mutations, other.mutations, (l, r) => mutationEquals(l, r)) &&\n            arrayEquals(this.baseMutations, other.baseMutations, (l, r) => mutationEquals(l, r)));\n    }\n}\n/** The result of applying a mutation batch to the backend. */\nclass MutationBatchResult {\n    constructor(batch, commitVersion, mutationResults, \n    /**\n     * A pre-computed mapping from each mutated document to the resulting\n     * version.\n     */\n    docVersions) {\n        this.batch = batch;\n        this.commitVersion = commitVersion;\n        this.mutationResults = mutationResults;\n        this.docVersions = docVersions;\n    }\n    /**\n     * Creates a new MutationBatchResult for the given batch and results. There\n     * must be one result for each mutation in the batch. This static factory\n     * caches a document=&gt;version mapping (docVersions).\n     */\n    static from(batch, commitVersion, results) {\n        hardAssert(batch.mutations.length === results.length, 0xe5da, {\n            mutationsSent: batch.mutations.length,\n            resultsReceived: results.length\n        });\n        let versionMap = documentVersionMap();\n        const mutations = batch.mutations;\n        for (let i = 0; i < mutations.length; i++) {\n            versionMap = versionMap.insert(mutations[i].key, results[i].version);\n        }\n        return new MutationBatchResult(batch, commitVersion, results, versionMap);\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Representation of an overlay computed by Firestore.\n *\n * Holds information about a mutation and the largest batch id in Firestore when\n * the mutation was created.\n */\nclass Overlay {\n    constructor(largestBatchId, mutation) {\n        this.largestBatchId = largestBatchId;\n        this.mutation = mutation;\n    }\n    getKey() {\n        return this.mutation.key;\n    }\n    isEqual(other) {\n        return other !== null && this.mutation === other.mutation;\n    }\n    toString() {\n        return `Overlay{\n      largestBatchId: ${this.largestBatchId},\n      mutation: ${this.mutation.toString()}\n    }`;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass ExistenceFilter {\n    constructor(count, unchangedNames) {\n        this.count = count;\n        this.unchangedNames = unchangedNames;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Error Codes describing the different ways GRPC can fail. These are copied\n * directly from GRPC's sources here:\n *\n * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n *\n * Important! The names of these identifiers matter because the string forms\n * are used for reverse lookups from the webchannel stream. Do NOT change the\n * names of these identifiers or change this into a const enum.\n */\nvar RpcCode;\n(function (RpcCode) {\n    RpcCode[RpcCode[\"OK\"] = 0] = \"OK\";\n    RpcCode[RpcCode[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    RpcCode[RpcCode[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    RpcCode[RpcCode[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    RpcCode[RpcCode[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    RpcCode[RpcCode[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    RpcCode[RpcCode[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    RpcCode[RpcCode[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    RpcCode[RpcCode[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n    RpcCode[RpcCode[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    RpcCode[RpcCode[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    RpcCode[RpcCode[\"ABORTED\"] = 10] = \"ABORTED\";\n    RpcCode[RpcCode[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    RpcCode[RpcCode[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    RpcCode[RpcCode[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    RpcCode[RpcCode[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    RpcCode[RpcCode[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n})(RpcCode || (RpcCode = {}));\n/**\n * Determines whether an error code represents a permanent error when received\n * in response to a non-write operation.\n *\n * See isPermanentWriteError for classifying write errors.\n */\nfunction isPermanentError(code) {\n    switch (code) {\n        case Code.OK:\n            return fail(0xfdaa);\n        case Code.CANCELLED:\n        case Code.UNKNOWN:\n        case Code.DEADLINE_EXCEEDED:\n        case Code.RESOURCE_EXHAUSTED:\n        case Code.INTERNAL:\n        case Code.UNAVAILABLE:\n        // Unauthenticated means something went wrong with our token and we need\n        // to retry with new credentials which will happen automatically.\n        case Code.UNAUTHENTICATED:\n            return false;\n        case Code.INVALID_ARGUMENT:\n        case Code.NOT_FOUND:\n        case Code.ALREADY_EXISTS:\n        case Code.PERMISSION_DENIED:\n        case Code.FAILED_PRECONDITION:\n        // Aborted might be retried in some scenarios, but that is dependent on\n        // the context and should handled individually by the calling code.\n        // See https://cloud.google.com/apis/design/errors.\n        case Code.ABORTED:\n        case Code.OUT_OF_RANGE:\n        case Code.UNIMPLEMENTED:\n        case Code.DATA_LOSS:\n            return true;\n        default:\n            return fail(0x3c6b, { code });\n    }\n}\n/**\n * Determines whether an error code represents a permanent error when received\n * in response to a write operation.\n *\n * Write operations must be handled specially because as of b/119437764, ABORTED\n * errors on the write stream should be retried too (even though ABORTED errors\n * are not generally retryable).\n *\n * Note that during the initial handshake on the write stream an ABORTED error\n * signals that we should discard our stream token (i.e. it is permanent). This\n * means a handshake error should be classified with isPermanentError, above.\n */\nfunction isPermanentWriteError(code) {\n    return isPermanentError(code) && code !== Code.ABORTED;\n}\n/**\n * Maps an error Code from GRPC status code number, like 0, 1, or 14. These\n * are not the same as HTTP status codes.\n *\n * @returns The Code equivalent to the given GRPC status code. Fails if there\n *     is no match.\n */\nfunction mapCodeFromRpcCode(code) {\n    if (code === undefined) {\n        // This shouldn't normally happen, but in certain error cases (like trying\n        // to send invalid proto messages) we may get an error with no GRPC code.\n        logError('GRPC error has no .code');\n        return Code.UNKNOWN;\n    }\n    switch (code) {\n        case RpcCode.OK:\n            return Code.OK;\n        case RpcCode.CANCELLED:\n            return Code.CANCELLED;\n        case RpcCode.UNKNOWN:\n            return Code.UNKNOWN;\n        case RpcCode.DEADLINE_EXCEEDED:\n            return Code.DEADLINE_EXCEEDED;\n        case RpcCode.RESOURCE_EXHAUSTED:\n            return Code.RESOURCE_EXHAUSTED;\n        case RpcCode.INTERNAL:\n            return Code.INTERNAL;\n        case RpcCode.UNAVAILABLE:\n            return Code.UNAVAILABLE;\n        case RpcCode.UNAUTHENTICATED:\n            return Code.UNAUTHENTICATED;\n        case RpcCode.INVALID_ARGUMENT:\n            return Code.INVALID_ARGUMENT;\n        case RpcCode.NOT_FOUND:\n            return Code.NOT_FOUND;\n        case RpcCode.ALREADY_EXISTS:\n            return Code.ALREADY_EXISTS;\n        case RpcCode.PERMISSION_DENIED:\n            return Code.PERMISSION_DENIED;\n        case RpcCode.FAILED_PRECONDITION:\n            return Code.FAILED_PRECONDITION;\n        case RpcCode.ABORTED:\n            return Code.ABORTED;\n        case RpcCode.OUT_OF_RANGE:\n            return Code.OUT_OF_RANGE;\n        case RpcCode.UNIMPLEMENTED:\n            return Code.UNIMPLEMENTED;\n        case RpcCode.DATA_LOSS:\n            return Code.DATA_LOSS;\n        default:\n            return fail(0x999b, { code });\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An error encountered while decoding base64 string.\n */\nclass Base64DecodeError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'Base64DecodeError';\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The global, singleton instance of TestingHooksSpi.\n *\n * This variable will be `null` in all cases _except_ when running from\n * integration tests that have registered callbacks to be notified of events\n * that happen during the test execution.\n */\nlet testingHooksSpi = null;\n/**\n * Sets the value of the `testingHooksSpi` object.\n * @param instance - the instance to set.\n */\nfunction setTestingHooksSpi(instance) {\n    if (testingHooksSpi) {\n        throw new Error('a TestingHooksSpi instance is already set');\n    }\n    testingHooksSpi = instance;\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An instance of the Platform's 'TextEncoder' implementation.\n */\nfunction newTextEncoder() {\n    return new util__WEBPACK_IMPORTED_MODULE_4__.TextEncoder();\n}\n/**\n * An instance of the Platform's 'TextDecoder' implementation.\n */\nfunction newTextDecoder() {\n    return new util__WEBPACK_IMPORTED_MODULE_4__.TextDecoder('utf-8');\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst MAX_64_BIT_UNSIGNED_INTEGER = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_2__.Integer([0xffffffff, 0xffffffff], 0);\n// Hash a string using md5 hashing algorithm.\nfunction getMd5HashValue(value) {\n    const encodedValue = newTextEncoder().encode(value);\n    const md5 = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_2__.Md5();\n    md5.update(encodedValue);\n    return new Uint8Array(md5.digest());\n}\n// Interpret the 16 bytes array as two 64-bit unsigned integers, encoded using\n// 2s complement using little endian.\nfunction get64BitUints(Bytes) {\n    const dataView = new DataView(Bytes.buffer);\n    const chunk1 = dataView.getUint32(0, /* littleEndian= */ true);\n    const chunk2 = dataView.getUint32(4, /* littleEndian= */ true);\n    const chunk3 = dataView.getUint32(8, /* littleEndian= */ true);\n    const chunk4 = dataView.getUint32(12, /* littleEndian= */ true);\n    const integer1 = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_2__.Integer([chunk1, chunk2], 0);\n    const integer2 = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_2__.Integer([chunk3, chunk4], 0);\n    return [integer1, integer2];\n}\nclass BloomFilter {\n    constructor(bitmap, padding, hashCount) {\n        this.bitmap = bitmap;\n        this.padding = padding;\n        this.hashCount = hashCount;\n        if (padding < 0 || padding >= 8) {\n            throw new BloomFilterError(`Invalid padding: ${padding}`);\n        }\n        if (hashCount < 0) {\n            throw new BloomFilterError(`Invalid hash count: ${hashCount}`);\n        }\n        if (bitmap.length > 0 && this.hashCount === 0) {\n            // Only empty bloom filter can have 0 hash count.\n            throw new BloomFilterError(`Invalid hash count: ${hashCount}`);\n        }\n        if (bitmap.length === 0 && padding !== 0) {\n            // Empty bloom filter should have 0 padding.\n            throw new BloomFilterError(`Invalid padding when bitmap length is 0: ${padding}`);\n        }\n        this.bitCount = bitmap.length * 8 - padding;\n        // Set the bit count in Integer to avoid repetition in mightContain().\n        this.bitCountInInteger = _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_2__.Integer.fromNumber(this.bitCount);\n    }\n    // Calculate the ith hash value based on the hashed 64bit integers,\n    // and calculate its corresponding bit index in the bitmap to be checked.\n    getBitIndex(num1, num2, hashIndex) {\n        // Calculate hashed value h(i) = h1 + (i * h2).\n        let hashValue = num1.add(num2.multiply(_firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_2__.Integer.fromNumber(hashIndex)));\n        // Wrap if hash value overflow 64bit.\n        if (hashValue.compare(MAX_64_BIT_UNSIGNED_INTEGER) === 1) {\n            hashValue = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_2__.Integer([hashValue.getBits(0), hashValue.getBits(1)], 0);\n        }\n        return hashValue.modulo(this.bitCountInInteger).toNumber();\n    }\n    // Return whether the bit on the given index in the bitmap is set to 1.\n    isBitSet(index) {\n        // To retrieve bit n, calculate: (bitmap[n / 8] & (0x01 << (n % 8))).\n        const byte = this.bitmap[Math.floor(index / 8)];\n        const offset = index % 8;\n        return (byte & (0x01 << offset)) !== 0;\n    }\n    mightContain(value) {\n        // Empty bitmap should always return false on membership check.\n        if (this.bitCount === 0) {\n            return false;\n        }\n        const md5HashedValue = getMd5HashValue(value);\n        const [hash1, hash2] = get64BitUints(md5HashedValue);\n        for (let i = 0; i < this.hashCount; i++) {\n            const index = this.getBitIndex(hash1, hash2, i);\n            if (!this.isBitSet(index)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** Create bloom filter for testing purposes only. */\n    static create(bitCount, hashCount, contains) {\n        const padding = bitCount % 8 === 0 ? 0 : 8 - (bitCount % 8);\n        const bitmap = new Uint8Array(Math.ceil(bitCount / 8));\n        const bloomFilter = new BloomFilter(bitmap, padding, hashCount);\n        contains.forEach(item => bloomFilter.insert(item));\n        return bloomFilter;\n    }\n    insert(value) {\n        if (this.bitCount === 0) {\n            return;\n        }\n        const md5HashedValue = getMd5HashValue(value);\n        const [hash1, hash2] = get64BitUints(md5HashedValue);\n        for (let i = 0; i < this.hashCount; i++) {\n            const index = this.getBitIndex(hash1, hash2, i);\n            this.setBit(index);\n        }\n    }\n    setBit(index) {\n        const indexOfByte = Math.floor(index / 8);\n        const offset = index % 8;\n        this.bitmap[indexOfByte] |= 0x01 << offset;\n    }\n}\nclass BloomFilterError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'BloomFilterError';\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An event from the RemoteStore. It is split into targetChanges (changes to the\n * state or the set of documents in our watched targets) and documentUpdates\n * (changes to the actual documents).\n */\nclass RemoteEvent {\n    constructor(\n    /**\n     * The snapshot version this event brings us up to, or MIN if not set.\n     */\n    snapshotVersion, \n    /**\n     * A map from target to changes to the target. See TargetChange.\n     */\n    targetChanges, \n    /**\n     * A map of targets that is known to be inconsistent, and the purpose for\n     * re-listening. Listens for these targets should be re-established without\n     * resume tokens.\n     */\n    targetMismatches, \n    /**\n     * A set of which documents have changed or been deleted, along with the\n     * doc's new values (if not deleted).\n     */\n    documentUpdates, \n    /**\n     * A set of which document updates are due only to limbo resolution targets.\n     */\n    resolvedLimboDocuments) {\n        this.snapshotVersion = snapshotVersion;\n        this.targetChanges = targetChanges;\n        this.targetMismatches = targetMismatches;\n        this.documentUpdates = documentUpdates;\n        this.resolvedLimboDocuments = resolvedLimboDocuments;\n    }\n    /**\n     * HACK: Views require RemoteEvents in order to determine whether the view is\n     * CURRENT, but secondary tabs don't receive remote events. So this method is\n     * used to create a synthesized RemoteEvent that can be used to apply a\n     * CURRENT status change to a View, for queries executed in a different tab.\n     */\n    // PORTING NOTE: Multi-tab only\n    static createSynthesizedRemoteEventForCurrentChange(targetId, current, resumeToken) {\n        const targetChanges = new Map();\n        targetChanges.set(targetId, TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current, resumeToken));\n        return new RemoteEvent(SnapshotVersion.min(), targetChanges, new SortedMap(primitiveComparator), mutableDocumentMap(), documentKeySet());\n    }\n}\n/**\n * A TargetChange specifies the set of changes for a specific target as part of\n * a RemoteEvent. These changes track which documents are added, modified or\n * removed, as well as the target's resume token and whether the target is\n * marked CURRENT.\n * The actual changes *to* documents are not part of the TargetChange since\n * documents may be part of multiple targets.\n */\nclass TargetChange {\n    constructor(\n    /**\n     * An opaque, server-assigned token that allows watching a query to be resumed\n     * after disconnecting without retransmitting all the data that matches the\n     * query. The resume token essentially identifies a point in time from which\n     * the server should resume sending results.\n     */\n    resumeToken, \n    /**\n     * The \"current\" (synced) status of this target. Note that \"current\"\n     * has special meaning in the RPC protocol that implies that a target is\n     * both up-to-date and consistent with the rest of the watch stream.\n     */\n    current, \n    /**\n     * The set of documents that were newly assigned to this target as part of\n     * this remote event.\n     */\n    addedDocuments, \n    /**\n     * The set of documents that were already assigned to this target but received\n     * an update during this remote event.\n     */\n    modifiedDocuments, \n    /**\n     * The set of documents that were removed from this target as part of this\n     * remote event.\n     */\n    removedDocuments) {\n        this.resumeToken = resumeToken;\n        this.current = current;\n        this.addedDocuments = addedDocuments;\n        this.modifiedDocuments = modifiedDocuments;\n        this.removedDocuments = removedDocuments;\n    }\n    /**\n     * This method is used to create a synthesized TargetChanges that can be used to\n     * apply a CURRENT status change to a View (for queries executed in a different\n     * tab) or for new queries (to raise snapshots with correct CURRENT status).\n     */\n    static createSynthesizedTargetChangeForCurrentChange(targetId, current, resumeToken) {\n        return new TargetChange(resumeToken, current, documentKeySet(), documentKeySet(), documentKeySet());\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a changed document and a list of target ids to which this change\n * applies.\n *\n * If document has been deleted NoDocument will be provided.\n */\nclass DocumentWatchChange {\n    constructor(\n    /** The new document applies to all of these targets. */\n    updatedTargetIds, \n    /** The new document is removed from all of these targets. */\n    removedTargetIds, \n    /** The key of the document for this change. */\n    key, \n    /**\n     * The new document or NoDocument if it was deleted. Is null if the\n     * document went out of view without the server sending a new document.\n     */\n    newDoc) {\n        this.updatedTargetIds = updatedTargetIds;\n        this.removedTargetIds = removedTargetIds;\n        this.key = key;\n        this.newDoc = newDoc;\n    }\n}\nclass ExistenceFilterChange {\n    constructor(targetId, existenceFilter) {\n        this.targetId = targetId;\n        this.existenceFilter = existenceFilter;\n    }\n}\nclass WatchTargetChange {\n    constructor(\n    /** What kind of change occurred to the watch target. */\n    state, \n    /** The target IDs that were added/removed/set. */\n    targetIds, \n    /**\n     * An opaque, server-assigned token that allows watching a target to be\n     * resumed after disconnecting without retransmitting all the data that\n     * matches the target. The resume token essentially identifies a point in\n     * time from which the server should resume sending results.\n     */\n    resumeToken = ByteString.EMPTY_BYTE_STRING, \n    /** An RPC error indicating why the watch failed. */\n    cause = null) {\n        this.state = state;\n        this.targetIds = targetIds;\n        this.resumeToken = resumeToken;\n        this.cause = cause;\n    }\n}\n/** Tracks the internal state of a Watch target. */\nclass TargetState {\n    constructor() {\n        /**\n         * The number of pending responses (adds or removes) that we are waiting on.\n         * We only consider targets active that have no pending responses.\n         */\n        this.pendingResponses = 0;\n        /**\n         * Keeps track of the document changes since the last raised snapshot.\n         *\n         * These changes are continuously updated as we receive document updates and\n         * always reflect the current set of changes against the last issued snapshot.\n         */\n        this.documentChanges = snapshotChangesMap();\n        /** See public getters for explanations of these fields. */\n        this._resumeToken = ByteString.EMPTY_BYTE_STRING;\n        this._current = false;\n        /**\n         * Whether this target state should be included in the next snapshot. We\n         * initialize to true so that newly-added targets are included in the next\n         * RemoteEvent.\n         */\n        this._hasPendingChanges = true;\n    }\n    /**\n     * Whether this target has been marked 'current'.\n     *\n     * 'Current' has special meaning in the RPC protocol: It implies that the\n     * Watch backend has sent us all changes up to the point at which the target\n     * was added and that the target is consistent with the rest of the watch\n     * stream.\n     */\n    get current() {\n        return this._current;\n    }\n    /** The last resume token sent to us for this target. */\n    get resumeToken() {\n        return this._resumeToken;\n    }\n    /** Whether this target has pending target adds or target removes. */\n    get isPending() {\n        return this.pendingResponses !== 0;\n    }\n    /** Whether we have modified any state that should trigger a snapshot. */\n    get hasPendingChanges() {\n        return this._hasPendingChanges;\n    }\n    /**\n     * Applies the resume token to the TargetChange, but only when it has a new\n     * value. Empty resumeTokens are discarded.\n     */\n    updateResumeToken(resumeToken) {\n        if (resumeToken.approximateByteSize() > 0) {\n            this._hasPendingChanges = true;\n            this._resumeToken = resumeToken;\n        }\n    }\n    /**\n     * Creates a target change from the current set of changes.\n     *\n     * To reset the document changes after raising this snapshot, call\n     * `clearPendingChanges()`.\n     */\n    toTargetChange() {\n        let addedDocuments = documentKeySet();\n        let modifiedDocuments = documentKeySet();\n        let removedDocuments = documentKeySet();\n        this.documentChanges.forEach((key, changeType) => {\n            switch (changeType) {\n                case 0 /* ChangeType.Added */:\n                    addedDocuments = addedDocuments.add(key);\n                    break;\n                case 2 /* ChangeType.Modified */:\n                    modifiedDocuments = modifiedDocuments.add(key);\n                    break;\n                case 1 /* ChangeType.Removed */:\n                    removedDocuments = removedDocuments.add(key);\n                    break;\n                default:\n                    fail(0x9481, { changeType });\n            }\n        });\n        return new TargetChange(this._resumeToken, this._current, addedDocuments, modifiedDocuments, removedDocuments);\n    }\n    /**\n     * Resets the document changes and sets `hasPendingChanges` to false.\n     */\n    clearPendingChanges() {\n        this._hasPendingChanges = false;\n        this.documentChanges = snapshotChangesMap();\n    }\n    addDocumentChange(key, changeType) {\n        this._hasPendingChanges = true;\n        this.documentChanges = this.documentChanges.insert(key, changeType);\n    }\n    removeDocumentChange(key) {\n        this._hasPendingChanges = true;\n        this.documentChanges = this.documentChanges.remove(key);\n    }\n    recordPendingTargetRequest() {\n        this.pendingResponses += 1;\n    }\n    recordTargetResponse() {\n        this.pendingResponses -= 1;\n        hardAssert(this.pendingResponses >= 0, 0x0ca9, { pendingResponses: this.pendingResponses });\n    }\n    markCurrent() {\n        this._hasPendingChanges = true;\n        this._current = true;\n    }\n}\nconst LOG_TAG$g = 'WatchChangeAggregator';\n/**\n * A helper class to accumulate watch changes into a RemoteEvent.\n */\nclass WatchChangeAggregator {\n    constructor(metadataProvider) {\n        this.metadataProvider = metadataProvider;\n        /** The internal state of all tracked targets. */\n        this.targetStates = new Map();\n        /** Keeps track of the documents to update since the last raised snapshot. */\n        this.pendingDocumentUpdates = mutableDocumentMap();\n        this.pendingDocumentUpdatesByTarget = documentTargetMap();\n        /** A mapping of document keys to their set of target IDs. */\n        this.pendingDocumentTargetMapping = documentTargetMap();\n        /**\n         * A map of targets with existence filter mismatches. These targets are\n         * known to be inconsistent and their listens needs to be re-established by\n         * RemoteStore.\n         */\n        this.pendingTargetResets = new SortedMap(primitiveComparator);\n    }\n    /**\n     * Processes and adds the DocumentWatchChange to the current set of changes.\n     */\n    handleDocumentChange(docChange) {\n        for (const targetId of docChange.updatedTargetIds) {\n            if (docChange.newDoc && docChange.newDoc.isFoundDocument()) {\n                this.addDocumentToTarget(targetId, docChange.newDoc);\n            }\n            else {\n                this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);\n            }\n        }\n        for (const targetId of docChange.removedTargetIds) {\n            this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);\n        }\n    }\n    /** Processes and adds the WatchTargetChange to the current set of changes. */\n    handleTargetChange(targetChange) {\n        this.forEachTarget(targetChange, targetId => {\n            const targetState = this.ensureTargetState(targetId);\n            switch (targetChange.state) {\n                case 0 /* WatchTargetChangeState.NoChange */:\n                    if (this.isActiveTarget(targetId)) {\n                        targetState.updateResumeToken(targetChange.resumeToken);\n                    }\n                    break;\n                case 1 /* WatchTargetChangeState.Added */:\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    targetState.recordTargetResponse();\n                    if (!targetState.isPending) {\n                        // We have a freshly added target, so we need to reset any state\n                        // that we had previously. This can happen e.g. when remove and add\n                        // back a target for existence filter mismatches.\n                        targetState.clearPendingChanges();\n                    }\n                    targetState.updateResumeToken(targetChange.resumeToken);\n                    break;\n                case 2 /* WatchTargetChangeState.Removed */:\n                    // We need to keep track of removed targets to we can post-filter and\n                    // remove any target changes.\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    targetState.recordTargetResponse();\n                    if (!targetState.isPending) {\n                        this.removeTarget(targetId);\n                    }\n                    break;\n                case 3 /* WatchTargetChangeState.Current */:\n                    if (this.isActiveTarget(targetId)) {\n                        targetState.markCurrent();\n                        targetState.updateResumeToken(targetChange.resumeToken);\n                    }\n                    break;\n                case 4 /* WatchTargetChangeState.Reset */:\n                    if (this.isActiveTarget(targetId)) {\n                        // Reset the target and synthesizes removes for all existing\n                        // documents. The backend will re-add any documents that still\n                        // match the target before it sends the next global snapshot.\n                        this.resetTarget(targetId);\n                        targetState.updateResumeToken(targetChange.resumeToken);\n                    }\n                    break;\n                default:\n                    fail(0xddd6, {\n                        state: targetChange.state\n                    });\n            }\n        });\n    }\n    /**\n     * Iterates over all targetIds that the watch change applies to: either the\n     * targetIds explicitly listed in the change or the targetIds of all currently\n     * active targets.\n     */\n    forEachTarget(targetChange, fn) {\n        if (targetChange.targetIds.length > 0) {\n            targetChange.targetIds.forEach(fn);\n        }\n        else {\n            this.targetStates.forEach((_, targetId) => {\n                if (this.isActiveTarget(targetId)) {\n                    fn(targetId);\n                }\n            });\n        }\n    }\n    /**\n     * Handles existence filters and synthesizes deletes for filter mismatches.\n     * Targets that are invalidated by filter mismatches are added to\n     * `pendingTargetResets`.\n     */\n    handleExistenceFilter(watchChange) {\n        const targetId = watchChange.targetId;\n        const expectedCount = watchChange.existenceFilter.count;\n        const targetData = this.targetDataForActiveTarget(targetId);\n        if (targetData) {\n            const target = targetData.target;\n            if (targetIsDocumentTarget(target)) {\n                if (expectedCount === 0) {\n                    // The existence filter told us the document does not exist. We deduce\n                    // that this document does not exist and apply a deleted document to\n                    // our updates. Without applying this deleted document there might be\n                    // another query that will raise this document as part of a snapshot\n                    // until it is resolved, essentially exposing inconsistency between\n                    // queries.\n                    const key = new DocumentKey(target.path);\n                    this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, SnapshotVersion.min()));\n                }\n                else {\n                    hardAssert(expectedCount === 1, 0x4e2d, { expectedCount });\n                }\n            }\n            else {\n                const currentSize = this.getCurrentDocumentCountForTarget(targetId);\n                // Existence filter mismatch. Mark the documents as being in limbo, and\n                // raise a snapshot with `isFromCache:true`.\n                if (currentSize !== expectedCount) {\n                    // Apply bloom filter to identify and mark removed documents.\n                    const bloomFilter = this.parseBloomFilter(watchChange);\n                    const status = bloomFilter\n                        ? this.applyBloomFilter(bloomFilter, watchChange, currentSize)\n                        : 1 /* BloomFilterApplicationStatus.Skipped */;\n                    if (status !== 0 /* BloomFilterApplicationStatus.Success */) {\n                        // If bloom filter application fails, we reset the mapping and\n                        // trigger re-run of the query.\n                        this.resetTarget(targetId);\n                        const purpose = status === 2 /* BloomFilterApplicationStatus.FalsePositive */\n                            ? \"TargetPurposeExistenceFilterMismatchBloom\" /* TargetPurpose.ExistenceFilterMismatchBloom */\n                            : \"TargetPurposeExistenceFilterMismatch\" /* TargetPurpose.ExistenceFilterMismatch */;\n                        this.pendingTargetResets = this.pendingTargetResets.insert(targetId, purpose);\n                    }\n                    testingHooksSpi?.notifyOnExistenceFilterMismatch(createExistenceFilterMismatchInfoForTestingHooks(currentSize, watchChange.existenceFilter, this.metadataProvider.getDatabaseId(), bloomFilter, status));\n                }\n            }\n        }\n    }\n    /**\n     * Parse the bloom filter from the \"unchanged_names\" field of an existence\n     * filter.\n     */\n    parseBloomFilter(watchChange) {\n        const unchangedNames = watchChange.existenceFilter.unchangedNames;\n        if (!unchangedNames || !unchangedNames.bits) {\n            return null;\n        }\n        const { bits: { bitmap = '', padding = 0 }, hashCount = 0 } = unchangedNames;\n        let normalizedBitmap;\n        try {\n            normalizedBitmap = normalizeByteString(bitmap).toUint8Array();\n        }\n        catch (err) {\n            if (err instanceof Base64DecodeError) {\n                logWarn('Decoding the base64 bloom filter in existence filter failed (' +\n                    err.message +\n                    '); ignoring the bloom filter and falling back to full re-query.');\n                return null;\n            }\n            else {\n                throw err;\n            }\n        }\n        let bloomFilter;\n        try {\n            // BloomFilter throws error if the inputs are invalid.\n            bloomFilter = new BloomFilter(normalizedBitmap, padding, hashCount);\n        }\n        catch (err) {\n            if (err instanceof BloomFilterError) {\n                logWarn('BloomFilter error: ', err);\n            }\n            else {\n                logWarn('Applying bloom filter failed: ', err);\n            }\n            return null;\n        }\n        if (bloomFilter.bitCount === 0) {\n            return null;\n        }\n        return bloomFilter;\n    }\n    /**\n     * Apply bloom filter to remove the deleted documents, and return the\n     * application status.\n     */\n    applyBloomFilter(bloomFilter, watchChange, currentCount) {\n        const expectedCount = watchChange.existenceFilter.count;\n        const removedDocumentCount = this.filterRemovedDocuments(bloomFilter, watchChange.targetId);\n        return expectedCount === currentCount - removedDocumentCount\n            ? 0 /* BloomFilterApplicationStatus.Success */\n            : 2 /* BloomFilterApplicationStatus.FalsePositive */;\n    }\n    /**\n     * Filter out removed documents based on bloom filter membership result and\n     * return number of documents removed.\n     */\n    filterRemovedDocuments(bloomFilter, targetId) {\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\n        let removalCount = 0;\n        existingKeys.forEach(key => {\n            const databaseId = this.metadataProvider.getDatabaseId();\n            const documentPath = `projects/${databaseId.projectId}` +\n                `/databases/${databaseId.database}` +\n                `/documents/${key.path.canonicalString()}`;\n            if (!bloomFilter.mightContain(documentPath)) {\n                this.removeDocumentFromTarget(targetId, key, /*updatedDocument=*/ null);\n                removalCount++;\n            }\n        });\n        return removalCount;\n    }\n    /**\n     * Converts the currently accumulated state into a remote event at the\n     * provided snapshot version. Resets the accumulated changes before returning.\n     */\n    createRemoteEvent(snapshotVersion) {\n        const targetChanges = new Map();\n        this.targetStates.forEach((targetState, targetId) => {\n            const targetData = this.targetDataForActiveTarget(targetId);\n            if (targetData) {\n                if (targetState.current && targetIsDocumentTarget(targetData.target)) {\n                    // Document queries for document that don't exist can produce an empty\n                    // result set. To update our local cache, we synthesize a document\n                    // delete if we have not previously received the document for this\n                    // target. This resolves the limbo state of the document, removing it\n                    // from limboDocumentRefs.\n                    //\n                    // TODO(dimond): Ideally we would have an explicit lookup target\n                    // instead resulting in an explicit delete message and we could\n                    // remove this special logic.\n                    const key = new DocumentKey(targetData.target.path);\n                    if (!this.ensureDocumentUpdateByTarget(key).has(targetId) &&\n                        !this.targetContainsDocument(targetId, key)) {\n                        this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, snapshotVersion));\n                    }\n                }\n                if (targetState.hasPendingChanges) {\n                    targetChanges.set(targetId, targetState.toTargetChange());\n                    targetState.clearPendingChanges();\n                }\n            }\n        });\n        let resolvedLimboDocuments = documentKeySet();\n        // We extract the set of limbo-only document updates as the GC logic\n        // special-cases documents that do not appear in the target cache.\n        //\n        // TODO(gsoltis): Expand on this comment once GC is available in the JS\n        // client.\n        this.pendingDocumentTargetMapping.forEach((key, targets) => {\n            let isOnlyLimboTarget = true;\n            targets.forEachWhile(targetId => {\n                const targetData = this.targetDataForActiveTarget(targetId);\n                if (targetData &&\n                    targetData.purpose !== \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */) {\n                    isOnlyLimboTarget = false;\n                    return false;\n                }\n                return true;\n            });\n            if (isOnlyLimboTarget) {\n                resolvedLimboDocuments = resolvedLimboDocuments.add(key);\n            }\n        });\n        this.pendingDocumentUpdates.forEach((_, doc) => doc.setReadTime(snapshotVersion));\n        const remoteEvent = new RemoteEvent(snapshotVersion, targetChanges, this.pendingTargetResets, this.pendingDocumentUpdates, resolvedLimboDocuments);\n        this.pendingDocumentUpdates = mutableDocumentMap();\n        this.pendingDocumentUpdatesByTarget = documentTargetMap();\n        this.pendingDocumentTargetMapping = documentTargetMap();\n        this.pendingTargetResets = new SortedMap(primitiveComparator);\n        return remoteEvent;\n    }\n    /**\n     * Adds the provided document to the internal list of document updates and\n     * its document key to the given target's mapping.\n     */\n    // Visible for testing.\n    addDocumentToTarget(targetId, document) {\n        if (!this.isActiveTarget(targetId)) {\n            return;\n        }\n        const changeType = this.targetContainsDocument(targetId, document.key)\n            ? 2 /* ChangeType.Modified */\n            : 0 /* ChangeType.Added */;\n        const targetState = this.ensureTargetState(targetId);\n        targetState.addDocumentChange(document.key, changeType);\n        this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(document.key, document);\n        this.pendingDocumentUpdatesByTarget =\n            this.pendingDocumentUpdatesByTarget.insert(document.key, this.ensureDocumentUpdateByTarget(document.key).add(targetId));\n        this.pendingDocumentTargetMapping =\n            this.pendingDocumentTargetMapping.insert(document.key, this.ensureDocumentTargetMapping(document.key).add(targetId));\n    }\n    /**\n     * Removes the provided document from the target mapping. If the\n     * document no longer matches the target, but the document's state is still\n     * known (e.g. we know that the document was deleted or we received the change\n     * that caused the filter mismatch), the new document can be provided\n     * to update the remote document cache.\n     */\n    // Visible for testing.\n    removeDocumentFromTarget(targetId, key, updatedDocument) {\n        if (!this.isActiveTarget(targetId)) {\n            return;\n        }\n        const targetState = this.ensureTargetState(targetId);\n        if (this.targetContainsDocument(targetId, key)) {\n            targetState.addDocumentChange(key, 1 /* ChangeType.Removed */);\n        }\n        else {\n            // The document may have entered and left the target before we raised a\n            // snapshot, so we can just ignore the change.\n            targetState.removeDocumentChange(key);\n        }\n        this.pendingDocumentTargetMapping =\n            this.pendingDocumentTargetMapping.insert(key, this.ensureDocumentTargetMapping(key).delete(targetId));\n        this.pendingDocumentTargetMapping =\n            this.pendingDocumentTargetMapping.insert(key, this.ensureDocumentTargetMapping(key).add(targetId));\n        if (updatedDocument) {\n            this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(key, updatedDocument);\n        }\n    }\n    removeTarget(targetId) {\n        this.targetStates.delete(targetId);\n    }\n    /**\n     * Returns the current count of documents in the target. This includes both\n     * the number of documents that the LocalStore considers to be part of the\n     * target as well as any accumulated changes.\n     */\n    getCurrentDocumentCountForTarget(targetId) {\n        const targetState = this.ensureTargetState(targetId);\n        const targetChange = targetState.toTargetChange();\n        return (this.metadataProvider.getRemoteKeysForTarget(targetId).size +\n            targetChange.addedDocuments.size -\n            targetChange.removedDocuments.size);\n    }\n    /**\n     * Increment the number of acks needed from watch before we can consider the\n     * server to be 'in-sync' with the client's active targets.\n     */\n    recordPendingTargetRequest(targetId) {\n        // For each request we get we need to record we need a response for it.\n        const targetState = this.ensureTargetState(targetId);\n        targetState.recordPendingTargetRequest();\n    }\n    ensureTargetState(targetId) {\n        let result = this.targetStates.get(targetId);\n        if (!result) {\n            result = new TargetState();\n            this.targetStates.set(targetId, result);\n        }\n        return result;\n    }\n    ensureDocumentTargetMapping(key) {\n        let targetMapping = this.pendingDocumentTargetMapping.get(key);\n        if (!targetMapping) {\n            targetMapping = new SortedSet(primitiveComparator);\n            this.pendingDocumentTargetMapping =\n                this.pendingDocumentTargetMapping.insert(key, targetMapping);\n        }\n        return targetMapping;\n    }\n    ensureDocumentUpdateByTarget(key) {\n        let targetMapping = this.pendingDocumentUpdatesByTarget.get(key);\n        if (!targetMapping) {\n            targetMapping = new SortedSet(primitiveComparator);\n            this.pendingDocumentUpdatesByTarget =\n                this.pendingDocumentUpdatesByTarget.insert(key, targetMapping);\n        }\n        return targetMapping;\n    }\n    /**\n     * Verifies that the user is still interested in this target (by calling\n     * `getTargetDataForTarget()`) and that we are not waiting for pending ADDs\n     * from watch.\n     */\n    isActiveTarget(targetId) {\n        const targetActive = this.targetDataForActiveTarget(targetId) !== null;\n        if (!targetActive) {\n            logDebug(LOG_TAG$g, 'Detected inactive target', targetId);\n        }\n        return targetActive;\n    }\n    /**\n     * Returns the TargetData for an active target (i.e. a target that the user\n     * is still interested in that has no outstanding target change requests).\n     */\n    targetDataForActiveTarget(targetId) {\n        const targetState = this.targetStates.get(targetId);\n        return targetState && targetState.isPending\n            ? null\n            : this.metadataProvider.getTargetDataForTarget(targetId);\n    }\n    /**\n     * Resets the state of a Watch target to its initial state (e.g. sets\n     * 'current' to false, clears the resume token and removes its target mapping\n     * from all documents).\n     */\n    resetTarget(targetId) {\n        this.targetStates.set(targetId, new TargetState());\n        // Trigger removal for any documents currently mapped to this target.\n        // These removals will be part of the initial snapshot if Watch does not\n        // resend these documents.\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\n        existingKeys.forEach(key => {\n            this.removeDocumentFromTarget(targetId, key, /*updatedDocument=*/ null);\n        });\n    }\n    /**\n     * Returns whether the LocalStore considers the document to be part of the\n     * specified target.\n     */\n    targetContainsDocument(targetId, key) {\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\n        return existingKeys.has(key);\n    }\n}\nfunction documentTargetMap() {\n    return new SortedMap(DocumentKey.comparator);\n}\nfunction snapshotChangesMap() {\n    return new SortedMap(DocumentKey.comparator);\n}\nfunction createExistenceFilterMismatchInfoForTestingHooks(localCacheCount, existenceFilter, databaseId, bloomFilter, bloomFilterStatus) {\n    const result = {\n        localCacheCount,\n        existenceFilterCount: existenceFilter.count,\n        databaseId: databaseId.database,\n        projectId: databaseId.projectId\n    };\n    const unchangedNames = existenceFilter.unchangedNames;\n    if (unchangedNames) {\n        result.bloomFilter = {\n            applied: bloomFilterStatus === 0 /* BloomFilterApplicationStatus.Success */,\n            hashCount: unchangedNames?.hashCount ?? 0,\n            bitmapLength: unchangedNames?.bits?.bitmap?.length ?? 0,\n            padding: unchangedNames?.bits?.padding ?? 0,\n            mightContain: (value) => bloomFilter?.mightContain(value) ?? false\n        };\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DIRECTIONS = (() => {\n    const dirs = {};\n    dirs[\"asc\" /* Direction.ASCENDING */] = 'ASCENDING';\n    dirs[\"desc\" /* Direction.DESCENDING */] = 'DESCENDING';\n    return dirs;\n})();\nconst OPERATORS = (() => {\n    const ops = {};\n    ops[\"<\" /* Operator.LESS_THAN */] = 'LESS_THAN';\n    ops[\"<=\" /* Operator.LESS_THAN_OR_EQUAL */] = 'LESS_THAN_OR_EQUAL';\n    ops[\">\" /* Operator.GREATER_THAN */] = 'GREATER_THAN';\n    ops[\">=\" /* Operator.GREATER_THAN_OR_EQUAL */] = 'GREATER_THAN_OR_EQUAL';\n    ops[\"==\" /* Operator.EQUAL */] = 'EQUAL';\n    ops[\"!=\" /* Operator.NOT_EQUAL */] = 'NOT_EQUAL';\n    ops[\"array-contains\" /* Operator.ARRAY_CONTAINS */] = 'ARRAY_CONTAINS';\n    ops[\"in\" /* Operator.IN */] = 'IN';\n    ops[\"not-in\" /* Operator.NOT_IN */] = 'NOT_IN';\n    ops[\"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */] = 'ARRAY_CONTAINS_ANY';\n    return ops;\n})();\nconst COMPOSITE_OPERATORS = (() => {\n    const ops = {};\n    ops[\"and\" /* CompositeOperator.AND */] = 'AND';\n    ops[\"or\" /* CompositeOperator.OR */] = 'OR';\n    return ops;\n})();\nfunction assertPresent(value, description) {\n}\n/**\n * This class generates JsonObject values for the Datastore API suitable for\n * sending to either GRPC stub methods or via the JSON/HTTP REST API.\n *\n * The serializer supports both Protobuf.js and Proto3 JSON formats. By\n * setting `useProto3Json` to true, the serializer will use the Proto3 JSON\n * format.\n *\n * For a description of the Proto3 JSON format check\n * https://developers.google.com/protocol-buffers/docs/proto3#json\n *\n * TODO(klimt): We can remove the databaseId argument if we keep the full\n * resource name in documents.\n */\nclass JsonProtoSerializer {\n    constructor(databaseId, useProto3Json) {\n        this.databaseId = databaseId;\n        this.useProto3Json = useProto3Json;\n    }\n}\nfunction fromRpcStatus(status) {\n    const code = status.code === undefined ? Code.UNKNOWN : mapCodeFromRpcCode(status.code);\n    return new FirestoreError(code, status.message || '');\n}\n/**\n * Returns a value for a number (or null) that's appropriate to put into\n * a google.protobuf.Int32Value proto.\n * DO NOT USE THIS FOR ANYTHING ELSE.\n * This method cheats. It's typed as returning \"number\" because that's what\n * our generated proto interfaces say Int32Value must be. But GRPC actually\n * expects a { value: <number> } struct.\n */\nfunction toInt32Proto(serializer, val) {\n    if (serializer.useProto3Json || isNullOrUndefined(val)) {\n        return val;\n    }\n    else {\n        return { value: val };\n    }\n}\n/**\n * Returns a number (or null) from a google.protobuf.Int32Value proto.\n */\nfunction fromInt32Proto(val) {\n    let result;\n    if (typeof val === 'object') {\n        result = val.value;\n    }\n    else {\n        result = val;\n    }\n    return isNullOrUndefined(result) ? null : result;\n}\n/**\n * Returns a value for a Date that's appropriate to put into a proto.\n */\nfunction toTimestamp(serializer, timestamp) {\n    if (serializer.useProto3Json) {\n        // Serialize to ISO-8601 date format, but with full nano resolution.\n        // Since JS Date has only millis, let's only use it for the seconds and\n        // then manually add the fractions to the end.\n        const jsDateStr = new Date(timestamp.seconds * 1000).toISOString();\n        // Remove .xxx frac part and Z in the end.\n        const strUntilSeconds = jsDateStr.replace(/\\.\\d*/, '').replace('Z', '');\n        // Pad the fraction out to 9 digits (nanos).\n        const nanoStr = ('000000000' + timestamp.nanoseconds).slice(-9);\n        return `${strUntilSeconds}.${nanoStr}Z`;\n    }\n    else {\n        return {\n            seconds: '' + timestamp.seconds,\n            nanos: timestamp.nanoseconds\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        };\n    }\n}\n/**\n * Returns a Timestamp typed object given protobuf timestamp value.\n */\nfunction fromTimestamp(date) {\n    const timestamp = normalizeTimestamp(date);\n    return new Timestamp(timestamp.seconds, timestamp.nanos);\n}\n/**\n * Returns a value for bytes that's appropriate to put in a proto.\n *\n * Visible for testing.\n */\nfunction toBytes(serializer, bytes) {\n    if (serializer.useProto3Json) {\n        return bytes.toBase64();\n    }\n    else {\n        return bytes.toUint8Array();\n    }\n}\n/**\n * Returns a ByteString based on the proto string value.\n */\nfunction fromBytes(serializer, value) {\n    if (serializer.useProto3Json) {\n        hardAssert(value === undefined || typeof value === 'string', 0xe30b);\n        return ByteString.fromBase64String(value ? value : '');\n    }\n    else {\n        hardAssert(value === undefined ||\n            // Check if the value is an instance of both Buffer and Uint8Array,\n            // despite the fact that Buffer extends Uint8Array. In some\n            // environments, such as jsdom, the prototype chain of Buffer\n            // does not indicate that it extends Uint8Array.\n            value instanceof Buffer ||\n            value instanceof Uint8Array, 0x3f41);\n        return ByteString.fromUint8Array(value ? value : new Uint8Array());\n    }\n}\nfunction toVersion(serializer, version) {\n    return toTimestamp(serializer, version.toTimestamp());\n}\nfunction fromVersion(version) {\n    hardAssert(!!version, 0xc050);\n    return SnapshotVersion.fromTimestamp(fromTimestamp(version));\n}\nfunction toResourceName(databaseId, path) {\n    return toResourcePath(databaseId, path).canonicalString();\n}\nfunction toResourcePath(databaseId, path) {\n    const resourcePath = fullyQualifiedPrefixPath(databaseId).child('documents');\n    return path === undefined ? resourcePath : resourcePath.child(path);\n}\nfunction fromResourceName(name) {\n    const resource = ResourcePath.fromString(name);\n    hardAssert(isValidResourceName(resource), 0x27ce, { key: resource.toString() });\n    return resource;\n}\nfunction toName(serializer, key) {\n    return toResourceName(serializer.databaseId, key.path);\n}\nfunction fromName(serializer, name) {\n    const resource = fromResourceName(name);\n    if (resource.get(1) !== serializer.databaseId.projectId) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Tried to deserialize key from different project: ' +\n            resource.get(1) +\n            ' vs ' +\n            serializer.databaseId.projectId);\n    }\n    if (resource.get(3) !== serializer.databaseId.database) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Tried to deserialize key from different database: ' +\n            resource.get(3) +\n            ' vs ' +\n            serializer.databaseId.database);\n    }\n    return new DocumentKey(extractLocalPathFromResourceName(resource));\n}\nfunction toQueryPath(serializer, path) {\n    return toResourceName(serializer.databaseId, path);\n}\nfunction fromQueryPath(name) {\n    const resourceName = fromResourceName(name);\n    // In v1beta1 queries for collections at the root did not have a trailing\n    // \"/documents\". In v1 all resource paths contain \"/documents\". Preserve the\n    // ability to read the v1beta1 form for compatibility with queries persisted\n    // in the local target cache.\n    if (resourceName.length === 4) {\n        return ResourcePath.emptyPath();\n    }\n    return extractLocalPathFromResourceName(resourceName);\n}\nfunction getEncodedDatabaseId(serializer) {\n    const path = new ResourcePath([\n        'projects',\n        serializer.databaseId.projectId,\n        'databases',\n        serializer.databaseId.database\n    ]);\n    return path.canonicalString();\n}\nfunction fullyQualifiedPrefixPath(databaseId) {\n    return new ResourcePath([\n        'projects',\n        databaseId.projectId,\n        'databases',\n        databaseId.database\n    ]);\n}\nfunction extractLocalPathFromResourceName(resourceName) {\n    hardAssert(resourceName.length > 4 && resourceName.get(4) === 'documents', 0x71a3, { key: resourceName.toString() });\n    return resourceName.popFirst(5);\n}\n/** Creates a Document proto from key and fields (but no create/update time) */\nfunction toMutationDocument(serializer, key, fields) {\n    return {\n        name: toName(serializer, key),\n        fields: fields.value.mapValue.fields\n    };\n}\nfunction toDocument(serializer, document) {\n    return {\n        name: toName(serializer, document.key),\n        fields: document.data.value.mapValue.fields,\n        updateTime: toTimestamp(serializer, document.version.toTimestamp()),\n        createTime: toTimestamp(serializer, document.createTime.toTimestamp())\n    };\n}\nfunction fromPipelineResponse(serializer, proto, document) {\n    const output = {};\n    if (proto.transaction?.length) {\n        output.transaction = proto.transaction;\n    }\n    const executionTime = proto.executionTime\n        ? fromVersion(proto.executionTime)\n        : undefined;\n    output.executionTime = executionTime;\n    if (!!document) {\n        output.key = document.name\n            ? fromName(serializer, document.name)\n            : undefined;\n        output.fields = new ObjectValue({ mapValue: { fields: document.fields } });\n        output.createTime = document.createTime\n            ? fromVersion(document.createTime)\n            : undefined;\n        output.updateTime = document.updateTime\n            ? fromVersion(document.updateTime)\n            : undefined;\n    }\n    return output;\n}\nfunction fromDocument(serializer, document, hasCommittedMutations) {\n    const key = fromName(serializer, document.name);\n    const version = fromVersion(document.updateTime);\n    // If we read a document from persistence that is missing createTime, it's due\n    // to older SDK versions not storing this information. In such cases, we'll\n    // set the createTime to zero. This can be removed in the long term.\n    const createTime = document.createTime\n        ? fromVersion(document.createTime)\n        : SnapshotVersion.min();\n    const data = new ObjectValue({ mapValue: { fields: document.fields } });\n    const result = MutableDocument.newFoundDocument(key, version, createTime, data);\n    if (hasCommittedMutations) {\n        result.setHasCommittedMutations();\n    }\n    return hasCommittedMutations ? result.setHasCommittedMutations() : result;\n}\nfunction fromFound(serializer, doc) {\n    hardAssert(!!doc.found, 0xaa33);\n    assertPresent(doc.found.name);\n    assertPresent(doc.found.updateTime);\n    const key = fromName(serializer, doc.found.name);\n    const version = fromVersion(doc.found.updateTime);\n    const createTime = doc.found.createTime\n        ? fromVersion(doc.found.createTime)\n        : SnapshotVersion.min();\n    const data = new ObjectValue({ mapValue: { fields: doc.found.fields } });\n    return MutableDocument.newFoundDocument(key, version, createTime, data);\n}\nfunction fromMissing(serializer, result) {\n    hardAssert(!!result.missing, 0x0f36);\n    hardAssert(!!result.readTime, 0x5995);\n    const key = fromName(serializer, result.missing);\n    const version = fromVersion(result.readTime);\n    return MutableDocument.newNoDocument(key, version);\n}\nfunction fromBatchGetDocumentsResponse(serializer, result) {\n    if ('found' in result) {\n        return fromFound(serializer, result);\n    }\n    else if ('missing' in result) {\n        return fromMissing(serializer, result);\n    }\n    return fail(0x1c42, { result });\n}\nfunction fromWatchChange(serializer, change) {\n    let watchChange;\n    if ('targetChange' in change) {\n        assertPresent(change.targetChange);\n        // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'\n        // if unset\n        const state = fromWatchTargetChangeState(change.targetChange.targetChangeType || 'NO_CHANGE');\n        const targetIds = change.targetChange.targetIds || [];\n        const resumeToken = fromBytes(serializer, change.targetChange.resumeToken);\n        const causeProto = change.targetChange.cause;\n        const cause = causeProto && fromRpcStatus(causeProto);\n        watchChange = new WatchTargetChange(state, targetIds, resumeToken, cause || null);\n    }\n    else if ('documentChange' in change) {\n        assertPresent(change.documentChange);\n        const entityChange = change.documentChange;\n        assertPresent(entityChange.document);\n        assertPresent(entityChange.document.name);\n        assertPresent(entityChange.document.updateTime);\n        const key = fromName(serializer, entityChange.document.name);\n        const version = fromVersion(entityChange.document.updateTime);\n        const createTime = entityChange.document.createTime\n            ? fromVersion(entityChange.document.createTime)\n            : SnapshotVersion.min();\n        const data = new ObjectValue({\n            mapValue: { fields: entityChange.document.fields }\n        });\n        const doc = MutableDocument.newFoundDocument(key, version, createTime, data);\n        const updatedTargetIds = entityChange.targetIds || [];\n        const removedTargetIds = entityChange.removedTargetIds || [];\n        watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);\n    }\n    else if ('documentDelete' in change) {\n        assertPresent(change.documentDelete);\n        const docDelete = change.documentDelete;\n        assertPresent(docDelete.document);\n        const key = fromName(serializer, docDelete.document);\n        const version = docDelete.readTime\n            ? fromVersion(docDelete.readTime)\n            : SnapshotVersion.min();\n        const doc = MutableDocument.newNoDocument(key, version);\n        const removedTargetIds = docDelete.removedTargetIds || [];\n        watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);\n    }\n    else if ('documentRemove' in change) {\n        assertPresent(change.documentRemove);\n        const docRemove = change.documentRemove;\n        assertPresent(docRemove.document);\n        const key = fromName(serializer, docRemove.document);\n        const removedTargetIds = docRemove.removedTargetIds || [];\n        watchChange = new DocumentWatchChange([], removedTargetIds, key, null);\n    }\n    else if ('filter' in change) {\n        // TODO(dimond): implement existence filter parsing with strategy.\n        assertPresent(change.filter);\n        const filter = change.filter;\n        assertPresent(filter.targetId);\n        const { count = 0, unchangedNames } = filter;\n        const existenceFilter = new ExistenceFilter(count, unchangedNames);\n        const targetId = filter.targetId;\n        watchChange = new ExistenceFilterChange(targetId, existenceFilter);\n    }\n    else {\n        return fail(0x2d51, { change });\n    }\n    return watchChange;\n}\nfunction fromWatchTargetChangeState(state) {\n    if (state === 'NO_CHANGE') {\n        return 0 /* WatchTargetChangeState.NoChange */;\n    }\n    else if (state === 'ADD') {\n        return 1 /* WatchTargetChangeState.Added */;\n    }\n    else if (state === 'REMOVE') {\n        return 2 /* WatchTargetChangeState.Removed */;\n    }\n    else if (state === 'CURRENT') {\n        return 3 /* WatchTargetChangeState.Current */;\n    }\n    else if (state === 'RESET') {\n        return 4 /* WatchTargetChangeState.Reset */;\n    }\n    else {\n        return fail(0x9991, { state });\n    }\n}\nfunction versionFromListenResponse(change) {\n    // We have only reached a consistent snapshot for the entire stream if there\n    // is a read_time set and it applies to all targets (i.e. the list of\n    // targets is empty). The backend is guaranteed to send such responses.\n    if (!('targetChange' in change)) {\n        return SnapshotVersion.min();\n    }\n    const targetChange = change.targetChange;\n    if (targetChange.targetIds && targetChange.targetIds.length) {\n        return SnapshotVersion.min();\n    }\n    if (!targetChange.readTime) {\n        return SnapshotVersion.min();\n    }\n    return fromVersion(targetChange.readTime);\n}\nfunction toMutation(serializer, mutation) {\n    let result;\n    if (mutation instanceof SetMutation) {\n        result = {\n            update: toMutationDocument(serializer, mutation.key, mutation.value)\n        };\n    }\n    else if (mutation instanceof DeleteMutation) {\n        result = { delete: toName(serializer, mutation.key) };\n    }\n    else if (mutation instanceof PatchMutation) {\n        result = {\n            update: toMutationDocument(serializer, mutation.key, mutation.data),\n            updateMask: toDocumentMask(mutation.fieldMask)\n        };\n    }\n    else if (mutation instanceof VerifyMutation) {\n        result = {\n            verify: toName(serializer, mutation.key)\n        };\n    }\n    else {\n        return fail(0x40d7, {\n            mutationType: mutation.type\n        });\n    }\n    if (mutation.fieldTransforms.length > 0) {\n        result.updateTransforms = mutation.fieldTransforms.map(transform => toFieldTransform(serializer, transform));\n    }\n    if (!mutation.precondition.isNone) {\n        result.currentDocument = toPrecondition(serializer, mutation.precondition);\n    }\n    return result;\n}\nfunction fromMutation(serializer, proto) {\n    const precondition = proto.currentDocument\n        ? fromPrecondition(proto.currentDocument)\n        : Precondition.none();\n    const fieldTransforms = proto.updateTransforms\n        ? proto.updateTransforms.map(transform => fromFieldTransform(serializer, transform))\n        : [];\n    if (proto.update) {\n        assertPresent(proto.update.name);\n        const key = fromName(serializer, proto.update.name);\n        const value = new ObjectValue({\n            mapValue: { fields: proto.update.fields }\n        });\n        if (proto.updateMask) {\n            const fieldMask = fromDocumentMask(proto.updateMask);\n            return new PatchMutation(key, value, fieldMask, precondition, fieldTransforms);\n        }\n        else {\n            return new SetMutation(key, value, precondition, fieldTransforms);\n        }\n    }\n    else if (proto.delete) {\n        const key = fromName(serializer, proto.delete);\n        return new DeleteMutation(key, precondition);\n    }\n    else if (proto.verify) {\n        const key = fromName(serializer, proto.verify);\n        return new VerifyMutation(key, precondition);\n    }\n    else {\n        return fail(0x05b7, { proto });\n    }\n}\nfunction toPrecondition(serializer, precondition) {\n    if (precondition.updateTime !== undefined) {\n        return {\n            updateTime: toVersion(serializer, precondition.updateTime)\n        };\n    }\n    else if (precondition.exists !== undefined) {\n        return { exists: precondition.exists };\n    }\n    else {\n        return fail(0x6b69);\n    }\n}\nfunction fromPrecondition(precondition) {\n    if (precondition.updateTime !== undefined) {\n        return Precondition.updateTime(fromVersion(precondition.updateTime));\n    }\n    else if (precondition.exists !== undefined) {\n        return Precondition.exists(precondition.exists);\n    }\n    else {\n        return Precondition.none();\n    }\n}\nfunction fromWriteResult(proto, commitTime) {\n    // NOTE: Deletes don't have an updateTime.\n    let version = proto.updateTime\n        ? fromVersion(proto.updateTime)\n        : fromVersion(commitTime);\n    if (version.isEqual(SnapshotVersion.min())) {\n        // The Firestore Emulator currently returns an update time of 0 for\n        // deletes of non-existing documents (rather than null). This breaks the\n        // test \"get deleted doc while offline with source=cache\" as NoDocuments\n        // with version 0 are filtered by IndexedDb's RemoteDocumentCache.\n        // TODO(#2149): Remove this when Emulator is fixed\n        version = fromVersion(commitTime);\n    }\n    return new MutationResult(version, proto.transformResults || []);\n}\nfunction fromWriteResults(protos, commitTime) {\n    if (protos && protos.length > 0) {\n        hardAssert(commitTime !== undefined, 0x3811);\n        return protos.map(proto => fromWriteResult(proto, commitTime));\n    }\n    else {\n        return [];\n    }\n}\nfunction toFieldTransform(serializer, fieldTransform) {\n    const transform = fieldTransform.transform;\n    if (transform instanceof ServerTimestampTransform) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            setToServerValue: 'REQUEST_TIME'\n        };\n    }\n    else if (transform instanceof ArrayUnionTransformOperation) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            appendMissingElements: {\n                values: transform.elements\n            }\n        };\n    }\n    else if (transform instanceof ArrayRemoveTransformOperation) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            removeAllFromArray: {\n                values: transform.elements\n            }\n        };\n    }\n    else if (transform instanceof NumericIncrementTransformOperation) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            increment: transform.operand\n        };\n    }\n    else {\n        throw fail(0x51c2, {\n            transform: fieldTransform.transform\n        });\n    }\n}\nfunction fromFieldTransform(serializer, proto) {\n    let transform = null;\n    if ('setToServerValue' in proto) {\n        hardAssert(proto.setToServerValue === 'REQUEST_TIME', 0x40f6, { proto });\n        transform = new ServerTimestampTransform();\n    }\n    else if ('appendMissingElements' in proto) {\n        const values = proto.appendMissingElements.values || [];\n        transform = new ArrayUnionTransformOperation(values);\n    }\n    else if ('removeAllFromArray' in proto) {\n        const values = proto.removeAllFromArray.values || [];\n        transform = new ArrayRemoveTransformOperation(values);\n    }\n    else if ('increment' in proto) {\n        transform = new NumericIncrementTransformOperation(serializer, proto.increment);\n    }\n    else {\n        fail(0x40c8, { proto });\n    }\n    const fieldPath = FieldPath$1.fromServerFormat(proto.fieldPath);\n    return new FieldTransform(fieldPath, transform);\n}\nfunction toDocumentsTarget(serializer, target) {\n    return { documents: [toQueryPath(serializer, target.path)] };\n}\nfunction fromDocumentsTarget(documentsTarget) {\n    const count = documentsTarget.documents.length;\n    hardAssert(count === 1, 0x07ae, {\n        count\n    });\n    const name = documentsTarget.documents[0];\n    return queryToTarget(newQueryForPath(fromQueryPath(name)));\n}\nfunction toQueryTarget(serializer, target) {\n    // Dissect the path into parent, collectionId, and optional key filter.\n    const queryTarget = { structuredQuery: {} };\n    const path = target.path;\n    let parent;\n    if (target.collectionGroup !== null) {\n        parent = path;\n        queryTarget.structuredQuery.from = [\n            {\n                collectionId: target.collectionGroup,\n                allDescendants: true\n            }\n        ];\n    }\n    else {\n        parent = path.popLast();\n        queryTarget.structuredQuery.from = [{ collectionId: path.lastSegment() }];\n    }\n    queryTarget.parent = toQueryPath(serializer, parent);\n    const where = toFilters(target.filters);\n    if (where) {\n        queryTarget.structuredQuery.where = where;\n    }\n    const orderBy = toOrder(target.orderBy);\n    if (orderBy) {\n        queryTarget.structuredQuery.orderBy = orderBy;\n    }\n    const limit = toInt32Proto(serializer, target.limit);\n    if (limit !== null) {\n        queryTarget.structuredQuery.limit = limit;\n    }\n    if (target.startAt) {\n        queryTarget.structuredQuery.startAt = toStartAtCursor(target.startAt);\n    }\n    if (target.endAt) {\n        queryTarget.structuredQuery.endAt = toEndAtCursor(target.endAt);\n    }\n    return { queryTarget, parent };\n}\nfunction toRunAggregationQueryRequest(serializer, target, aggregates, skipAliasing) {\n    const { queryTarget, parent } = toQueryTarget(serializer, target);\n    const aliasMap = {};\n    const aggregations = [];\n    let aggregationNum = 0;\n    aggregates.forEach(aggregate => {\n        // Map all client-side aliases to a unique short-form\n        // alias. This avoids issues with client-side aliases that\n        // exceed the 1500-byte string size limit.\n        const serverAlias = skipAliasing\n            ? aggregate.alias\n            : `aggregate_${aggregationNum++}`;\n        aliasMap[serverAlias] = aggregate.alias;\n        if (aggregate.aggregateType === 'count') {\n            aggregations.push({\n                alias: serverAlias,\n                count: {}\n            });\n        }\n        else if (aggregate.aggregateType === 'avg') {\n            aggregations.push({\n                alias: serverAlias,\n                avg: {\n                    field: toFieldPathReference(aggregate.fieldPath)\n                }\n            });\n        }\n        else if (aggregate.aggregateType === 'sum') {\n            aggregations.push({\n                alias: serverAlias,\n                sum: {\n                    field: toFieldPathReference(aggregate.fieldPath)\n                }\n            });\n        }\n    });\n    return {\n        request: {\n            structuredAggregationQuery: {\n                aggregations,\n                structuredQuery: queryTarget.structuredQuery\n            },\n            parent: queryTarget.parent\n        },\n        aliasMap,\n        parent\n    };\n}\nfunction convertQueryTargetToQuery(target) {\n    let path = fromQueryPath(target.parent);\n    const query = target.structuredQuery;\n    const fromCount = query.from ? query.from.length : 0;\n    let collectionGroup = null;\n    if (fromCount > 0) {\n        hardAssert(fromCount === 1, 0xfe26);\n        const from = query.from[0];\n        if (from.allDescendants) {\n            collectionGroup = from.collectionId;\n        }\n        else {\n            path = path.child(from.collectionId);\n        }\n    }\n    let filterBy = [];\n    if (query.where) {\n        filterBy = fromFilters(query.where);\n    }\n    let orderBy = [];\n    if (query.orderBy) {\n        orderBy = fromOrder(query.orderBy);\n    }\n    let limit = null;\n    if (query.limit) {\n        limit = fromInt32Proto(query.limit);\n    }\n    let startAt = null;\n    if (query.startAt) {\n        startAt = fromStartAtCursor(query.startAt);\n    }\n    let endAt = null;\n    if (query.endAt) {\n        endAt = fromEndAtCursor(query.endAt);\n    }\n    return newQuery(path, collectionGroup, orderBy, filterBy, limit, \"F\" /* LimitType.First */, startAt, endAt);\n}\nfunction fromQueryTarget(target) {\n    return queryToTarget(convertQueryTargetToQuery(target));\n}\nfunction toListenRequestLabels(serializer, targetData) {\n    const value = toLabel(targetData.purpose);\n    if (value == null) {\n        return null;\n    }\n    else {\n        return {\n            'goog-listen-tags': value\n        };\n    }\n}\nfunction toLabel(purpose) {\n    switch (purpose) {\n        case \"TargetPurposeListen\" /* TargetPurpose.Listen */:\n            return null;\n        case \"TargetPurposeExistenceFilterMismatch\" /* TargetPurpose.ExistenceFilterMismatch */:\n            return 'existence-filter-mismatch';\n        case \"TargetPurposeExistenceFilterMismatchBloom\" /* TargetPurpose.ExistenceFilterMismatchBloom */:\n            return 'existence-filter-mismatch-bloom';\n        case \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */:\n            return 'limbo-document';\n        default:\n            return fail(0x713b, { purpose });\n    }\n}\nfunction toTarget(serializer, targetData) {\n    let result;\n    const target = targetData.target;\n    if (targetIsDocumentTarget(target)) {\n        result = { documents: toDocumentsTarget(serializer, target) };\n    }\n    else {\n        result = { query: toQueryTarget(serializer, target).queryTarget };\n    }\n    result.targetId = targetData.targetId;\n    if (targetData.resumeToken.approximateByteSize() > 0) {\n        result.resumeToken = toBytes(serializer, targetData.resumeToken);\n        const expectedCount = toInt32Proto(serializer, targetData.expectedCount);\n        if (expectedCount !== null) {\n            result.expectedCount = expectedCount;\n        }\n    }\n    else if (targetData.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {\n        // TODO(wuandy): Consider removing above check because it is most likely true.\n        // Right now, many tests depend on this behaviour though (leaving min() out\n        // of serialization).\n        result.readTime = toTimestamp(serializer, targetData.snapshotVersion.toTimestamp());\n        const expectedCount = toInt32Proto(serializer, targetData.expectedCount);\n        if (expectedCount !== null) {\n            result.expectedCount = expectedCount;\n        }\n    }\n    return result;\n}\nfunction toFilters(filters) {\n    if (filters.length === 0) {\n        return;\n    }\n    return toFilter(CompositeFilter.create(filters, \"and\" /* CompositeOperator.AND */));\n}\nfunction fromFilters(filter) {\n    const result = fromFilter(filter);\n    if (result instanceof CompositeFilter &&\n        compositeFilterIsFlatConjunction(result)) {\n        return result.getFilters();\n    }\n    return [result];\n}\nfunction fromFilter(filter) {\n    if (filter.unaryFilter !== undefined) {\n        return fromUnaryFilter(filter);\n    }\n    else if (filter.fieldFilter !== undefined) {\n        return fromFieldFilter(filter);\n    }\n    else if (filter.compositeFilter !== undefined) {\n        return fromCompositeFilter(filter);\n    }\n    else {\n        return fail(0x7591, { filter });\n    }\n}\nfunction toOrder(orderBys) {\n    if (orderBys.length === 0) {\n        return;\n    }\n    return orderBys.map(order => toPropertyOrder(order));\n}\nfunction fromOrder(orderBys) {\n    return orderBys.map(order => fromPropertyOrder(order));\n}\nfunction toStartAtCursor(cursor) {\n    return {\n        before: cursor.inclusive,\n        values: cursor.position\n    };\n}\nfunction toEndAtCursor(cursor) {\n    return {\n        before: !cursor.inclusive,\n        values: cursor.position\n    };\n}\nfunction fromStartAtCursor(cursor) {\n    const inclusive = !!cursor.before;\n    const position = cursor.values || [];\n    return new Bound(position, inclusive);\n}\nfunction fromEndAtCursor(cursor) {\n    const inclusive = !cursor.before;\n    const position = cursor.values || [];\n    return new Bound(position, inclusive);\n}\n// visible for testing\nfunction toDirection(dir) {\n    return DIRECTIONS[dir];\n}\n// visible for testing\nfunction fromDirection(dir) {\n    switch (dir) {\n        case 'ASCENDING':\n            return \"asc\" /* Direction.ASCENDING */;\n        case 'DESCENDING':\n            return \"desc\" /* Direction.DESCENDING */;\n        default:\n            return undefined;\n    }\n}\n// visible for testing\nfunction toOperatorName(op) {\n    return OPERATORS[op];\n}\nfunction toCompositeOperatorName(op) {\n    return COMPOSITE_OPERATORS[op];\n}\nfunction fromOperatorName(op) {\n    switch (op) {\n        case 'EQUAL':\n            return \"==\" /* Operator.EQUAL */;\n        case 'NOT_EQUAL':\n            return \"!=\" /* Operator.NOT_EQUAL */;\n        case 'GREATER_THAN':\n            return \">\" /* Operator.GREATER_THAN */;\n        case 'GREATER_THAN_OR_EQUAL':\n            return \">=\" /* Operator.GREATER_THAN_OR_EQUAL */;\n        case 'LESS_THAN':\n            return \"<\" /* Operator.LESS_THAN */;\n        case 'LESS_THAN_OR_EQUAL':\n            return \"<=\" /* Operator.LESS_THAN_OR_EQUAL */;\n        case 'ARRAY_CONTAINS':\n            return \"array-contains\" /* Operator.ARRAY_CONTAINS */;\n        case 'IN':\n            return \"in\" /* Operator.IN */;\n        case 'NOT_IN':\n            return \"not-in\" /* Operator.NOT_IN */;\n        case 'ARRAY_CONTAINS_ANY':\n            return \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\n        case 'OPERATOR_UNSPECIFIED':\n            return fail(0xe2fe);\n        default:\n            return fail(0xc54a);\n    }\n}\nfunction fromCompositeOperatorName(op) {\n    switch (op) {\n        case 'AND':\n            return \"and\" /* CompositeOperator.AND */;\n        case 'OR':\n            return \"or\" /* CompositeOperator.OR */;\n        default:\n            return fail(0x0402);\n    }\n}\nfunction toFieldPathReference(path) {\n    return { fieldPath: path.canonicalString() };\n}\nfunction fromFieldPathReference(fieldReference) {\n    return FieldPath$1.fromServerFormat(fieldReference.fieldPath);\n}\n// visible for testing\nfunction toPropertyOrder(orderBy) {\n    return {\n        field: toFieldPathReference(orderBy.field),\n        direction: toDirection(orderBy.dir)\n    };\n}\nfunction fromPropertyOrder(orderBy) {\n    return new OrderBy(fromFieldPathReference(orderBy.field), fromDirection(orderBy.direction));\n}\n// visible for testing\nfunction toFilter(filter) {\n    if (filter instanceof FieldFilter) {\n        return toUnaryOrFieldFilter(filter);\n    }\n    else if (filter instanceof CompositeFilter) {\n        return toCompositeFilter(filter);\n    }\n    else {\n        return fail(0xd65d, { filter });\n    }\n}\nfunction toCompositeFilter(filter) {\n    const protos = filter.getFilters().map(filter => toFilter(filter));\n    if (protos.length === 1) {\n        return protos[0];\n    }\n    return {\n        compositeFilter: {\n            op: toCompositeOperatorName(filter.op),\n            filters: protos\n        }\n    };\n}\nfunction toUnaryOrFieldFilter(filter) {\n    if (filter.op === \"==\" /* Operator.EQUAL */) {\n        if (isNanValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: 'IS_NAN'\n                }\n            };\n        }\n        else if (isNullValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: 'IS_NULL'\n                }\n            };\n        }\n    }\n    else if (filter.op === \"!=\" /* Operator.NOT_EQUAL */) {\n        if (isNanValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: 'IS_NOT_NAN'\n                }\n            };\n        }\n        else if (isNullValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: 'IS_NOT_NULL'\n                }\n            };\n        }\n    }\n    return {\n        fieldFilter: {\n            field: toFieldPathReference(filter.field),\n            op: toOperatorName(filter.op),\n            value: filter.value\n        }\n    };\n}\nfunction fromUnaryFilter(filter) {\n    switch (filter.unaryFilter.op) {\n        case 'IS_NAN':\n            const nanField = fromFieldPathReference(filter.unaryFilter.field);\n            return FieldFilter.create(nanField, \"==\" /* Operator.EQUAL */, {\n                doubleValue: NaN\n            });\n        case 'IS_NULL':\n            const nullField = fromFieldPathReference(filter.unaryFilter.field);\n            return FieldFilter.create(nullField, \"==\" /* Operator.EQUAL */, {\n                nullValue: 'NULL_VALUE'\n            });\n        case 'IS_NOT_NAN':\n            const notNanField = fromFieldPathReference(filter.unaryFilter.field);\n            return FieldFilter.create(notNanField, \"!=\" /* Operator.NOT_EQUAL */, {\n                doubleValue: NaN\n            });\n        case 'IS_NOT_NULL':\n            const notNullField = fromFieldPathReference(filter.unaryFilter.field);\n            return FieldFilter.create(notNullField, \"!=\" /* Operator.NOT_EQUAL */, {\n                nullValue: 'NULL_VALUE'\n            });\n        case 'OPERATOR_UNSPECIFIED':\n            return fail(0xef81);\n        default:\n            return fail(0xed36);\n    }\n}\nfunction fromFieldFilter(filter) {\n    return FieldFilter.create(fromFieldPathReference(filter.fieldFilter.field), fromOperatorName(filter.fieldFilter.op), filter.fieldFilter.value);\n}\nfunction fromCompositeFilter(filter) {\n    return CompositeFilter.create(filter.compositeFilter.filters.map(filter => fromFilter(filter)), fromCompositeOperatorName(filter.compositeFilter.op));\n}\nfunction toDocumentMask(fieldMask) {\n    const canonicalFields = [];\n    fieldMask.fields.forEach(field => canonicalFields.push(field.canonicalString()));\n    return {\n        fieldPaths: canonicalFields\n    };\n}\nfunction fromDocumentMask(proto) {\n    const paths = proto.fieldPaths || [];\n    return new FieldMask(paths.map(path => FieldPath$1.fromServerFormat(path)));\n}\nfunction isValidResourceName(path) {\n    // Resource names have at least 4 components (project ID, database ID)\n    return (path.length >= 4 &&\n        path.get(0) === 'projects' &&\n        path.get(2) === 'databases');\n}\nfunction isProtoValueSerializable(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvalue) {\n    return (!!value &&\n        typeof value._toProto === 'function' &&\n        value._protoValueType === 'ProtoValue');\n}\nfunction toMapValue(serializer, input) {\n    const map = { fields: {} };\n    input.forEach((exp, key) => {\n        if (typeof key !== 'string') {\n            throw new Error(`Cannot encode map with non-string key: ${key}`);\n        }\n        map.fields[key] = exp._toProto(serializer);\n    });\n    return {\n        mapValue: map\n    };\n}\nfunction toStringValue(value) {\n    return { stringValue: value };\n}\nfunction toPipelineValue(value) {\n    return { pipelineValue: value };\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An immutable set of metadata that the local store tracks for each target.\n */\nclass TargetData {\n    constructor(\n    /** The target being listened to. */\n    target, \n    /**\n     * The target ID to which the target corresponds; Assigned by the\n     * LocalStore for user listens and by the SyncEngine for limbo watches.\n     */\n    targetId, \n    /** The purpose of the target. */\n    purpose, \n    /**\n     * The sequence number of the last transaction during which this target data\n     * was modified.\n     */\n    sequenceNumber, \n    /** The latest snapshot version seen for this target. */\n    snapshotVersion = SnapshotVersion.min(), \n    /**\n     * The maximum snapshot version at which the associated view\n     * contained no limbo documents.\n     */\n    lastLimboFreeSnapshotVersion = SnapshotVersion.min(), \n    /**\n     * An opaque, server-assigned token that allows watching a target to be\n     * resumed after disconnecting without retransmitting all the data that\n     * matches the target. The resume token essentially identifies a point in\n     * time from which the server should resume sending results.\n     */\n    resumeToken = ByteString.EMPTY_BYTE_STRING, \n    /**\n     * The number of documents that last matched the query at the resume token or\n     * read time. Documents are counted only when making a listen request with\n     * resume token or read time, otherwise, keep it null.\n     */\n    expectedCount = null) {\n        this.target = target;\n        this.targetId = targetId;\n        this.purpose = purpose;\n        this.sequenceNumber = sequenceNumber;\n        this.snapshotVersion = snapshotVersion;\n        this.lastLimboFreeSnapshotVersion = lastLimboFreeSnapshotVersion;\n        this.resumeToken = resumeToken;\n        this.expectedCount = expectedCount;\n    }\n    /** Creates a new target data instance with an updated sequence number. */\n    withSequenceNumber(sequenceNumber) {\n        return new TargetData(this.target, this.targetId, this.purpose, sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);\n    }\n    /**\n     * Creates a new target data instance with an updated resume token and\n     * snapshot version.\n     */\n    withResumeToken(resumeToken, snapshotVersion) {\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, snapshotVersion, this.lastLimboFreeSnapshotVersion, resumeToken, \n        /* expectedCount= */ null);\n    }\n    /**\n     * Creates a new target data instance with an updated expected count.\n     */\n    withExpectedCount(expectedCount) {\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, expectedCount);\n    }\n    /**\n     * Creates a new target data instance with an updated last limbo free\n     * snapshot version number.\n     */\n    withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion) {\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Serializer for values stored in the LocalStore. */\nclass LocalSerializer {\n    constructor(remoteSerializer) {\n        this.remoteSerializer = remoteSerializer;\n    }\n}\n/** Decodes a remote document from storage locally to a Document. */\nfunction fromDbRemoteDocument(localSerializer, remoteDoc) {\n    let doc;\n    if (remoteDoc.document) {\n        doc = fromDocument(localSerializer.remoteSerializer, remoteDoc.document, !!remoteDoc.hasCommittedMutations);\n    }\n    else if (remoteDoc.noDocument) {\n        const key = DocumentKey.fromSegments(remoteDoc.noDocument.path);\n        const version = fromDbTimestamp(remoteDoc.noDocument.readTime);\n        doc = MutableDocument.newNoDocument(key, version);\n        if (remoteDoc.hasCommittedMutations) {\n            doc.setHasCommittedMutations();\n        }\n    }\n    else if (remoteDoc.unknownDocument) {\n        const key = DocumentKey.fromSegments(remoteDoc.unknownDocument.path);\n        const version = fromDbTimestamp(remoteDoc.unknownDocument.version);\n        doc = MutableDocument.newUnknownDocument(key, version);\n    }\n    else {\n        return fail(0xdd85);\n    }\n    if (remoteDoc.readTime) {\n        doc.setReadTime(fromDbTimestampKey(remoteDoc.readTime));\n    }\n    return doc;\n}\n/** Encodes a document for storage locally. */\nfunction toDbRemoteDocument(localSerializer, document) {\n    const key = document.key;\n    const remoteDoc = {\n        prefixPath: key.getCollectionPath().popLast().toArray(),\n        collectionGroup: key.collectionGroup,\n        documentId: key.path.lastSegment(),\n        readTime: toDbTimestampKey(document.readTime),\n        hasCommittedMutations: document.hasCommittedMutations\n    };\n    if (document.isFoundDocument()) {\n        remoteDoc.document = toDocument(localSerializer.remoteSerializer, document);\n    }\n    else if (document.isNoDocument()) {\n        remoteDoc.noDocument = {\n            path: key.path.toArray(),\n            readTime: toDbTimestamp(document.version)\n        };\n    }\n    else if (document.isUnknownDocument()) {\n        remoteDoc.unknownDocument = {\n            path: key.path.toArray(),\n            version: toDbTimestamp(document.version)\n        };\n    }\n    else {\n        return fail(0xe230, { document });\n    }\n    return remoteDoc;\n}\nfunction toDbTimestampKey(snapshotVersion) {\n    const timestamp = snapshotVersion.toTimestamp();\n    return [timestamp.seconds, timestamp.nanoseconds];\n}\nfunction fromDbTimestampKey(dbTimestampKey) {\n    const timestamp = new Timestamp(dbTimestampKey[0], dbTimestampKey[1]);\n    return SnapshotVersion.fromTimestamp(timestamp);\n}\nfunction toDbTimestamp(snapshotVersion) {\n    const timestamp = snapshotVersion.toTimestamp();\n    return { seconds: timestamp.seconds, nanoseconds: timestamp.nanoseconds };\n}\nfunction fromDbTimestamp(dbTimestamp) {\n    const timestamp = new Timestamp(dbTimestamp.seconds, dbTimestamp.nanoseconds);\n    return SnapshotVersion.fromTimestamp(timestamp);\n}\n/** Encodes a batch of mutations into a DbMutationBatch for local storage. */\nfunction toDbMutationBatch(localSerializer, userId, batch) {\n    const serializedBaseMutations = batch.baseMutations.map(m => toMutation(localSerializer.remoteSerializer, m));\n    const serializedMutations = batch.mutations.map(m => toMutation(localSerializer.remoteSerializer, m));\n    return {\n        userId,\n        batchId: batch.batchId,\n        localWriteTimeMs: batch.localWriteTime.toMillis(),\n        baseMutations: serializedBaseMutations,\n        mutations: serializedMutations\n    };\n}\n/** Decodes a DbMutationBatch into a MutationBatch */\nfunction fromDbMutationBatch(localSerializer, dbBatch) {\n    const baseMutations = (dbBatch.baseMutations || []).map(m => fromMutation(localSerializer.remoteSerializer, m));\n    // Squash old transform mutations into existing patch or set mutations.\n    // The replacement of representing `transforms` with `update_transforms`\n    // on the SDK means that old `transform` mutations stored in IndexedDB need\n    // to be updated to `update_transforms`.\n    // TODO(b/174608374): Remove this code once we perform a schema migration.\n    for (let i = 0; i < dbBatch.mutations.length - 1; ++i) {\n        const currentMutation = dbBatch.mutations[i];\n        const hasTransform = i + 1 < dbBatch.mutations.length &&\n            dbBatch.mutations[i + 1].transform !== undefined;\n        if (hasTransform) {\n            const transformMutation = dbBatch.mutations[i + 1];\n            currentMutation.updateTransforms =\n                transformMutation.transform.fieldTransforms;\n            dbBatch.mutations.splice(i + 1, 1);\n            ++i;\n        }\n    }\n    const mutations = dbBatch.mutations.map(m => fromMutation(localSerializer.remoteSerializer, m));\n    const timestamp = Timestamp.fromMillis(dbBatch.localWriteTimeMs);\n    return new MutationBatch(dbBatch.batchId, timestamp, baseMutations, mutations);\n}\n/** Decodes a DbTarget into TargetData */\nfunction fromDbTarget(dbTarget) {\n    const version = fromDbTimestamp(dbTarget.readTime);\n    const lastLimboFreeSnapshotVersion = dbTarget.lastLimboFreeSnapshotVersion !== undefined\n        ? fromDbTimestamp(dbTarget.lastLimboFreeSnapshotVersion)\n        : SnapshotVersion.min();\n    let target;\n    if (isDocumentQuery(dbTarget.query)) {\n        target = fromDocumentsTarget(dbTarget.query);\n    }\n    else {\n        target = fromQueryTarget(dbTarget.query);\n    }\n    return new TargetData(target, dbTarget.targetId, \"TargetPurposeListen\" /* TargetPurpose.Listen */, dbTarget.lastListenSequenceNumber, version, lastLimboFreeSnapshotVersion, ByteString.fromBase64String(dbTarget.resumeToken));\n}\n/** Encodes TargetData into a DbTarget for storage locally. */\nfunction toDbTarget(localSerializer, targetData) {\n    const dbTimestamp = toDbTimestamp(targetData.snapshotVersion);\n    const dbLastLimboFreeTimestamp = toDbTimestamp(targetData.lastLimboFreeSnapshotVersion);\n    let queryProto;\n    if (targetIsDocumentTarget(targetData.target)) {\n        queryProto = toDocumentsTarget(localSerializer.remoteSerializer, targetData.target);\n    }\n    else {\n        queryProto = toQueryTarget(localSerializer.remoteSerializer, targetData.target).queryTarget;\n    }\n    // We can't store the resumeToken as a ByteString in IndexedDb, so we\n    // convert it to a base64 string for storage.\n    const resumeToken = targetData.resumeToken.toBase64();\n    // lastListenSequenceNumber is always 0 until we do real GC.\n    return {\n        targetId: targetData.targetId,\n        canonicalId: canonifyTarget(targetData.target),\n        readTime: dbTimestamp,\n        resumeToken,\n        lastListenSequenceNumber: targetData.sequenceNumber,\n        lastLimboFreeSnapshotVersion: dbLastLimboFreeTimestamp,\n        query: queryProto\n    };\n}\n/**\n * A helper function for figuring out what kind of query has been stored.\n */\nfunction isDocumentQuery(dbQuery) {\n    return dbQuery.documents !== undefined;\n}\n/** Encodes a DbBundle to a BundleMetadata object. */\nfunction fromDbBundle(dbBundle) {\n    return {\n        id: dbBundle.bundleId,\n        createTime: fromDbTimestamp(dbBundle.createTime),\n        version: dbBundle.version\n    };\n}\n/** Encodes a BundleMetadata to a DbBundle. */\nfunction toDbBundle(metadata) {\n    return {\n        bundleId: metadata.id,\n        createTime: toDbTimestamp(fromVersion(metadata.createTime)),\n        version: metadata.version\n    };\n}\n/** Encodes a DbNamedQuery to a NamedQuery. */\nfunction fromDbNamedQuery(dbNamedQuery) {\n    return {\n        name: dbNamedQuery.name,\n        query: fromBundledQuery(dbNamedQuery.bundledQuery),\n        readTime: fromDbTimestamp(dbNamedQuery.readTime)\n    };\n}\n/** Encodes a NamedQuery from a bundle proto to a DbNamedQuery. */\nfunction toDbNamedQuery(query) {\n    return {\n        name: query.name,\n        readTime: toDbTimestamp(fromVersion(query.readTime)),\n        bundledQuery: query.bundledQuery\n    };\n}\n/**\n * Encodes a `BundledQuery` from bundle proto to a Query object.\n *\n * This reconstructs the original query used to build the bundle being loaded,\n * including features exists only in SDKs (for example: limit-to-last).\n */\nfunction fromBundledQuery(bundledQuery) {\n    const query = convertQueryTargetToQuery({\n        parent: bundledQuery.parent,\n        structuredQuery: bundledQuery.structuredQuery\n    });\n    if (bundledQuery.limitType === 'LAST') {\n        return queryWithLimit(query, query.limit, \"L\" /* LimitType.Last */);\n    }\n    return query;\n}\n/** Encodes a NamedQuery proto object to a NamedQuery model object. */\nfunction fromProtoNamedQuery(namedQuery) {\n    return {\n        name: namedQuery.name,\n        query: fromBundledQuery(namedQuery.bundledQuery),\n        readTime: fromVersion(namedQuery.readTime)\n    };\n}\n/** Decodes a BundleMetadata proto into a BundleMetadata object. */\nfunction fromBundleMetadata(metadata) {\n    return {\n        id: metadata.id,\n        version: metadata.version,\n        createTime: fromVersion(metadata.createTime)\n    };\n}\n/** Encodes a DbDocumentOverlay object to an Overlay model object. */\nfunction fromDbDocumentOverlay(localSerializer, dbDocumentOverlay) {\n    return new Overlay(dbDocumentOverlay.largestBatchId, fromMutation(localSerializer.remoteSerializer, dbDocumentOverlay.overlayMutation));\n}\n/** Decodes an Overlay model object into a DbDocumentOverlay object. */\nfunction toDbDocumentOverlay(localSerializer, userId, overlay) {\n    const [_, collectionPath, documentId] = toDbDocumentOverlayKey(userId, overlay.mutation.key);\n    return {\n        userId,\n        collectionPath,\n        documentId,\n        collectionGroup: overlay.mutation.key.getCollectionGroup(),\n        largestBatchId: overlay.largestBatchId,\n        overlayMutation: toMutation(localSerializer.remoteSerializer, overlay.mutation)\n    };\n}\n/**\n * Returns the DbDocumentOverlayKey corresponding to the given user and\n * document key.\n */\nfunction toDbDocumentOverlayKey(userId, docKey) {\n    const docId = docKey.path.lastSegment();\n    const collectionPath = encodeResourcePath(docKey.path.popLast());\n    return [userId, collectionPath, docId];\n}\nfunction toDbIndexConfiguration(index) {\n    return {\n        indexId: index.indexId,\n        collectionGroup: index.collectionGroup,\n        fields: index.fields.map(s => [s.fieldPath.canonicalString(), s.kind])\n    };\n}\nfunction fromDbIndexConfiguration(index, state) {\n    const decodedState = state\n        ? new IndexState(state.sequenceNumber, new IndexOffset(fromDbTimestamp(state.readTime), new DocumentKey(decodeResourcePath(state.documentKey)), state.largestBatchId))\n        : IndexState.empty();\n    const decodedSegments = index.fields.map(([fieldPath, kind]) => new IndexSegment(FieldPath$1.fromServerFormat(fieldPath), kind));\n    return new FieldIndex(index.indexId, index.collectionGroup, decodedSegments, decodedState);\n}\nfunction toDbIndexState(indexId, uid, sequenceNumber, offset) {\n    return {\n        indexId,\n        uid,\n        sequenceNumber,\n        readTime: toDbTimestamp(offset.readTime),\n        documentKey: encodeResourcePath(offset.documentKey.path),\n        largestBatchId: offset.largestBatchId\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass IndexedDbBundleCache {\n    getBundleMetadata(transaction, bundleId) {\n        return bundlesStore(transaction)\n            .get(bundleId)\n            .next(bundle => {\n            if (bundle) {\n                return fromDbBundle(bundle);\n            }\n            return undefined;\n        });\n    }\n    saveBundleMetadata(transaction, bundleMetadata) {\n        return bundlesStore(transaction).put(toDbBundle(bundleMetadata));\n    }\n    getNamedQuery(transaction, queryName) {\n        return namedQueriesStore(transaction)\n            .get(queryName)\n            .next(query => {\n            if (query) {\n                return fromDbNamedQuery(query);\n            }\n            return undefined;\n        });\n    }\n    saveNamedQuery(transaction, query) {\n        return namedQueriesStore(transaction).put(toDbNamedQuery(query));\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the bundles object store.\n */\nfunction bundlesStore(txn) {\n    return getStore(txn, DbBundleStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the namedQueries object store.\n */\nfunction namedQueriesStore(txn) {\n    return getStore(txn, DbNamedQueryStore);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Implementation of DocumentOverlayCache using IndexedDb.\n */\nclass IndexedDbDocumentOverlayCache {\n    /**\n     * @param serializer - The document serializer.\n     * @param userId - The userId for which we are accessing overlays.\n     */\n    constructor(serializer, userId) {\n        this.serializer = serializer;\n        this.userId = userId;\n    }\n    static forUser(serializer, user) {\n        const userId = user.uid || '';\n        return new IndexedDbDocumentOverlayCache(serializer, userId);\n    }\n    getOverlay(transaction, key) {\n        return documentOverlayStore(transaction)\n            .get(toDbDocumentOverlayKey(this.userId, key))\n            .next(dbOverlay => {\n            if (dbOverlay) {\n                return fromDbDocumentOverlay(this.serializer, dbOverlay);\n            }\n            return null;\n        });\n    }\n    getOverlays(transaction, keys) {\n        const result = newOverlayMap();\n        return PersistencePromise.forEach(keys, (key) => {\n            return this.getOverlay(transaction, key).next(overlay => {\n                if (overlay !== null) {\n                    result.set(key, overlay);\n                }\n            });\n        }).next(() => result);\n    }\n    saveOverlays(transaction, largestBatchId, overlays) {\n        const promises = [];\n        overlays.forEach((_, mutation) => {\n            const overlay = new Overlay(largestBatchId, mutation);\n            promises.push(this.saveOverlay(transaction, overlay));\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    removeOverlaysForBatchId(transaction, documentKeys, batchId) {\n        const collectionPaths = new Set();\n        // Get the set of unique collection paths.\n        documentKeys.forEach(key => collectionPaths.add(encodeResourcePath(key.getCollectionPath())));\n        const promises = [];\n        collectionPaths.forEach(collectionPath => {\n            const range = IDBKeyRange.bound([this.userId, collectionPath, batchId], [this.userId, collectionPath, batchId + 1], \n            /*lowerOpen=*/ false, \n            /*upperOpen=*/ true);\n            promises.push(documentOverlayStore(transaction).deleteAll(DbDocumentOverlayCollectionPathOverlayIndex, range));\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    getOverlaysForCollection(transaction, collection, sinceBatchId) {\n        const result = newOverlayMap();\n        const collectionPath = encodeResourcePath(collection);\n        // We want batch IDs larger than `sinceBatchId`, and so the lower bound\n        // is not inclusive.\n        const range = IDBKeyRange.bound([this.userId, collectionPath, sinceBatchId], [this.userId, collectionPath, Number.POSITIVE_INFINITY], \n        /*lowerOpen=*/ true);\n        return documentOverlayStore(transaction)\n            .loadAll(DbDocumentOverlayCollectionPathOverlayIndex, range)\n            .next(dbOverlays => {\n            for (const dbOverlay of dbOverlays) {\n                const overlay = fromDbDocumentOverlay(this.serializer, dbOverlay);\n                result.set(overlay.getKey(), overlay);\n            }\n            return result;\n        });\n    }\n    getOverlaysForCollectionGroup(transaction, collectionGroup, sinceBatchId, count) {\n        const result = newOverlayMap();\n        let currentBatchId = undefined;\n        // We want batch IDs larger than `sinceBatchId`, and so the lower bound\n        // is not inclusive.\n        const range = IDBKeyRange.bound([this.userId, collectionGroup, sinceBatchId], [this.userId, collectionGroup, Number.POSITIVE_INFINITY], \n        /*lowerOpen=*/ true);\n        return documentOverlayStore(transaction)\n            .iterate({\n            index: DbDocumentOverlayCollectionGroupOverlayIndex,\n            range\n        }, (_, dbOverlay, control) => {\n            // We do not want to return partial batch overlays, even if the size\n            // of the result set exceeds the given `count` argument. Therefore, we\n            // continue to aggregate results even after the result size exceeds\n            // `count` if there are more overlays from the `currentBatchId`.\n            const overlay = fromDbDocumentOverlay(this.serializer, dbOverlay);\n            if (result.size() < count ||\n                overlay.largestBatchId === currentBatchId) {\n                result.set(overlay.getKey(), overlay);\n                currentBatchId = overlay.largestBatchId;\n            }\n            else {\n                control.done();\n            }\n        })\n            .next(() => result);\n    }\n    saveOverlay(transaction, overlay) {\n        return documentOverlayStore(transaction).put(toDbDocumentOverlay(this.serializer, this.userId, overlay));\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the document overlay object store.\n */\nfunction documentOverlayStore(txn) {\n    return getStore(txn, DbDocumentOverlayStore);\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass IndexedDbGlobalsCache {\n    globalsStore(txn) {\n        return getStore(txn, DbGlobalsStore);\n    }\n    getSessionToken(txn) {\n        const globals = this.globalsStore(txn);\n        return globals.get('sessionToken').next(global => {\n            const value = global?.value;\n            return value\n                ? ByteString.fromUint8Array(value)\n                : ByteString.EMPTY_BYTE_STRING;\n        });\n    }\n    setSessionToken(txn, sessionToken) {\n        const globals = this.globalsStore(txn);\n        return globals.put({\n            name: 'sessionToken',\n            value: sessionToken.toUint8Array()\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Note: This code is copied from the backend. Code that is not used by\n// Firestore was removed.\nconst INDEX_TYPE_NULL = 5;\nconst INDEX_TYPE_BOOLEAN = 10;\nconst INDEX_TYPE_NAN = 13;\nconst INDEX_TYPE_NUMBER = 15;\nconst INDEX_TYPE_TIMESTAMP = 20;\nconst INDEX_TYPE_STRING = 25;\nconst INDEX_TYPE_BLOB = 30;\nconst INDEX_TYPE_REFERENCE = 37;\nconst INDEX_TYPE_GEOPOINT = 45;\nconst INDEX_TYPE_ARRAY = 50;\nconst INDEX_TYPE_VECTOR = 53;\nconst INDEX_TYPE_MAP = 55;\nconst INDEX_TYPE_REFERENCE_SEGMENT = 60;\n// A terminator that indicates that a truncatable value was not truncated.\n// This must be smaller than all other type labels.\nconst NOT_TRUNCATED = 2;\n/** Firestore index value writer.  */\nclass FirestoreIndexValueWriter {\n    constructor() { }\n    // The write methods below short-circuit writing terminators for values\n    // containing a (terminating) truncated value.\n    //\n    // As an example, consider the resulting encoding for:\n    //\n    // [\"bar\", [2, \"foo\"]] -> (STRING, \"bar\", TERM, ARRAY, NUMBER, 2, STRING, \"foo\", TERM, TERM, TERM)\n    // [\"bar\", [2, truncated(\"foo\")]] -> (STRING, \"bar\", TERM, ARRAY, NUMBER, 2, STRING, \"foo\", TRUNC)\n    // [\"bar\", truncated([\"foo\"])] -> (STRING, \"bar\", TERM, ARRAY. STRING, \"foo\", TERM, TRUNC)\n    /** Writes an index value.  */\n    writeIndexValue(value, encoder) {\n        this.writeIndexValueAux(value, encoder);\n        // Write separator to split index values\n        // (see go/firestore-storage-format#encodings).\n        encoder.writeInfinity();\n    }\n    writeIndexValueAux(indexValue, encoder) {\n        if ('nullValue' in indexValue) {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_NULL);\n        }\n        else if ('booleanValue' in indexValue) {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_BOOLEAN);\n            encoder.writeNumber(indexValue.booleanValue ? 1 : 0);\n        }\n        else if ('integerValue' in indexValue) {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\n            encoder.writeNumber(normalizeNumber(indexValue.integerValue));\n        }\n        else if ('doubleValue' in indexValue) {\n            const n = normalizeNumber(indexValue.doubleValue);\n            if (isNaN(n)) {\n                this.writeValueTypeLabel(encoder, INDEX_TYPE_NAN);\n            }\n            else {\n                this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\n                if (isNegativeZero(n)) {\n                    // -0.0, 0 and 0.0 are all considered the same\n                    encoder.writeNumber(0.0);\n                }\n                else {\n                    encoder.writeNumber(n);\n                }\n            }\n        }\n        else if ('timestampValue' in indexValue) {\n            let timestamp = indexValue.timestampValue;\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_TIMESTAMP);\n            if (typeof timestamp === 'string') {\n                timestamp = normalizeTimestamp(timestamp);\n            }\n            encoder.writeString(`${timestamp.seconds || ''}`);\n            encoder.writeNumber(timestamp.nanos || 0);\n        }\n        else if ('stringValue' in indexValue) {\n            this.writeIndexString(indexValue.stringValue, encoder);\n            this.writeTruncationMarker(encoder);\n        }\n        else if ('bytesValue' in indexValue) {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_BLOB);\n            encoder.writeBytes(normalizeByteString(indexValue.bytesValue));\n            this.writeTruncationMarker(encoder);\n        }\n        else if ('referenceValue' in indexValue) {\n            this.writeIndexEntityRef(indexValue.referenceValue, encoder);\n        }\n        else if ('geoPointValue' in indexValue) {\n            const geoPoint = indexValue.geoPointValue;\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_GEOPOINT);\n            encoder.writeNumber(geoPoint.latitude || 0);\n            encoder.writeNumber(geoPoint.longitude || 0);\n        }\n        else if ('mapValue' in indexValue) {\n            if (isMaxValue(indexValue)) {\n                this.writeValueTypeLabel(encoder, Number.MAX_SAFE_INTEGER);\n            }\n            else if (isVectorValue(indexValue)) {\n                this.writeIndexVector(indexValue.mapValue, encoder);\n            }\n            else {\n                this.writeIndexMap(indexValue.mapValue, encoder);\n                this.writeTruncationMarker(encoder);\n            }\n        }\n        else if ('arrayValue' in indexValue) {\n            this.writeIndexArray(indexValue.arrayValue, encoder);\n            this.writeTruncationMarker(encoder);\n        }\n        else {\n            fail(0x4a4e, { indexValue });\n        }\n    }\n    writeIndexString(stringIndexValue, encoder) {\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_STRING);\n        this.writeUnlabeledIndexString(stringIndexValue, encoder);\n    }\n    writeUnlabeledIndexString(stringIndexValue, encoder) {\n        encoder.writeString(stringIndexValue);\n    }\n    writeIndexMap(mapIndexValue, encoder) {\n        const map = mapIndexValue.fields || {};\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_MAP);\n        for (const key of Object.keys(map)) {\n            this.writeIndexString(key, encoder);\n            this.writeIndexValueAux(map[key], encoder);\n        }\n    }\n    writeIndexVector(mapIndexValue, encoder) {\n        const map = mapIndexValue.fields || {};\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_VECTOR);\n        // Vectors sort first by length\n        const key = VECTOR_MAP_VECTORS_KEY;\n        const length = map[key].arrayValue?.values?.length || 0;\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\n        encoder.writeNumber(normalizeNumber(length));\n        // Vectors then sort by position value\n        this.writeIndexString(key, encoder);\n        this.writeIndexValueAux(map[key], encoder);\n    }\n    writeIndexArray(arrayIndexValue, encoder) {\n        const values = arrayIndexValue.values || [];\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_ARRAY);\n        for (const element of values) {\n            this.writeIndexValueAux(element, encoder);\n        }\n    }\n    writeIndexEntityRef(referenceValue, encoder) {\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_REFERENCE);\n        const path = DocumentKey.fromName(referenceValue).path;\n        path.forEach(segment => {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_REFERENCE_SEGMENT);\n            this.writeUnlabeledIndexString(segment, encoder);\n        });\n    }\n    writeValueTypeLabel(encoder, typeOrder) {\n        encoder.writeNumber(typeOrder);\n    }\n    writeTruncationMarker(encoder) {\n        // While the SDK does not implement truncation, the truncation marker is\n        // used to terminate all variable length values (which are strings, bytes,\n        // references, arrays and maps).\n        encoder.writeNumber(NOT_TRUNCATED);\n    }\n}\nFirestoreIndexValueWriter.INSTANCE = new FirestoreIndexValueWriter();\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law | agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES | CONDITIONS OF ANY KIND, either express | implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** These constants are taken from the backend. */\nconst MIN_SURROGATE = '\\uD800';\nconst MAX_SURROGATE = '\\uDBFF';\nconst ESCAPE1 = 0x00;\nconst NULL_BYTE = 0xff; // Combined with ESCAPE1\nconst SEPARATOR = 0x01; // Combined with ESCAPE1\nconst ESCAPE2 = 0xff;\nconst INFINITY = 0xff; // Combined with ESCAPE2\nconst FF_BYTE = 0x00; // Combined with ESCAPE2\nconst LONG_SIZE = 64;\nconst BYTE_SIZE = 8;\n/**\n * The default size of the buffer. This is arbitrary, but likely larger than\n * most index values so that less copies of the underlying buffer will be made.\n * For large values, a single copy will made to double the buffer length.\n */\nconst DEFAULT_BUFFER_SIZE = 1024;\n/** Converts a JavaScript number to a byte array (using big endian encoding). */\nfunction doubleToLongBits(value) {\n    const dv = new DataView(new ArrayBuffer(8));\n    dv.setFloat64(0, value, /* littleEndian= */ false);\n    return new Uint8Array(dv.buffer);\n}\n/**\n * Counts the number of zeros in a byte.\n *\n * Visible for testing.\n */\nfunction numberOfLeadingZerosInByte(x) {\n    if (x === 0) {\n        return 8;\n    }\n    let zeros = 0;\n    if (x >> 4 === 0) {\n        // Test if the first four bits are zero.\n        zeros += 4;\n        x = x << 4;\n    }\n    if (x >> 6 === 0) {\n        // Test if the first two (or next two) bits are zero.\n        zeros += 2;\n        x = x << 2;\n    }\n    if (x >> 7 === 0) {\n        // Test if the remaining bit is zero.\n        zeros += 1;\n    }\n    return zeros;\n}\n/** Counts the number of leading zeros in the given byte array. */\nfunction numberOfLeadingZeros(bytes) {\n    let leadingZeros = 0;\n    for (let i = 0; i < 8; ++i) {\n        const zeros = numberOfLeadingZerosInByte(bytes[i] & 0xff);\n        leadingZeros += zeros;\n        if (zeros !== 8) {\n            break;\n        }\n    }\n    return leadingZeros;\n}\n/**\n * Returns the number of bytes required to store \"value\". Leading zero bytes\n * are skipped.\n */\nfunction unsignedNumLength(value) {\n    // This is just the number of bytes for the unsigned representation of the number.\n    const numBits = LONG_SIZE - numberOfLeadingZeros(value);\n    return Math.ceil(numBits / BYTE_SIZE);\n}\n/**\n * OrderedCodeWriter is a minimal-allocation implementation of the writing\n * behavior defined by the backend.\n *\n * The code is ported from its Java counterpart.\n */\nclass OrderedCodeWriter {\n    constructor() {\n        this.buffer = new Uint8Array(DEFAULT_BUFFER_SIZE);\n        this.position = 0;\n    }\n    writeBytesAscending(value) {\n        const it = value[Symbol.iterator]();\n        let byte = it.next();\n        while (!byte.done) {\n            this.writeByteAscending(byte.value);\n            byte = it.next();\n        }\n        this.writeSeparatorAscending();\n    }\n    writeBytesDescending(value) {\n        const it = value[Symbol.iterator]();\n        let byte = it.next();\n        while (!byte.done) {\n            this.writeByteDescending(byte.value);\n            byte = it.next();\n        }\n        this.writeSeparatorDescending();\n    }\n    /** Writes utf8 bytes into this byte sequence, ascending. */\n    writeUtf8Ascending(sequence) {\n        for (const c of sequence) {\n            const charCode = c.charCodeAt(0);\n            if (charCode < 0x80) {\n                this.writeByteAscending(charCode);\n            }\n            else if (charCode < 0x800) {\n                this.writeByteAscending((0x0f << 6) | (charCode >>> 6));\n                this.writeByteAscending(0x80 | (0x3f & charCode));\n            }\n            else if (c < MIN_SURROGATE || MAX_SURROGATE < c) {\n                this.writeByteAscending((0x0f << 5) | (charCode >>> 12));\n                this.writeByteAscending(0x80 | (0x3f & (charCode >>> 6)));\n                this.writeByteAscending(0x80 | (0x3f & charCode));\n            }\n            else {\n                const codePoint = c.codePointAt(0);\n                this.writeByteAscending((0x0f << 4) | (codePoint >>> 18));\n                this.writeByteAscending(0x80 | (0x3f & (codePoint >>> 12)));\n                this.writeByteAscending(0x80 | (0x3f & (codePoint >>> 6)));\n                this.writeByteAscending(0x80 | (0x3f & codePoint));\n            }\n        }\n        this.writeSeparatorAscending();\n    }\n    /** Writes utf8 bytes into this byte sequence, descending */\n    writeUtf8Descending(sequence) {\n        for (const c of sequence) {\n            const charCode = c.charCodeAt(0);\n            if (charCode < 0x80) {\n                this.writeByteDescending(charCode);\n            }\n            else if (charCode < 0x800) {\n                this.writeByteDescending((0x0f << 6) | (charCode >>> 6));\n                this.writeByteDescending(0x80 | (0x3f & charCode));\n            }\n            else if (c < MIN_SURROGATE || MAX_SURROGATE < c) {\n                this.writeByteDescending((0x0f << 5) | (charCode >>> 12));\n                this.writeByteDescending(0x80 | (0x3f & (charCode >>> 6)));\n                this.writeByteDescending(0x80 | (0x3f & charCode));\n            }\n            else {\n                const codePoint = c.codePointAt(0);\n                this.writeByteDescending((0x0f << 4) | (codePoint >>> 18));\n                this.writeByteDescending(0x80 | (0x3f & (codePoint >>> 12)));\n                this.writeByteDescending(0x80 | (0x3f & (codePoint >>> 6)));\n                this.writeByteDescending(0x80 | (0x3f & codePoint));\n            }\n        }\n        this.writeSeparatorDescending();\n    }\n    writeNumberAscending(val) {\n        // Values are encoded with a single byte length prefix, followed by the\n        // actual value in big-endian format with leading 0 bytes dropped.\n        const value = this.toOrderedBits(val);\n        const len = unsignedNumLength(value);\n        this.ensureAvailable(1 + len);\n        this.buffer[this.position++] = len & 0xff; // Write the length\n        for (let i = value.length - len; i < value.length; ++i) {\n            this.buffer[this.position++] = value[i] & 0xff;\n        }\n    }\n    writeNumberDescending(val) {\n        // Values are encoded with a single byte length prefix, followed by the\n        // inverted value in big-endian format with leading 0 bytes dropped.\n        const value = this.toOrderedBits(val);\n        const len = unsignedNumLength(value);\n        this.ensureAvailable(1 + len);\n        this.buffer[this.position++] = ~(len & 0xff); // Write the length\n        for (let i = value.length - len; i < value.length; ++i) {\n            this.buffer[this.position++] = ~(value[i] & 0xff);\n        }\n    }\n    /**\n     * Writes the \"infinity\" byte sequence that sorts after all other byte\n     * sequences written in ascending order.\n     */\n    writeInfinityAscending() {\n        this.writeEscapedByteAscending(ESCAPE2);\n        this.writeEscapedByteAscending(INFINITY);\n    }\n    /**\n     * Writes the \"infinity\" byte sequence that sorts before all other byte\n     * sequences written in descending order.\n     */\n    writeInfinityDescending() {\n        this.writeEscapedByteDescending(ESCAPE2);\n        this.writeEscapedByteDescending(INFINITY);\n    }\n    /**\n     * Resets the buffer such that it is the same as when it was newly\n     * constructed.\n     */\n    reset() {\n        this.position = 0;\n    }\n    seed(encodedBytes) {\n        this.ensureAvailable(encodedBytes.length);\n        this.buffer.set(encodedBytes, this.position);\n        this.position += encodedBytes.length;\n    }\n    /** Makes a copy of the encoded bytes in this buffer.  */\n    encodedBytes() {\n        return this.buffer.slice(0, this.position);\n    }\n    /**\n     * Encodes `val` into an encoding so that the order matches the IEEE 754\n     * floating-point comparison results with the following exceptions:\n     *   -0.0 < 0.0\n     *   all non-NaN < NaN\n     *   NaN = NaN\n     */\n    toOrderedBits(val) {\n        const value = doubleToLongBits(val);\n        // Check if the first bit is set. We use a bit mask since value[0] is\n        // encoded as a number from 0 to 255.\n        const isNegative = (value[0] & 0x80) !== 0;\n        // Revert the two complement to get natural ordering\n        value[0] ^= isNegative ? 0xff : 0x80;\n        for (let i = 1; i < value.length; ++i) {\n            value[i] ^= isNegative ? 0xff : 0x00;\n        }\n        return value;\n    }\n    /** Writes a single byte ascending to the buffer. */\n    writeByteAscending(b) {\n        const masked = b & 0xff;\n        if (masked === ESCAPE1) {\n            this.writeEscapedByteAscending(ESCAPE1);\n            this.writeEscapedByteAscending(NULL_BYTE);\n        }\n        else if (masked === ESCAPE2) {\n            this.writeEscapedByteAscending(ESCAPE2);\n            this.writeEscapedByteAscending(FF_BYTE);\n        }\n        else {\n            this.writeEscapedByteAscending(masked);\n        }\n    }\n    /** Writes a single byte descending to the buffer.  */\n    writeByteDescending(b) {\n        const masked = b & 0xff;\n        if (masked === ESCAPE1) {\n            this.writeEscapedByteDescending(ESCAPE1);\n            this.writeEscapedByteDescending(NULL_BYTE);\n        }\n        else if (masked === ESCAPE2) {\n            this.writeEscapedByteDescending(ESCAPE2);\n            this.writeEscapedByteDescending(FF_BYTE);\n        }\n        else {\n            this.writeEscapedByteDescending(b);\n        }\n    }\n    writeSeparatorAscending() {\n        this.writeEscapedByteAscending(ESCAPE1);\n        this.writeEscapedByteAscending(SEPARATOR);\n    }\n    writeSeparatorDescending() {\n        this.writeEscapedByteDescending(ESCAPE1);\n        this.writeEscapedByteDescending(SEPARATOR);\n    }\n    writeEscapedByteAscending(b) {\n        this.ensureAvailable(1);\n        this.buffer[this.position++] = b;\n    }\n    writeEscapedByteDescending(b) {\n        this.ensureAvailable(1);\n        this.buffer[this.position++] = ~b;\n    }\n    ensureAvailable(bytes) {\n        const minCapacity = bytes + this.position;\n        if (minCapacity <= this.buffer.length) {\n            return;\n        }\n        // Try doubling.\n        let newLength = this.buffer.length * 2;\n        // Still not big enough? Just allocate the right size.\n        if (newLength < minCapacity) {\n            newLength = minCapacity;\n        }\n        // Create the new buffer.\n        const newBuffer = new Uint8Array(newLength);\n        newBuffer.set(this.buffer); // copy old data\n        this.buffer = newBuffer;\n    }\n}\n\nclass AscendingIndexByteEncoder {\n    constructor(orderedCode) {\n        this.orderedCode = orderedCode;\n    }\n    writeBytes(value) {\n        this.orderedCode.writeBytesAscending(value);\n    }\n    writeString(value) {\n        this.orderedCode.writeUtf8Ascending(value);\n    }\n    writeNumber(value) {\n        this.orderedCode.writeNumberAscending(value);\n    }\n    writeInfinity() {\n        this.orderedCode.writeInfinityAscending();\n    }\n}\nclass DescendingIndexByteEncoder {\n    constructor(orderedCode) {\n        this.orderedCode = orderedCode;\n    }\n    writeBytes(value) {\n        this.orderedCode.writeBytesDescending(value);\n    }\n    writeString(value) {\n        this.orderedCode.writeUtf8Descending(value);\n    }\n    writeNumber(value) {\n        this.orderedCode.writeNumberDescending(value);\n    }\n    writeInfinity() {\n        this.orderedCode.writeInfinityDescending();\n    }\n}\n/**\n * Implements `DirectionalIndexByteEncoder` using `OrderedCodeWriter` for the\n * actual encoding.\n */\nclass IndexByteEncoder {\n    constructor() {\n        this.orderedCode = new OrderedCodeWriter();\n        this.ascending = new AscendingIndexByteEncoder(this.orderedCode);\n        this.descending = new DescendingIndexByteEncoder(this.orderedCode);\n    }\n    seed(encodedBytes) {\n        this.orderedCode.seed(encodedBytes);\n    }\n    forKind(kind) {\n        return kind === 0 /* IndexKind.ASCENDING */ ? this.ascending : this.descending;\n    }\n    encodedBytes() {\n        return this.orderedCode.encodedBytes();\n    }\n    reset() {\n        this.orderedCode.reset();\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Represents an index entry saved by the SDK in persisted storage. */\nclass IndexEntry {\n    constructor(_indexId, _documentKey, _arrayValue, _directionalValue) {\n        this._indexId = _indexId;\n        this._documentKey = _documentKey;\n        this._arrayValue = _arrayValue;\n        this._directionalValue = _directionalValue;\n    }\n    /**\n     * Returns an IndexEntry entry that sorts immediately after the current\n     * directional value.\n     */\n    successor() {\n        const currentLength = this._directionalValue.length;\n        const newLength = currentLength === 0 || this._directionalValue[currentLength - 1] === 255\n            ? currentLength + 1\n            : currentLength;\n        const successor = new Uint8Array(newLength);\n        successor.set(this._directionalValue, 0);\n        if (newLength !== currentLength) {\n            successor.set([0], this._directionalValue.length);\n        }\n        else {\n            ++successor[successor.length - 1];\n        }\n        return new IndexEntry(this._indexId, this._documentKey, this._arrayValue, successor);\n    }\n    // Create a representation of the Index Entry as a DbIndexEntry\n    dbIndexEntry(uid, orderedDocumentKey, documentKey) {\n        return {\n            indexId: this._indexId,\n            uid,\n            arrayValue: encodeKeySafeBytes(this._arrayValue),\n            directionalValue: encodeKeySafeBytes(this._directionalValue),\n            orderedDocumentKey: encodeKeySafeBytes(orderedDocumentKey),\n            documentKey: documentKey.path.toArray()\n        };\n    }\n    // Create a representation of the Index Entry as a DbIndexEntryKey\n    dbIndexEntryKey(uid, orderedDocumentKey, documentKey) {\n        const entry = this.dbIndexEntry(uid, orderedDocumentKey, documentKey);\n        return [\n            entry.indexId,\n            entry.uid,\n            entry.arrayValue,\n            entry.directionalValue,\n            entry.orderedDocumentKey,\n            entry.documentKey\n        ];\n    }\n}\nfunction indexEntryComparator(left, right) {\n    let cmp = left._indexId - right._indexId;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = compareByteArrays(left._arrayValue, right._arrayValue);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = compareByteArrays(left._directionalValue, right._directionalValue);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return DocumentKey.comparator(left._documentKey, right._documentKey);\n}\nfunction compareByteArrays(left, right) {\n    for (let i = 0; i < left.length && i < right.length; ++i) {\n        const compare = left[i] - right[i];\n        if (compare !== 0) {\n            return compare;\n        }\n    }\n    return left.length - right.length;\n}\n/**\n * Workaround for WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=292721\n * Create a key safe representation of Uint8Array values.\n * If the browser is detected as Safari or WebKit, then\n * the input array will be converted to \"sortable byte string\".\n * Otherwise, the input array will be returned in its original type.\n */\nfunction encodeKeySafeBytes(array) {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isSafariOrWebkit)()) {\n        return encodeUint8ArrayToSortableString(array);\n    }\n    return array;\n}\n/**\n * Reverts the key safe representation of Uint8Array (created by\n * encodeKeySafeBytes) to a normal Uint8Array.\n */\nfunction decodeKeySafeBytes(input) {\n    if (typeof input !== 'string') {\n        return input;\n    }\n    return decodeSortableStringToUint8Array(input);\n}\n/**\n * Encodes a Uint8Array into a \"sortable byte string\".\n * A \"sortable byte string\" sorts in the same order as the Uint8Array.\n * This works because JS string comparison sorts strings based on code points.\n */\nfunction encodeUint8ArrayToSortableString(array) {\n    let byteString = '';\n    for (let i = 0; i < array.length; i++) {\n        byteString += String.fromCharCode(array[i]);\n    }\n    return byteString;\n}\n/**\n * Decodes a \"sortable byte string\" back into a Uint8Array.\n * A \"sortable byte string\" is assumed to be created where each character's\n * Unicode code point directly corresponds to a single byte value (0-255).\n */\nfunction decodeSortableStringToUint8Array(byteString) {\n    const uint8array = new Uint8Array(byteString.length);\n    for (let i = 0; i < byteString.length; i++) {\n        uint8array[i] = byteString.charCodeAt(i);\n    }\n    return uint8array;\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A light query planner for Firestore.\n *\n * This class matches a `FieldIndex` against a Firestore Query `Target`. It\n * determines whether a given index can be used to serve the specified target.\n *\n * The following table showcases some possible index configurations:\n *\n * Query                                               | Index\n * -----------------------------------------------------------------------------\n * where('a', '==', 'a').where('b', '==', 'b')         | a ASC, b DESC\n * where('a', '==', 'a').where('b', '==', 'b')         | a ASC\n * where('a', '==', 'a').where('b', '==', 'b')         | b DESC\n * where('a', '>=', 'a').orderBy('a')                  | a ASC\n * where('a', '>=', 'a').orderBy('a', 'desc')          | a DESC\n * where('a', '>=', 'a').orderBy('a').orderBy('b')     | a ASC, b ASC\n * where('a', '>=', 'a').orderBy('a').orderBy('b')     | a ASC\n * where('a', 'array-contains', 'a').orderBy('b')      | a CONTAINS, b ASCENDING\n * where('a', 'array-contains', 'a').orderBy('b')      | a CONTAINS\n */\nclass TargetIndexMatcher {\n    constructor(target) {\n        // The inequality filters of the target (if it exists).\n        // Note: The sort on FieldFilters is not required. Using SortedSet here just to utilize the custom\n        // comparator.\n        this.inequalityFilters = new SortedSet((lhs, rhs) => FieldPath$1.comparator(lhs.field, rhs.field));\n        this.collectionId =\n            target.collectionGroup != null\n                ? target.collectionGroup\n                : target.path.lastSegment();\n        this.orderBys = target.orderBy;\n        this.equalityFilters = [];\n        for (const filter of target.filters) {\n            const fieldFilter = filter;\n            if (fieldFilter.isInequality()) {\n                this.inequalityFilters = this.inequalityFilters.add(fieldFilter);\n            }\n            else {\n                this.equalityFilters.push(fieldFilter);\n            }\n        }\n    }\n    get hasMultipleInequality() {\n        return this.inequalityFilters.size > 1;\n    }\n    /**\n     * Returns whether the index can be used to serve the TargetIndexMatcher's\n     * target.\n     *\n     * An index is considered capable of serving the target when:\n     * - The target uses all index segments for its filters and orderBy clauses.\n     *   The target can have additional filter and orderBy clauses, but not\n     *   fewer.\n     * - If an ArrayContains/ArrayContainsAnyfilter is used, the index must also\n     *   have a corresponding `CONTAINS` segment.\n     * - All directional index segments can be mapped to the target as a series of\n     *   equality filters, a single inequality filter and a series of orderBy\n     *   clauses.\n     * - The segments that represent the equality filters may appear out of order.\n     * - The optional segment for the inequality filter must appear after all\n     *   equality segments.\n     * - The segments that represent that orderBy clause of the target must appear\n     *   in order after all equality and inequality segments. Single orderBy\n     *   clauses cannot be skipped, but a continuous orderBy suffix may be\n     *   omitted.\n     */\n    servedByIndex(index) {\n        hardAssert(index.collectionGroup === this.collectionId, 0xc07f);\n        if (this.hasMultipleInequality) {\n            // Only single inequality is supported for now.\n            // TODO(Add support for multiple inequality query): b/298441043\n            return false;\n        }\n        // If there is an array element, find a matching filter.\n        const arraySegment = fieldIndexGetArraySegment(index);\n        if (arraySegment !== undefined &&\n            !this.hasMatchingEqualityFilter(arraySegment)) {\n            return false;\n        }\n        const segments = fieldIndexGetDirectionalSegments(index);\n        let equalitySegments = new Set();\n        let segmentIndex = 0;\n        let orderBysIndex = 0;\n        // Process all equalities first. Equalities can appear out of order.\n        for (; segmentIndex < segments.length; ++segmentIndex) {\n            // We attempt to greedily match all segments to equality filters. If a\n            // filter matches an index segment, we can mark the segment as used.\n            if (this.hasMatchingEqualityFilter(segments[segmentIndex])) {\n                equalitySegments = equalitySegments.add(segments[segmentIndex].fieldPath.canonicalString());\n            }\n            else {\n                // If we cannot find a matching filter, we need to verify whether the\n                // remaining segments map to the target's inequality and its orderBy\n                // clauses.\n                break;\n            }\n        }\n        // If we already have processed all segments, all segments are used to serve\n        // the equality filters and we do not need to map any segments to the\n        // target's inequality and orderBy clauses.\n        if (segmentIndex === segments.length) {\n            return true;\n        }\n        if (this.inequalityFilters.size > 0) {\n            // Only a single inequality is currently supported. Get the only entry in the set.\n            const inequalityFilter = this.inequalityFilters.getIterator().getNext();\n            // If there is an inequality filter and the field was not in one of the\n            // equality filters above, the next segment must match both the filter\n            // and the first orderBy clause.\n            if (!equalitySegments.has(inequalityFilter.field.canonicalString())) {\n                const segment = segments[segmentIndex];\n                if (!this.matchesFilter(inequalityFilter, segment) ||\n                    !this.matchesOrderBy(this.orderBys[orderBysIndex++], segment)) {\n                    return false;\n                }\n            }\n            ++segmentIndex;\n        }\n        // All remaining segments need to represent the prefix of the target's\n        // orderBy.\n        for (; segmentIndex < segments.length; ++segmentIndex) {\n            const segment = segments[segmentIndex];\n            if (orderBysIndex >= this.orderBys.length ||\n                !this.matchesOrderBy(this.orderBys[orderBysIndex++], segment)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns a full matched field index for this target. Currently multiple\n     * inequality query is not supported so function returns null.\n     */\n    buildTargetIndex() {\n        if (this.hasMultipleInequality) {\n            return null;\n        }\n        // We want to make sure only one segment created for one field. For example,\n        // in case like a == 3 and a > 2, Index {a ASCENDING} will only be created\n        // once.\n        let uniqueFields = new SortedSet(FieldPath$1.comparator);\n        const segments = [];\n        for (const filter of this.equalityFilters) {\n            if (filter.field.isKeyField()) {\n                continue;\n            }\n            const isArrayOperator = filter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\n                filter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\n            if (isArrayOperator) {\n                segments.push(new IndexSegment(filter.field, 2 /* IndexKind.CONTAINS */));\n            }\n            else {\n                if (uniqueFields.has(filter.field)) {\n                    continue;\n                }\n                uniqueFields = uniqueFields.add(filter.field);\n                segments.push(new IndexSegment(filter.field, 0 /* IndexKind.ASCENDING */));\n            }\n        }\n        // Note: We do not explicitly check `this.inequalityFilter` but rather rely\n        // on the target defining an appropriate \"order by\" to ensure that the\n        // required index segment is added. The query engine would reject a query\n        // with an inequality filter that lacks the required order-by clause.\n        for (const orderBy of this.orderBys) {\n            // Stop adding more segments if we see a order-by on key. Typically this\n            // is the default implicit order-by which is covered in the index_entry\n            // table as a separate column. If it is not the default order-by, the\n            // generated index will be missing some segments optimized for order-bys,\n            // which is probably fine.\n            if (orderBy.field.isKeyField()) {\n                continue;\n            }\n            if (uniqueFields.has(orderBy.field)) {\n                continue;\n            }\n            uniqueFields = uniqueFields.add(orderBy.field);\n            segments.push(new IndexSegment(orderBy.field, orderBy.dir === \"asc\" /* Direction.ASCENDING */\n                ? 0 /* IndexKind.ASCENDING */\n                : 1 /* IndexKind.DESCENDING */));\n        }\n        return new FieldIndex(FieldIndex.UNKNOWN_ID, this.collectionId, segments, IndexState.empty());\n    }\n    hasMatchingEqualityFilter(segment) {\n        for (const filter of this.equalityFilters) {\n            if (this.matchesFilter(filter, segment)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    matchesFilter(filter, segment) {\n        if (filter === undefined || !filter.field.isEqual(segment.fieldPath)) {\n            return false;\n        }\n        const isArrayOperator = filter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\n            filter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\n        return (segment.kind === 2 /* IndexKind.CONTAINS */) === isArrayOperator;\n    }\n    matchesOrderBy(orderBy, segment) {\n        if (!orderBy.field.isEqual(segment.fieldPath)) {\n            return false;\n        }\n        return ((segment.kind === 0 /* IndexKind.ASCENDING */ &&\n            orderBy.dir === \"asc\" /* Direction.ASCENDING */) ||\n            (segment.kind === 1 /* IndexKind.DESCENDING */ &&\n                orderBy.dir === \"desc\" /* Direction.DESCENDING */));\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides utility functions that help with boolean logic transformations needed for handling\n * complex filters used in queries.\n */\n/**\n * The `in` filter is only a syntactic sugar over a disjunction of equalities. For instance: `a in\n * [1,2,3]` is in fact `a==1 || a==2 || a==3`. This method expands any `in` filter in the given\n * input into a disjunction of equality filters and returns the expanded filter.\n */\nfunction computeInExpansion(filter) {\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter, 0x4e2c);\n    if (filter instanceof FieldFilter) {\n        if (filter instanceof InFilter) {\n            const expandedFilters = filter.value.arrayValue?.values?.map(value => FieldFilter.create(filter.field, \"==\" /* Operator.EQUAL */, value)) || [];\n            return CompositeFilter.create(expandedFilters, \"or\" /* CompositeOperator.OR */);\n        }\n        else {\n            // We have reached other kinds of field filters.\n            return filter;\n        }\n    }\n    // We have a composite filter.\n    const expandedFilters = filter.filters.map(subfilter => computeInExpansion(subfilter));\n    return CompositeFilter.create(expandedFilters, filter.op);\n}\n/**\n * Given a composite filter, returns the list of terms in its disjunctive normal form.\n *\n * <p>Each element in the return value is one term of the resulting DNF. For instance: For the\n * input: (A || B) && C, the DNF form is: (A && C) || (B && C), and the return value is a list\n * with two elements: a composite filter that performs (A && C), and a composite filter that\n * performs (B && C).\n *\n * @param filter - the composite filter to calculate DNF transform for.\n * @returns the terms in the DNF transform.\n */\nfunction getDnfTerms(filter) {\n    if (filter.getFilters().length === 0) {\n        return [];\n    }\n    const result = computeDistributedNormalForm(computeInExpansion(filter));\n    hardAssert(isDisjunctiveNormalForm(result), 0x1cdf);\n    if (isSingleFieldFilter(result) || isFlatConjunction(result)) {\n        return [result];\n    }\n    return result.getFilters();\n}\n/** Returns true if the given filter is a single field filter. e.g. (a == 10). */\nfunction isSingleFieldFilter(filter) {\n    return filter instanceof FieldFilter;\n}\n/**\n * Returns true if the given filter is the conjunction of one or more field filters. e.g. (a == 10\n * && b == 20)\n */\nfunction isFlatConjunction(filter) {\n    return (filter instanceof CompositeFilter &&\n        compositeFilterIsFlatConjunction(filter));\n}\n/**\n * Returns whether or not the given filter is in disjunctive normal form (DNF).\n *\n * <p>In boolean logic, a disjunctive normal form (DNF) is a canonical normal form of a logical\n * formula consisting of a disjunction of conjunctions; it can also be described as an OR of ANDs.\n *\n * <p>For more info, visit: https://en.wikipedia.org/wiki/Disjunctive_normal_form\n */\nfunction isDisjunctiveNormalForm(filter) {\n    return (isSingleFieldFilter(filter) ||\n        isFlatConjunction(filter) ||\n        isDisjunctionOfFieldFiltersAndFlatConjunctions(filter));\n}\n/**\n * Returns true if the given filter is the disjunction of one or more \"flat conjunctions\" and\n * field filters. e.g. (a == 10) || (b==20 && c==30)\n */\nfunction isDisjunctionOfFieldFiltersAndFlatConjunctions(filter) {\n    if (filter instanceof CompositeFilter) {\n        if (compositeFilterIsDisjunction(filter)) {\n            for (const subFilter of filter.getFilters()) {\n                if (!isSingleFieldFilter(subFilter) && !isFlatConjunction(subFilter)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction computeDistributedNormalForm(filter) {\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter, 0x84e2);\n    if (filter instanceof FieldFilter) {\n        return filter;\n    }\n    if (filter.filters.length === 1) {\n        return computeDistributedNormalForm(filter.filters[0]);\n    }\n    // Compute DNF for each of the subfilters first\n    const result = filter.filters.map(subfilter => computeDistributedNormalForm(subfilter));\n    let newFilter = CompositeFilter.create(result, filter.op);\n    newFilter = applyAssociation(newFilter);\n    if (isDisjunctiveNormalForm(newFilter)) {\n        return newFilter;\n    }\n    hardAssert(newFilter instanceof CompositeFilter, 0xfbf2);\n    hardAssert(compositeFilterIsConjunction(newFilter), 0x9d3b);\n    hardAssert(newFilter.filters.length > 1, 0xe247);\n    return newFilter.filters.reduce((runningResult, filter) => applyDistribution(runningResult, filter));\n}\nfunction applyDistribution(lhs, rhs) {\n    hardAssert(lhs instanceof FieldFilter || lhs instanceof CompositeFilter, 0x95f4);\n    hardAssert(rhs instanceof FieldFilter || rhs instanceof CompositeFilter, 0x6381);\n    let result;\n    if (lhs instanceof FieldFilter) {\n        if (rhs instanceof FieldFilter) {\n            // FieldFilter FieldFilter\n            result = applyDistributionFieldFilters(lhs, rhs);\n        }\n        else {\n            // FieldFilter CompositeFilter\n            result = applyDistributionFieldAndCompositeFilters(lhs, rhs);\n        }\n    }\n    else {\n        if (rhs instanceof FieldFilter) {\n            // CompositeFilter FieldFilter\n            result = applyDistributionFieldAndCompositeFilters(rhs, lhs);\n        }\n        else {\n            // CompositeFilter CompositeFilter\n            result = applyDistributionCompositeFilters(lhs, rhs);\n        }\n    }\n    return applyAssociation(result);\n}\nfunction applyDistributionFieldFilters(lhs, rhs) {\n    // Conjunction distribution for two field filters is the conjunction of them.\n    return CompositeFilter.create([lhs, rhs], \"and\" /* CompositeOperator.AND */);\n}\nfunction applyDistributionCompositeFilters(lhs, rhs) {\n    hardAssert(lhs.filters.length > 0 && rhs.filters.length > 0, 0xbb85);\n    // There are four cases:\n    // (A & B) & (C & D) --> (A & B & C & D)\n    // (A & B) & (C | D) --> (A & B & C) | (A & B & D)\n    // (A | B) & (C & D) --> (C & D & A) | (C & D & B)\n    // (A | B) & (C | D) --> (A & C) | (A & D) | (B & C) | (B & D)\n    // Case 1 is a merge.\n    if (compositeFilterIsConjunction(lhs) && compositeFilterIsConjunction(rhs)) {\n        return compositeFilterWithAddedFilters(lhs, rhs.getFilters());\n    }\n    // Case 2,3,4 all have at least one side (lhs or rhs) that is a disjunction. In all three cases\n    // we should take each element of the disjunction and distribute it over the other side, and\n    // return the disjunction of the distribution results.\n    const disjunctionSide = compositeFilterIsDisjunction(lhs) ? lhs : rhs;\n    const otherSide = compositeFilterIsDisjunction(lhs) ? rhs : lhs;\n    const results = disjunctionSide.filters.map(subfilter => applyDistribution(subfilter, otherSide));\n    return CompositeFilter.create(results, \"or\" /* CompositeOperator.OR */);\n}\nfunction applyDistributionFieldAndCompositeFilters(fieldFilter, compositeFilter) {\n    // There are two cases:\n    // A & (B & C) --> (A & B & C)\n    // A & (B | C) --> (A & B) | (A & C)\n    if (compositeFilterIsConjunction(compositeFilter)) {\n        // Case 1\n        return compositeFilterWithAddedFilters(compositeFilter, fieldFilter.getFilters());\n    }\n    else {\n        // Case 2\n        const newFilters = compositeFilter.filters.map(subfilter => applyDistribution(fieldFilter, subfilter));\n        return CompositeFilter.create(newFilters, \"or\" /* CompositeOperator.OR */);\n    }\n}\n/**\n * Applies the associativity property to the given filter and returns the resulting filter.\n *\n * <ul>\n *   <li>A | (B | C) == (A | B) | C == (A | B | C)\n *   <li>A & (B & C) == (A & B) & C == (A & B & C)\n * </ul>\n *\n * <p>For more info, visit: https://en.wikipedia.org/wiki/Associative_property#Propositional_logic\n */\nfunction applyAssociation(filter) {\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter, 0x2e4a);\n    if (filter instanceof FieldFilter) {\n        return filter;\n    }\n    const filters = filter.getFilters();\n    // If the composite filter only contains 1 filter, apply associativity to it.\n    if (filters.length === 1) {\n        return applyAssociation(filters[0]);\n    }\n    // Associativity applied to a flat composite filter results is itself.\n    if (compositeFilterIsFlat(filter)) {\n        return filter;\n    }\n    // First apply associativity to all subfilters. This will in turn recursively apply\n    // associativity to all nested composite filters and field filters.\n    const updatedFilters = filters.map(subfilter => applyAssociation(subfilter));\n    // For composite subfilters that perform the same kind of logical operation as `compositeFilter`\n    // take out their filters and add them to `compositeFilter`. For example:\n    // compositeFilter = (A | (B | C | D))\n    // compositeSubfilter = (B | C | D)\n    // Result: (A | B | C | D)\n    // Note that the `compositeSubfilter` has been eliminated, and its filters (B, C, D) have been\n    // added to the top-level \"compositeFilter\".\n    const newSubfilters = [];\n    updatedFilters.forEach(subfilter => {\n        if (subfilter instanceof FieldFilter) {\n            newSubfilters.push(subfilter);\n        }\n        else if (subfilter instanceof CompositeFilter) {\n            if (subfilter.op === filter.op) {\n                // compositeFilter: (A | (B | C))\n                // compositeSubfilter: (B | C)\n                // Result: (A | B | C)\n                newSubfilters.push(...subfilter.filters);\n            }\n            else {\n                // compositeFilter: (A | (B & C))\n                // compositeSubfilter: (B & C)\n                // Result: (A | (B & C))\n                newSubfilters.push(subfilter);\n            }\n        }\n    });\n    if (newSubfilters.length === 1) {\n        return newSubfilters[0];\n    }\n    return CompositeFilter.create(newSubfilters, filter.op);\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An in-memory implementation of IndexManager.\n */\nclass MemoryIndexManager {\n    constructor() {\n        this.collectionParentIndex = new MemoryCollectionParentIndex();\n    }\n    addToCollectionParentIndex(transaction, collectionPath) {\n        this.collectionParentIndex.add(collectionPath);\n        return PersistencePromise.resolve();\n    }\n    getCollectionParents(transaction, collectionId) {\n        return PersistencePromise.resolve(this.collectionParentIndex.getEntries(collectionId));\n    }\n    addFieldIndex(transaction, index) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    deleteFieldIndex(transaction, index) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    deleteAllFieldIndexes(transaction) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    createTargetIndexes(transaction, target) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    getDocumentsMatchingTarget(transaction, target) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve(null);\n    }\n    getIndexType(transaction, target) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve(0 /* IndexType.NONE */);\n    }\n    getFieldIndexes(transaction, collectionGroup) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve([]);\n    }\n    getNextCollectionGroupToUpdate(transaction) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve(null);\n    }\n    getMinOffset(transaction, target) {\n        return PersistencePromise.resolve(IndexOffset.min());\n    }\n    getMinOffsetFromCollectionGroup(transaction, collectionGroup) {\n        return PersistencePromise.resolve(IndexOffset.min());\n    }\n    updateCollectionGroup(transaction, collectionGroup, offset) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    updateIndexEntries(transaction, documents) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n}\n/**\n * Internal implementation of the collection-parent index exposed by MemoryIndexManager.\n * Also used for in-memory caching by IndexedDbIndexManager and initial index population\n * in indexeddb_schema.ts\n */\nclass MemoryCollectionParentIndex {\n    constructor() {\n        this.index = {};\n    }\n    // Returns false if the entry already existed.\n    add(collectionPath) {\n        const collectionId = collectionPath.lastSegment();\n        const parentPath = collectionPath.popLast();\n        const existingParents = this.index[collectionId] ||\n            new SortedSet(ResourcePath.comparator);\n        const added = !existingParents.has(parentPath);\n        this.index[collectionId] = existingParents.add(parentPath);\n        return added;\n    }\n    has(collectionPath) {\n        const collectionId = collectionPath.lastSegment();\n        const parentPath = collectionPath.popLast();\n        const existingParents = this.index[collectionId];\n        return existingParents && existingParents.has(parentPath);\n    }\n    getEntries(collectionId) {\n        const parentPaths = this.index[collectionId] ||\n            new SortedSet(ResourcePath.comparator);\n        return parentPaths.toArray();\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$f = 'IndexedDbIndexManager';\nconst EMPTY_VALUE = new Uint8Array(0);\n/**\n * A persisted implementation of IndexManager.\n *\n * PORTING NOTE: Unlike iOS and Android, the Web SDK does not memoize index\n * data as it supports multi-tab access.\n */\nclass IndexedDbIndexManager {\n    constructor(user, databaseId) {\n        this.databaseId = databaseId;\n        /**\n         * An in-memory copy of the index entries we've already written since the SDK\n         * launched. Used to avoid re-writing the same entry repeatedly.\n         *\n         * This is *NOT* a complete cache of what's in persistence and so can never be\n         * used to satisfy reads.\n         */\n        this.collectionParentsCache = new MemoryCollectionParentIndex();\n        /**\n         * Maps from a target to its equivalent list of sub-targets. Each sub-target\n         * contains only one term from the target's disjunctive normal form (DNF).\n         */\n        this.targetToDnfSubTargets = new ObjectMap(t => canonifyTarget(t), (l, r) => targetEquals(l, r));\n        this.uid = user.uid || '';\n    }\n    /**\n     * Adds a new entry to the collection parent index.\n     *\n     * Repeated calls for the same collectionPath should be avoided within a\n     * transaction as IndexedDbIndexManager only caches writes once a transaction\n     * has been committed.\n     */\n    addToCollectionParentIndex(transaction, collectionPath) {\n        if (!this.collectionParentsCache.has(collectionPath)) {\n            const collectionId = collectionPath.lastSegment();\n            const parentPath = collectionPath.popLast();\n            transaction.addOnCommittedListener(() => {\n                // Add the collection to the in memory cache only if the transaction was\n                // successfully committed.\n                this.collectionParentsCache.add(collectionPath);\n            });\n            const collectionParent = {\n                collectionId,\n                parent: encodeResourcePath(parentPath)\n            };\n            return collectionParentsStore(transaction).put(collectionParent);\n        }\n        return PersistencePromise.resolve();\n    }\n    getCollectionParents(transaction, collectionId) {\n        const parentPaths = [];\n        const range = IDBKeyRange.bound([collectionId, ''], [immediateSuccessor(collectionId), ''], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        return collectionParentsStore(transaction)\n            .loadAll(range)\n            .next(entries => {\n            for (const entry of entries) {\n                // This collectionId guard shouldn't be necessary (and isn't as long\n                // as we're running in a real browser), but there's a bug in\n                // indexeddbshim that breaks our range in our tests running in node:\n                // https://github.com/axemclion/IndexedDBShim/issues/334\n                if (entry.collectionId !== collectionId) {\n                    break;\n                }\n                parentPaths.push(decodeResourcePath(entry.parent));\n            }\n            return parentPaths;\n        });\n    }\n    addFieldIndex(transaction, index) {\n        // TODO(indexing): Verify that the auto-incrementing index ID works in\n        // Safari & Firefox.\n        const indexes = indexConfigurationStore(transaction);\n        const dbIndex = toDbIndexConfiguration(index);\n        delete dbIndex.indexId; // `indexId` is auto-populated by IndexedDb\n        const result = indexes.add(dbIndex);\n        if (index.indexState) {\n            const states = indexStateStore(transaction);\n            return result.next(indexId => {\n                states.put(toDbIndexState(indexId, this.uid, index.indexState.sequenceNumber, index.indexState.offset));\n            });\n        }\n        else {\n            return result.next();\n        }\n    }\n    deleteFieldIndex(transaction, index) {\n        const indexes = indexConfigurationStore(transaction);\n        const states = indexStateStore(transaction);\n        const entries = indexEntriesStore(transaction);\n        return indexes\n            .delete(index.indexId)\n            .next(() => states.delete(IDBKeyRange.bound([index.indexId], [index.indexId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true)))\n            .next(() => entries.delete(IDBKeyRange.bound([index.indexId], [index.indexId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true)));\n    }\n    deleteAllFieldIndexes(transaction) {\n        const indexes = indexConfigurationStore(transaction);\n        const entries = indexEntriesStore(transaction);\n        const states = indexStateStore(transaction);\n        return indexes\n            .deleteAll()\n            .next(() => entries.deleteAll())\n            .next(() => states.deleteAll());\n    }\n    createTargetIndexes(transaction, target) {\n        return PersistencePromise.forEach(this.getSubTargets(target), (subTarget) => {\n            return this.getIndexType(transaction, subTarget).next(type => {\n                if (type === 0 /* IndexType.NONE */ || type === 1 /* IndexType.PARTIAL */) {\n                    const targetIndexMatcher = new TargetIndexMatcher(subTarget);\n                    const fieldIndex = targetIndexMatcher.buildTargetIndex();\n                    if (fieldIndex != null) {\n                        return this.addFieldIndex(transaction, fieldIndex);\n                    }\n                }\n            });\n        });\n    }\n    getDocumentsMatchingTarget(transaction, target) {\n        const indexEntries = indexEntriesStore(transaction);\n        let canServeTarget = true;\n        const indexes = new Map();\n        return PersistencePromise.forEach(this.getSubTargets(target), (subTarget) => {\n            return this.getFieldIndex(transaction, subTarget).next(index => {\n                canServeTarget && (canServeTarget = !!index);\n                indexes.set(subTarget, index);\n            });\n        }).next(() => {\n            if (!canServeTarget) {\n                return PersistencePromise.resolve(null);\n            }\n            else {\n                let existingKeys = documentKeySet();\n                const result = [];\n                return PersistencePromise.forEach(indexes, (index, subTarget) => {\n                    logDebug(LOG_TAG$f, `Using index ${fieldIndexToString(index)} to execute ${canonifyTarget(target)}`);\n                    const arrayValues = targetGetArrayValues(subTarget, index);\n                    const notInValues = targetGetNotInValues(subTarget, index);\n                    const lowerBound = targetGetLowerBound(subTarget, index);\n                    const upperBound = targetGetUpperBound(subTarget, index);\n                    const lowerBoundEncoded = this.encodeBound(index, subTarget, lowerBound);\n                    const upperBoundEncoded = this.encodeBound(index, subTarget, upperBound);\n                    const notInEncoded = this.encodeValues(index, subTarget, notInValues);\n                    const indexRanges = this.generateIndexRanges(index.indexId, arrayValues, lowerBoundEncoded, lowerBound.inclusive, upperBoundEncoded, upperBound.inclusive, notInEncoded);\n                    return PersistencePromise.forEach(indexRanges, (indexRange) => {\n                        return indexEntries\n                            .loadFirst(indexRange, target.limit)\n                            .next(entries => {\n                            entries.forEach(entry => {\n                                const documentKey = DocumentKey.fromSegments(entry.documentKey);\n                                if (!existingKeys.has(documentKey)) {\n                                    existingKeys = existingKeys.add(documentKey);\n                                    result.push(documentKey);\n                                }\n                            });\n                        });\n                    });\n                }).next(() => result);\n            }\n        });\n    }\n    getSubTargets(target) {\n        let subTargets = this.targetToDnfSubTargets.get(target);\n        if (subTargets) {\n            return subTargets;\n        }\n        if (target.filters.length === 0) {\n            subTargets = [target];\n        }\n        else {\n            // There is an implicit AND operation between all the filters stored in the target\n            const dnf = getDnfTerms(CompositeFilter.create(target.filters, \"and\" /* CompositeOperator.AND */));\n            subTargets = dnf.map(term => newTarget(target.path, target.collectionGroup, target.orderBy, term.getFilters(), target.limit, target.startAt, target.endAt));\n        }\n        this.targetToDnfSubTargets.set(target, subTargets);\n        return subTargets;\n    }\n    /**\n     * Constructs a key range query on `DbIndexEntryStore` that unions all\n     * bounds.\n     */\n    generateIndexRanges(indexId, arrayValues, lowerBounds, lowerBoundInclusive, upperBounds, upperBoundInclusive, notInValues) {\n        // The number of total index scans we union together. This is similar to a\n        // distributed normal form, but adapted for array values. We create a single\n        // index range per value in an ARRAY_CONTAINS or ARRAY_CONTAINS_ANY filter\n        // combined with the values from the query bounds.\n        const totalScans = (arrayValues != null ? arrayValues.length : 1) *\n            Math.max(lowerBounds.length, upperBounds.length);\n        const scansPerArrayElement = totalScans / (arrayValues != null ? arrayValues.length : 1);\n        const indexRanges = [];\n        for (let i = 0; i < totalScans; ++i) {\n            const arrayValue = arrayValues\n                ? this.encodeSingleElement(arrayValues[i / scansPerArrayElement])\n                : EMPTY_VALUE;\n            const lowerBound = this.generateLowerBound(indexId, arrayValue, lowerBounds[i % scansPerArrayElement], lowerBoundInclusive);\n            const upperBound = this.generateUpperBound(indexId, arrayValue, upperBounds[i % scansPerArrayElement], upperBoundInclusive);\n            const notInBound = notInValues.map(notIn => this.generateLowerBound(indexId, arrayValue, notIn, \n            /* inclusive= */ true));\n            indexRanges.push(...this.createRange(lowerBound, upperBound, notInBound));\n        }\n        return indexRanges;\n    }\n    /** Generates the lower bound for `arrayValue` and `directionalValue`. */\n    generateLowerBound(indexId, arrayValue, directionalValue, inclusive) {\n        const entry = new IndexEntry(indexId, DocumentKey.empty(), arrayValue, directionalValue);\n        return inclusive ? entry : entry.successor();\n    }\n    /** Generates the upper bound for `arrayValue` and `directionalValue`. */\n    generateUpperBound(indexId, arrayValue, directionalValue, inclusive) {\n        const entry = new IndexEntry(indexId, DocumentKey.empty(), arrayValue, directionalValue);\n        return inclusive ? entry.successor() : entry;\n    }\n    getFieldIndex(transaction, target) {\n        const targetIndexMatcher = new TargetIndexMatcher(target);\n        const collectionGroup = target.collectionGroup != null\n            ? target.collectionGroup\n            : target.path.lastSegment();\n        return this.getFieldIndexes(transaction, collectionGroup).next(indexes => {\n            // Return the index with the most number of segments.\n            let index = null;\n            for (const candidate of indexes) {\n                const matches = targetIndexMatcher.servedByIndex(candidate);\n                if (matches &&\n                    (!index || candidate.fields.length > index.fields.length)) {\n                    index = candidate;\n                }\n            }\n            return index;\n        });\n    }\n    getIndexType(transaction, target) {\n        let indexType = 2 /* IndexType.FULL */;\n        const subTargets = this.getSubTargets(target);\n        return PersistencePromise.forEach(subTargets, (target) => {\n            return this.getFieldIndex(transaction, target).next(index => {\n                if (!index) {\n                    indexType = 0 /* IndexType.NONE */;\n                }\n                else if (indexType !== 0 /* IndexType.NONE */ &&\n                    index.fields.length < targetGetSegmentCount(target)) {\n                    indexType = 1 /* IndexType.PARTIAL */;\n                }\n            });\n        }).next(() => {\n            // OR queries have more than one sub-target (one sub-target per DNF term). We currently consider\n            // OR queries that have a `limit` to have a partial index. For such queries we perform sorting\n            // and apply the limit in memory as a post-processing step.\n            if (targetHasLimit(target) &&\n                subTargets.length > 1 &&\n                indexType === 2 /* IndexType.FULL */) {\n                return 1 /* IndexType.PARTIAL */;\n            }\n            return indexType;\n        });\n    }\n    /**\n     * Returns the byte encoded form of the directional values in the field index.\n     * Returns `null` if the document does not have all fields specified in the\n     * index.\n     */\n    encodeDirectionalElements(fieldIndex, document) {\n        const encoder = new IndexByteEncoder();\n        for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n            const field = document.data.field(segment.fieldPath);\n            if (field == null) {\n                return null;\n            }\n            const directionalEncoder = encoder.forKind(segment.kind);\n            FirestoreIndexValueWriter.INSTANCE.writeIndexValue(field, directionalEncoder);\n        }\n        return encoder.encodedBytes();\n    }\n    /** Encodes a single value to the ascending index format. */\n    encodeSingleElement(value) {\n        const encoder = new IndexByteEncoder();\n        FirestoreIndexValueWriter.INSTANCE.writeIndexValue(value, encoder.forKind(0 /* IndexKind.ASCENDING */));\n        return encoder.encodedBytes();\n    }\n    /**\n     * Returns an encoded form of the document key that sorts based on the key\n     * ordering of the field index.\n     */\n    encodeDirectionalKey(fieldIndex, documentKey) {\n        const encoder = new IndexByteEncoder();\n        FirestoreIndexValueWriter.INSTANCE.writeIndexValue(refValue(this.databaseId, documentKey), encoder.forKind(fieldIndexGetKeyOrder(fieldIndex)));\n        return encoder.encodedBytes();\n    }\n    /**\n     * Encodes the given field values according to the specification in `target`.\n     * For IN queries, a list of possible values is returned.\n     */\n    encodeValues(fieldIndex, target, values) {\n        if (values === null) {\n            return [];\n        }\n        let encoders = [];\n        encoders.push(new IndexByteEncoder());\n        let valueIdx = 0;\n        for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n            const value = values[valueIdx++];\n            for (const encoder of encoders) {\n                if (this.isInFilter(target, segment.fieldPath) && isArray(value)) {\n                    encoders = this.expandIndexValues(encoders, segment, value);\n                }\n                else {\n                    const directionalEncoder = encoder.forKind(segment.kind);\n                    FirestoreIndexValueWriter.INSTANCE.writeIndexValue(value, directionalEncoder);\n                }\n            }\n        }\n        return this.getEncodedBytes(encoders);\n    }\n    /**\n     * Encodes the given bounds according to the specification in `target`. For IN\n     * queries, a list of possible values is returned.\n     */\n    encodeBound(fieldIndex, target, bound) {\n        return this.encodeValues(fieldIndex, target, bound.position);\n    }\n    /** Returns the byte representation for the provided encoders. */\n    getEncodedBytes(encoders) {\n        const result = [];\n        for (let i = 0; i < encoders.length; ++i) {\n            result[i] = encoders[i].encodedBytes();\n        }\n        return result;\n    }\n    /**\n     * Creates a separate encoder for each element of an array.\n     *\n     * The method appends each value to all existing encoders (e.g. filter(\"a\",\n     * \"==\", \"a1\").filter(\"b\", \"in\", [\"b1\", \"b2\"]) becomes [\"a1,b1\", \"a1,b2\"]). A\n     * list of new encoders is returned.\n     */\n    expandIndexValues(encoders, segment, value) {\n        const prefixes = [...encoders];\n        const results = [];\n        for (const arrayElement of value.arrayValue.values || []) {\n            for (const prefix of prefixes) {\n                const clonedEncoder = new IndexByteEncoder();\n                clonedEncoder.seed(prefix.encodedBytes());\n                FirestoreIndexValueWriter.INSTANCE.writeIndexValue(arrayElement, clonedEncoder.forKind(segment.kind));\n                results.push(clonedEncoder);\n            }\n        }\n        return results;\n    }\n    isInFilter(target, fieldPath) {\n        return !!target.filters.find(f => f instanceof FieldFilter &&\n            f.field.isEqual(fieldPath) &&\n            (f.op === \"in\" /* Operator.IN */ || f.op === \"not-in\" /* Operator.NOT_IN */));\n    }\n    getFieldIndexes(transaction, collectionGroup) {\n        const indexes = indexConfigurationStore(transaction);\n        const states = indexStateStore(transaction);\n        return (collectionGroup\n            ? indexes.loadAll(DbIndexConfigurationCollectionGroupIndex, IDBKeyRange.bound(collectionGroup, collectionGroup))\n            : indexes.loadAll()).next(indexConfigs => {\n            const result = [];\n            return PersistencePromise.forEach(indexConfigs, (indexConfig) => {\n                return states\n                    .get([indexConfig.indexId, this.uid])\n                    .next(indexState => {\n                    result.push(fromDbIndexConfiguration(indexConfig, indexState));\n                });\n            }).next(() => result);\n        });\n    }\n    getNextCollectionGroupToUpdate(transaction) {\n        return this.getFieldIndexes(transaction).next(indexes => {\n            if (indexes.length === 0) {\n                return null;\n            }\n            indexes.sort((l, r) => {\n                const cmp = l.indexState.sequenceNumber - r.indexState.sequenceNumber;\n                return cmp !== 0\n                    ? cmp\n                    : primitiveComparator(l.collectionGroup, r.collectionGroup);\n            });\n            return indexes[0].collectionGroup;\n        });\n    }\n    updateCollectionGroup(transaction, collectionGroup, offset) {\n        const indexes = indexConfigurationStore(transaction);\n        const states = indexStateStore(transaction);\n        return this.getNextSequenceNumber(transaction).next(nextSequenceNumber => indexes\n            .loadAll(DbIndexConfigurationCollectionGroupIndex, IDBKeyRange.bound(collectionGroup, collectionGroup))\n            .next(configs => PersistencePromise.forEach(configs, (config) => states.put(toDbIndexState(config.indexId, this.uid, nextSequenceNumber, offset)))));\n    }\n    updateIndexEntries(transaction, documents) {\n        // Porting Note: `getFieldIndexes()` on Web does not cache index lookups as\n        // it could be used across different IndexedDB transactions. As any cached\n        // data might be invalidated by other multi-tab clients, we can only trust\n        // data within a single IndexedDB transaction. We therefore add a cache\n        // here.\n        const memoizedIndexes = new Map();\n        return PersistencePromise.forEach(documents, (key, doc) => {\n            const memoizedCollectionIndexes = memoizedIndexes.get(key.collectionGroup);\n            const fieldIndexes = memoizedCollectionIndexes\n                ? PersistencePromise.resolve(memoizedCollectionIndexes)\n                : this.getFieldIndexes(transaction, key.collectionGroup);\n            return fieldIndexes.next(fieldIndexes => {\n                memoizedIndexes.set(key.collectionGroup, fieldIndexes);\n                return PersistencePromise.forEach(fieldIndexes, (fieldIndex) => {\n                    return this.getExistingIndexEntries(transaction, key, fieldIndex).next(existingEntries => {\n                        const newEntries = this.computeIndexEntries(doc, fieldIndex);\n                        if (!existingEntries.isEqual(newEntries)) {\n                            return this.updateEntries(transaction, doc, fieldIndex, existingEntries, newEntries);\n                        }\n                        return PersistencePromise.resolve();\n                    });\n                });\n            });\n        });\n    }\n    addIndexEntry(transaction, document, fieldIndex, indexEntry) {\n        const indexEntries = indexEntriesStore(transaction);\n        return indexEntries.put(indexEntry.dbIndexEntry(this.uid, this.encodeDirectionalKey(fieldIndex, document.key), document.key));\n    }\n    deleteIndexEntry(transaction, document, fieldIndex, indexEntry) {\n        const indexEntries = indexEntriesStore(transaction);\n        return indexEntries.delete(indexEntry.dbIndexEntryKey(this.uid, this.encodeDirectionalKey(fieldIndex, document.key), document.key));\n    }\n    getExistingIndexEntries(transaction, documentKey, fieldIndex) {\n        const indexEntries = indexEntriesStore(transaction);\n        let results = new SortedSet(indexEntryComparator);\n        return indexEntries\n            .iterate({\n            index: DbIndexEntryDocumentKeyIndex,\n            range: IDBKeyRange.only([\n                fieldIndex.indexId,\n                this.uid,\n                encodeKeySafeBytes(this.encodeDirectionalKey(fieldIndex, documentKey))\n            ])\n        }, (_, entry) => {\n            results = results.add(new IndexEntry(fieldIndex.indexId, documentKey, decodeKeySafeBytes(entry.arrayValue), decodeKeySafeBytes(entry.directionalValue)));\n        })\n            .next(() => results);\n    }\n    /** Creates the index entries for the given document. */\n    computeIndexEntries(document, fieldIndex) {\n        let results = new SortedSet(indexEntryComparator);\n        const directionalValue = this.encodeDirectionalElements(fieldIndex, document);\n        if (directionalValue == null) {\n            return results;\n        }\n        const arraySegment = fieldIndexGetArraySegment(fieldIndex);\n        if (arraySegment != null) {\n            const value = document.data.field(arraySegment.fieldPath);\n            if (isArray(value)) {\n                for (const arrayValue of value.arrayValue.values || []) {\n                    results = results.add(new IndexEntry(fieldIndex.indexId, document.key, this.encodeSingleElement(arrayValue), directionalValue));\n                }\n            }\n        }\n        else {\n            results = results.add(new IndexEntry(fieldIndex.indexId, document.key, EMPTY_VALUE, directionalValue));\n        }\n        return results;\n    }\n    /**\n     * Updates the index entries for the provided document by deleting entries\n     * that are no longer referenced in `newEntries` and adding all newly added\n     * entries.\n     */\n    updateEntries(transaction, document, fieldIndex, existingEntries, newEntries) {\n        logDebug(LOG_TAG$f, \"Updating index entries for document '%s'\", document.key);\n        const promises = [];\n        diffSortedSets(existingEntries, newEntries, indexEntryComparator, \n        /* onAdd= */ entry => {\n            promises.push(this.addIndexEntry(transaction, document, fieldIndex, entry));\n        }, \n        /* onRemove= */ entry => {\n            promises.push(this.deleteIndexEntry(transaction, document, fieldIndex, entry));\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    getNextSequenceNumber(transaction) {\n        let nextSequenceNumber = 1;\n        const states = indexStateStore(transaction);\n        return states\n            .iterate({\n            index: DbIndexStateSequenceNumberIndex,\n            reverse: true,\n            range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])\n        }, (_, state, controller) => {\n            controller.done();\n            nextSequenceNumber = state.sequenceNumber + 1;\n        })\n            .next(() => nextSequenceNumber);\n    }\n    /**\n     * Returns a new set of IDB ranges that splits the existing range and excludes\n     * any values that match the `notInValue` from these ranges. As an example,\n     * '[foo > 2 && foo != 3]` becomes  `[foo > 2 && < 3, foo > 3]`.\n     */\n    createRange(lower, upper, notInValues) {\n        // The notIn values need to be sorted and unique so that we can return a\n        // sorted set of non-overlapping ranges.\n        notInValues = notInValues\n            .sort((l, r) => indexEntryComparator(l, r))\n            .filter((el, i, values) => !i || indexEntryComparator(el, values[i - 1]) !== 0);\n        const bounds = [];\n        bounds.push(lower);\n        for (const notInValue of notInValues) {\n            const cmpToLower = indexEntryComparator(notInValue, lower);\n            const cmpToUpper = indexEntryComparator(notInValue, upper);\n            if (cmpToLower === 0) {\n                // `notInValue` is the lower bound. We therefore need to raise the bound\n                // to the next value.\n                bounds[0] = lower.successor();\n            }\n            else if (cmpToLower > 0 && cmpToUpper < 0) {\n                // `notInValue` is in the middle of the range\n                bounds.push(notInValue);\n                bounds.push(notInValue.successor());\n            }\n            else if (cmpToUpper > 0) {\n                // `notInValue` (and all following values) are out of the range\n                break;\n            }\n        }\n        bounds.push(upper);\n        const ranges = [];\n        for (let i = 0; i < bounds.length; i += 2) {\n            // If we encounter two bounds that will create an unmatchable key range,\n            // then we return an empty set of key ranges.\n            if (this.isRangeMatchable(bounds[i], bounds[i + 1])) {\n                return [];\n            }\n            const lowerBound = bounds[i].dbIndexEntryKey(this.uid, EMPTY_VALUE, DocumentKey.empty());\n            const upperBound = bounds[i + 1].dbIndexEntryKey(this.uid, EMPTY_VALUE, DocumentKey.empty());\n            ranges.push(IDBKeyRange.bound(lowerBound, upperBound));\n        }\n        return ranges;\n    }\n    isRangeMatchable(lowerBound, upperBound) {\n        // If lower bound is greater than the upper bound, then the key\n        // range can never be matched.\n        return indexEntryComparator(lowerBound, upperBound) > 0;\n    }\n    getMinOffsetFromCollectionGroup(transaction, collectionGroup) {\n        return this.getFieldIndexes(transaction, collectionGroup).next(getMinOffsetFromFieldIndexes);\n    }\n    getMinOffset(transaction, target) {\n        return PersistencePromise.mapArray(this.getSubTargets(target), (subTarget) => this.getFieldIndex(transaction, subTarget).next(index => index ? index : fail(0xad8a))).next(getMinOffsetFromFieldIndexes);\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the collectionParents\n * document store.\n */\nfunction collectionParentsStore(txn) {\n    return getStore(txn, DbCollectionParentStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the index entry object store.\n */\nfunction indexEntriesStore(txn) {\n    return getStore(txn, DbIndexEntryStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the index configuration object store.\n */\nfunction indexConfigurationStore(txn) {\n    return getStore(txn, DbIndexConfigurationStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the index state object store.\n */\nfunction indexStateStore(txn) {\n    return getStore(txn, DbIndexStateStore);\n}\nfunction getMinOffsetFromFieldIndexes(fieldIndexes) {\n    hardAssert(fieldIndexes.length !== 0, 0x7099);\n    let minOffset = fieldIndexes[0].indexState.offset;\n    let maxBatchId = minOffset.largestBatchId;\n    for (let i = 1; i < fieldIndexes.length; i++) {\n        const newOffset = fieldIndexes[i].indexState.offset;\n        if (indexOffsetComparator(newOffset, minOffset) < 0) {\n            minOffset = newOffset;\n        }\n        if (maxBatchId < newOffset.largestBatchId) {\n            maxBatchId = newOffset.largestBatchId;\n        }\n    }\n    return new IndexOffset(minOffset.readTime, minOffset.documentKey, maxBatchId);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Delete a mutation batch and the associated document mutations.\n * @returns A PersistencePromise of the document mutations that were removed.\n */\nfunction removeMutationBatch(txn, userId, batch) {\n    const mutationStore = txn.store(DbMutationBatchStore);\n    const indexTxn = txn.store(DbDocumentMutationStore);\n    const promises = [];\n    const range = IDBKeyRange.only(batch.batchId);\n    let numDeleted = 0;\n    const removePromise = mutationStore.iterate({ range }, (key, value, control) => {\n        numDeleted++;\n        return control.delete();\n    });\n    promises.push(removePromise.next(() => {\n        hardAssert(numDeleted === 1, 0xb7de, { batchId: batch.batchId });\n    }));\n    const removedDocuments = [];\n    for (const mutation of batch.mutations) {\n        const indexKey = newDbDocumentMutationKey(userId, mutation.key.path, batch.batchId);\n        promises.push(indexTxn.delete(indexKey));\n        removedDocuments.push(mutation.key);\n    }\n    return PersistencePromise.waitFor(promises).next(() => removedDocuments);\n}\n/**\n * Returns an approximate size for the given document.\n */\nfunction dbDocumentSize(doc) {\n    if (!doc) {\n        return 0;\n    }\n    let value;\n    if (doc.document) {\n        value = doc.document;\n    }\n    else if (doc.unknownDocument) {\n        value = doc.unknownDocument;\n    }\n    else if (doc.noDocument) {\n        value = doc.noDocument;\n    }\n    else {\n        throw fail(0x398b);\n    }\n    return JSON.stringify(value).length;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** A mutation queue for a specific user, backed by IndexedDB. */\nclass IndexedDbMutationQueue {\n    constructor(\n    /**\n     * The normalized userId (e.g. null UID => \"\" userId) used to store /\n     * retrieve mutations.\n     */\n    userId, serializer, indexManager, referenceDelegate) {\n        this.userId = userId;\n        this.serializer = serializer;\n        this.indexManager = indexManager;\n        this.referenceDelegate = referenceDelegate;\n        /**\n         * Caches the document keys for pending mutation batches. If the mutation\n         * has been removed from IndexedDb, the cached value may continue to\n         * be used to retrieve the batch's document keys. To remove a cached value\n         * locally, `removeCachedMutationKeys()` should be invoked either directly\n         * or through `removeMutationBatches()`.\n         *\n         * With multi-tab, when the primary client acknowledges or rejects a mutation,\n         * this cache is used by secondary clients to invalidate the local\n         * view of the documents that were previously affected by the mutation.\n         */\n        // PORTING NOTE: Multi-tab only.\n        this.documentKeysByBatchId = {};\n    }\n    /**\n     * Creates a new mutation queue for the given user.\n     * @param user - The user for which to create a mutation queue.\n     * @param serializer - The serializer to use when persisting to IndexedDb.\n     */\n    static forUser(user, serializer, indexManager, referenceDelegate) {\n        // TODO(mcg): Figure out what constraints there are on userIDs\n        // In particular, are there any reserved characters? are empty ids allowed?\n        // For the moment store these together in the same mutations table assuming\n        // that empty userIDs aren't allowed.\n        hardAssert(user.uid !== '', 0xfb83);\n        const userId = user.isAuthenticated() ? user.uid : '';\n        return new IndexedDbMutationQueue(userId, serializer, indexManager, referenceDelegate);\n    }\n    checkEmpty(transaction) {\n        let empty = true;\n        const range = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);\n        return mutationsStore(transaction)\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range }, (key, value, control) => {\n            empty = false;\n            control.done();\n        })\n            .next(() => empty);\n    }\n    addMutationBatch(transaction, localWriteTime, baseMutations, mutations) {\n        const documentStore = documentMutationsStore(transaction);\n        const mutationStore = mutationsStore(transaction);\n        // The IndexedDb implementation in Chrome (and Firefox) does not handle\n        // compound indices that include auto-generated keys correctly. To ensure\n        // that the index entry is added correctly in all browsers, we perform two\n        // writes: The first write is used to retrieve the next auto-generated Batch\n        // ID, and the second write populates the index and stores the actual\n        // mutation batch.\n        // See: https://bugs.chromium.org/p/chromium/issues/detail?id=701972\n        // We write an empty object to obtain key\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return mutationStore.add({}).next(batchId => {\n            hardAssert(typeof batchId === 'number', 0xbf7b);\n            const batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);\n            const dbBatch = toDbMutationBatch(this.serializer, this.userId, batch);\n            const promises = [];\n            let collectionParents = new SortedSet((l, r) => primitiveComparator(l.canonicalString(), r.canonicalString()));\n            for (const mutation of mutations) {\n                const indexKey = newDbDocumentMutationKey(this.userId, mutation.key.path, batchId);\n                collectionParents = collectionParents.add(mutation.key.path.popLast());\n                promises.push(mutationStore.put(dbBatch));\n                promises.push(documentStore.put(indexKey, DbDocumentMutationPlaceholder));\n            }\n            collectionParents.forEach(parent => {\n                promises.push(this.indexManager.addToCollectionParentIndex(transaction, parent));\n            });\n            transaction.addOnCommittedListener(() => {\n                this.documentKeysByBatchId[batchId] = batch.keys();\n            });\n            return PersistencePromise.waitFor(promises).next(() => batch);\n        });\n    }\n    lookupMutationBatch(transaction, batchId) {\n        return mutationsStore(transaction)\n            .get(batchId)\n            .next(dbBatch => {\n            if (dbBatch) {\n                hardAssert(dbBatch.userId === this.userId, 0x0030, `Unexpected user for mutation batch`, {\n                    userId: dbBatch.userId,\n                    batchId\n                });\n                return fromDbMutationBatch(this.serializer, dbBatch);\n            }\n            return null;\n        });\n    }\n    /**\n     * Returns the document keys for the mutation batch with the given batchId.\n     * For primary clients, this method returns `null` after\n     * `removeMutationBatches()` has been called. Secondary clients return a\n     * cached result until `removeCachedMutationKeys()` is invoked.\n     */\n    // PORTING NOTE: Multi-tab only.\n    lookupMutationKeys(transaction, batchId) {\n        if (this.documentKeysByBatchId[batchId]) {\n            return PersistencePromise.resolve(this.documentKeysByBatchId[batchId]);\n        }\n        else {\n            return this.lookupMutationBatch(transaction, batchId).next(batch => {\n                if (batch) {\n                    const keys = batch.keys();\n                    this.documentKeysByBatchId[batchId] = keys;\n                    return keys;\n                }\n                else {\n                    return null;\n                }\n            });\n        }\n    }\n    getNextMutationBatchAfterBatchId(transaction, batchId) {\n        const nextBatchId = batchId + 1;\n        const range = IDBKeyRange.lowerBound([this.userId, nextBatchId]);\n        let foundBatch = null;\n        return mutationsStore(transaction)\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range }, (key, dbBatch, control) => {\n            if (dbBatch.userId === this.userId) {\n                hardAssert(dbBatch.batchId >= nextBatchId, 0xb9a4, { nextBatchId });\n                foundBatch = fromDbMutationBatch(this.serializer, dbBatch);\n            }\n            control.done();\n        })\n            .next(() => foundBatch);\n    }\n    getHighestUnacknowledgedBatchId(transaction) {\n        const range = IDBKeyRange.upperBound([\n            this.userId,\n            Number.POSITIVE_INFINITY\n        ]);\n        let batchId = BATCHID_UNKNOWN;\n        return mutationsStore(transaction)\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range, reverse: true }, (key, dbBatch, control) => {\n            batchId = dbBatch.batchId;\n            control.done();\n        })\n            .next(() => batchId);\n    }\n    getAllMutationBatches(transaction) {\n        const range = IDBKeyRange.bound([this.userId, BATCHID_UNKNOWN], [this.userId, Number.POSITIVE_INFINITY]);\n        return mutationsStore(transaction)\n            .loadAll(DbMutationBatchUserMutationsIndex, range)\n            .next(dbBatches => dbBatches.map(dbBatch => fromDbMutationBatch(this.serializer, dbBatch)));\n    }\n    getAllMutationBatchesAffectingDocumentKey(transaction, documentKey) {\n        // Scan the document-mutation index starting with a prefix starting with\n        // the given documentKey.\n        const indexPrefix = newDbDocumentMutationPrefixForPath(this.userId, documentKey.path);\n        const indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        const results = [];\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, (indexKey, _, control) => {\n            const [userID, encodedPath, batchId] = indexKey;\n            // Only consider rows matching exactly the specific key of\n            // interest. Note that because we order by path first, and we\n            // order terminators before path separators, we'll encounter all\n            // the index rows for documentKey contiguously. In particular, all\n            // the rows for documentKey will occur before any rows for\n            // documents nested in a subcollection beneath documentKey so we\n            // can stop as soon as we hit any such row.\n            const path = decodeResourcePath(encodedPath);\n            if (userID !== this.userId || !documentKey.path.isEqual(path)) {\n                control.done();\n                return;\n            }\n            // Look up the mutation batch in the store.\n            return mutationsStore(transaction)\n                .get(batchId)\n                .next(mutation => {\n                if (!mutation) {\n                    throw fail(0xf028, {\n                        indexKey,\n                        batchId\n                    });\n                }\n                hardAssert(mutation.userId === this.userId, 0x2907, `Unexpected user for mutation batch`, {\n                    userId: mutation.userId,\n                    batchId\n                });\n                results.push(fromDbMutationBatch(this.serializer, mutation));\n            });\n        })\n            .next(() => results);\n    }\n    getAllMutationBatchesAffectingDocumentKeys(transaction, documentKeys) {\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\n        const promises = [];\n        documentKeys.forEach(documentKey => {\n            const indexStart = newDbDocumentMutationPrefixForPath(this.userId, documentKey.path);\n            const range = IDBKeyRange.lowerBound(indexStart);\n            const promise = documentMutationsStore(transaction).iterate({ range }, (indexKey, _, control) => {\n                const [userID, encodedPath, batchID] = indexKey;\n                // Only consider rows matching exactly the specific key of\n                // interest. Note that because we order by path first, and we\n                // order terminators before path separators, we'll encounter all\n                // the index rows for documentKey contiguously. In particular, all\n                // the rows for documentKey will occur before any rows for\n                // documents nested in a subcollection beneath documentKey so we\n                // can stop as soon as we hit any such row.\n                const path = decodeResourcePath(encodedPath);\n                if (userID !== this.userId || !documentKey.path.isEqual(path)) {\n                    control.done();\n                    return;\n                }\n                uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n            });\n            promises.push(promise);\n        });\n        return PersistencePromise.waitFor(promises).next(() => this.lookupMutationBatches(transaction, uniqueBatchIDs));\n    }\n    getAllMutationBatchesAffectingQuery(transaction, query) {\n        const queryPath = query.path;\n        const immediateChildrenLength = queryPath.length + 1;\n        // TODO(mcg): Actually implement a single-collection query\n        //\n        // This is actually executing an ancestor query, traversing the whole\n        // subtree below the collection which can be horrifically inefficient for\n        // some structures. The right way to solve this is to implement the full\n        // value index, but that's not in the cards in the near future so this is\n        // the best we can do for the moment.\n        //\n        // Since we don't yet index the actual properties in the mutations, our\n        // current approach is to just return all mutation batches that affect\n        // documents in the collection being queried.\n        const indexPrefix = newDbDocumentMutationPrefixForPath(this.userId, queryPath);\n        const indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        // Collect up unique batchIDs encountered during a scan of the index. Use a\n        // SortedSet to accumulate batch IDs so they can be traversed in order in a\n        // scan of the main table.\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, (indexKey, _, control) => {\n            const [userID, encodedPath, batchID] = indexKey;\n            const path = decodeResourcePath(encodedPath);\n            if (userID !== this.userId || !queryPath.isPrefixOf(path)) {\n                control.done();\n                return;\n            }\n            // Rows with document keys more than one segment longer than the\n            // query path can't be matches. For example, a query on 'rooms'\n            // can't match the document /rooms/abc/messages/xyx.\n            // TODO(mcg): we'll need a different scanner when we implement\n            // ancestor queries.\n            if (path.length !== immediateChildrenLength) {\n                return;\n            }\n            uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n        })\n            .next(() => this.lookupMutationBatches(transaction, uniqueBatchIDs));\n    }\n    lookupMutationBatches(transaction, batchIDs) {\n        const results = [];\n        const promises = [];\n        // TODO(rockwood): Implement this using iterate.\n        batchIDs.forEach(batchId => {\n            promises.push(mutationsStore(transaction)\n                .get(batchId)\n                .next(mutation => {\n                if (mutation === null) {\n                    throw fail(0x89ca, {\n                        batchId\n                    });\n                }\n                hardAssert(mutation.userId === this.userId, 0x2614, `Unexpected user for mutation batch`, { userId: mutation.userId, batchId });\n                results.push(fromDbMutationBatch(this.serializer, mutation));\n            }));\n        });\n        return PersistencePromise.waitFor(promises).next(() => results);\n    }\n    removeMutationBatch(transaction, batch) {\n        return removeMutationBatch(transaction.simpleDbTransaction, this.userId, batch).next(removedDocuments => {\n            transaction.addOnCommittedListener(() => {\n                this.removeCachedMutationKeys(batch.batchId);\n            });\n            return PersistencePromise.forEach(removedDocuments, (key) => {\n                return this.referenceDelegate.markPotentiallyOrphaned(transaction, key);\n            });\n        });\n    }\n    /**\n     * Clears the cached keys for a mutation batch. This method should be\n     * called by secondary clients after they process mutation updates.\n     *\n     * Note that this method does not have to be called from primary clients as\n     * the corresponding cache entries are cleared when an acknowledged or\n     * rejected batch is removed from the mutation queue.\n     */\n    // PORTING NOTE: Multi-tab only\n    removeCachedMutationKeys(batchId) {\n        delete this.documentKeysByBatchId[batchId];\n    }\n    performConsistencyCheck(txn) {\n        return this.checkEmpty(txn).next(empty => {\n            if (!empty) {\n                return PersistencePromise.resolve();\n            }\n            // Verify that there are no entries in the documentMutations index if\n            // the queue is empty.\n            const startRange = IDBKeyRange.lowerBound(newDbDocumentMutationPrefixForUser(this.userId));\n            const danglingMutationReferences = [];\n            return documentMutationsStore(txn)\n                .iterate({ range: startRange }, (key, _, control) => {\n                const userID = key[0];\n                if (userID !== this.userId) {\n                    control.done();\n                    return;\n                }\n                else {\n                    const path = decodeResourcePath(key[1]);\n                    danglingMutationReferences.push(path);\n                }\n            })\n                .next(() => {\n                hardAssert(danglingMutationReferences.length === 0, 0xdd90, {\n                    danglingKeys: danglingMutationReferences.map(p => p.canonicalString())\n                });\n            });\n        });\n    }\n    containsKey(txn, key) {\n        return mutationQueueContainsKey(txn, this.userId, key);\n    }\n    // PORTING NOTE: Multi-tab only (state is held in memory in other clients).\n    /** Returns the mutation queue's metadata from IndexedDb. */\n    getMutationQueueMetadata(transaction) {\n        return mutationQueuesStore(transaction)\n            .get(this.userId)\n            .next((metadata) => {\n            return (metadata || {\n                userId: this.userId,\n                lastAcknowledgedBatchId: BATCHID_UNKNOWN,\n                lastStreamToken: ''\n            });\n        });\n    }\n}\n/**\n * @returns true if the mutation queue for the given user contains a pending\n *         mutation for the given key.\n */\nfunction mutationQueueContainsKey(txn, userId, key) {\n    const indexKey = newDbDocumentMutationPrefixForPath(userId, key.path);\n    const encodedPath = indexKey[1];\n    const startRange = IDBKeyRange.lowerBound(indexKey);\n    let containsKey = false;\n    return documentMutationsStore(txn)\n        .iterate({ range: startRange, keysOnly: true }, (key, value, control) => {\n        const [userID, keyPath, /*batchID*/ _] = key;\n        if (userID === userId && keyPath === encodedPath) {\n            containsKey = true;\n        }\n        control.done();\n    })\n        .next(() => containsKey);\n}\n/** Returns true if any mutation queue contains the given document. */\nfunction mutationQueuesContainKey(txn, docKey) {\n    let found = false;\n    return mutationQueuesStore(txn)\n        .iterateSerial(userId => {\n        return mutationQueueContainsKey(txn, userId, docKey).next(containsKey => {\n            if (containsKey) {\n                found = true;\n            }\n            return PersistencePromise.resolve(!containsKey);\n        });\n    })\n        .next(() => found);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutations object store.\n */\nfunction mutationsStore(txn) {\n    return getStore(txn, DbMutationBatchStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction documentMutationsStore(txn) {\n    return getStore(txn, DbDocumentMutationStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction mutationQueuesStore(txn) {\n    return getStore(txn, DbMutationQueueStore);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Offset to ensure non-overlapping target ids. */\nconst OFFSET = 2;\n/**\n * Generates monotonically increasing target IDs for sending targets to the\n * watch stream.\n *\n * The client constructs two generators, one for the target cache, and one for\n * for the sync engine (to generate limbo documents targets). These\n * generators produce non-overlapping IDs (by using even and odd IDs\n * respectively).\n *\n * By separating the target ID space, the query cache can generate target IDs\n * that persist across client restarts, while sync engine can independently\n * generate in-memory target IDs that are transient and can be reused after a\n * restart.\n */\nclass TargetIdGenerator {\n    constructor(lastId) {\n        this.lastId = lastId;\n    }\n    next() {\n        this.lastId += OFFSET;\n        return this.lastId;\n    }\n    static forTargetCache() {\n        // The target cache generator must return '2' in its first call to `next()`\n        // as there is no differentiation in the protocol layer between an unset\n        // number and the number '0'. If we were to sent a target with target ID\n        // '0', the backend would consider it unset and replace it with its own ID.\n        return new TargetIdGenerator(2 - OFFSET);\n    }\n    static forSyncEngine() {\n        // Sync engine assigns target IDs for limbo document detection.\n        return new TargetIdGenerator(1 - OFFSET);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass IndexedDbTargetCache {\n    constructor(referenceDelegate, serializer) {\n        this.referenceDelegate = referenceDelegate;\n        this.serializer = serializer;\n    }\n    // PORTING NOTE: We don't cache global metadata for the target cache, since\n    // some of it (in particular `highestTargetId`) can be modified by secondary\n    // tabs. We could perhaps be more granular (and e.g. still cache\n    // `lastRemoteSnapshotVersion` in memory) but for simplicity we currently go\n    // to IndexedDb whenever we need to read metadata. We can revisit if it turns\n    // out to have a meaningful performance impact.\n    allocateTargetId(transaction) {\n        return this.retrieveMetadata(transaction).next(metadata => {\n            const targetIdGenerator = new TargetIdGenerator(metadata.highestTargetId);\n            metadata.highestTargetId = targetIdGenerator.next();\n            return this.saveMetadata(transaction, metadata).next(() => metadata.highestTargetId);\n        });\n    }\n    getLastRemoteSnapshotVersion(transaction) {\n        return this.retrieveMetadata(transaction).next(metadata => {\n            return SnapshotVersion.fromTimestamp(new Timestamp(metadata.lastRemoteSnapshotVersion.seconds, metadata.lastRemoteSnapshotVersion.nanoseconds));\n        });\n    }\n    getHighestSequenceNumber(transaction) {\n        return this.retrieveMetadata(transaction).next(targetGlobal => targetGlobal.highestListenSequenceNumber);\n    }\n    setTargetsMetadata(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {\n        return this.retrieveMetadata(transaction).next(metadata => {\n            metadata.highestListenSequenceNumber = highestListenSequenceNumber;\n            if (lastRemoteSnapshotVersion) {\n                metadata.lastRemoteSnapshotVersion =\n                    lastRemoteSnapshotVersion.toTimestamp();\n            }\n            if (highestListenSequenceNumber > metadata.highestListenSequenceNumber) {\n                metadata.highestListenSequenceNumber = highestListenSequenceNumber;\n            }\n            return this.saveMetadata(transaction, metadata);\n        });\n    }\n    addTargetData(transaction, targetData) {\n        return this.saveTargetData(transaction, targetData).next(() => {\n            return this.retrieveMetadata(transaction).next(metadata => {\n                metadata.targetCount += 1;\n                this.updateMetadataFromTargetData(targetData, metadata);\n                return this.saveMetadata(transaction, metadata);\n            });\n        });\n    }\n    updateTargetData(transaction, targetData) {\n        return this.saveTargetData(transaction, targetData);\n    }\n    removeTargetData(transaction, targetData) {\n        return this.removeMatchingKeysForTargetId(transaction, targetData.targetId)\n            .next(() => targetsStore(transaction).delete(targetData.targetId))\n            .next(() => this.retrieveMetadata(transaction))\n            .next(metadata => {\n            hardAssert(metadata.targetCount > 0, 0x1f81);\n            metadata.targetCount -= 1;\n            return this.saveMetadata(transaction, metadata);\n        });\n    }\n    /**\n     * Drops any targets with sequence number less than or equal to the upper bound, excepting those\n     * present in `activeTargetIds`. Document associations for the removed targets are also removed.\n     * Returns the number of targets removed.\n     */\n    removeTargets(txn, upperBound, activeTargetIds) {\n        let count = 0;\n        const promises = [];\n        return targetsStore(txn)\n            .iterate((key, value) => {\n            const targetData = fromDbTarget(value);\n            if (targetData.sequenceNumber <= upperBound &&\n                activeTargetIds.get(targetData.targetId) === null) {\n                count++;\n                promises.push(this.removeTargetData(txn, targetData));\n            }\n        })\n            .next(() => PersistencePromise.waitFor(promises))\n            .next(() => count);\n    }\n    /**\n     * Call provided function with each `TargetData` that we have cached.\n     */\n    forEachTarget(txn, f) {\n        return targetsStore(txn).iterate((key, value) => {\n            const targetData = fromDbTarget(value);\n            f(targetData);\n        });\n    }\n    retrieveMetadata(transaction) {\n        return globalTargetStore(transaction)\n            .get(DbTargetGlobalKey)\n            .next(metadata => {\n            hardAssert(metadata !== null, 0x0b48);\n            return metadata;\n        });\n    }\n    saveMetadata(transaction, metadata) {\n        return globalTargetStore(transaction).put(DbTargetGlobalKey, metadata);\n    }\n    saveTargetData(transaction, targetData) {\n        return targetsStore(transaction).put(toDbTarget(this.serializer, targetData));\n    }\n    /**\n     * In-place updates the provided metadata to account for values in the given\n     * TargetData. Saving is done separately. Returns true if there were any\n     * changes to the metadata.\n     */\n    updateMetadataFromTargetData(targetData, metadata) {\n        let updated = false;\n        if (targetData.targetId > metadata.highestTargetId) {\n            metadata.highestTargetId = targetData.targetId;\n            updated = true;\n        }\n        if (targetData.sequenceNumber > metadata.highestListenSequenceNumber) {\n            metadata.highestListenSequenceNumber = targetData.sequenceNumber;\n            updated = true;\n        }\n        return updated;\n    }\n    getTargetCount(transaction) {\n        return this.retrieveMetadata(transaction).next(metadata => metadata.targetCount);\n    }\n    getTargetData(transaction, target) {\n        // Iterating by the canonicalId may yield more than one result because\n        // canonicalId values are not required to be unique per target. This query\n        // depends on the queryTargets index to be efficient.\n        const canonicalId = canonifyTarget(target);\n        const range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);\n        let result = null;\n        return targetsStore(transaction)\n            .iterate({ range, index: DbTargetQueryTargetsIndexName }, (key, value, control) => {\n            const found = fromDbTarget(value);\n            // After finding a potential match, check that the target is\n            // actually equal to the requested target.\n            if (targetEquals(target, found.target)) {\n                result = found;\n                control.done();\n            }\n        })\n            .next(() => result);\n    }\n    addMatchingKeys(txn, keys, targetId) {\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // IndexedDb.\n        const promises = [];\n        const store = documentTargetStore(txn);\n        keys.forEach(key => {\n            const path = encodeResourcePath(key.path);\n            promises.push(store.put({ targetId, path }));\n            promises.push(this.referenceDelegate.addReference(txn, targetId, key));\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    removeMatchingKeys(txn, keys, targetId) {\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // IndexedDb.\n        const store = documentTargetStore(txn);\n        return PersistencePromise.forEach(keys, (key) => {\n            const path = encodeResourcePath(key.path);\n            return PersistencePromise.waitFor([\n                store.delete([targetId, path]),\n                this.referenceDelegate.removeReference(txn, targetId, key)\n            ]);\n        });\n    }\n    removeMatchingKeysForTargetId(txn, targetId) {\n        const store = documentTargetStore(txn);\n        const range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        return store.delete(range);\n    }\n    getMatchingKeysForTargetId(txn, targetId) {\n        const range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        const store = documentTargetStore(txn);\n        let result = documentKeySet();\n        return store\n            .iterate({ range, keysOnly: true }, (key, _, control) => {\n            const path = decodeResourcePath(key[1]);\n            const docKey = new DocumentKey(path);\n            result = result.add(docKey);\n        })\n            .next(() => result);\n    }\n    containsKey(txn, key) {\n        const path = encodeResourcePath(key.path);\n        const range = IDBKeyRange.bound([path], [immediateSuccessor(path)], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        let count = 0;\n        return documentTargetStore(txn)\n            .iterate({\n            index: DbTargetDocumentDocumentTargetsIndex,\n            keysOnly: true,\n            range\n        }, ([targetId, path], _, control) => {\n            // Having a sentinel row for a document does not count as containing that document;\n            // For the target cache, containing the document means the document is part of some\n            // target.\n            if (targetId !== 0) {\n                count++;\n                control.done();\n            }\n        })\n            .next(() => count > 0);\n    }\n    /**\n     * Looks up a TargetData entry by target ID.\n     *\n     * @param targetId - The target ID of the TargetData entry to look up.\n     * @returns The cached TargetData entry, or null if the cache has no entry for\n     * the target.\n     */\n    // PORTING NOTE: Multi-tab only.\n    getTargetDataForTarget(transaction, targetId) {\n        return targetsStore(transaction)\n            .get(targetId)\n            .next(found => {\n            if (found) {\n                return fromDbTarget(found);\n            }\n            else {\n                return null;\n            }\n        });\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the queries object store.\n */\nfunction targetsStore(txn) {\n    return getStore(txn, DbTargetStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the target globals object store.\n */\nfunction globalTargetStore(txn) {\n    return getStore(txn, DbTargetGlobalStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the document target object store.\n */\nfunction documentTargetStore(txn) {\n    return getStore(txn, DbTargetDocumentStore);\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst GC_DID_NOT_RUN = {\n    didRun: false,\n    sequenceNumbersCollected: 0,\n    targetsRemoved: 0,\n    documentsRemoved: 0\n};\nconst LRU_COLLECTION_DISABLED = -1;\nconst LRU_DEFAULT_CACHE_SIZE_BYTES = 40 * 1024 * 1024;\nclass LruParams {\n    static withCacheSize(cacheSize) {\n        return new LruParams(cacheSize, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\n    }\n    constructor(\n    // When we attempt to collect, we will only do so if the cache size is greater than this\n    // threshold. Passing `COLLECTION_DISABLED` here will cause collection to always be skipped.\n    cacheSizeCollectionThreshold, \n    // The percentage of sequence numbers that we will attempt to collect\n    percentileToCollect, \n    // A cap on the total number of sequence numbers that will be collected. This prevents\n    // us from collecting a huge number of sequence numbers if the cache has grown very large.\n    maximumSequenceNumbersToCollect) {\n        this.cacheSizeCollectionThreshold = cacheSizeCollectionThreshold;\n        this.percentileToCollect = percentileToCollect;\n        this.maximumSequenceNumbersToCollect = maximumSequenceNumbersToCollect;\n    }\n}\nLruParams.DEFAULT_COLLECTION_PERCENTILE = 10;\nLruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1000;\nLruParams.DEFAULT = new LruParams(LRU_DEFAULT_CACHE_SIZE_BYTES, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\nLruParams.DISABLED = new LruParams(LRU_COLLECTION_DISABLED, 0, 0);\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$e = 'LruGarbageCollector';\nconst LRU_MINIMUM_CACHE_SIZE_BYTES = 1 * 1024 * 1024;\n/** How long we wait to try running LRU GC after SDK initialization. */\nconst INITIAL_GC_DELAY_MS = 1 * 60 * 1000;\n/** Minimum amount of time between GC checks, after the first one. */\nconst REGULAR_GC_DELAY_MS = 5 * 60 * 1000;\nfunction bufferEntryComparator([aSequence, aIndex], [bSequence, bIndex]) {\n    const seqCmp = primitiveComparator(aSequence, bSequence);\n    if (seqCmp === 0) {\n        // This order doesn't matter, but we can bias against churn by sorting\n        // entries created earlier as less than newer entries.\n        return primitiveComparator(aIndex, bIndex);\n    }\n    else {\n        return seqCmp;\n    }\n}\n/**\n * Used to calculate the nth sequence number. Keeps a rolling buffer of the\n * lowest n values passed to `addElement`, and finally reports the largest of\n * them in `maxValue`.\n */\nclass RollingSequenceNumberBuffer {\n    constructor(maxElements) {\n        this.maxElements = maxElements;\n        this.buffer = new SortedSet(bufferEntryComparator);\n        this.previousIndex = 0;\n    }\n    nextIndex() {\n        return ++this.previousIndex;\n    }\n    addElement(sequenceNumber) {\n        const entry = [sequenceNumber, this.nextIndex()];\n        if (this.buffer.size < this.maxElements) {\n            this.buffer = this.buffer.add(entry);\n        }\n        else {\n            const highestValue = this.buffer.last();\n            if (bufferEntryComparator(entry, highestValue) < 0) {\n                this.buffer = this.buffer.delete(highestValue).add(entry);\n            }\n        }\n    }\n    get maxValue() {\n        // Guaranteed to be non-empty. If we decide we are not collecting any\n        // sequence numbers, nthSequenceNumber below short-circuits. If we have\n        // decided that we are collecting n sequence numbers, it's because n is some\n        // percentage of the existing sequence numbers. That means we should never\n        // be in a situation where we are collecting sequence numbers but don't\n        // actually have any.\n        return this.buffer.last()[0];\n    }\n}\n/**\n * This class is responsible for the scheduling of LRU garbage collection. It handles checking\n * whether or not GC is enabled, as well as which delay to use before the next run.\n */\nclass LruScheduler {\n    constructor(garbageCollector, asyncQueue, localStore) {\n        this.garbageCollector = garbageCollector;\n        this.asyncQueue = asyncQueue;\n        this.localStore = localStore;\n        this.gcTask = null;\n    }\n    start() {\n        if (this.garbageCollector.params.cacheSizeCollectionThreshold !==\n            LRU_COLLECTION_DISABLED) {\n            this.scheduleGC(INITIAL_GC_DELAY_MS);\n        }\n    }\n    stop() {\n        if (this.gcTask) {\n            this.gcTask.cancel();\n            this.gcTask = null;\n        }\n    }\n    get started() {\n        return this.gcTask !== null;\n    }\n    scheduleGC(delay) {\n        logDebug(LOG_TAG$e, `Garbage collection scheduled in ${delay}ms`);\n        this.gcTask = this.asyncQueue.enqueueAfterDelay(\"lru_garbage_collection\" /* TimerId.LruGarbageCollection */, delay, async () => {\n            this.gcTask = null;\n            try {\n                await this.localStore.collectGarbage(this.garbageCollector);\n            }\n            catch (e) {\n                if (isIndexedDbTransactionError(e)) {\n                    logDebug(LOG_TAG$e, 'Ignoring IndexedDB error during garbage collection: ', e);\n                }\n                else {\n                    await ignoreIfPrimaryLeaseLoss(e);\n                }\n            }\n            await this.scheduleGC(REGULAR_GC_DELAY_MS);\n        });\n    }\n}\n/**\n * Implements the steps for LRU garbage collection.\n */\nclass LruGarbageCollectorImpl {\n    constructor(delegate, params) {\n        this.delegate = delegate;\n        this.params = params;\n    }\n    calculateTargetCount(txn, percentile) {\n        return this.delegate.getSequenceNumberCount(txn).next(targetCount => {\n            return Math.floor((percentile / 100.0) * targetCount);\n        });\n    }\n    nthSequenceNumber(txn, n) {\n        if (n === 0) {\n            return PersistencePromise.resolve(ListenSequence.INVALID);\n        }\n        const buffer = new RollingSequenceNumberBuffer(n);\n        return this.delegate\n            .forEachTarget(txn, target => buffer.addElement(target.sequenceNumber))\n            .next(() => {\n            return this.delegate.forEachOrphanedDocumentSequenceNumber(txn, sequenceNumber => buffer.addElement(sequenceNumber));\n        })\n            .next(() => buffer.maxValue);\n    }\n    removeTargets(txn, upperBound, activeTargetIds) {\n        return this.delegate.removeTargets(txn, upperBound, activeTargetIds);\n    }\n    removeOrphanedDocuments(txn, upperBound) {\n        return this.delegate.removeOrphanedDocuments(txn, upperBound);\n    }\n    collect(txn, activeTargetIds) {\n        if (this.params.cacheSizeCollectionThreshold === LRU_COLLECTION_DISABLED) {\n            logDebug('LruGarbageCollector', 'Garbage collection skipped; disabled');\n            return PersistencePromise.resolve(GC_DID_NOT_RUN);\n        }\n        return this.getCacheSize(txn).next(cacheSize => {\n            if (cacheSize < this.params.cacheSizeCollectionThreshold) {\n                logDebug('LruGarbageCollector', `Garbage collection skipped; Cache size ${cacheSize} ` +\n                    `is lower than threshold ${this.params.cacheSizeCollectionThreshold}`);\n                return GC_DID_NOT_RUN;\n            }\n            else {\n                return this.runGarbageCollection(txn, activeTargetIds);\n            }\n        });\n    }\n    getCacheSize(txn) {\n        return this.delegate.getCacheSize(txn);\n    }\n    runGarbageCollection(txn, activeTargetIds) {\n        let upperBoundSequenceNumber;\n        let sequenceNumbersToCollect, targetsRemoved;\n        // Timestamps for various pieces of the process\n        let countedTargetsTs, foundUpperBoundTs, removedTargetsTs, removedDocumentsTs;\n        const startTs = Date.now();\n        return this.calculateTargetCount(txn, this.params.percentileToCollect)\n            .next(sequenceNumbers => {\n            // Cap at the configured max\n            if (sequenceNumbers > this.params.maximumSequenceNumbersToCollect) {\n                logDebug('LruGarbageCollector', 'Capping sequence numbers to collect down ' +\n                    `to the maximum of ${this.params.maximumSequenceNumbersToCollect} ` +\n                    `from ${sequenceNumbers}`);\n                sequenceNumbersToCollect =\n                    this.params.maximumSequenceNumbersToCollect;\n            }\n            else {\n                sequenceNumbersToCollect = sequenceNumbers;\n            }\n            countedTargetsTs = Date.now();\n            return this.nthSequenceNumber(txn, sequenceNumbersToCollect);\n        })\n            .next(upperBound => {\n            upperBoundSequenceNumber = upperBound;\n            foundUpperBoundTs = Date.now();\n            return this.removeTargets(txn, upperBoundSequenceNumber, activeTargetIds);\n        })\n            .next(numTargetsRemoved => {\n            targetsRemoved = numTargetsRemoved;\n            removedTargetsTs = Date.now();\n            return this.removeOrphanedDocuments(txn, upperBoundSequenceNumber);\n        })\n            .next(documentsRemoved => {\n            removedDocumentsTs = Date.now();\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.DEBUG) {\n                const desc = 'LRU Garbage Collection\\n' +\n                    `\\tCounted targets in ${countedTargetsTs - startTs}ms\\n` +\n                    `\\tDetermined least recently used ${sequenceNumbersToCollect} in ` +\n                    `${foundUpperBoundTs - countedTargetsTs}ms\\n` +\n                    `\\tRemoved ${targetsRemoved} targets in ` +\n                    `${removedTargetsTs - foundUpperBoundTs}ms\\n` +\n                    `\\tRemoved ${documentsRemoved} documents in ` +\n                    `${removedDocumentsTs - removedTargetsTs}ms\\n` +\n                    `Total Duration: ${removedDocumentsTs - startTs}ms`;\n                logDebug('LruGarbageCollector', desc);\n            }\n            return PersistencePromise.resolve({\n                didRun: true,\n                sequenceNumbersCollected: sequenceNumbersToCollect,\n                targetsRemoved,\n                documentsRemoved\n            });\n        });\n    }\n}\nfunction newLruGarbageCollector(delegate, params) {\n    return new LruGarbageCollectorImpl(delegate, params);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Provides LRU functionality for IndexedDB persistence. */\nclass IndexedDbLruDelegateImpl {\n    constructor(db, params) {\n        this.db = db;\n        this.garbageCollector = newLruGarbageCollector(this, params);\n    }\n    getSequenceNumberCount(txn) {\n        const docCountPromise = this.orphanedDocumentCount(txn);\n        const targetCountPromise = this.db.getTargetCache().getTargetCount(txn);\n        return targetCountPromise.next(targetCount => docCountPromise.next(docCount => targetCount + docCount));\n    }\n    orphanedDocumentCount(txn) {\n        let orphanedCount = 0;\n        return this.forEachOrphanedDocumentSequenceNumber(txn, _ => {\n            orphanedCount++;\n        }).next(() => orphanedCount);\n    }\n    forEachTarget(txn, f) {\n        return this.db.getTargetCache().forEachTarget(txn, f);\n    }\n    forEachOrphanedDocumentSequenceNumber(txn, f) {\n        return this.forEachOrphanedDocument(txn, (docKey, sequenceNumber) => f(sequenceNumber));\n    }\n    addReference(txn, targetId, key) {\n        return writeSentinelKey(txn, key);\n    }\n    removeReference(txn, targetId, key) {\n        return writeSentinelKey(txn, key);\n    }\n    removeTargets(txn, upperBound, activeTargetIds) {\n        return this.db.getTargetCache().removeTargets(txn, upperBound, activeTargetIds);\n    }\n    markPotentiallyOrphaned(txn, key) {\n        return writeSentinelKey(txn, key);\n    }\n    /**\n     * Returns true if anything would prevent this document from being garbage\n     * collected, given that the document in question is not present in any\n     * targets and has a sequence number less than or equal to the upper bound for\n     * the collection run.\n     */\n    isPinned(txn, docKey) {\n        return mutationQueuesContainKey(txn, docKey);\n    }\n    removeOrphanedDocuments(txn, upperBound) {\n        const documentCache = this.db.getRemoteDocumentCache();\n        const changeBuffer = documentCache.newChangeBuffer();\n        const promises = [];\n        let documentCount = 0;\n        const iteration = this.forEachOrphanedDocument(txn, (docKey, sequenceNumber) => {\n            if (sequenceNumber <= upperBound) {\n                const p = this.isPinned(txn, docKey).next(isPinned => {\n                    if (!isPinned) {\n                        documentCount++;\n                        // Our size accounting requires us to read all documents before\n                        // removing them.\n                        return changeBuffer.getEntry(txn, docKey).next(() => {\n                            changeBuffer.removeEntry(docKey, SnapshotVersion.min());\n                            return documentTargetStore(txn).delete(sentinelKey$1(docKey));\n                        });\n                    }\n                });\n                promises.push(p);\n            }\n        });\n        return iteration\n            .next(() => PersistencePromise.waitFor(promises))\n            .next(() => changeBuffer.apply(txn))\n            .next(() => documentCount);\n    }\n    removeTarget(txn, targetData) {\n        const updated = targetData.withSequenceNumber(txn.currentSequenceNumber);\n        return this.db.getTargetCache().updateTargetData(txn, updated);\n    }\n    updateLimboDocument(txn, key) {\n        return writeSentinelKey(txn, key);\n    }\n    /**\n     * Call provided function for each document in the cache that is 'orphaned'. Orphaned\n     * means not a part of any target, so the only entry in the target-document index for\n     * that document will be the sentinel row (targetId 0), which will also have the sequence\n     * number for the last time the document was accessed.\n     */\n    forEachOrphanedDocument(txn, f) {\n        const store = documentTargetStore(txn);\n        let nextToReport = ListenSequence.INVALID;\n        let nextPath;\n        return store\n            .iterate({\n            index: DbTargetDocumentDocumentTargetsIndex\n        }, ([targetId, docKey], { path, sequenceNumber }) => {\n            if (targetId === 0) {\n                // if nextToReport is valid, report it, this is a new key so the\n                // last one must not be a member of any targets.\n                if (nextToReport !== ListenSequence.INVALID) {\n                    f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);\n                }\n                // set nextToReport to be this sequence number. It's the next one we\n                // might report, if we don't find any targets for this document.\n                // Note that the sequence number must be defined when the targetId\n                // is 0.\n                nextToReport = sequenceNumber;\n                nextPath = path;\n            }\n            else {\n                // set nextToReport to be invalid, we know we don't need to report\n                // this one since we found a target for it.\n                nextToReport = ListenSequence.INVALID;\n            }\n        })\n            .next(() => {\n            // Since we report sequence numbers after getting to the next key, we\n            // need to check if the last key we iterated over was an orphaned\n            // document and report it.\n            if (nextToReport !== ListenSequence.INVALID) {\n                f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);\n            }\n        });\n    }\n    getCacheSize(txn) {\n        return this.db.getRemoteDocumentCache().getSize(txn);\n    }\n}\nfunction sentinelKey$1(key) {\n    return [0, encodeResourcePath(key.path)];\n}\n/**\n * @returns A value suitable for writing a sentinel row in the target-document\n * store.\n */\nfunction sentinelRow(key, sequenceNumber) {\n    return { targetId: 0, path: encodeResourcePath(key.path), sequenceNumber };\n}\nfunction writeSentinelKey(txn, key) {\n    return documentTargetStore(txn).put(sentinelRow(key, txn.currentSequenceNumber));\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An in-memory buffer of entries to be written to a RemoteDocumentCache.\n * It can be used to batch up a set of changes to be written to the cache, but\n * additionally supports reading entries back with the `getEntry()` method,\n * falling back to the underlying RemoteDocumentCache if no entry is\n * buffered.\n *\n * Entries added to the cache *must* be read first. This is to facilitate\n * calculating the size delta of the pending changes.\n *\n * PORTING NOTE: This class was implemented then removed from other platforms.\n * If byte-counting ends up being needed on the other platforms, consider\n * porting this class as part of that implementation work.\n */\nclass RemoteDocumentChangeBuffer {\n    constructor() {\n        // A mapping of document key to the new cache entry that should be written.\n        this.changes = new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\n        this.changesApplied = false;\n    }\n    /**\n     * Buffers a `RemoteDocumentCache.addEntry()` call.\n     *\n     * You can only modify documents that have already been retrieved via\n     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).\n     */\n    addEntry(document) {\n        this.assertNotApplied();\n        this.changes.set(document.key, document);\n    }\n    /**\n     * Buffers a `RemoteDocumentCache.removeEntry()` call.\n     *\n     * You can only remove documents that have already been retrieved via\n     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).\n     */\n    removeEntry(key, readTime) {\n        this.assertNotApplied();\n        this.changes.set(key, MutableDocument.newInvalidDocument(key).setReadTime(readTime));\n    }\n    /**\n     * Looks up an entry in the cache. The buffered changes will first be checked,\n     * and if no buffered change applies, this will forward to\n     * `RemoteDocumentCache.getEntry()`.\n     *\n     * @param transaction - The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKey - The key of the entry to look up.\n     * @returns The cached document or an invalid document if we have nothing\n     * cached.\n     */\n    getEntry(transaction, documentKey) {\n        this.assertNotApplied();\n        const bufferedEntry = this.changes.get(documentKey);\n        if (bufferedEntry !== undefined) {\n            return PersistencePromise.resolve(bufferedEntry);\n        }\n        else {\n            return this.getFromCache(transaction, documentKey);\n        }\n    }\n    /**\n     * Looks up several entries in the cache, forwarding to\n     * `RemoteDocumentCache.getEntry()`.\n     *\n     * @param transaction - The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKeys - The keys of the entries to look up.\n     * @returns A map of cached documents, indexed by key. If an entry cannot be\n     *     found, the corresponding key will be mapped to an invalid document.\n     */\n    getEntries(transaction, documentKeys) {\n        return this.getAllFromCache(transaction, documentKeys);\n    }\n    /**\n     * Applies buffered changes to the underlying RemoteDocumentCache, using\n     * the provided transaction.\n     */\n    apply(transaction) {\n        this.assertNotApplied();\n        this.changesApplied = true;\n        return this.applyChanges(transaction);\n    }\n    /** Helper to assert this.changes is not null  */\n    assertNotApplied() {\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The RemoteDocumentCache for IndexedDb. To construct, invoke\n * `newIndexedDbRemoteDocumentCache()`.\n */\nclass IndexedDbRemoteDocumentCacheImpl {\n    constructor(serializer) {\n        this.serializer = serializer;\n    }\n    setIndexManager(indexManager) {\n        this.indexManager = indexManager;\n    }\n    /**\n     * Adds the supplied entries to the cache.\n     *\n     * All calls of `addEntry` are required to go through the RemoteDocumentChangeBuffer\n     * returned by `newChangeBuffer()` to ensure proper accounting of metadata.\n     */\n    addEntry(transaction, key, doc) {\n        const documentStore = remoteDocumentsStore(transaction);\n        return documentStore.put(doc);\n    }\n    /**\n     * Removes a document from the cache.\n     *\n     * All calls of `removeEntry`  are required to go through the RemoteDocumentChangeBuffer\n     * returned by `newChangeBuffer()` to ensure proper accounting of metadata.\n     */\n    removeEntry(transaction, documentKey, readTime) {\n        const store = remoteDocumentsStore(transaction);\n        return store.delete(dbReadTimeKey(documentKey, readTime));\n    }\n    /**\n     * Updates the current cache size.\n     *\n     * Callers to `addEntry()` and `removeEntry()` *must* call this afterwards to update the\n     * cache's metadata.\n     */\n    updateMetadata(transaction, sizeDelta) {\n        return this.getMetadata(transaction).next(metadata => {\n            metadata.byteSize += sizeDelta;\n            return this.setMetadata(transaction, metadata);\n        });\n    }\n    getEntry(transaction, documentKey) {\n        let doc = MutableDocument.newInvalidDocument(documentKey);\n        return remoteDocumentsStore(transaction)\n            .iterate({\n            index: DbRemoteDocumentDocumentKeyIndex,\n            range: IDBKeyRange.only(dbKey(documentKey))\n        }, (_, dbRemoteDoc) => {\n            doc = this.maybeDecodeDocument(documentKey, dbRemoteDoc);\n        })\n            .next(() => doc);\n    }\n    /**\n     * Looks up an entry in the cache.\n     *\n     * @param documentKey - The key of the entry to look up.\n     * @returns The cached document entry and its size.\n     */\n    getSizedEntry(transaction, documentKey) {\n        let result = {\n            size: 0,\n            document: MutableDocument.newInvalidDocument(documentKey)\n        };\n        return remoteDocumentsStore(transaction)\n            .iterate({\n            index: DbRemoteDocumentDocumentKeyIndex,\n            range: IDBKeyRange.only(dbKey(documentKey))\n        }, (_, dbRemoteDoc) => {\n            result = {\n                document: this.maybeDecodeDocument(documentKey, dbRemoteDoc),\n                size: dbDocumentSize(dbRemoteDoc)\n            };\n        })\n            .next(() => result);\n    }\n    getEntries(transaction, documentKeys) {\n        let results = mutableDocumentMap();\n        return this.forEachDbEntry(transaction, documentKeys, (key, dbRemoteDoc) => {\n            const doc = this.maybeDecodeDocument(key, dbRemoteDoc);\n            results = results.insert(key, doc);\n        }).next(() => results);\n    }\n    /**\n     * Looks up several entries in the cache.\n     *\n     * @param documentKeys - The set of keys entries to look up.\n     * @returns A map of documents indexed by key and a map of sizes indexed by\n     *     key (zero if the document does not exist).\n     */\n    getSizedEntries(transaction, documentKeys) {\n        let results = mutableDocumentMap();\n        let sizeMap = new SortedMap(DocumentKey.comparator);\n        return this.forEachDbEntry(transaction, documentKeys, (key, dbRemoteDoc) => {\n            const doc = this.maybeDecodeDocument(key, dbRemoteDoc);\n            results = results.insert(key, doc);\n            sizeMap = sizeMap.insert(key, dbDocumentSize(dbRemoteDoc));\n        }).next(() => {\n            return { documents: results, sizeMap };\n        });\n    }\n    forEachDbEntry(transaction, documentKeys, callback) {\n        if (documentKeys.isEmpty()) {\n            return PersistencePromise.resolve();\n        }\n        let sortedKeys = new SortedSet(dbKeyComparator);\n        documentKeys.forEach(e => (sortedKeys = sortedKeys.add(e)));\n        const range = IDBKeyRange.bound(dbKey(sortedKeys.first()), dbKey(sortedKeys.last()));\n        const keyIter = sortedKeys.getIterator();\n        let nextKey = keyIter.getNext();\n        return remoteDocumentsStore(transaction)\n            .iterate({ index: DbRemoteDocumentDocumentKeyIndex, range }, (_, dbRemoteDoc, control) => {\n            const potentialKey = DocumentKey.fromSegments([\n                ...dbRemoteDoc.prefixPath,\n                dbRemoteDoc.collectionGroup,\n                dbRemoteDoc.documentId\n            ]);\n            // Go through keys not found in cache.\n            while (nextKey && dbKeyComparator(nextKey, potentialKey) < 0) {\n                callback(nextKey, null);\n                nextKey = keyIter.getNext();\n            }\n            if (nextKey && nextKey.isEqual(potentialKey)) {\n                // Key found in cache.\n                callback(nextKey, dbRemoteDoc);\n                nextKey = keyIter.hasNext() ? keyIter.getNext() : null;\n            }\n            // Skip to the next key (if there is one).\n            if (nextKey) {\n                control.skip(dbKey(nextKey));\n            }\n            else {\n                control.done();\n            }\n        })\n            .next(() => {\n            // The rest of the keys are not in the cache. One case where `iterate`\n            // above won't go through them is when the cache is empty.\n            while (nextKey) {\n                callback(nextKey, null);\n                nextKey = keyIter.hasNext() ? keyIter.getNext() : null;\n            }\n        });\n    }\n    getDocumentsMatchingQuery(transaction, query, offset, mutatedDocs, context) {\n        const collection = query.path;\n        const startKey = [\n            collection.popLast().toArray(),\n            collection.lastSegment(),\n            toDbTimestampKey(offset.readTime),\n            offset.documentKey.path.isEmpty()\n                ? ''\n                : offset.documentKey.path.lastSegment()\n        ];\n        const endKey = [\n            collection.popLast().toArray(),\n            collection.lastSegment(),\n            [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n            ''\n        ];\n        return remoteDocumentsStore(transaction)\n            .loadAll(IDBKeyRange.bound(startKey, endKey, true))\n            .next(dbRemoteDocs => {\n            context?.incrementDocumentReadCount(dbRemoteDocs.length);\n            let results = mutableDocumentMap();\n            for (const dbRemoteDoc of dbRemoteDocs) {\n                const document = this.maybeDecodeDocument(DocumentKey.fromSegments(dbRemoteDoc.prefixPath.concat(dbRemoteDoc.collectionGroup, dbRemoteDoc.documentId)), dbRemoteDoc);\n                if (document.isFoundDocument() &&\n                    (queryMatches(query, document) || mutatedDocs.has(document.key))) {\n                    // Either the document matches the given query, or it is mutated.\n                    results = results.insert(document.key, document);\n                }\n            }\n            return results;\n        });\n    }\n    getAllFromCollectionGroup(transaction, collectionGroup, offset, limit) {\n        let results = mutableDocumentMap();\n        const startKey = dbCollectionGroupKey(collectionGroup, offset);\n        const endKey = dbCollectionGroupKey(collectionGroup, IndexOffset.max());\n        return remoteDocumentsStore(transaction)\n            .iterate({\n            index: DbRemoteDocumentCollectionGroupIndex,\n            range: IDBKeyRange.bound(startKey, endKey, true)\n        }, (_, dbRemoteDoc, control) => {\n            const document = this.maybeDecodeDocument(DocumentKey.fromSegments(dbRemoteDoc.prefixPath.concat(dbRemoteDoc.collectionGroup, dbRemoteDoc.documentId)), dbRemoteDoc);\n            results = results.insert(document.key, document);\n            if (results.size === limit) {\n                control.done();\n            }\n        })\n            .next(() => results);\n    }\n    newChangeBuffer(options) {\n        return new IndexedDbRemoteDocumentChangeBuffer(this, !!options && options.trackRemovals);\n    }\n    getSize(txn) {\n        return this.getMetadata(txn).next(metadata => metadata.byteSize);\n    }\n    getMetadata(txn) {\n        return documentGlobalStore(txn)\n            .get(DbRemoteDocumentGlobalKey)\n            .next(metadata => {\n            hardAssert(!!metadata, 0x4e35);\n            return metadata;\n        });\n    }\n    setMetadata(txn, metadata) {\n        return documentGlobalStore(txn).put(DbRemoteDocumentGlobalKey, metadata);\n    }\n    /**\n     * Decodes `dbRemoteDoc` and returns the document (or an invalid document if\n     * the document corresponds to the format used for sentinel deletes).\n     */\n    maybeDecodeDocument(documentKey, dbRemoteDoc) {\n        if (dbRemoteDoc) {\n            const doc = fromDbRemoteDocument(this.serializer, dbRemoteDoc);\n            // Whether the document is a sentinel removal and should only be used in the\n            // `getNewDocumentChanges()`\n            const isSentinelRemoval = doc.isNoDocument() && doc.version.isEqual(SnapshotVersion.min());\n            if (!isSentinelRemoval) {\n                return doc;\n            }\n        }\n        return MutableDocument.newInvalidDocument(documentKey);\n    }\n}\n/** Creates a new IndexedDbRemoteDocumentCache. */\nfunction newIndexedDbRemoteDocumentCache(serializer) {\n    return new IndexedDbRemoteDocumentCacheImpl(serializer);\n}\n/**\n * Handles the details of adding and updating documents in the IndexedDbRemoteDocumentCache.\n *\n * Unlike the MemoryRemoteDocumentChangeBuffer, the IndexedDb implementation computes the size\n * delta for all submitted changes. This avoids having to re-read all documents from IndexedDb\n * when we apply the changes.\n */\nclass IndexedDbRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {\n    /**\n     * @param documentCache - The IndexedDbRemoteDocumentCache to apply the changes to.\n     * @param trackRemovals - Whether to create sentinel deletes that can be tracked by\n     * `getNewDocumentChanges()`.\n     */\n    constructor(documentCache, trackRemovals) {\n        super();\n        this.documentCache = documentCache;\n        this.trackRemovals = trackRemovals;\n        // A map of document sizes and read times prior to applying the changes in\n        // this buffer.\n        this.documentStates = new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\n    }\n    applyChanges(transaction) {\n        const promises = [];\n        let sizeDelta = 0;\n        let collectionParents = new SortedSet((l, r) => primitiveComparator(l.canonicalString(), r.canonicalString()));\n        this.changes.forEach((key, documentChange) => {\n            const previousDoc = this.documentStates.get(key);\n            promises.push(this.documentCache.removeEntry(transaction, key, previousDoc.readTime));\n            if (documentChange.isValidDocument()) {\n                const doc = toDbRemoteDocument(this.documentCache.serializer, documentChange);\n                collectionParents = collectionParents.add(key.path.popLast());\n                const size = dbDocumentSize(doc);\n                sizeDelta += size - previousDoc.size;\n                promises.push(this.documentCache.addEntry(transaction, key, doc));\n            }\n            else {\n                sizeDelta -= previousDoc.size;\n                if (this.trackRemovals) {\n                    // In order to track removals, we store a \"sentinel delete\" in the\n                    // RemoteDocumentCache. This entry is represented by a NoDocument\n                    // with a version of 0 and ignored by `maybeDecodeDocument()` but\n                    // preserved in `getNewDocumentChanges()`.\n                    const deletedDoc = toDbRemoteDocument(this.documentCache.serializer, documentChange.convertToNoDocument(SnapshotVersion.min()));\n                    promises.push(this.documentCache.addEntry(transaction, key, deletedDoc));\n                }\n            }\n        });\n        collectionParents.forEach(parent => {\n            promises.push(this.documentCache.indexManager.addToCollectionParentIndex(transaction, parent));\n        });\n        promises.push(this.documentCache.updateMetadata(transaction, sizeDelta));\n        return PersistencePromise.waitFor(promises);\n    }\n    getFromCache(transaction, documentKey) {\n        // Record the size of everything we load from the cache so we can compute a delta later.\n        return this.documentCache\n            .getSizedEntry(transaction, documentKey)\n            .next(getResult => {\n            this.documentStates.set(documentKey, {\n                size: getResult.size,\n                readTime: getResult.document.readTime\n            });\n            return getResult.document;\n        });\n    }\n    getAllFromCache(transaction, documentKeys) {\n        // Record the size of everything we load from the cache so we can compute\n        // a delta later.\n        return this.documentCache\n            .getSizedEntries(transaction, documentKeys)\n            .next(({ documents, sizeMap }) => {\n            // Note: `getAllFromCache` returns two maps instead of a single map from\n            // keys to `DocumentSizeEntry`s. This is to allow returning the\n            // `MutableDocumentMap` directly, without a conversion.\n            sizeMap.forEach((documentKey, size) => {\n                this.documentStates.set(documentKey, {\n                    size,\n                    readTime: documents.get(documentKey).readTime\n                });\n            });\n            return documents;\n        });\n    }\n}\nfunction documentGlobalStore(txn) {\n    return getStore(txn, DbRemoteDocumentGlobalStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the remoteDocuments object store.\n */\nfunction remoteDocumentsStore(txn) {\n    return getStore(txn, DbRemoteDocumentStore);\n}\n/**\n * Returns a key that can be used for document lookups on the\n * `DbRemoteDocumentDocumentKeyIndex` index.\n */\nfunction dbKey(documentKey) {\n    const path = documentKey.path.toArray();\n    return [\n        /* prefix path */ path.slice(0, path.length - 2),\n        /* collection id */ path[path.length - 2],\n        /* document id */ path[path.length - 1]\n    ];\n}\n/**\n * Returns a key that can be used for document lookups via the primary key of\n * the DbRemoteDocument object store.\n */\nfunction dbReadTimeKey(documentKey, readTime) {\n    const path = documentKey.path.toArray();\n    return [\n        /* prefix path */ path.slice(0, path.length - 2),\n        /* collection id */ path[path.length - 2],\n        toDbTimestampKey(readTime),\n        /* document id */ path[path.length - 1]\n    ];\n}\n/**\n * Returns a key that can be used for document lookups on the\n * `DbRemoteDocumentDocumentCollectionGroupIndex` index.\n */\nfunction dbCollectionGroupKey(collectionGroup, offset) {\n    const path = offset.documentKey.path.toArray();\n    return [\n        /* collection id */ collectionGroup,\n        toDbTimestampKey(offset.readTime),\n        /* prefix path */ path.slice(0, path.length - 2),\n        /* document id */ path.length > 0 ? path[path.length - 1] : ''\n    ];\n}\n/**\n * Comparator that compares document keys according to the primary key sorting\n * used by the `DbRemoteDocumentDocument` store (by prefix path, collection id\n * and then document ID).\n *\n * Visible for testing.\n */\nfunction dbKeyComparator(l, r) {\n    const left = l.path.toArray();\n    const right = r.path.toArray();\n    // The ordering is based on https://chromium.googlesource.com/chromium/blink/+/fe5c21fef94dae71c1c3344775b8d8a7f7e6d9ec/Source/modules/indexeddb/IDBKey.cpp#74\n    let cmp = 0;\n    for (let i = 0; i < left.length - 2 && i < right.length - 2; ++i) {\n        cmp = primitiveComparator(left[i], right[i]);\n        if (cmp) {\n            return cmp;\n        }\n    }\n    cmp = primitiveComparator(left.length, right.length);\n    if (cmp) {\n        return cmp;\n    }\n    cmp = primitiveComparator(left[left.length - 2], right[right.length - 2]);\n    if (cmp) {\n        return cmp;\n    }\n    // TODO(b/329441702): Document IDs should be sorted by UTF-8 encoded byte\n    // order, but IndexedDB sorts strings lexicographically. Document ID\n    // comparison here still relies on primitive comparison to avoid mismatches\n    // observed in snapshot listeners with Unicode characters in documentIds\n    return primitiveComparator(left[left.length - 1], right[right.length - 1]);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Schema Version for the Web client:\n * 1.  Initial version including Mutation Queue, Query Cache, and Remote\n *     Document Cache\n * 2.  Used to ensure a targetGlobal object exists and add targetCount to it. No\n *     longer required because migration 3 unconditionally clears it.\n * 3.  Dropped and re-created Query Cache to deal with cache corruption related\n *     to limbo resolution. Addresses\n *     https://github.com/firebase/firebase-ios-sdk/issues/1548\n * 4.  Multi-Tab Support.\n * 5.  Removal of held write acks.\n * 6.  Create document global for tracking document cache size.\n * 7.  Ensure every cached document has a sentinel row with a sequence number.\n * 8.  Add collection-parent index for Collection Group queries.\n * 9.  Change RemoteDocumentChanges store to be keyed by readTime rather than\n *     an auto-incrementing ID. This is required for Index-Free queries.\n * 10. Rewrite the canonical IDs to the explicit Protobuf-based format.\n * 11. Add bundles and named_queries for bundle support.\n * 12. Add document overlays.\n * 13. Rewrite the keys of the remote document cache to allow for efficient\n *     document lookup via `getAll()`.\n * 14. Add overlays.\n * 15. Add indexing support.\n * 16. Parse timestamp strings before creating index entries.\n * 17. TODO(tomandersen)\n * 18. Encode key safe representations of IndexEntry in DbIndexEntryStore.\n */\nconst SCHEMA_VERSION = 18;\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a local view (overlay) of a document, and the fields that are\n * locally mutated.\n */\nclass OverlayedDocument {\n    constructor(overlayedDocument, \n    /**\n     * The fields that are locally mutated by patch mutations.\n     *\n     * If the overlayed\tdocument is from set or delete mutations, this is `null`.\n     * If there is no overlay (mutation) for the document, this is an empty `FieldMask`.\n     */\n    mutatedFields) {\n        this.overlayedDocument = overlayedDocument;\n        this.mutatedFields = mutatedFields;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A readonly view of the local state of all documents we're tracking (i.e. we\n * have a cached version in remoteDocumentCache or local mutations for the\n * document). The view is computed by applying the mutations in the\n * MutationQueue to the RemoteDocumentCache.\n */\nclass LocalDocumentsView {\n    constructor(remoteDocumentCache, mutationQueue, documentOverlayCache, indexManager) {\n        this.remoteDocumentCache = remoteDocumentCache;\n        this.mutationQueue = mutationQueue;\n        this.documentOverlayCache = documentOverlayCache;\n        this.indexManager = indexManager;\n    }\n    /**\n     * Get the local view of the document identified by `key`.\n     *\n     * @returns Local view of the document or null if we don't have any cached\n     * state for it.\n     */\n    getDocument(transaction, key) {\n        let overlay = null;\n        return this.documentOverlayCache\n            .getOverlay(transaction, key)\n            .next(value => {\n            overlay = value;\n            return this.remoteDocumentCache.getEntry(transaction, key);\n        })\n            .next(document => {\n            if (overlay !== null) {\n                mutationApplyToLocalView(overlay.mutation, document, FieldMask.empty(), Timestamp.now());\n            }\n            return document;\n        });\n    }\n    /**\n     * Gets the local view of the documents identified by `keys`.\n     *\n     * If we don't have cached state for a document in `keys`, a NoDocument will\n     * be stored for that key in the resulting set.\n     */\n    getDocuments(transaction, keys) {\n        return this.remoteDocumentCache\n            .getEntries(transaction, keys)\n            .next(docs => this.getLocalViewOfDocuments(transaction, docs, documentKeySet()).next(() => docs));\n    }\n    /**\n     * Similar to `getDocuments`, but creates the local view from the given\n     * `baseDocs` without retrieving documents from the local store.\n     *\n     * @param transaction - The transaction this operation is scoped to.\n     * @param docs - The documents to apply local mutations to get the local views.\n     * @param existenceStateChanged - The set of document keys whose existence state\n     *   is changed. This is useful to determine if some documents overlay needs\n     *   to be recalculated.\n     */\n    getLocalViewOfDocuments(transaction, docs, existenceStateChanged = documentKeySet()) {\n        const overlays = newOverlayMap();\n        return this.populateOverlays(transaction, overlays, docs).next(() => {\n            return this.computeViews(transaction, docs, overlays, existenceStateChanged).next(computeViewsResult => {\n                let result = documentMap();\n                computeViewsResult.forEach((documentKey, overlayedDocument) => {\n                    result = result.insert(documentKey, overlayedDocument.overlayedDocument);\n                });\n                return result;\n            });\n        });\n    }\n    /**\n     * Gets the overlayed documents for the given document map, which will include\n     * the local view of those documents and a `FieldMask` indicating which fields\n     * are mutated locally, `null` if overlay is a Set or Delete mutation.\n     */\n    getOverlayedDocuments(transaction, docs) {\n        const overlays = newOverlayMap();\n        return this.populateOverlays(transaction, overlays, docs).next(() => this.computeViews(transaction, docs, overlays, documentKeySet()));\n    }\n    /**\n     * Fetches the overlays for {@code docs} and adds them to provided overlay map\n     * if the map does not already contain an entry for the given document key.\n     */\n    populateOverlays(transaction, overlays, docs) {\n        const missingOverlays = [];\n        docs.forEach(key => {\n            if (!overlays.has(key)) {\n                missingOverlays.push(key);\n            }\n        });\n        return this.documentOverlayCache\n            .getOverlays(transaction, missingOverlays)\n            .next(result => {\n            result.forEach((key, val) => {\n                overlays.set(key, val);\n            });\n        });\n    }\n    /**\n     * Computes the local view for the given documents.\n     *\n     * @param docs - The documents to compute views for. It also has the base\n     *   version of the documents.\n     * @param overlays - The overlays that need to be applied to the given base\n     *   version of the documents.\n     * @param existenceStateChanged - A set of documents whose existence states\n     *   might have changed. This is used to determine if we need to re-calculate\n     *   overlays from mutation queues.\n     * @returns A map represents the local documents view.\n     */\n    computeViews(transaction, docs, overlays, existenceStateChanged) {\n        let recalculateDocuments = mutableDocumentMap();\n        const mutatedFields = newDocumentKeyMap();\n        const results = newOverlayedDocumentMap();\n        docs.forEach((_, doc) => {\n            const overlay = overlays.get(doc.key);\n            // Recalculate an overlay if the document's existence state changed due to\n            // a remote event *and* the overlay is a PatchMutation. This is because\n            // document existence state can change if some patch mutation's\n            // preconditions are met.\n            // NOTE: we recalculate when `overlay` is undefined as well, because there\n            // might be a patch mutation whose precondition does not match before the\n            // change (hence overlay is undefined), but would now match.\n            if (existenceStateChanged.has(doc.key) &&\n                (overlay === undefined || overlay.mutation instanceof PatchMutation)) {\n                recalculateDocuments = recalculateDocuments.insert(doc.key, doc);\n            }\n            else if (overlay !== undefined) {\n                mutatedFields.set(doc.key, overlay.mutation.getFieldMask());\n                mutationApplyToLocalView(overlay.mutation, doc, overlay.mutation.getFieldMask(), Timestamp.now());\n            }\n            else {\n                // no overlay exists\n                // Using EMPTY to indicate there is no overlay for the document.\n                mutatedFields.set(doc.key, FieldMask.empty());\n            }\n        });\n        return this.recalculateAndSaveOverlays(transaction, recalculateDocuments).next(recalculatedFields => {\n            recalculatedFields.forEach((documentKey, mask) => mutatedFields.set(documentKey, mask));\n            docs.forEach((documentKey, document) => results.set(documentKey, new OverlayedDocument(document, mutatedFields.get(documentKey) ?? null)));\n            return results;\n        });\n    }\n    recalculateAndSaveOverlays(transaction, docs) {\n        const masks = newDocumentKeyMap();\n        // A reverse lookup map from batch id to the documents within that batch.\n        let documentsByBatchId = new SortedMap((key1, key2) => key1 - key2);\n        let processed = documentKeySet();\n        return this.mutationQueue\n            .getAllMutationBatchesAffectingDocumentKeys(transaction, docs)\n            .next(batches => {\n            for (const batch of batches) {\n                batch.keys().forEach(key => {\n                    const baseDoc = docs.get(key);\n                    if (baseDoc === null) {\n                        return;\n                    }\n                    let mask = masks.get(key) || FieldMask.empty();\n                    mask = batch.applyToLocalView(baseDoc, mask);\n                    masks.set(key, mask);\n                    const newSet = (documentsByBatchId.get(batch.batchId) || documentKeySet()).add(key);\n                    documentsByBatchId = documentsByBatchId.insert(batch.batchId, newSet);\n                });\n            }\n        })\n            .next(() => {\n            const promises = [];\n            // Iterate in descending order of batch IDs, and skip documents that are\n            // already saved.\n            const iter = documentsByBatchId.getReverseIterator();\n            while (iter.hasNext()) {\n                const entry = iter.getNext();\n                const batchId = entry.key;\n                const keys = entry.value;\n                const overlays = newMutationMap();\n                keys.forEach(key => {\n                    if (!processed.has(key)) {\n                        const overlayMutation = calculateOverlayMutation(docs.get(key), masks.get(key));\n                        if (overlayMutation !== null) {\n                            overlays.set(key, overlayMutation);\n                        }\n                        processed = processed.add(key);\n                    }\n                });\n                promises.push(this.documentOverlayCache.saveOverlays(transaction, batchId, overlays));\n            }\n            return PersistencePromise.waitFor(promises);\n        })\n            .next(() => masks);\n    }\n    /**\n     * Recalculates overlays by reading the documents from remote document cache\n     * first, and saves them after they are calculated.\n     */\n    recalculateAndSaveOverlaysForDocumentKeys(transaction, documentKeys) {\n        return this.remoteDocumentCache\n            .getEntries(transaction, documentKeys)\n            .next(docs => this.recalculateAndSaveOverlays(transaction, docs));\n    }\n    /**\n     * Performs a query against the local view of all documents.\n     *\n     * @param transaction - The persistence transaction.\n     * @param query - The query to match documents against.\n     * @param offset - Read time and key to start scanning by (exclusive).\n     * @param context - A optional tracker to keep a record of important details\n     *   during database local query execution.\n     */\n    getDocumentsMatchingQuery(transaction, query, offset, context) {\n        if (isDocumentQuery$1(query)) {\n            return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\n        }\n        else if (isCollectionGroupQuery(query)) {\n            return this.getDocumentsMatchingCollectionGroupQuery(transaction, query, offset, context);\n        }\n        else {\n            return this.getDocumentsMatchingCollectionQuery(transaction, query, offset, context);\n        }\n    }\n    /**\n     * Given a collection group, returns the next documents that follow the provided offset, along\n     * with an updated batch ID.\n     *\n     * <p>The documents returned by this method are ordered by remote version from the provided\n     * offset. If there are no more remote documents after the provided offset, documents with\n     * mutations in order of batch id from the offset are returned. Since all documents in a batch are\n     * returned together, the total number of documents returned can exceed {@code count}.\n     *\n     * @param transaction\n     * @param collectionGroup - The collection group for the documents.\n     * @param offset - The offset to index into.\n     * @param count - The number of documents to return\n     * @returns A LocalWriteResult with the documents that follow the provided offset and the last processed batch id.\n     */\n    getNextDocuments(transaction, collectionGroup, offset, count) {\n        return this.remoteDocumentCache\n            .getAllFromCollectionGroup(transaction, collectionGroup, offset, count)\n            .next((originalDocs) => {\n            const overlaysPromise = count - originalDocs.size > 0\n                ? this.documentOverlayCache.getOverlaysForCollectionGroup(transaction, collectionGroup, offset.largestBatchId, count - originalDocs.size)\n                : PersistencePromise.resolve(newOverlayMap());\n            // The callsite will use the largest batch ID together with the latest read time to create\n            // a new index offset. Since we only process batch IDs if all remote documents have been read,\n            // no overlay will increase the overall read time. This is why we only need to special case\n            // the batch id.\n            let largestBatchId = INITIAL_LARGEST_BATCH_ID;\n            let modifiedDocs = originalDocs;\n            return overlaysPromise.next(overlays => {\n                return PersistencePromise.forEach(overlays, (key, overlay) => {\n                    if (largestBatchId < overlay.largestBatchId) {\n                        largestBatchId = overlay.largestBatchId;\n                    }\n                    if (originalDocs.get(key)) {\n                        return PersistencePromise.resolve();\n                    }\n                    return this.remoteDocumentCache\n                        .getEntry(transaction, key)\n                        .next(doc => {\n                        modifiedDocs = modifiedDocs.insert(key, doc);\n                    });\n                })\n                    .next(() => this.populateOverlays(transaction, overlays, originalDocs))\n                    .next(() => this.computeViews(transaction, modifiedDocs, overlays, documentKeySet()))\n                    .next(localDocs => ({\n                    batchId: largestBatchId,\n                    changes: convertOverlayedDocumentMapToDocumentMap(localDocs)\n                }));\n            });\n        });\n    }\n    getDocumentsMatchingDocumentQuery(transaction, docPath) {\n        // Just do a simple document lookup.\n        return this.getDocument(transaction, new DocumentKey(docPath)).next(document => {\n            let result = documentMap();\n            if (document.isFoundDocument()) {\n                result = result.insert(document.key, document);\n            }\n            return result;\n        });\n    }\n    getDocumentsMatchingCollectionGroupQuery(transaction, query, offset, context) {\n        const collectionId = query.collectionGroup;\n        let results = documentMap();\n        return this.indexManager\n            .getCollectionParents(transaction, collectionId)\n            .next(parents => {\n            // Perform a collection query against each parent that contains the\n            // collectionId and aggregate the results.\n            return PersistencePromise.forEach(parents, (parent) => {\n                const collectionQuery = asCollectionQueryAtPath(query, parent.child(collectionId));\n                return this.getDocumentsMatchingCollectionQuery(transaction, collectionQuery, offset, context).next(r => {\n                    r.forEach((key, doc) => {\n                        results = results.insert(key, doc);\n                    });\n                });\n            }).next(() => results);\n        });\n    }\n    getDocumentsMatchingCollectionQuery(transaction, query, offset, context) {\n        // Query the remote documents and overlay mutations.\n        let overlays;\n        return this.documentOverlayCache\n            .getOverlaysForCollection(transaction, query.path, offset.largestBatchId)\n            .next(result => {\n            overlays = result;\n            return this.remoteDocumentCache.getDocumentsMatchingQuery(transaction, query, offset, overlays, context);\n        })\n            .next(remoteDocuments => {\n            // As documents might match the query because of their overlay we need to\n            // include documents for all overlays in the initial document set.\n            overlays.forEach((_, overlay) => {\n                const key = overlay.getKey();\n                if (remoteDocuments.get(key) === null) {\n                    remoteDocuments = remoteDocuments.insert(key, MutableDocument.newInvalidDocument(key));\n                }\n            });\n            // Apply the overlays and match against the query.\n            let results = documentMap();\n            remoteDocuments.forEach((key, document) => {\n                const overlay = overlays.get(key);\n                if (overlay !== undefined) {\n                    mutationApplyToLocalView(overlay.mutation, document, FieldMask.empty(), Timestamp.now());\n                }\n                // Finally, insert the documents that still match the query\n                if (queryMatches(query, document)) {\n                    results = results.insert(key, document);\n                }\n            });\n            return results;\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryBundleCache {\n    constructor(serializer) {\n        this.serializer = serializer;\n        this.bundles = new Map();\n        this.namedQueries = new Map();\n    }\n    getBundleMetadata(transaction, bundleId) {\n        return PersistencePromise.resolve(this.bundles.get(bundleId));\n    }\n    saveBundleMetadata(transaction, bundleMetadata) {\n        this.bundles.set(bundleMetadata.id, fromBundleMetadata(bundleMetadata));\n        return PersistencePromise.resolve();\n    }\n    getNamedQuery(transaction, queryName) {\n        return PersistencePromise.resolve(this.namedQueries.get(queryName));\n    }\n    saveNamedQuery(transaction, query) {\n        this.namedQueries.set(query.name, fromProtoNamedQuery(query));\n        return PersistencePromise.resolve();\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An in-memory implementation of DocumentOverlayCache.\n */\nclass MemoryDocumentOverlayCache {\n    constructor() {\n        // A map sorted by DocumentKey, whose value is a pair of the largest batch id\n        // for the overlay and the overlay itself.\n        this.overlays = new SortedMap(DocumentKey.comparator);\n        this.overlayByBatchId = new Map();\n    }\n    getOverlay(transaction, key) {\n        return PersistencePromise.resolve(this.overlays.get(key));\n    }\n    getOverlays(transaction, keys) {\n        const result = newOverlayMap();\n        return PersistencePromise.forEach(keys, (key) => {\n            return this.getOverlay(transaction, key).next(overlay => {\n                if (overlay !== null) {\n                    result.set(key, overlay);\n                }\n            });\n        }).next(() => result);\n    }\n    saveOverlays(transaction, largestBatchId, overlays) {\n        overlays.forEach((_, mutation) => {\n            this.saveOverlay(transaction, largestBatchId, mutation);\n        });\n        return PersistencePromise.resolve();\n    }\n    removeOverlaysForBatchId(transaction, documentKeys, batchId) {\n        const keys = this.overlayByBatchId.get(batchId);\n        if (keys !== undefined) {\n            keys.forEach(key => (this.overlays = this.overlays.remove(key)));\n            this.overlayByBatchId.delete(batchId);\n        }\n        return PersistencePromise.resolve();\n    }\n    getOverlaysForCollection(transaction, collection, sinceBatchId) {\n        const result = newOverlayMap();\n        const immediateChildrenPathLength = collection.length + 1;\n        const prefix = new DocumentKey(collection.child(''));\n        const iter = this.overlays.getIteratorFrom(prefix);\n        while (iter.hasNext()) {\n            const entry = iter.getNext();\n            const overlay = entry.value;\n            const key = overlay.getKey();\n            if (!collection.isPrefixOf(key.path)) {\n                break;\n            }\n            // Documents from sub-collections\n            if (key.path.length !== immediateChildrenPathLength) {\n                continue;\n            }\n            if (overlay.largestBatchId > sinceBatchId) {\n                result.set(overlay.getKey(), overlay);\n            }\n        }\n        return PersistencePromise.resolve(result);\n    }\n    getOverlaysForCollectionGroup(transaction, collectionGroup, sinceBatchId, count) {\n        let batchIdToOverlays = new SortedMap((key1, key2) => key1 - key2);\n        const iter = this.overlays.getIterator();\n        while (iter.hasNext()) {\n            const entry = iter.getNext();\n            const overlay = entry.value;\n            const key = overlay.getKey();\n            if (key.getCollectionGroup() !== collectionGroup) {\n                continue;\n            }\n            if (overlay.largestBatchId > sinceBatchId) {\n                let overlaysForBatchId = batchIdToOverlays.get(overlay.largestBatchId);\n                if (overlaysForBatchId === null) {\n                    overlaysForBatchId = newOverlayMap();\n                    batchIdToOverlays = batchIdToOverlays.insert(overlay.largestBatchId, overlaysForBatchId);\n                }\n                overlaysForBatchId.set(overlay.getKey(), overlay);\n            }\n        }\n        const result = newOverlayMap();\n        const batchIter = batchIdToOverlays.getIterator();\n        while (batchIter.hasNext()) {\n            const entry = batchIter.getNext();\n            const overlays = entry.value;\n            overlays.forEach((key, overlay) => result.set(key, overlay));\n            if (result.size() >= count) {\n                break;\n            }\n        }\n        return PersistencePromise.resolve(result);\n    }\n    saveOverlay(transaction, largestBatchId, mutation) {\n        // Remove the association of the overlay to its batch id.\n        const existing = this.overlays.get(mutation.key);\n        if (existing !== null) {\n            const newSet = this.overlayByBatchId\n                .get(existing.largestBatchId)\n                .delete(mutation.key);\n            this.overlayByBatchId.set(existing.largestBatchId, newSet);\n        }\n        this.overlays = this.overlays.insert(mutation.key, new Overlay(largestBatchId, mutation));\n        // Create the association of this overlay to the given largestBatchId.\n        let batch = this.overlayByBatchId.get(largestBatchId);\n        if (batch === undefined) {\n            batch = documentKeySet();\n            this.overlayByBatchId.set(largestBatchId, batch);\n        }\n        this.overlayByBatchId.set(largestBatchId, batch.add(mutation.key));\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryGlobalsCache {\n    constructor() {\n        this.sessionToken = ByteString.EMPTY_BYTE_STRING;\n    }\n    getSessionToken(transaction) {\n        return PersistencePromise.resolve(this.sessionToken);\n    }\n    setSessionToken(transaction, sessionToken) {\n        this.sessionToken = sessionToken;\n        return PersistencePromise.resolve();\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A collection of references to a document from some kind of numbered entity\n * (either a target ID or batch ID). As references are added to or removed from\n * the set corresponding events are emitted to a registered garbage collector.\n *\n * Each reference is represented by a DocumentReference object. Each of them\n * contains enough information to uniquely identify the reference. They are all\n * stored primarily in a set sorted by key. A document is considered garbage if\n * there's no references in that set (this can be efficiently checked thanks to\n * sorting by key).\n *\n * ReferenceSet also keeps a secondary set that contains references sorted by\n * IDs. This one is used to efficiently implement removal of all references by\n * some target ID.\n */\nclass ReferenceSet {\n    constructor() {\n        // A set of outstanding references to a document sorted by key.\n        this.refsByKey = new SortedSet(DocReference.compareByKey);\n        // A set of outstanding references to a document sorted by target id.\n        this.refsByTarget = new SortedSet(DocReference.compareByTargetId);\n    }\n    /** Returns true if the reference set contains no references. */\n    isEmpty() {\n        return this.refsByKey.isEmpty();\n    }\n    /** Adds a reference to the given document key for the given ID. */\n    addReference(key, id) {\n        const ref = new DocReference(key, id);\n        this.refsByKey = this.refsByKey.add(ref);\n        this.refsByTarget = this.refsByTarget.add(ref);\n    }\n    /** Add references to the given document keys for the given ID. */\n    addReferences(keys, id) {\n        keys.forEach(key => this.addReference(key, id));\n    }\n    /**\n     * Removes a reference to the given document key for the given\n     * ID.\n     */\n    removeReference(key, id) {\n        this.removeRef(new DocReference(key, id));\n    }\n    removeReferences(keys, id) {\n        keys.forEach(key => this.removeReference(key, id));\n    }\n    /**\n     * Clears all references with a given ID. Calls removeRef() for each key\n     * removed.\n     */\n    removeReferencesForId(id) {\n        const emptyKey = new DocumentKey(new ResourcePath([]));\n        const startRef = new DocReference(emptyKey, id);\n        const endRef = new DocReference(emptyKey, id + 1);\n        const keys = [];\n        this.refsByTarget.forEachInRange([startRef, endRef], ref => {\n            this.removeRef(ref);\n            keys.push(ref.key);\n        });\n        return keys;\n    }\n    removeAllReferences() {\n        this.refsByKey.forEach(ref => this.removeRef(ref));\n    }\n    removeRef(ref) {\n        this.refsByKey = this.refsByKey.delete(ref);\n        this.refsByTarget = this.refsByTarget.delete(ref);\n    }\n    referencesForId(id) {\n        const emptyKey = new DocumentKey(new ResourcePath([]));\n        const startRef = new DocReference(emptyKey, id);\n        const endRef = new DocReference(emptyKey, id + 1);\n        let keys = documentKeySet();\n        this.refsByTarget.forEachInRange([startRef, endRef], ref => {\n            keys = keys.add(ref.key);\n        });\n        return keys;\n    }\n    containsKey(key) {\n        const ref = new DocReference(key, 0);\n        const firstRef = this.refsByKey.firstAfterOrEqual(ref);\n        return firstRef !== null && key.isEqual(firstRef.key);\n    }\n}\nclass DocReference {\n    constructor(key, targetOrBatchId) {\n        this.key = key;\n        this.targetOrBatchId = targetOrBatchId;\n    }\n    /** Compare by key then by ID */\n    static compareByKey(left, right) {\n        return (DocumentKey.comparator(left.key, right.key) ||\n            primitiveComparator(left.targetOrBatchId, right.targetOrBatchId));\n    }\n    /** Compare by ID then by key */\n    static compareByTargetId(left, right) {\n        return (primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) ||\n            DocumentKey.comparator(left.key, right.key));\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryMutationQueue {\n    constructor(indexManager, referenceDelegate) {\n        this.indexManager = indexManager;\n        this.referenceDelegate = referenceDelegate;\n        /**\n         * The set of all mutations that have been sent but not yet been applied to\n         * the backend.\n         */\n        this.mutationQueue = [];\n        /** Next value to use when assigning sequential IDs to each mutation batch. */\n        this.nextBatchId = 1;\n        /** An ordered mapping between documents and the mutations batch IDs. */\n        this.batchesByDocumentKey = new SortedSet(DocReference.compareByKey);\n    }\n    checkEmpty(transaction) {\n        return PersistencePromise.resolve(this.mutationQueue.length === 0);\n    }\n    addMutationBatch(transaction, localWriteTime, baseMutations, mutations) {\n        const batchId = this.nextBatchId;\n        this.nextBatchId++;\n        if (this.mutationQueue.length > 0) {\n            this.mutationQueue[this.mutationQueue.length - 1];\n        }\n        const batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);\n        this.mutationQueue.push(batch);\n        // Track references by document key and index collection parents.\n        for (const mutation of mutations) {\n            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new DocReference(mutation.key, batchId));\n            this.indexManager.addToCollectionParentIndex(transaction, mutation.key.path.popLast());\n        }\n        return PersistencePromise.resolve(batch);\n    }\n    lookupMutationBatch(transaction, batchId) {\n        return PersistencePromise.resolve(this.findMutationBatch(batchId));\n    }\n    getNextMutationBatchAfterBatchId(transaction, batchId) {\n        const nextBatchId = batchId + 1;\n        // The requested batchId may still be out of range so normalize it to the\n        // start of the queue.\n        const rawIndex = this.indexOfBatchId(nextBatchId);\n        const index = rawIndex < 0 ? 0 : rawIndex;\n        return PersistencePromise.resolve(this.mutationQueue.length > index ? this.mutationQueue[index] : null);\n    }\n    getHighestUnacknowledgedBatchId() {\n        return PersistencePromise.resolve(this.mutationQueue.length === 0 ? BATCHID_UNKNOWN : this.nextBatchId - 1);\n    }\n    getAllMutationBatches(transaction) {\n        return PersistencePromise.resolve(this.mutationQueue.slice());\n    }\n    getAllMutationBatchesAffectingDocumentKey(transaction, documentKey) {\n        const start = new DocReference(documentKey, 0);\n        const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n        const result = [];\n        this.batchesByDocumentKey.forEachInRange([start, end], ref => {\n            const batch = this.findMutationBatch(ref.targetOrBatchId);\n            result.push(batch);\n        });\n        return PersistencePromise.resolve(result);\n    }\n    getAllMutationBatchesAffectingDocumentKeys(transaction, documentKeys) {\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\n        documentKeys.forEach(documentKey => {\n            const start = new DocReference(documentKey, 0);\n            const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n            this.batchesByDocumentKey.forEachInRange([start, end], ref => {\n                uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n            });\n        });\n        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));\n    }\n    getAllMutationBatchesAffectingQuery(transaction, query) {\n        // Use the query path as a prefix for testing if a document matches the\n        // query.\n        const prefix = query.path;\n        const immediateChildrenPathLength = prefix.length + 1;\n        // Construct a document reference for actually scanning the index. Unlike\n        // the prefix the document key in this reference must have an even number of\n        // segments. The empty segment can be used a suffix of the query path\n        // because it precedes all other segments in an ordered traversal.\n        let startPath = prefix;\n        if (!DocumentKey.isDocumentKey(startPath)) {\n            startPath = startPath.child('');\n        }\n        const start = new DocReference(new DocumentKey(startPath), 0);\n        // Find unique batchIDs referenced by all documents potentially matching the\n        // query.\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\n        this.batchesByDocumentKey.forEachWhile(ref => {\n            const rowKeyPath = ref.key.path;\n            if (!prefix.isPrefixOf(rowKeyPath)) {\n                return false;\n            }\n            else {\n                // Rows with document keys more than one segment longer than the query\n                // path can't be matches. For example, a query on 'rooms' can't match\n                // the document /rooms/abc/messages/xyx.\n                // TODO(mcg): we'll need a different scanner when we implement\n                // ancestor queries.\n                if (rowKeyPath.length === immediateChildrenPathLength) {\n                    uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n                }\n                return true;\n            }\n        }, start);\n        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));\n    }\n    findMutationBatches(batchIDs) {\n        // Construct an array of matching batches, sorted by batchID to ensure that\n        // multiple mutations affecting the same document key are applied in order.\n        const result = [];\n        batchIDs.forEach(batchId => {\n            const batch = this.findMutationBatch(batchId);\n            if (batch !== null) {\n                result.push(batch);\n            }\n        });\n        return result;\n    }\n    removeMutationBatch(transaction, batch) {\n        // Find the position of the first batch for removal.\n        const batchIndex = this.indexOfExistingBatchId(batch.batchId, 'removed');\n        hardAssert(batchIndex === 0, 0xd6db);\n        this.mutationQueue.shift();\n        let references = this.batchesByDocumentKey;\n        return PersistencePromise.forEach(batch.mutations, (mutation) => {\n            const ref = new DocReference(mutation.key, batch.batchId);\n            references = references.delete(ref);\n            return this.referenceDelegate.markPotentiallyOrphaned(transaction, mutation.key);\n        }).next(() => {\n            this.batchesByDocumentKey = references;\n        });\n    }\n    removeCachedMutationKeys(batchId) {\n        // No-op since the memory mutation queue does not maintain a separate cache.\n    }\n    containsKey(txn, key) {\n        const ref = new DocReference(key, 0);\n        const firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\n        return PersistencePromise.resolve(key.isEqual(firstRef && firstRef.key));\n    }\n    performConsistencyCheck(txn) {\n        if (this.mutationQueue.length === 0) ;\n        return PersistencePromise.resolve();\n    }\n    /**\n     * Finds the index of the given batchId in the mutation queue and asserts that\n     * the resulting index is within the bounds of the queue.\n     *\n     * @param batchId - The batchId to search for\n     * @param action - A description of what the caller is doing, phrased in passive\n     * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\n     */\n    indexOfExistingBatchId(batchId, action) {\n        const index = this.indexOfBatchId(batchId);\n        return index;\n    }\n    /**\n     * Finds the index of the given batchId in the mutation queue. This operation\n     * is O(1).\n     *\n     * @returns The computed index of the batch with the given batchId, based on\n     * the state of the queue. Note this index can be negative if the requested\n     * batchId has already been removed from the queue or past the end of the\n     * queue if the batchId is larger than the last added batch.\n     */\n    indexOfBatchId(batchId) {\n        if (this.mutationQueue.length === 0) {\n            // As an index this is past the end of the queue\n            return 0;\n        }\n        // Examine the front of the queue to figure out the difference between the\n        // batchId and indexes in the array. Note that since the queue is ordered\n        // by batchId, if the first batch has a larger batchId then the requested\n        // batchId doesn't exist in the queue.\n        const firstBatchId = this.mutationQueue[0].batchId;\n        return batchId - firstBatchId;\n    }\n    /**\n     * A version of lookupMutationBatch that doesn't return a promise, this makes\n     * other functions that uses this code easier to read and more efficient.\n     */\n    findMutationBatch(batchId) {\n        const index = this.indexOfBatchId(batchId);\n        if (index < 0 || index >= this.mutationQueue.length) {\n            return null;\n        }\n        const batch = this.mutationQueue[index];\n        return batch;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The smallest value representable by a 64-bit signed integer (long).\n */\nconst MIN_LONG_VALUE = '-9223372036854775808';\nfunction documentEntryMap() {\n    return new SortedMap(DocumentKey.comparator);\n}\n/**\n * The memory-only RemoteDocumentCache for IndexedDb. To construct, invoke\n * `newMemoryRemoteDocumentCache()`.\n */\nclass MemoryRemoteDocumentCacheImpl {\n    /**\n     * @param sizer - Used to assess the size of a document. For eager GC, this is\n     * expected to just return 0 to avoid unnecessarily doing the work of\n     * calculating the size.\n     */\n    constructor(sizer) {\n        this.sizer = sizer;\n        /** Underlying cache of documents and their read times. */\n        this.docs = documentEntryMap();\n        /** Size of all cached documents. */\n        this.size = 0;\n    }\n    setIndexManager(indexManager) {\n        this.indexManager = indexManager;\n    }\n    /**\n     * Adds the supplied entry to the cache and updates the cache size as appropriate.\n     *\n     * All calls of `addEntry`  are required to go through the RemoteDocumentChangeBuffer\n     * returned by `newChangeBuffer()`.\n     */\n    addEntry(transaction, doc) {\n        const key = doc.key;\n        const entry = this.docs.get(key);\n        const previousSize = entry ? entry.size : 0;\n        const currentSize = this.sizer(doc);\n        this.docs = this.docs.insert(key, {\n            document: doc.mutableCopy(),\n            size: currentSize\n        });\n        this.size += currentSize - previousSize;\n        return this.indexManager.addToCollectionParentIndex(transaction, key.path.popLast());\n    }\n    /**\n     * Removes the specified entry from the cache and updates the cache size as appropriate.\n     *\n     * All calls of `removeEntry` are required to go through the RemoteDocumentChangeBuffer\n     * returned by `newChangeBuffer()`.\n     */\n    removeEntry(documentKey) {\n        const entry = this.docs.get(documentKey);\n        if (entry) {\n            this.docs = this.docs.remove(documentKey);\n            this.size -= entry.size;\n        }\n    }\n    getEntry(transaction, documentKey) {\n        const entry = this.docs.get(documentKey);\n        return PersistencePromise.resolve(entry\n            ? entry.document.mutableCopy()\n            : MutableDocument.newInvalidDocument(documentKey));\n    }\n    getEntries(transaction, documentKeys) {\n        let results = mutableDocumentMap();\n        documentKeys.forEach(documentKey => {\n            const entry = this.docs.get(documentKey);\n            results = results.insert(documentKey, entry\n                ? entry.document.mutableCopy()\n                : MutableDocument.newInvalidDocument(documentKey));\n        });\n        return PersistencePromise.resolve(results);\n    }\n    getDocumentsMatchingQuery(transaction, query, offset, mutatedDocs) {\n        let results = mutableDocumentMap();\n        // Documents are ordered by key, so we can use a prefix scan to narrow down\n        // the documents we need to match the query against.\n        const collectionPath = query.path;\n        // Document keys are ordered first by numeric value (\"__id<Long>__\"),\n        // then lexicographically by string value. Start the iterator at the minimum\n        // possible Document key value.\n        const prefix = new DocumentKey(collectionPath.child('__id' + MIN_LONG_VALUE + '__'));\n        const iterator = this.docs.getIteratorFrom(prefix);\n        while (iterator.hasNext()) {\n            const { key, value: { document } } = iterator.getNext();\n            if (!collectionPath.isPrefixOf(key.path)) {\n                break;\n            }\n            if (key.path.length > collectionPath.length + 1) {\n                // Exclude entries from subcollections.\n                continue;\n            }\n            if (indexOffsetComparator(newIndexOffsetFromDocument(document), offset) <= 0) {\n                // The document sorts before the offset.\n                continue;\n            }\n            if (!mutatedDocs.has(document.key) && !queryMatches(query, document)) {\n                // The document cannot possibly match the query.\n                continue;\n            }\n            results = results.insert(document.key, document.mutableCopy());\n        }\n        return PersistencePromise.resolve(results);\n    }\n    getAllFromCollectionGroup(transaction, collectionGroup, offset, limit) {\n        // This method should only be called from the IndexBackfiller if persistence\n        // is enabled.\n        fail(0x251c);\n    }\n    forEachDocumentKey(transaction, f) {\n        return PersistencePromise.forEach(this.docs, (key) => f(key));\n    }\n    newChangeBuffer(options) {\n        // `trackRemovals` is ignores since the MemoryRemoteDocumentCache keeps\n        // a separate changelog and does not need special handling for removals.\n        return new MemoryRemoteDocumentChangeBuffer(this);\n    }\n    getSize(txn) {\n        return PersistencePromise.resolve(this.size);\n    }\n}\n/**\n * Creates a new memory-only RemoteDocumentCache.\n *\n * @param sizer - Used to assess the size of a document. For eager GC, this is\n * expected to just return 0 to avoid unnecessarily doing the work of\n * calculating the size.\n */\nfunction newMemoryRemoteDocumentCache(sizer) {\n    return new MemoryRemoteDocumentCacheImpl(sizer);\n}\n/**\n * Handles the details of adding and updating documents in the MemoryRemoteDocumentCache.\n */\nclass MemoryRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {\n    constructor(documentCache) {\n        super();\n        this.documentCache = documentCache;\n    }\n    applyChanges(transaction) {\n        const promises = [];\n        this.changes.forEach((key, doc) => {\n            if (doc.isValidDocument()) {\n                promises.push(this.documentCache.addEntry(transaction, doc));\n            }\n            else {\n                this.documentCache.removeEntry(key);\n            }\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    getFromCache(transaction, documentKey) {\n        return this.documentCache.getEntry(transaction, documentKey);\n    }\n    getAllFromCache(transaction, documentKeys) {\n        return this.documentCache.getEntries(transaction, documentKeys);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryTargetCache {\n    constructor(persistence) {\n        this.persistence = persistence;\n        /**\n         * Maps a target to the data about that target\n         */\n        this.targets = new ObjectMap(t => canonifyTarget(t), targetEquals);\n        /** The last received snapshot version. */\n        this.lastRemoteSnapshotVersion = SnapshotVersion.min();\n        /** The highest numbered target ID encountered. */\n        this.highestTargetId = 0;\n        /** The highest sequence number encountered. */\n        this.highestSequenceNumber = 0;\n        /**\n         * A ordered bidirectional mapping between documents and the remote target\n         * IDs.\n         */\n        this.references = new ReferenceSet();\n        this.targetCount = 0;\n        this.targetIdGenerator = TargetIdGenerator.forTargetCache();\n    }\n    forEachTarget(txn, f) {\n        this.targets.forEach((_, targetData) => f(targetData));\n        return PersistencePromise.resolve();\n    }\n    getLastRemoteSnapshotVersion(transaction) {\n        return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);\n    }\n    getHighestSequenceNumber(transaction) {\n        return PersistencePromise.resolve(this.highestSequenceNumber);\n    }\n    allocateTargetId(transaction) {\n        this.highestTargetId = this.targetIdGenerator.next();\n        return PersistencePromise.resolve(this.highestTargetId);\n    }\n    setTargetsMetadata(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {\n        if (lastRemoteSnapshotVersion) {\n            this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;\n        }\n        if (highestListenSequenceNumber > this.highestSequenceNumber) {\n            this.highestSequenceNumber = highestListenSequenceNumber;\n        }\n        return PersistencePromise.resolve();\n    }\n    saveTargetData(targetData) {\n        this.targets.set(targetData.target, targetData);\n        const targetId = targetData.targetId;\n        if (targetId > this.highestTargetId) {\n            this.targetIdGenerator = new TargetIdGenerator(targetId);\n            this.highestTargetId = targetId;\n        }\n        if (targetData.sequenceNumber > this.highestSequenceNumber) {\n            this.highestSequenceNumber = targetData.sequenceNumber;\n        }\n    }\n    addTargetData(transaction, targetData) {\n        this.saveTargetData(targetData);\n        this.targetCount += 1;\n        return PersistencePromise.resolve();\n    }\n    updateTargetData(transaction, targetData) {\n        this.saveTargetData(targetData);\n        return PersistencePromise.resolve();\n    }\n    removeTargetData(transaction, targetData) {\n        this.targets.delete(targetData.target);\n        this.references.removeReferencesForId(targetData.targetId);\n        this.targetCount -= 1;\n        return PersistencePromise.resolve();\n    }\n    removeTargets(transaction, upperBound, activeTargetIds) {\n        let count = 0;\n        const removals = [];\n        this.targets.forEach((key, targetData) => {\n            if (targetData.sequenceNumber <= upperBound &&\n                activeTargetIds.get(targetData.targetId) === null) {\n                this.targets.delete(key);\n                removals.push(this.removeMatchingKeysForTargetId(transaction, targetData.targetId));\n                count++;\n            }\n        });\n        return PersistencePromise.waitFor(removals).next(() => count);\n    }\n    getTargetCount(transaction) {\n        return PersistencePromise.resolve(this.targetCount);\n    }\n    getTargetData(transaction, target) {\n        const targetData = this.targets.get(target) || null;\n        return PersistencePromise.resolve(targetData);\n    }\n    addMatchingKeys(txn, keys, targetId) {\n        this.references.addReferences(keys, targetId);\n        return PersistencePromise.resolve();\n    }\n    removeMatchingKeys(txn, keys, targetId) {\n        this.references.removeReferences(keys, targetId);\n        const referenceDelegate = this.persistence.referenceDelegate;\n        const promises = [];\n        if (referenceDelegate) {\n            keys.forEach(key => {\n                promises.push(referenceDelegate.markPotentiallyOrphaned(txn, key));\n            });\n        }\n        return PersistencePromise.waitFor(promises);\n    }\n    removeMatchingKeysForTargetId(txn, targetId) {\n        this.references.removeReferencesForId(targetId);\n        return PersistencePromise.resolve();\n    }\n    getMatchingKeysForTargetId(txn, targetId) {\n        const matchingKeys = this.references.referencesForId(targetId);\n        return PersistencePromise.resolve(matchingKeys);\n    }\n    containsKey(txn, key) {\n        return PersistencePromise.resolve(this.references.containsKey(key));\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$d = 'MemoryPersistence';\n/**\n * A memory-backed instance of Persistence. Data is stored only in RAM and\n * not persisted across sessions.\n */\nclass MemoryPersistence {\n    /**\n     * The constructor accepts a factory for creating a reference delegate. This\n     * allows both the delegate and this instance to have strong references to\n     * each other without having nullable fields that would then need to be\n     * checked or asserted on every access.\n     */\n    constructor(referenceDelegateFactory, serializer) {\n        this.mutationQueues = {};\n        this.overlays = {};\n        this.listenSequence = new ListenSequence(0);\n        this._started = false;\n        this._started = true;\n        this.globalsCache = new MemoryGlobalsCache();\n        this.referenceDelegate = referenceDelegateFactory(this);\n        this.targetCache = new MemoryTargetCache(this);\n        const sizer = (doc) => this.referenceDelegate.documentSize(doc);\n        this.indexManager = new MemoryIndexManager();\n        this.remoteDocumentCache = newMemoryRemoteDocumentCache(sizer);\n        this.serializer = new LocalSerializer(serializer);\n        this.bundleCache = new MemoryBundleCache(this.serializer);\n    }\n    start() {\n        return Promise.resolve();\n    }\n    shutdown() {\n        // No durable state to ensure is closed on shutdown.\n        this._started = false;\n        return Promise.resolve();\n    }\n    get started() {\n        return this._started;\n    }\n    setDatabaseDeletedListener() {\n        // No op.\n    }\n    setNetworkEnabled() {\n        // No op.\n    }\n    getIndexManager(user) {\n        // We do not currently support indices for memory persistence, so we can\n        // return the same shared instance of the memory index manager.\n        return this.indexManager;\n    }\n    getDocumentOverlayCache(user) {\n        let overlay = this.overlays[user.toKey()];\n        if (!overlay) {\n            overlay = new MemoryDocumentOverlayCache();\n            this.overlays[user.toKey()] = overlay;\n        }\n        return overlay;\n    }\n    getMutationQueue(user, indexManager) {\n        let queue = this.mutationQueues[user.toKey()];\n        if (!queue) {\n            queue = new MemoryMutationQueue(indexManager, this.referenceDelegate);\n            this.mutationQueues[user.toKey()] = queue;\n        }\n        return queue;\n    }\n    getGlobalsCache() {\n        return this.globalsCache;\n    }\n    getTargetCache() {\n        return this.targetCache;\n    }\n    getRemoteDocumentCache() {\n        return this.remoteDocumentCache;\n    }\n    getBundleCache() {\n        return this.bundleCache;\n    }\n    runTransaction(action, mode, transactionOperation) {\n        logDebug(LOG_TAG$d, 'Starting transaction:', action);\n        const txn = new MemoryTransaction(this.listenSequence.next());\n        this.referenceDelegate.onTransactionStarted();\n        return transactionOperation(txn)\n            .next(result => {\n            return this.referenceDelegate\n                .onTransactionCommitted(txn)\n                .next(() => result);\n        })\n            .toPromise()\n            .then(result => {\n            txn.raiseOnCommittedEvent();\n            return result;\n        });\n    }\n    mutationQueuesContainKey(transaction, key) {\n        return PersistencePromise.or(Object.values(this.mutationQueues).map(queue => () => queue.containsKey(transaction, key)));\n    }\n}\n/**\n * Memory persistence is not actually transactional, but future implementations\n * may have transaction-scoped state.\n */\nclass MemoryTransaction extends PersistenceTransaction {\n    constructor(currentSequenceNumber) {\n        super();\n        this.currentSequenceNumber = currentSequenceNumber;\n    }\n}\nclass MemoryEagerDelegate {\n    constructor(persistence) {\n        this.persistence = persistence;\n        /** Tracks all documents that are active in Query views. */\n        this.localViewReferences = new ReferenceSet();\n        /** The list of documents that are potentially GCed after each transaction. */\n        this._orphanedDocuments = null;\n    }\n    static factory(persistence) {\n        return new MemoryEagerDelegate(persistence);\n    }\n    get orphanedDocuments() {\n        if (!this._orphanedDocuments) {\n            throw fail(0xee44);\n        }\n        else {\n            return this._orphanedDocuments;\n        }\n    }\n    addReference(txn, targetId, key) {\n        this.localViewReferences.addReference(key, targetId);\n        this.orphanedDocuments.delete(key.toString());\n        return PersistencePromise.resolve();\n    }\n    removeReference(txn, targetId, key) {\n        this.localViewReferences.removeReference(key, targetId);\n        this.orphanedDocuments.add(key.toString());\n        return PersistencePromise.resolve();\n    }\n    markPotentiallyOrphaned(txn, key) {\n        this.orphanedDocuments.add(key.toString());\n        return PersistencePromise.resolve();\n    }\n    removeTarget(txn, targetData) {\n        const orphaned = this.localViewReferences.removeReferencesForId(targetData.targetId);\n        orphaned.forEach(key => this.orphanedDocuments.add(key.toString()));\n        const cache = this.persistence.getTargetCache();\n        return cache\n            .getMatchingKeysForTargetId(txn, targetData.targetId)\n            .next(keys => {\n            keys.forEach(key => this.orphanedDocuments.add(key.toString()));\n        })\n            .next(() => cache.removeTargetData(txn, targetData));\n    }\n    onTransactionStarted() {\n        this._orphanedDocuments = new Set();\n    }\n    onTransactionCommitted(txn) {\n        // Remove newly orphaned documents.\n        const cache = this.persistence.getRemoteDocumentCache();\n        const changeBuffer = cache.newChangeBuffer();\n        return PersistencePromise.forEach(this.orphanedDocuments, (path) => {\n            const key = DocumentKey.fromPath(path);\n            return this.isReferenced(txn, key).next(isReferenced => {\n                if (!isReferenced) {\n                    changeBuffer.removeEntry(key, SnapshotVersion.min());\n                }\n            });\n        }).next(() => {\n            this._orphanedDocuments = null;\n            return changeBuffer.apply(txn);\n        });\n    }\n    updateLimboDocument(txn, key) {\n        return this.isReferenced(txn, key).next(isReferenced => {\n            if (isReferenced) {\n                this.orphanedDocuments.delete(key.toString());\n            }\n            else {\n                this.orphanedDocuments.add(key.toString());\n            }\n        });\n    }\n    documentSize(doc) {\n        // For eager GC, we don't care about the document size, there are no size thresholds.\n        return 0;\n    }\n    isReferenced(txn, key) {\n        return PersistencePromise.or([\n            () => PersistencePromise.resolve(this.localViewReferences.containsKey(key)),\n            () => this.persistence.getTargetCache().containsKey(txn, key),\n            () => this.persistence.mutationQueuesContainKey(txn, key)\n        ]);\n    }\n}\nclass MemoryLruDelegate {\n    constructor(persistence, lruParams) {\n        this.persistence = persistence;\n        this.orphanedSequenceNumbers = new ObjectMap(k => encodeResourcePath(k.path), (l, r) => l.isEqual(r));\n        this.garbageCollector = newLruGarbageCollector(this, lruParams);\n    }\n    static factory(persistence, lruParams) {\n        return new MemoryLruDelegate(persistence, lruParams);\n    }\n    // No-ops, present so memory persistence doesn't have to care which delegate\n    // it has.\n    onTransactionStarted() { }\n    onTransactionCommitted(txn) {\n        return PersistencePromise.resolve();\n    }\n    forEachTarget(txn, f) {\n        return this.persistence.getTargetCache().forEachTarget(txn, f);\n    }\n    getSequenceNumberCount(txn) {\n        const docCountPromise = this.orphanedDocumentCount(txn);\n        const targetCountPromise = this.persistence\n            .getTargetCache()\n            .getTargetCount(txn);\n        return targetCountPromise.next(targetCount => docCountPromise.next(docCount => targetCount + docCount));\n    }\n    orphanedDocumentCount(txn) {\n        let orphanedCount = 0;\n        return this.forEachOrphanedDocumentSequenceNumber(txn, _ => {\n            orphanedCount++;\n        }).next(() => orphanedCount);\n    }\n    forEachOrphanedDocumentSequenceNumber(txn, f) {\n        return PersistencePromise.forEach(this.orphanedSequenceNumbers, (key, sequenceNumber) => {\n            // Pass in the exact sequence number as the upper bound so we know it won't be pinned by\n            // being too recent.\n            return this.isPinned(txn, key, sequenceNumber).next(isPinned => {\n                if (!isPinned) {\n                    return f(sequenceNumber);\n                }\n                else {\n                    return PersistencePromise.resolve();\n                }\n            });\n        });\n    }\n    removeTargets(txn, upperBound, activeTargetIds) {\n        return this.persistence\n            .getTargetCache()\n            .removeTargets(txn, upperBound, activeTargetIds);\n    }\n    removeOrphanedDocuments(txn, upperBound) {\n        let count = 0;\n        const cache = this.persistence.getRemoteDocumentCache();\n        const changeBuffer = cache.newChangeBuffer();\n        const p = cache.forEachDocumentKey(txn, key => {\n            return this.isPinned(txn, key, upperBound).next(isPinned => {\n                if (!isPinned) {\n                    count++;\n                    changeBuffer.removeEntry(key, SnapshotVersion.min());\n                }\n            });\n        });\n        return p.next(() => changeBuffer.apply(txn)).next(() => count);\n    }\n    markPotentiallyOrphaned(txn, key) {\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n        return PersistencePromise.resolve();\n    }\n    removeTarget(txn, targetData) {\n        const updated = targetData.withSequenceNumber(txn.currentSequenceNumber);\n        return this.persistence.getTargetCache().updateTargetData(txn, updated);\n    }\n    addReference(txn, targetId, key) {\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n        return PersistencePromise.resolve();\n    }\n    removeReference(txn, targetId, key) {\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n        return PersistencePromise.resolve();\n    }\n    updateLimboDocument(txn, key) {\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n        return PersistencePromise.resolve();\n    }\n    documentSize(document) {\n        let documentSize = document.key.toString().length;\n        if (document.isFoundDocument()) {\n            documentSize += estimateByteSize(document.data.value);\n        }\n        return documentSize;\n    }\n    isPinned(txn, key, upperBound) {\n        return PersistencePromise.or([\n            () => this.persistence.mutationQueuesContainKey(txn, key),\n            () => this.persistence.getTargetCache().containsKey(txn, key),\n            () => {\n                const orphanedAt = this.orphanedSequenceNumbers.get(key);\n                return PersistencePromise.resolve(orphanedAt !== undefined && orphanedAt > upperBound);\n            }\n        ]);\n    }\n    getCacheSize(txn) {\n        return this.persistence.getRemoteDocumentCache().getSize(txn);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Performs database creation and schema upgrades. */\nclass SchemaConverter {\n    constructor(serializer) {\n        this.serializer = serializer;\n    }\n    /**\n     * Performs database creation and schema upgrades.\n     *\n     * Note that in production, this method is only ever used to upgrade the schema\n     * to SCHEMA_VERSION. Different values of toVersion are only used for testing\n     * and local feature development.\n     */\n    createOrUpgrade(db, txn, fromVersion, toVersion) {\n        const simpleDbTransaction = new SimpleDbTransaction('createOrUpgrade', txn);\n        if (fromVersion < 1 && toVersion >= 1) {\n            createPrimaryClientStore(db);\n            createMutationQueue(db);\n            createQueryCache(db);\n            createLegacyRemoteDocumentCache(db);\n        }\n        // Migration 2 to populate the targetGlobal object no longer needed since\n        // migration 3 unconditionally clears it.\n        let p = PersistencePromise.resolve();\n        if (fromVersion < 3 && toVersion >= 3) {\n            // Brand new clients don't need to drop and recreate--only clients that\n            // potentially have corrupt data.\n            if (fromVersion !== 0) {\n                dropQueryCache(db);\n                createQueryCache(db);\n            }\n            p = p.next(() => writeEmptyTargetGlobalEntry(simpleDbTransaction));\n        }\n        if (fromVersion < 4 && toVersion >= 4) {\n            if (fromVersion !== 0) {\n                // Schema version 3 uses auto-generated keys to generate globally unique\n                // mutation batch IDs (this was previously ensured internally by the\n                // client). To migrate to the new schema, we have to read all mutations\n                // and write them back out. We preserve the existing batch IDs to guarantee\n                // consistency with other object stores. Any further mutation batch IDs will\n                // be auto-generated.\n                p = p.next(() => upgradeMutationBatchSchemaAndMigrateData(db, simpleDbTransaction));\n            }\n            p = p.next(() => {\n                createClientMetadataStore(db);\n            });\n        }\n        if (fromVersion < 5 && toVersion >= 5) {\n            p = p.next(() => this.removeAcknowledgedMutations(simpleDbTransaction));\n        }\n        if (fromVersion < 6 && toVersion >= 6) {\n            p = p.next(() => {\n                createDocumentGlobalStore(db);\n                return this.addDocumentGlobal(simpleDbTransaction);\n            });\n        }\n        if (fromVersion < 7 && toVersion >= 7) {\n            p = p.next(() => this.ensureSequenceNumbers(simpleDbTransaction));\n        }\n        if (fromVersion < 8 && toVersion >= 8) {\n            p = p.next(() => this.createCollectionParentIndex(db, simpleDbTransaction));\n        }\n        if (fromVersion < 9 && toVersion >= 9) {\n            p = p.next(() => {\n                // Multi-Tab used to manage its own changelog, but this has been moved\n                // to the DbRemoteDocument object store itself. Since the previous change\n                // log only contained transient data, we can drop its object store.\n                dropRemoteDocumentChangesStore(db);\n                // Note: Schema version 9 used to create a read time index for the\n                // RemoteDocumentCache. This is now done with schema version 13.\n            });\n        }\n        if (fromVersion < 10 && toVersion >= 10) {\n            p = p.next(() => this.rewriteCanonicalIds(simpleDbTransaction));\n        }\n        if (fromVersion < 11 && toVersion >= 11) {\n            p = p.next(() => {\n                createBundlesStore(db);\n                createNamedQueriesStore(db);\n            });\n        }\n        if (fromVersion < 12 && toVersion >= 12) {\n            p = p.next(() => {\n                createDocumentOverlayStore(db);\n            });\n        }\n        if (fromVersion < 13 && toVersion >= 13) {\n            p = p\n                .next(() => createRemoteDocumentCache(db))\n                .next(() => this.rewriteRemoteDocumentCache(db, simpleDbTransaction))\n                .next(() => db.deleteObjectStore(DbRemoteDocumentStore$1));\n        }\n        if (fromVersion < 14 && toVersion >= 14) {\n            p = p.next(() => this.runOverlayMigration(db, simpleDbTransaction));\n        }\n        if (fromVersion < 15 && toVersion >= 15) {\n            p = p.next(() => createFieldIndex(db));\n        }\n        if (fromVersion < 16 && toVersion >= 16) {\n            // Clear the object stores to remove possibly corrupted index entries\n            p = p\n                .next(() => {\n                const indexStateStore = txn.objectStore(DbIndexStateStore);\n                indexStateStore.clear();\n            })\n                .next(() => {\n                const indexEntryStore = txn.objectStore(DbIndexEntryStore);\n                indexEntryStore.clear();\n            });\n        }\n        if (fromVersion < 17 && toVersion >= 17) {\n            p = p.next(() => {\n                createGlobalsStore(db);\n            });\n        }\n        if (fromVersion < 18 && toVersion >= 18) {\n            // Clear the IndexEntryStores on WebKit and Safari to remove possibly\n            // corrupted index entries\n            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isSafariOrWebkit)()) {\n                p = p\n                    .next(() => {\n                    const indexStateStore = txn.objectStore(DbIndexStateStore);\n                    indexStateStore.clear();\n                })\n                    .next(() => {\n                    const indexEntryStore = txn.objectStore(DbIndexEntryStore);\n                    indexEntryStore.clear();\n                });\n            }\n        }\n        return p;\n    }\n    addDocumentGlobal(txn) {\n        let byteSize = 0;\n        return txn\n            .store(DbRemoteDocumentStore$1)\n            .iterate((_, doc) => {\n            byteSize += dbDocumentSize(doc);\n        })\n            .next(() => {\n            const metadata = { byteSize };\n            return txn\n                .store(DbRemoteDocumentGlobalStore)\n                .put(DbRemoteDocumentGlobalKey, metadata);\n        });\n    }\n    removeAcknowledgedMutations(txn) {\n        const queuesStore = txn.store(DbMutationQueueStore);\n        const mutationsStore = txn.store(DbMutationBatchStore);\n        return queuesStore.loadAll().next(queues => {\n            return PersistencePromise.forEach(queues, (queue) => {\n                const range = IDBKeyRange.bound([queue.userId, BATCHID_UNKNOWN], [queue.userId, queue.lastAcknowledgedBatchId]);\n                return mutationsStore\n                    .loadAll(DbMutationBatchUserMutationsIndex, range)\n                    .next(dbBatches => {\n                    return PersistencePromise.forEach(dbBatches, (dbBatch) => {\n                        hardAssert(dbBatch.userId === queue.userId, 0x48da, `Cannot process batch from unexpected user`, { batchId: dbBatch.batchId });\n                        const batch = fromDbMutationBatch(this.serializer, dbBatch);\n                        return removeMutationBatch(txn, queue.userId, batch).next(() => { });\n                    });\n                });\n            });\n        });\n    }\n    /**\n     * Ensures that every document in the remote document cache has a corresponding sentinel row\n     * with a sequence number. Missing rows are given the most recently used sequence number.\n     */\n    ensureSequenceNumbers(txn) {\n        const documentTargetStore = txn.store(DbTargetDocumentStore);\n        const documentsStore = txn.store(DbRemoteDocumentStore$1);\n        const globalTargetStore = txn.store(DbTargetGlobalStore);\n        return globalTargetStore.get(DbTargetGlobalKey).next(metadata => {\n            const writeSentinelKey = (path) => {\n                return documentTargetStore.put({\n                    targetId: 0,\n                    path: encodeResourcePath(path),\n                    sequenceNumber: metadata.highestListenSequenceNumber\n                });\n            };\n            const promises = [];\n            return documentsStore\n                .iterate((key, doc) => {\n                const path = new ResourcePath(key);\n                const docSentinelKey = sentinelKey(path);\n                promises.push(documentTargetStore.get(docSentinelKey).next(maybeSentinel => {\n                    if (!maybeSentinel) {\n                        return writeSentinelKey(path);\n                    }\n                    else {\n                        return PersistencePromise.resolve();\n                    }\n                }));\n            })\n                .next(() => PersistencePromise.waitFor(promises));\n        });\n    }\n    createCollectionParentIndex(db, txn) {\n        // Create the index.\n        db.createObjectStore(DbCollectionParentStore, {\n            keyPath: DbCollectionParentKeyPath\n        });\n        const collectionParentsStore = txn.store(DbCollectionParentStore);\n        // Helper to add an index entry iff we haven't already written it.\n        const cache = new MemoryCollectionParentIndex();\n        const addEntry = (collectionPath) => {\n            if (cache.add(collectionPath)) {\n                const collectionId = collectionPath.lastSegment();\n                const parentPath = collectionPath.popLast();\n                return collectionParentsStore.put({\n                    collectionId,\n                    parent: encodeResourcePath(parentPath)\n                });\n            }\n        };\n        // Index existing remote documents.\n        return txn\n            .store(DbRemoteDocumentStore$1)\n            .iterate({ keysOnly: true }, (pathSegments, _) => {\n            const path = new ResourcePath(pathSegments);\n            return addEntry(path.popLast());\n        })\n            .next(() => {\n            // Index existing mutations.\n            return txn\n                .store(DbDocumentMutationStore)\n                .iterate({ keysOnly: true }, ([userID, encodedPath, batchId], _) => {\n                const path = decodeResourcePath(encodedPath);\n                return addEntry(path.popLast());\n            });\n        });\n    }\n    rewriteCanonicalIds(txn) {\n        const targetStore = txn.store(DbTargetStore);\n        return targetStore.iterate((key, originalDbTarget) => {\n            const originalTargetData = fromDbTarget(originalDbTarget);\n            const updatedDbTarget = toDbTarget(this.serializer, originalTargetData);\n            return targetStore.put(updatedDbTarget);\n        });\n    }\n    rewriteRemoteDocumentCache(db, transaction) {\n        const legacyRemoteDocumentStore = transaction.store(DbRemoteDocumentStore$1);\n        const writes = [];\n        return legacyRemoteDocumentStore\n            .iterate((_, legacyDocument) => {\n            const remoteDocumentStore = transaction.store(DbRemoteDocumentStore);\n            const path = extractKey(legacyDocument).path.toArray();\n            const dbRemoteDocument = {\n                prefixPath: path.slice(0, path.length - 2),\n                collectionGroup: path[path.length - 2],\n                documentId: path[path.length - 1],\n                readTime: legacyDocument.readTime || [0, 0],\n                unknownDocument: legacyDocument.unknownDocument,\n                noDocument: legacyDocument.noDocument,\n                document: legacyDocument.document,\n                hasCommittedMutations: !!legacyDocument.hasCommittedMutations\n            };\n            writes.push(remoteDocumentStore.put(dbRemoteDocument));\n        })\n            .next(() => PersistencePromise.waitFor(writes));\n    }\n    runOverlayMigration(db, transaction) {\n        const mutationsStore = transaction.store(DbMutationBatchStore);\n        const remoteDocumentCache = newIndexedDbRemoteDocumentCache(this.serializer);\n        const memoryPersistence = new MemoryPersistence(MemoryEagerDelegate.factory, this.serializer.remoteSerializer);\n        return mutationsStore.loadAll().next(dbBatches => {\n            const userToDocumentSet = new Map();\n            dbBatches.forEach(dbBatch => {\n                let documentSet = userToDocumentSet.get(dbBatch.userId) ?? documentKeySet();\n                const batch = fromDbMutationBatch(this.serializer, dbBatch);\n                batch.keys().forEach(key => (documentSet = documentSet.add(key)));\n                userToDocumentSet.set(dbBatch.userId, documentSet);\n            });\n            return PersistencePromise.forEach(userToDocumentSet, (allDocumentKeysForUser, userId) => {\n                const user = new User(userId);\n                const documentOverlayCache = IndexedDbDocumentOverlayCache.forUser(this.serializer, user);\n                // NOTE: The index manager and the reference delegate are\n                // irrelevant for the purpose of recalculating and saving\n                // overlays. We can therefore simply use the memory\n                // implementation.\n                const indexManager = memoryPersistence.getIndexManager(user);\n                const mutationQueue = IndexedDbMutationQueue.forUser(user, this.serializer, indexManager, memoryPersistence.referenceDelegate);\n                const localDocumentsView = new LocalDocumentsView(remoteDocumentCache, mutationQueue, documentOverlayCache, indexManager);\n                return localDocumentsView\n                    .recalculateAndSaveOverlaysForDocumentKeys(new IndexedDbTransaction(transaction, ListenSequence.INVALID), allDocumentKeysForUser)\n                    .next();\n            });\n        });\n    }\n}\nfunction sentinelKey(path) {\n    return [0, encodeResourcePath(path)];\n}\nfunction createPrimaryClientStore(db) {\n    db.createObjectStore(DbPrimaryClientStore);\n}\nfunction createMutationQueue(db) {\n    db.createObjectStore(DbMutationQueueStore, {\n        keyPath: DbMutationQueueKeyPath\n    });\n    const mutationBatchesStore = db.createObjectStore(DbMutationBatchStore, {\n        keyPath: DbMutationBatchKeyPath,\n        autoIncrement: true\n    });\n    mutationBatchesStore.createIndex(DbMutationBatchUserMutationsIndex, DbMutationBatchUserMutationsKeyPath, { unique: true });\n    db.createObjectStore(DbDocumentMutationStore);\n}\n/**\n * Upgrade function to migrate the 'mutations' store from V1 to V3. Loads\n * and rewrites all data.\n */\nfunction upgradeMutationBatchSchemaAndMigrateData(db, txn) {\n    const v1MutationsStore = txn.store(DbMutationBatchStore);\n    return v1MutationsStore.loadAll().next(existingMutations => {\n        db.deleteObjectStore(DbMutationBatchStore);\n        const mutationsStore = db.createObjectStore(DbMutationBatchStore, {\n            keyPath: DbMutationBatchKeyPath,\n            autoIncrement: true\n        });\n        mutationsStore.createIndex(DbMutationBatchUserMutationsIndex, DbMutationBatchUserMutationsKeyPath, { unique: true });\n        const v3MutationsStore = txn.store(DbMutationBatchStore);\n        const writeAll = existingMutations.map(mutation => v3MutationsStore.put(mutation));\n        return PersistencePromise.waitFor(writeAll);\n    });\n}\nfunction createLegacyRemoteDocumentCache(db) {\n    db.createObjectStore(DbRemoteDocumentStore$1);\n}\nfunction createRemoteDocumentCache(db) {\n    const remoteDocumentStore = db.createObjectStore(DbRemoteDocumentStore, {\n        keyPath: DbRemoteDocumentKeyPath\n    });\n    remoteDocumentStore.createIndex(DbRemoteDocumentDocumentKeyIndex, DbRemoteDocumentDocumentKeyIndexPath);\n    remoteDocumentStore.createIndex(DbRemoteDocumentCollectionGroupIndex, DbRemoteDocumentCollectionGroupIndexPath);\n}\nfunction createDocumentGlobalStore(db) {\n    db.createObjectStore(DbRemoteDocumentGlobalStore);\n}\nfunction createQueryCache(db) {\n    const targetDocumentsStore = db.createObjectStore(DbTargetDocumentStore, {\n        keyPath: DbTargetDocumentKeyPath\n    });\n    targetDocumentsStore.createIndex(DbTargetDocumentDocumentTargetsIndex, DbTargetDocumentDocumentTargetsKeyPath, { unique: true });\n    const targetStore = db.createObjectStore(DbTargetStore, {\n        keyPath: DbTargetKeyPath\n    });\n    // NOTE: This is unique only because the TargetId is the suffix.\n    targetStore.createIndex(DbTargetQueryTargetsIndexName, DbTargetQueryTargetsKeyPath, { unique: true });\n    db.createObjectStore(DbTargetGlobalStore);\n}\nfunction dropQueryCache(db) {\n    db.deleteObjectStore(DbTargetDocumentStore);\n    db.deleteObjectStore(DbTargetStore);\n    db.deleteObjectStore(DbTargetGlobalStore);\n}\nfunction dropRemoteDocumentChangesStore(db) {\n    if (db.objectStoreNames.contains('remoteDocumentChanges')) {\n        db.deleteObjectStore('remoteDocumentChanges');\n    }\n}\n/**\n * Creates the target global singleton row.\n *\n * @param txn - The version upgrade transaction for indexeddb\n */\nfunction writeEmptyTargetGlobalEntry(txn) {\n    const globalStore = txn.store(DbTargetGlobalStore);\n    const metadata = {\n        highestTargetId: 0,\n        highestListenSequenceNumber: 0,\n        lastRemoteSnapshotVersion: SnapshotVersion.min().toTimestamp(),\n        targetCount: 0\n    };\n    return globalStore.put(DbTargetGlobalKey, metadata);\n}\nfunction createClientMetadataStore(db) {\n    db.createObjectStore(DbClientMetadataStore, {\n        keyPath: DbClientMetadataKeyPath\n    });\n}\nfunction createBundlesStore(db) {\n    db.createObjectStore(DbBundleStore, {\n        keyPath: DbBundleKeyPath\n    });\n}\nfunction createNamedQueriesStore(db) {\n    db.createObjectStore(DbNamedQueryStore, {\n        keyPath: DbNamedQueryKeyPath\n    });\n}\nfunction createFieldIndex(db) {\n    const indexConfigurationStore = db.createObjectStore(DbIndexConfigurationStore, {\n        keyPath: DbIndexConfigurationKeyPath,\n        autoIncrement: true\n    });\n    indexConfigurationStore.createIndex(DbIndexConfigurationCollectionGroupIndex, DbIndexConfigurationCollectionGroupIndexPath, { unique: false });\n    const indexStateStore = db.createObjectStore(DbIndexStateStore, {\n        keyPath: DbIndexStateKeyPath\n    });\n    indexStateStore.createIndex(DbIndexStateSequenceNumberIndex, DbIndexStateSequenceNumberIndexPath, { unique: false });\n    const indexEntryStore = db.createObjectStore(DbIndexEntryStore, {\n        keyPath: DbIndexEntryKeyPath\n    });\n    indexEntryStore.createIndex(DbIndexEntryDocumentKeyIndex, DbIndexEntryDocumentKeyIndexPath, { unique: false });\n}\nfunction createDocumentOverlayStore(db) {\n    const documentOverlayStore = db.createObjectStore(DbDocumentOverlayStore, {\n        keyPath: DbDocumentOverlayKeyPath\n    });\n    documentOverlayStore.createIndex(DbDocumentOverlayCollectionPathOverlayIndex, DbDocumentOverlayCollectionPathOverlayIndexPath, { unique: false });\n    documentOverlayStore.createIndex(DbDocumentOverlayCollectionGroupOverlayIndex, DbDocumentOverlayCollectionGroupOverlayIndexPath, { unique: false });\n}\nfunction createGlobalsStore(db) {\n    db.createObjectStore(DbGlobalsStore, {\n        keyPath: DbGlobalsKeyPath\n    });\n}\nfunction extractKey(remoteDoc) {\n    if (remoteDoc.document) {\n        return new DocumentKey(ResourcePath.fromString(remoteDoc.document.name).popFirst(5));\n    }\n    else if (remoteDoc.noDocument) {\n        return DocumentKey.fromSegments(remoteDoc.noDocument.path);\n    }\n    else if (remoteDoc.unknownDocument) {\n        return DocumentKey.fromSegments(remoteDoc.unknownDocument.path);\n    }\n    else {\n        return fail(0x8faf);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$c = 'IndexedDbPersistence';\n/**\n * Oldest acceptable age in milliseconds for client metadata before the client\n * is considered inactive and its associated data is garbage collected.\n */\nconst MAX_CLIENT_AGE_MS = 30 * 60 * 1000; // 30 minutes\n/**\n * Oldest acceptable metadata age for clients that may participate in the\n * primary lease election. Clients that have not updated their client metadata\n * within 5 seconds are not eligible to receive a primary lease.\n */\nconst MAX_PRIMARY_ELIGIBLE_AGE_MS = 5000;\n/**\n * The interval at which clients will update their metadata, including\n * refreshing their primary lease if held or potentially trying to acquire it if\n * not held.\n *\n * Primary clients may opportunistically refresh their metadata earlier\n * if they're already performing an IndexedDB operation.\n */\nconst CLIENT_METADATA_REFRESH_INTERVAL_MS = 4000;\n/** User-facing error when the primary lease is required but not available. */\nconst PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG = 'Failed to obtain exclusive access to the persistence layer. To allow ' +\n    'shared access, multi-tab synchronization has to be enabled in all tabs. ' +\n    'If you are using `experimentalForceOwningTab:true`, make sure that only ' +\n    'one tab has persistence enabled at any given time.';\nconst UNSUPPORTED_PLATFORM_ERROR_MSG = 'This platform is either missing IndexedDB or is known to have ' +\n    'an incomplete implementation. Offline persistence has been disabled.';\n// The format of the LocalStorage key that stores zombied client is:\n//     firestore_zombie_<persistence_prefix>_<instance_key>\nconst ZOMBIED_CLIENTS_KEY_PREFIX = 'firestore_zombie';\n/**\n * The name of the main (and currently only) IndexedDB database. This name is\n * appended to the prefix provided to the IndexedDbPersistence constructor.\n */\nconst MAIN_DATABASE = 'main';\n/**\n * An IndexedDB-backed instance of Persistence. Data is stored persistently\n * across sessions.\n *\n * On Web only, the Firestore SDKs support shared access to its persistence\n * layer. This allows multiple browser tabs to read and write to IndexedDb and\n * to synchronize state even without network connectivity. Shared access is\n * currently optional and not enabled unless all clients invoke\n * `enablePersistence()` with `{synchronizeTabs:true}`.\n *\n * In multi-tab mode, if multiple clients are active at the same time, the SDK\n * will designate one client as the \"primary client\". An effort is made to pick\n * a visible, network-connected and active client, and this client is\n * responsible for letting other clients know about its presence. The primary\n * client writes a unique client-generated identifier (the client ID) to\n * IndexedDbs \"owner\" store every 4 seconds. If the primary client fails to\n * update this entry, another client can acquire the lease and take over as\n * primary.\n *\n * Some persistence operations in the SDK are designated as primary-client only\n * operations. This includes the acknowledgment of mutations and all updates of\n * remote documents. The effects of these operations are written to persistence\n * and then broadcast to other tabs via LocalStorage (see\n * `WebStorageSharedClientState`), which then refresh their state from\n * persistence.\n *\n * Similarly, the primary client listens to notifications sent by secondary\n * clients to discover persistence changes written by secondary clients, such as\n * the addition of new mutations and query targets.\n *\n * If multi-tab is not enabled and another tab already obtained the primary\n * lease, IndexedDbPersistence enters a failed state and all subsequent\n * operations will automatically fail.\n *\n * Additionally, there is an optimization so that when a tab is closed, the\n * primary lease is released immediately (this is especially important to make\n * sure that a refreshed tab is able to immediately re-acquire the primary\n * lease). Unfortunately, IndexedDB cannot be reliably used in window.unload\n * since it is an asynchronous API. So in addition to attempting to give up the\n * lease, the leaseholder writes its client ID to a \"zombiedClient\" entry in\n * LocalStorage which acts as an indicator that another tab should go ahead and\n * take the primary lease immediately regardless of the current lease timestamp.\n *\n * TODO(b/114226234): Remove `synchronizeTabs` section when multi-tab is no\n * longer optional.\n */\nclass IndexedDbPersistence {\n    constructor(\n    /**\n     * Whether to synchronize the in-memory state of multiple tabs and share\n     * access to local persistence.\n     */\n    allowTabSynchronization, persistenceKey, clientId, lruParams, queue, window, document, serializer, sequenceNumberSyncer, \n    /**\n     * If set to true, forcefully obtains database access. Existing tabs will\n     * no longer be able to access IndexedDB.\n     */\n    forceOwningTab, schemaVersion = SCHEMA_VERSION) {\n        this.allowTabSynchronization = allowTabSynchronization;\n        this.persistenceKey = persistenceKey;\n        this.clientId = clientId;\n        this.queue = queue;\n        this.window = window;\n        this.document = document;\n        this.sequenceNumberSyncer = sequenceNumberSyncer;\n        this.forceOwningTab = forceOwningTab;\n        this.schemaVersion = schemaVersion;\n        this.listenSequence = null;\n        this._started = false;\n        this.isPrimary = false;\n        this.networkEnabled = true;\n        /** Our window.unload handler, if registered. */\n        this.windowUnloadHandler = null;\n        this.inForeground = false;\n        /** Our 'visibilitychange' listener if registered. */\n        this.documentVisibilityHandler = null;\n        /** The client metadata refresh task. */\n        this.clientMetadataRefresher = null;\n        /** The last time we garbage collected the client metadata object store. */\n        this.lastGarbageCollectionTime = Number.NEGATIVE_INFINITY;\n        /** A listener to notify on primary state changes. */\n        this.primaryStateListener = _ => Promise.resolve();\n        if (!IndexedDbPersistence.isAvailable()) {\n            throw new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);\n        }\n        this.referenceDelegate = new IndexedDbLruDelegateImpl(this, lruParams);\n        this.dbName = persistenceKey + MAIN_DATABASE;\n        this.serializer = new LocalSerializer(serializer);\n        this.simpleDb = new SimpleDb(this.dbName, this.schemaVersion, new SchemaConverter(this.serializer));\n        this.globalsCache = new IndexedDbGlobalsCache();\n        this.targetCache = new IndexedDbTargetCache(this.referenceDelegate, this.serializer);\n        this.remoteDocumentCache = newIndexedDbRemoteDocumentCache(this.serializer);\n        this.bundleCache = new IndexedDbBundleCache();\n        if (this.window && this.window.localStorage) {\n            this.webStorage = this.window.localStorage;\n        }\n        else {\n            this.webStorage = null;\n            if (forceOwningTab === false) {\n                logError(LOG_TAG$c, 'LocalStorage is unavailable. As a result, persistence may not work ' +\n                    'reliably. In particular enablePersistence() could fail immediately ' +\n                    'after refreshing the page.');\n            }\n        }\n    }\n    /**\n     * Attempt to start IndexedDb persistence.\n     *\n     * @returns Whether persistence was enabled.\n     */\n    start() {\n        // NOTE: This is expected to fail sometimes (in the case of another tab\n        // already having the persistence lock), so it's the first thing we should\n        // do.\n        return this.updateClientMetadataAndTryBecomePrimary()\n            .then(() => {\n            if (!this.isPrimary && !this.allowTabSynchronization) {\n                // Fail `start()` if `synchronizeTabs` is disabled and we cannot\n                // obtain the primary lease.\n                throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\n            }\n            this.attachVisibilityHandler();\n            this.attachWindowUnloadHook();\n            this.scheduleClientMetadataAndPrimaryLeaseRefreshes();\n            return this.runTransaction('getHighestListenSequenceNumber', 'readonly', txn => this.targetCache.getHighestSequenceNumber(txn));\n        })\n            .then(highestListenSequenceNumber => {\n            this.listenSequence = new ListenSequence(highestListenSequenceNumber, this.sequenceNumberSyncer);\n        })\n            .then(() => {\n            this._started = true;\n        })\n            .catch(reason => {\n            this.simpleDb && this.simpleDb.close();\n            return Promise.reject(reason);\n        });\n    }\n    /**\n     * Registers a listener that gets called when the primary state of the\n     * instance changes. Upon registering, this listener is invoked immediately\n     * with the current primary state.\n     *\n     * PORTING NOTE: This is only used for Web multi-tab.\n     */\n    setPrimaryStateListener(primaryStateListener) {\n        this.primaryStateListener = async (primaryState) => {\n            if (this.started) {\n                return primaryStateListener(primaryState);\n            }\n        };\n        return primaryStateListener(this.isPrimary);\n    }\n    /**\n     * Registers a listener that gets called when the database receives a\n     * version change event indicating that it has deleted.\n     *\n     * PORTING NOTE: This is only used for Web multi-tab.\n     */\n    setDatabaseDeletedListener(databaseDeletedListener) {\n        this.simpleDb.setVersionChangeListener(async (event) => {\n            // Check if an attempt is made to delete IndexedDB.\n            if (event.newVersion === null) {\n                await databaseDeletedListener();\n            }\n        });\n    }\n    /**\n     * Adjusts the current network state in the client's metadata, potentially\n     * affecting the primary lease.\n     *\n     * PORTING NOTE: This is only used for Web multi-tab.\n     */\n    setNetworkEnabled(networkEnabled) {\n        if (this.networkEnabled !== networkEnabled) {\n            this.networkEnabled = networkEnabled;\n            // Schedule a primary lease refresh for immediate execution. The eventual\n            // lease update will be propagated via `primaryStateListener`.\n            this.queue.enqueueAndForget(async () => {\n                if (this.started) {\n                    await this.updateClientMetadataAndTryBecomePrimary();\n                }\n            });\n        }\n    }\n    /**\n     * Updates the client metadata in IndexedDb and attempts to either obtain or\n     * extend the primary lease for the local client. Asynchronously notifies the\n     * primary state listener if the client either newly obtained or released its\n     * primary lease.\n     */\n    updateClientMetadataAndTryBecomePrimary() {\n        return this.runTransaction('updateClientMetadataAndTryBecomePrimary', 'readwrite', txn => {\n            const metadataStore = clientMetadataStore(txn);\n            return metadataStore\n                .put({\n                clientId: this.clientId,\n                updateTimeMs: Date.now(),\n                networkEnabled: this.networkEnabled,\n                inForeground: this.inForeground\n            })\n                .next(() => {\n                if (this.isPrimary) {\n                    return this.verifyPrimaryLease(txn).next(success => {\n                        if (!success) {\n                            this.isPrimary = false;\n                            this.queue.enqueueRetryable(() => this.primaryStateListener(false));\n                        }\n                    });\n                }\n            })\n                .next(() => this.canActAsPrimary(txn))\n                .next(canActAsPrimary => {\n                if (this.isPrimary && !canActAsPrimary) {\n                    return this.releasePrimaryLeaseIfHeld(txn).next(() => false);\n                }\n                else if (canActAsPrimary) {\n                    return this.acquireOrExtendPrimaryLease(txn).next(() => true);\n                }\n                else {\n                    return /* canActAsPrimary= */ false;\n                }\n            });\n        })\n            .catch(e => {\n            if (isIndexedDbTransactionError(e)) {\n                logDebug(LOG_TAG$c, 'Failed to extend owner lease: ', e);\n                // Proceed with the existing state. Any subsequent access to\n                // IndexedDB will verify the lease.\n                return this.isPrimary;\n            }\n            if (!this.allowTabSynchronization) {\n                throw e;\n            }\n            logDebug(LOG_TAG$c, 'Releasing owner lease after error during lease refresh', e);\n            return /* isPrimary= */ false;\n        })\n            .then(isPrimary => {\n            if (this.isPrimary !== isPrimary) {\n                this.queue.enqueueRetryable(() => this.primaryStateListener(isPrimary));\n            }\n            this.isPrimary = isPrimary;\n        });\n    }\n    verifyPrimaryLease(txn) {\n        const store = primaryClientStore(txn);\n        return store.get(DbPrimaryClientKey).next(primaryClient => {\n            return PersistencePromise.resolve(this.isLocalClient(primaryClient));\n        });\n    }\n    removeClientMetadata(txn) {\n        const metadataStore = clientMetadataStore(txn);\n        return metadataStore.delete(this.clientId);\n    }\n    /**\n     * If the garbage collection threshold has passed, prunes the\n     * RemoteDocumentChanges and the ClientMetadata store based on the last update\n     * time of all clients.\n     */\n    async maybeGarbageCollectMultiClientState() {\n        if (this.isPrimary &&\n            !this.isWithinAge(this.lastGarbageCollectionTime, MAX_CLIENT_AGE_MS)) {\n            this.lastGarbageCollectionTime = Date.now();\n            const inactiveClients = await this.runTransaction('maybeGarbageCollectMultiClientState', 'readwrite-primary', txn => {\n                const metadataStore = getStore(txn, DbClientMetadataStore);\n                return metadataStore.loadAll().next(existingClients => {\n                    const active = this.filterActiveClients(existingClients, MAX_CLIENT_AGE_MS);\n                    const inactive = existingClients.filter(client => active.indexOf(client) === -1);\n                    // Delete metadata for clients that are no longer considered active.\n                    return PersistencePromise.forEach(inactive, (inactiveClient) => metadataStore.delete(inactiveClient.clientId)).next(() => inactive);\n                });\n            }).catch(() => {\n                // Ignore primary lease violations or any other type of error. The next\n                // primary will run `maybeGarbageCollectMultiClientState()` again.\n                // We don't use `ignoreIfPrimaryLeaseLoss()` since we don't want to depend\n                // on LocalStore.\n                return [];\n            });\n            // Delete potential leftover entries that may continue to mark the\n            // inactive clients as zombied in LocalStorage.\n            // Ideally we'd delete the IndexedDb and LocalStorage zombie entries for\n            // the client atomically, but we can't. So we opt to delete the IndexedDb\n            // entries first to avoid potentially reviving a zombied client.\n            if (this.webStorage) {\n                for (const inactiveClient of inactiveClients) {\n                    this.webStorage.removeItem(this.zombiedClientLocalStorageKey(inactiveClient.clientId));\n                }\n            }\n        }\n    }\n    /**\n     * Schedules a recurring timer to update the client metadata and to either\n     * extend or acquire the primary lease if the client is eligible.\n     */\n    scheduleClientMetadataAndPrimaryLeaseRefreshes() {\n        this.clientMetadataRefresher = this.queue.enqueueAfterDelay(\"client_metadata_refresh\" /* TimerId.ClientMetadataRefresh */, CLIENT_METADATA_REFRESH_INTERVAL_MS, () => {\n            return this.updateClientMetadataAndTryBecomePrimary()\n                .then(() => this.maybeGarbageCollectMultiClientState())\n                .then(() => this.scheduleClientMetadataAndPrimaryLeaseRefreshes());\n        });\n    }\n    /** Checks whether `client` is the local client. */\n    isLocalClient(client) {\n        return client ? client.ownerId === this.clientId : false;\n    }\n    /**\n     * Evaluate the state of all active clients and determine whether the local\n     * client is or can act as the holder of the primary lease. Returns whether\n     * the client is eligible for the lease, but does not actually acquire it.\n     * May return 'false' even if there is no active leaseholder and another\n     * (foreground) client should become leaseholder instead.\n     */\n    canActAsPrimary(txn) {\n        if (this.forceOwningTab) {\n            return PersistencePromise.resolve(true);\n        }\n        const store = primaryClientStore(txn);\n        return store\n            .get(DbPrimaryClientKey)\n            .next(currentPrimary => {\n            const currentLeaseIsValid = currentPrimary !== null &&\n                this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) &&\n                !this.isClientZombied(currentPrimary.ownerId);\n            // A client is eligible for the primary lease if:\n            // - its network is enabled and the client's tab is in the foreground.\n            // - its network is enabled and no other client's tab is in the\n            //   foreground.\n            // - every clients network is disabled and the client's tab is in the\n            //   foreground.\n            // - every clients network is disabled and no other client's tab is in\n            //   the foreground.\n            // - the `forceOwningTab` setting was passed in.\n            if (currentLeaseIsValid) {\n                if (this.isLocalClient(currentPrimary) && this.networkEnabled) {\n                    return true;\n                }\n                if (!this.isLocalClient(currentPrimary)) {\n                    if (!currentPrimary.allowTabSynchronization) {\n                        // Fail the `canActAsPrimary` check if the current leaseholder has\n                        // not opted into multi-tab synchronization. If this happens at\n                        // client startup, we reject the Promise returned by\n                        // `enablePersistence()` and the user can continue to use Firestore\n                        // with in-memory persistence.\n                        // If this fails during a lease refresh, we will instead block the\n                        // AsyncQueue from executing further operations. Note that this is\n                        // acceptable since mixing & matching different `synchronizeTabs`\n                        // settings is not supported.\n                        //\n                        // TODO(b/114226234): Remove this check when `synchronizeTabs` can\n                        // no longer be turned off.\n                        throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\n                    }\n                    return false;\n                }\n            }\n            if (this.networkEnabled && this.inForeground) {\n                return true;\n            }\n            return clientMetadataStore(txn)\n                .loadAll()\n                .next(existingClients => {\n                // Process all existing clients and determine whether at least one of\n                // them is better suited to obtain the primary lease.\n                const preferredCandidate = this.filterActiveClients(existingClients, MAX_PRIMARY_ELIGIBLE_AGE_MS).find(otherClient => {\n                    if (this.clientId !== otherClient.clientId) {\n                        const otherClientHasBetterNetworkState = !this.networkEnabled && otherClient.networkEnabled;\n                        const otherClientHasBetterVisibility = !this.inForeground && otherClient.inForeground;\n                        const otherClientHasSameNetworkState = this.networkEnabled === otherClient.networkEnabled;\n                        if (otherClientHasBetterNetworkState ||\n                            (otherClientHasBetterVisibility &&\n                                otherClientHasSameNetworkState)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                });\n                return preferredCandidate === undefined;\n            });\n        })\n            .next(canActAsPrimary => {\n            if (this.isPrimary !== canActAsPrimary) {\n                logDebug(LOG_TAG$c, `Client ${canActAsPrimary ? 'is' : 'is not'} eligible for a primary lease.`);\n            }\n            return canActAsPrimary;\n        });\n    }\n    async shutdown() {\n        // The shutdown() operations are idempotent and can be called even when\n        // start() aborted (e.g. because it couldn't acquire the persistence lease).\n        this._started = false;\n        this.markClientZombied();\n        if (this.clientMetadataRefresher) {\n            this.clientMetadataRefresher.cancel();\n            this.clientMetadataRefresher = null;\n        }\n        this.detachVisibilityHandler();\n        this.detachWindowUnloadHook();\n        // Use `SimpleDb.runTransaction` directly to avoid failing if another tab\n        // has obtained the primary lease.\n        await this.simpleDb.runTransaction('shutdown', 'readwrite', [DbPrimaryClientStore, DbClientMetadataStore], simpleDbTxn => {\n            const persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, ListenSequence.INVALID);\n            return this.releasePrimaryLeaseIfHeld(persistenceTransaction).next(() => this.removeClientMetadata(persistenceTransaction));\n        });\n        this.simpleDb.close();\n        // Remove the entry marking the client as zombied from LocalStorage since\n        // we successfully deleted its metadata from IndexedDb.\n        this.removeClientZombiedEntry();\n    }\n    /**\n     * Returns clients that are not zombied and have an updateTime within the\n     * provided threshold.\n     */\n    filterActiveClients(clients, activityThresholdMs) {\n        return clients.filter(client => this.isWithinAge(client.updateTimeMs, activityThresholdMs) &&\n            !this.isClientZombied(client.clientId));\n    }\n    /**\n     * Returns the IDs of the clients that are currently active. If multi-tab\n     * is not supported, returns an array that only contains the local client's\n     * ID.\n     *\n     * PORTING NOTE: This is only used for Web multi-tab.\n     */\n    getActiveClients() {\n        return this.runTransaction('getActiveClients', 'readonly', txn => {\n            return clientMetadataStore(txn)\n                .loadAll()\n                .next(clients => this.filterActiveClients(clients, MAX_CLIENT_AGE_MS).map(clientMetadata => clientMetadata.clientId));\n        });\n    }\n    get started() {\n        return this._started;\n    }\n    getGlobalsCache() {\n        return this.globalsCache;\n    }\n    getMutationQueue(user, indexManager) {\n        return IndexedDbMutationQueue.forUser(user, this.serializer, indexManager, this.referenceDelegate);\n    }\n    getTargetCache() {\n        return this.targetCache;\n    }\n    getRemoteDocumentCache() {\n        return this.remoteDocumentCache;\n    }\n    getIndexManager(user) {\n        return new IndexedDbIndexManager(user, this.serializer.remoteSerializer.databaseId);\n    }\n    getDocumentOverlayCache(user) {\n        return IndexedDbDocumentOverlayCache.forUser(this.serializer, user);\n    }\n    getBundleCache() {\n        return this.bundleCache;\n    }\n    runTransaction(action, mode, transactionOperation) {\n        logDebug(LOG_TAG$c, 'Starting transaction:', action);\n        const simpleDbMode = mode === 'readonly' ? 'readonly' : 'readwrite';\n        const objectStores = getObjectStores(this.schemaVersion);\n        let persistenceTransaction;\n        // Do all transactions as readwrite against all object stores, since we\n        // are the only reader/writer.\n        return this.simpleDb\n            .runTransaction(action, simpleDbMode, objectStores, simpleDbTxn => {\n            persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, this.listenSequence\n                ? this.listenSequence.next()\n                : ListenSequence.INVALID);\n            if (mode === 'readwrite-primary') {\n                // While we merely verify that we have (or can acquire) the lease\n                // immediately, we wait to extend the primary lease until after\n                // executing transactionOperation(). This ensures that even if the\n                // transactionOperation takes a long time, we'll use a recent\n                // leaseTimestampMs in the extended (or newly acquired) lease.\n                return this.verifyPrimaryLease(persistenceTransaction)\n                    .next(holdsPrimaryLease => {\n                    if (holdsPrimaryLease) {\n                        return /* holdsPrimaryLease= */ true;\n                    }\n                    return this.canActAsPrimary(persistenceTransaction);\n                })\n                    .next(holdsPrimaryLease => {\n                    if (!holdsPrimaryLease) {\n                        logError(`Failed to obtain primary lease for action '${action}'.`);\n                        this.isPrimary = false;\n                        this.queue.enqueueRetryable(() => this.primaryStateListener(false));\n                        throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_LOST_ERROR_MSG);\n                    }\n                    return transactionOperation(persistenceTransaction);\n                })\n                    .next(result => {\n                    return this.acquireOrExtendPrimaryLease(persistenceTransaction).next(() => result);\n                });\n            }\n            else {\n                return this.verifyAllowTabSynchronization(persistenceTransaction).next(() => transactionOperation(persistenceTransaction));\n            }\n        })\n            .then(result => {\n            persistenceTransaction.raiseOnCommittedEvent();\n            return result;\n        });\n    }\n    /**\n     * Verifies that the current tab is the primary leaseholder or alternatively\n     * that the leaseholder has opted into multi-tab synchronization.\n     */\n    // TODO(b/114226234): Remove this check when `synchronizeTabs` can no longer\n    // be turned off.\n    verifyAllowTabSynchronization(txn) {\n        const store = primaryClientStore(txn);\n        return store.get(DbPrimaryClientKey).next(currentPrimary => {\n            const currentLeaseIsValid = currentPrimary !== null &&\n                this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) &&\n                !this.isClientZombied(currentPrimary.ownerId);\n            if (currentLeaseIsValid && !this.isLocalClient(currentPrimary)) {\n                if (!this.forceOwningTab &&\n                    (!this.allowTabSynchronization ||\n                        !currentPrimary.allowTabSynchronization)) {\n                    throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\n                }\n            }\n        });\n    }\n    /**\n     * Obtains or extends the new primary lease for the local client. This\n     * method does not verify that the client is eligible for this lease.\n     */\n    acquireOrExtendPrimaryLease(txn) {\n        const newPrimary = {\n            ownerId: this.clientId,\n            allowTabSynchronization: this.allowTabSynchronization,\n            leaseTimestampMs: Date.now()\n        };\n        return primaryClientStore(txn).put(DbPrimaryClientKey, newPrimary);\n    }\n    static isAvailable() {\n        return SimpleDb.isAvailable();\n    }\n    /** Checks the primary lease and removes it if we are the current primary. */\n    releasePrimaryLeaseIfHeld(txn) {\n        const store = primaryClientStore(txn);\n        return store.get(DbPrimaryClientKey).next(primaryClient => {\n            if (this.isLocalClient(primaryClient)) {\n                logDebug(LOG_TAG$c, 'Releasing primary lease.');\n                return store.delete(DbPrimaryClientKey);\n            }\n            else {\n                return PersistencePromise.resolve();\n            }\n        });\n    }\n    /** Verifies that `updateTimeMs` is within `maxAgeMs`. */\n    isWithinAge(updateTimeMs, maxAgeMs) {\n        const now = Date.now();\n        const minAcceptable = now - maxAgeMs;\n        const maxAcceptable = now;\n        if (updateTimeMs < minAcceptable) {\n            return false;\n        }\n        else if (updateTimeMs > maxAcceptable) {\n            logError(`Detected an update time that is in the future: ${updateTimeMs} > ${maxAcceptable}`);\n            return false;\n        }\n        return true;\n    }\n    attachVisibilityHandler() {\n        if (this.document !== null &&\n            typeof this.document.addEventListener === 'function') {\n            this.documentVisibilityHandler = () => {\n                this.queue.enqueueAndForget(() => {\n                    this.inForeground = this.document.visibilityState === 'visible';\n                    return this.updateClientMetadataAndTryBecomePrimary();\n                });\n            };\n            this.document.addEventListener('visibilitychange', this.documentVisibilityHandler);\n            this.inForeground = this.document.visibilityState === 'visible';\n        }\n    }\n    detachVisibilityHandler() {\n        if (this.documentVisibilityHandler) {\n            this.document.removeEventListener('visibilitychange', this.documentVisibilityHandler);\n            this.documentVisibilityHandler = null;\n        }\n    }\n    /**\n     * Attaches a window.unload handler that will synchronously write our\n     * clientId to a \"zombie client id\" location in LocalStorage. This can be used\n     * by tabs trying to acquire the primary lease to determine that the lease\n     * is no longer valid even if the timestamp is recent. This is particularly\n     * important for the refresh case (so the tab correctly re-acquires the\n     * primary lease). LocalStorage is used for this rather than IndexedDb because\n     * it is a synchronous API and so can be used reliably from  an unload\n     * handler.\n     */\n    attachWindowUnloadHook() {\n        if (typeof this.window?.addEventListener === 'function') {\n            this.windowUnloadHandler = () => {\n                // Note: In theory, this should be scheduled on the AsyncQueue since it\n                // accesses internal state. We execute this code directly during shutdown\n                // to make sure it gets a chance to run.\n                this.markClientZombied();\n                const safariIndexdbBugVersionRegex = /(?:Version|Mobile)\\/1[456]/;\n                if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isSafari)() &&\n                    (navigator.appVersion.match(safariIndexdbBugVersionRegex) ||\n                        navigator.userAgent.match(safariIndexdbBugVersionRegex))) {\n                    // On Safari 14, 15, and 16, we do not run any cleanup actions as it might\n                    // trigger a bug that prevents Safari from re-opening IndexedDB during\n                    // the next page load.\n                    // See https://bugs.webkit.org/show_bug.cgi?id=226547\n                    this.queue.enterRestrictedMode(/* purgeExistingTasks= */ true);\n                }\n                this.queue.enqueueAndForget(() => {\n                    // Attempt graceful shutdown (including releasing our primary lease),\n                    // but there's no guarantee it will complete.\n                    return this.shutdown();\n                });\n            };\n            this.window.addEventListener('pagehide', this.windowUnloadHandler);\n        }\n    }\n    detachWindowUnloadHook() {\n        if (this.windowUnloadHandler) {\n            this.window.removeEventListener('pagehide', this.windowUnloadHandler);\n            this.windowUnloadHandler = null;\n        }\n    }\n    /**\n     * Returns whether a client is \"zombied\" based on its LocalStorage entry.\n     * Clients become zombied when their tab closes without running all of the\n     * cleanup logic in `shutdown()`.\n     */\n    isClientZombied(clientId) {\n        try {\n            const isZombied = this.webStorage?.getItem(this.zombiedClientLocalStorageKey(clientId)) !== null;\n            logDebug(LOG_TAG$c, `Client '${clientId}' ${isZombied ? 'is' : 'is not'} zombied in LocalStorage`);\n            return isZombied;\n        }\n        catch (e) {\n            // Gracefully handle if LocalStorage isn't working.\n            logError(LOG_TAG$c, 'Failed to get zombied client id.', e);\n            return false;\n        }\n    }\n    /**\n     * Record client as zombied (a client that had its tab closed). Zombied\n     * clients are ignored during primary tab selection.\n     */\n    markClientZombied() {\n        if (!this.webStorage) {\n            return;\n        }\n        try {\n            this.webStorage.setItem(this.zombiedClientLocalStorageKey(this.clientId), String(Date.now()));\n        }\n        catch (e) {\n            // Gracefully handle if LocalStorage isn't available / working.\n            logError('Failed to set zombie client id.', e);\n        }\n    }\n    /** Removes the zombied client entry if it exists. */\n    removeClientZombiedEntry() {\n        if (!this.webStorage) {\n            return;\n        }\n        try {\n            this.webStorage.removeItem(this.zombiedClientLocalStorageKey(this.clientId));\n        }\n        catch (e) {\n            // Ignore\n        }\n    }\n    zombiedClientLocalStorageKey(clientId) {\n        return `${ZOMBIED_CLIENTS_KEY_PREFIX}_${this.persistenceKey}_${clientId}`;\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the primary client object store.\n */\nfunction primaryClientStore(txn) {\n    return getStore(txn, DbPrimaryClientStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the client metadata object store.\n */\nfunction clientMetadataStore(txn) {\n    return getStore(txn, DbClientMetadataStore);\n}\n/**\n * Generates a string used as a prefix when storing data in IndexedDB and\n * LocalStorage.\n */\nfunction indexedDbStoragePrefix(databaseId, persistenceKey) {\n    // Use two different prefix formats:\n    //\n    //   * firestore / persistenceKey / projectID . databaseID / ...\n    //   * firestore / persistenceKey / projectID / ...\n    //\n    // projectIDs are DNS-compatible names and cannot contain dots\n    // so there's no danger of collisions.\n    let database = databaseId.projectId;\n    if (!databaseId.isDefaultDatabase) {\n        database += '.' + databaseId.database;\n    }\n    return 'firestore/' + persistenceKey + '/' + database + '/';\n}\nasync function indexedDbClearPersistence(persistenceKey) {\n    if (!SimpleDb.isAvailable()) {\n        return Promise.resolve();\n    }\n    const dbName = persistenceKey + MAIN_DATABASE;\n    await SimpleDb.delete(dbName);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Compares two array for equality using comparator. The method computes the\n * intersection and invokes `onAdd` for every element that is in `after` but not\n * `before`. `onRemove` is invoked for every element in `before` but missing\n * from `after`.\n *\n * The method creates a copy of both `before` and `after` and runs in O(n log\n * n), where n is the size of the two lists.\n *\n * @param before - The elements that exist in the original array.\n * @param after - The elements to diff against the original array.\n * @param comparator - The comparator for the elements in before and after.\n * @param onAdd - A function to invoke for every element that is part of `\n * after` but not `before`.\n * @param onRemove - A function to invoke for every element that is part of\n * `before` but not `after`.\n */\nfunction diffArrays(before, after, comparator, onAdd, onRemove) {\n    before = [...before];\n    after = [...after];\n    before.sort(comparator);\n    after.sort(comparator);\n    const bLen = before.length;\n    const aLen = after.length;\n    let a = 0;\n    let b = 0;\n    while (a < aLen && b < bLen) {\n        const cmp = comparator(before[b], after[a]);\n        if (cmp < 0) {\n            // The element was removed if the next element in our ordered\n            // walkthrough is only in `before`.\n            onRemove(before[b++]);\n        }\n        else if (cmp > 0) {\n            // The element was added if the next element in our ordered walkthrough\n            // is only in `after`.\n            onAdd(after[a++]);\n        }\n        else {\n            a++;\n            b++;\n        }\n    }\n    while (a < aLen) {\n        onAdd(after[a++]);\n    }\n    while (b < bLen) {\n        onRemove(before[b++]);\n    }\n}\n/**\n * Verifies equality for an array of primitives.\n *\n * @private\n * @internal\n * @param left - Array of primitives.\n * @param right - Array of primitives.\n * @returns True if arrays are equal.\n */\nfunction isPrimitiveArrayEqual(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    for (let i = 0; i < left.length; ++i) {\n        if (left[i] !== right[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$b = 'LocalStore';\n/**\n * The maximum time to leave a resume token buffered without writing it out.\n * This value is arbitrary: it's long enough to avoid several writes\n * (possibly indefinitely if updates come more frequently than this) but\n * short enough that restarting after crashing will still have a pretty\n * recent resume token.\n */\nconst RESUME_TOKEN_MAX_AGE_MICROS = 5 * 60 * 1e6;\n/**\n * Implements `LocalStore` interface.\n *\n * Note: some field defined in this class might have public access level, but\n * the class is not exported so they are only accessible from this module.\n * This is useful to implement optional features (like bundles) in free\n * functions, such that they are tree-shakeable.\n */\nclass LocalStoreImpl {\n    constructor(\n    /** Manages our in-memory or durable persistence. */\n    persistence, queryEngine, initialUser, serializer) {\n        this.persistence = persistence;\n        this.queryEngine = queryEngine;\n        this.serializer = serializer;\n        /**\n         * Maps a targetID to data about its target.\n         *\n         * PORTING NOTE: We are using an immutable data structure on Web to make re-runs\n         * of `applyRemoteEvent()` idempotent.\n         */\n        this.targetDataByTarget = new SortedMap(primitiveComparator);\n        /** Maps a target to its targetID. */\n        // TODO(wuandy): Evaluate if TargetId can be part of Target.\n        this.targetIdByTarget = new ObjectMap(t => canonifyTarget(t), targetEquals);\n        /**\n         * A per collection group index of the last read time processed by\n         * `getNewDocumentChanges()`.\n         *\n         * PORTING NOTE: This is only used for multi-tab synchronization.\n         */\n        this.collectionGroupReadTime = new Map();\n        this.remoteDocuments = persistence.getRemoteDocumentCache();\n        this.targetCache = persistence.getTargetCache();\n        this.bundleCache = persistence.getBundleCache();\n        this.initializeUserComponents(initialUser);\n    }\n    initializeUserComponents(user) {\n        // TODO(indexing): Add spec tests that test these components change after a\n        // user change\n        this.documentOverlayCache = this.persistence.getDocumentOverlayCache(user);\n        this.indexManager = this.persistence.getIndexManager(user);\n        this.mutationQueue = this.persistence.getMutationQueue(user, this.indexManager);\n        this.localDocuments = new LocalDocumentsView(this.remoteDocuments, this.mutationQueue, this.documentOverlayCache, this.indexManager);\n        this.remoteDocuments.setIndexManager(this.indexManager);\n        this.queryEngine.initialize(this.localDocuments, this.indexManager);\n    }\n    collectGarbage(garbageCollector) {\n        return this.persistence.runTransaction('Collect garbage', 'readwrite-primary', txn => garbageCollector.collect(txn, this.targetDataByTarget));\n    }\n}\nfunction newLocalStore(\n/** Manages our in-memory or durable persistence. */\npersistence, queryEngine, initialUser, serializer) {\n    return new LocalStoreImpl(persistence, queryEngine, initialUser, serializer);\n}\n/**\n * Tells the LocalStore that the currently authenticated user has changed.\n *\n * In response the local store switches the mutation queue to the new user and\n * returns any resulting document changes.\n */\n// PORTING NOTE: Android and iOS only return the documents affected by the\n// change.\nasync function localStoreHandleUserChange(localStore, user) {\n    const localStoreImpl = debugCast(localStore);\n    const result = await localStoreImpl.persistence.runTransaction('Handle user change', 'readonly', txn => {\n        // Swap out the mutation queue, grabbing the pending mutation batches\n        // before and after.\n        let oldBatches;\n        return localStoreImpl.mutationQueue\n            .getAllMutationBatches(txn)\n            .next(promisedOldBatches => {\n            oldBatches = promisedOldBatches;\n            localStoreImpl.initializeUserComponents(user);\n            return localStoreImpl.mutationQueue.getAllMutationBatches(txn);\n        })\n            .next(newBatches => {\n            const removedBatchIds = [];\n            const addedBatchIds = [];\n            // Union the old/new changed keys.\n            let changedKeys = documentKeySet();\n            for (const batch of oldBatches) {\n                removedBatchIds.push(batch.batchId);\n                for (const mutation of batch.mutations) {\n                    changedKeys = changedKeys.add(mutation.key);\n                }\n            }\n            for (const batch of newBatches) {\n                addedBatchIds.push(batch.batchId);\n                for (const mutation of batch.mutations) {\n                    changedKeys = changedKeys.add(mutation.key);\n                }\n            }\n            // Return the set of all (potentially) changed documents and the list\n            // of mutation batch IDs that were affected by change.\n            return localStoreImpl.localDocuments\n                .getDocuments(txn, changedKeys)\n                .next(affectedDocuments => {\n                return {\n                    affectedDocuments,\n                    removedBatchIds,\n                    addedBatchIds\n                };\n            });\n        });\n    });\n    return result;\n}\n/* Accepts locally generated Mutations and commit them to storage. */\nfunction localStoreWriteLocally(localStore, mutations) {\n    const localStoreImpl = debugCast(localStore);\n    const localWriteTime = Timestamp.now();\n    const keys = mutations.reduce((keys, m) => keys.add(m.key), documentKeySet());\n    let overlayedDocuments;\n    let mutationBatch;\n    return localStoreImpl.persistence\n        .runTransaction('Locally write mutations', 'readwrite', txn => {\n        // Figure out which keys do not have a remote version in the cache, this\n        // is needed to create the right overlay mutation: if no remote version\n        // presents, we do not need to create overlays as patch mutations.\n        // TODO(Overlay): Is there a better way to determine this? Using the\n        //  document version does not work because local mutations set them back\n        //  to 0.\n        let remoteDocs = mutableDocumentMap();\n        let docsWithoutRemoteVersion = documentKeySet();\n        return localStoreImpl.remoteDocuments\n            .getEntries(txn, keys)\n            .next(docs => {\n            remoteDocs = docs;\n            remoteDocs.forEach((key, doc) => {\n                if (!doc.isValidDocument()) {\n                    docsWithoutRemoteVersion = docsWithoutRemoteVersion.add(key);\n                }\n            });\n        })\n            .next(() => {\n            // Load and apply all existing mutations. This lets us compute the\n            // current base state for all non-idempotent transforms before applying\n            // any additional user-provided writes.\n            return localStoreImpl.localDocuments.getOverlayedDocuments(txn, remoteDocs);\n        })\n            .next((docs) => {\n            overlayedDocuments = docs;\n            // For non-idempotent mutations (such as `FieldValue.increment()`),\n            // we record the base state in a separate patch mutation. This is\n            // later used to guarantee consistent values and prevents flicker\n            // even if the backend sends us an update that already includes our\n            // transform.\n            const baseMutations = [];\n            for (const mutation of mutations) {\n                const baseValue = mutationExtractBaseValue(mutation, overlayedDocuments.get(mutation.key).overlayedDocument);\n                if (baseValue != null) {\n                    // NOTE: The base state should only be applied if there's some\n                    // existing document to override, so use a Precondition of\n                    // exists=true\n                    baseMutations.push(new PatchMutation(mutation.key, baseValue, extractFieldMask(baseValue.value.mapValue), Precondition.exists(true)));\n                }\n            }\n            return localStoreImpl.mutationQueue.addMutationBatch(txn, localWriteTime, baseMutations, mutations);\n        })\n            .next(batch => {\n            mutationBatch = batch;\n            const overlays = batch.applyToLocalDocumentSet(overlayedDocuments, docsWithoutRemoteVersion);\n            return localStoreImpl.documentOverlayCache.saveOverlays(txn, batch.batchId, overlays);\n        });\n    })\n        .then(() => ({\n        batchId: mutationBatch.batchId,\n        changes: convertOverlayedDocumentMapToDocumentMap(overlayedDocuments)\n    }));\n}\n/**\n * Acknowledges the given batch.\n *\n * On the happy path when a batch is acknowledged, the local store will\n *\n *  + remove the batch from the mutation queue;\n *  + apply the changes to the remote document cache;\n *  + recalculate the latency compensated view implied by those changes (there\n *    may be mutations in the queue that affect the documents but haven't been\n *    acknowledged yet); and\n *  + give the changed documents back the sync engine\n *\n * @returns The resulting (modified) documents.\n */\nfunction localStoreAcknowledgeBatch(localStore, batchResult) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Acknowledge batch', 'readwrite-primary', txn => {\n        const affected = batchResult.batch.keys();\n        const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\n            trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\n        });\n        return applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer)\n            .next(() => documentBuffer.apply(txn))\n            .next(() => localStoreImpl.mutationQueue.performConsistencyCheck(txn))\n            .next(() => localStoreImpl.documentOverlayCache.removeOverlaysForBatchId(txn, affected, batchResult.batch.batchId))\n            .next(() => localStoreImpl.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(txn, getKeysWithTransformResults(batchResult)))\n            .next(() => localStoreImpl.localDocuments.getDocuments(txn, affected));\n    });\n}\nfunction getKeysWithTransformResults(batchResult) {\n    let result = documentKeySet();\n    for (let i = 0; i < batchResult.mutationResults.length; ++i) {\n        const mutationResult = batchResult.mutationResults[i];\n        if (mutationResult.transformResults.length > 0) {\n            result = result.add(batchResult.batch.mutations[i].key);\n        }\n    }\n    return result;\n}\n/**\n * Removes mutations from the MutationQueue for the specified batch;\n * LocalDocuments will be recalculated.\n *\n * @returns The resulting modified documents.\n */\nfunction localStoreRejectBatch(localStore, batchId) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Reject batch', 'readwrite-primary', txn => {\n        let affectedKeys;\n        return localStoreImpl.mutationQueue\n            .lookupMutationBatch(txn, batchId)\n            .next((batch) => {\n            hardAssert(batch !== null, 0x90f9);\n            affectedKeys = batch.keys();\n            return localStoreImpl.mutationQueue.removeMutationBatch(txn, batch);\n        })\n            .next(() => localStoreImpl.mutationQueue.performConsistencyCheck(txn))\n            .next(() => localStoreImpl.documentOverlayCache.removeOverlaysForBatchId(txn, affectedKeys, batchId))\n            .next(() => localStoreImpl.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(txn, affectedKeys))\n            .next(() => localStoreImpl.localDocuments.getDocuments(txn, affectedKeys));\n    });\n}\n/**\n * Returns the largest (latest) batch id in mutation queue that is pending\n * server response.\n *\n * Returns `BATCHID_UNKNOWN` if the queue is empty.\n */\nfunction localStoreGetHighestUnacknowledgedBatchId(localStore) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Get highest unacknowledged batch id', 'readonly', txn => localStoreImpl.mutationQueue.getHighestUnacknowledgedBatchId(txn));\n}\n/**\n * Returns the last consistent snapshot processed (used by the RemoteStore to\n * determine whether to buffer incoming snapshots from the backend).\n */\nfunction localStoreGetLastRemoteSnapshotVersion(localStore) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Get last remote snapshot version', 'readonly', txn => localStoreImpl.targetCache.getLastRemoteSnapshotVersion(txn));\n}\n/**\n * Updates the \"ground-state\" (remote) documents. We assume that the remote\n * event reflects any write batches that have been acknowledged or rejected\n * (i.e. we do not re-apply local mutations to updates from this event).\n *\n * LocalDocuments are re-calculated if there are remaining mutations in the\n * queue.\n */\nfunction localStoreApplyRemoteEventToLocalCache(localStore, remoteEvent) {\n    const localStoreImpl = debugCast(localStore);\n    const remoteVersion = remoteEvent.snapshotVersion;\n    let newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;\n    return localStoreImpl.persistence\n        .runTransaction('Apply remote event', 'readwrite-primary', txn => {\n        const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\n            trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\n        });\n        // Reset newTargetDataByTargetMap in case this transaction gets re-run.\n        newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;\n        const promises = [];\n        remoteEvent.targetChanges.forEach((change, targetId) => {\n            const oldTargetData = newTargetDataByTargetMap.get(targetId);\n            if (!oldTargetData) {\n                return;\n            }\n            // Only update the remote keys if the target is still active. This\n            // ensures that we can persist the updated target data along with\n            // the updated assignment.\n            promises.push(localStoreImpl.targetCache\n                .removeMatchingKeys(txn, change.removedDocuments, targetId)\n                .next(() => {\n                return localStoreImpl.targetCache.addMatchingKeys(txn, change.addedDocuments, targetId);\n            }));\n            let newTargetData = oldTargetData.withSequenceNumber(txn.currentSequenceNumber);\n            if (remoteEvent.targetMismatches.get(targetId) !== null) {\n                newTargetData = newTargetData\n                    .withResumeToken(ByteString.EMPTY_BYTE_STRING, SnapshotVersion.min())\n                    .withLastLimboFreeSnapshotVersion(SnapshotVersion.min());\n            }\n            else if (change.resumeToken.approximateByteSize() > 0) {\n                newTargetData = newTargetData.withResumeToken(change.resumeToken, remoteVersion);\n            }\n            newTargetDataByTargetMap = newTargetDataByTargetMap.insert(targetId, newTargetData);\n            // Update the target data if there are target changes (or if\n            // sufficient time has passed since the last update).\n            if (shouldPersistTargetData(oldTargetData, newTargetData, change)) {\n                promises.push(localStoreImpl.targetCache.updateTargetData(txn, newTargetData));\n            }\n        });\n        let changedDocs = mutableDocumentMap();\n        let existenceChangedKeys = documentKeySet();\n        remoteEvent.documentUpdates.forEach(key => {\n            if (remoteEvent.resolvedLimboDocuments.has(key)) {\n                promises.push(localStoreImpl.persistence.referenceDelegate.updateLimboDocument(txn, key));\n            }\n        });\n        // Each loop iteration only affects its \"own\" doc, so it's safe to get all\n        // the remote documents in advance in a single call.\n        promises.push(populateDocumentChangeBuffer(txn, documentBuffer, remoteEvent.documentUpdates).next(result => {\n            changedDocs = result.changedDocuments;\n            existenceChangedKeys = result.existenceChangedKeys;\n        }));\n        // HACK: The only reason we allow a null snapshot version is so that we\n        // can synthesize remote events when we get permission denied errors while\n        // trying to resolve the state of a locally cached document that is in\n        // limbo.\n        if (!remoteVersion.isEqual(SnapshotVersion.min())) {\n            const updateRemoteVersion = localStoreImpl.targetCache\n                .getLastRemoteSnapshotVersion(txn)\n                .next(lastRemoteSnapshotVersion => {\n                return localStoreImpl.targetCache.setTargetsMetadata(txn, txn.currentSequenceNumber, remoteVersion);\n            });\n            promises.push(updateRemoteVersion);\n        }\n        return PersistencePromise.waitFor(promises)\n            .next(() => documentBuffer.apply(txn))\n            .next(() => localStoreImpl.localDocuments.getLocalViewOfDocuments(txn, changedDocs, existenceChangedKeys))\n            .next(() => changedDocs);\n    })\n        .then(changedDocs => {\n        localStoreImpl.targetDataByTarget = newTargetDataByTargetMap;\n        return changedDocs;\n    });\n}\n/**\n * Populates document change buffer with documents from backend or a bundle.\n * Returns the document changes resulting from applying those documents, and\n * also a set of documents whose existence state are changed as a result.\n *\n * @param txn - Transaction to use to read existing documents from storage.\n * @param documentBuffer - Document buffer to collect the resulted changes to be\n *        applied to storage.\n * @param documents - Documents to be applied.\n */\nfunction populateDocumentChangeBuffer(txn, documentBuffer, documents) {\n    let updatedKeys = documentKeySet();\n    let existenceChangedKeys = documentKeySet();\n    documents.forEach(k => (updatedKeys = updatedKeys.add(k)));\n    return documentBuffer.getEntries(txn, updatedKeys).next(existingDocs => {\n        let changedDocuments = mutableDocumentMap();\n        documents.forEach((key, doc) => {\n            const existingDoc = existingDocs.get(key);\n            // Check if see if there is a existence state change for this document.\n            if (doc.isFoundDocument() !== existingDoc.isFoundDocument()) {\n                existenceChangedKeys = existenceChangedKeys.add(key);\n            }\n            // Note: The order of the steps below is important, since we want\n            // to ensure that rejected limbo resolutions (which fabricate\n            // NoDocuments with SnapshotVersion.min()) never add documents to\n            // cache.\n            if (doc.isNoDocument() && doc.version.isEqual(SnapshotVersion.min())) {\n                // NoDocuments with SnapshotVersion.min() are used in manufactured\n                // events. We remove these documents from cache since we lost\n                // access.\n                documentBuffer.removeEntry(key, doc.readTime);\n                changedDocuments = changedDocuments.insert(key, doc);\n            }\n            else if (!existingDoc.isValidDocument() ||\n                doc.version.compareTo(existingDoc.version) > 0 ||\n                (doc.version.compareTo(existingDoc.version) === 0 &&\n                    existingDoc.hasPendingWrites)) {\n                documentBuffer.addEntry(doc);\n                changedDocuments = changedDocuments.insert(key, doc);\n            }\n            else {\n                logDebug(LOG_TAG$b, 'Ignoring outdated watch update for ', key, '. Current version:', existingDoc.version, ' Watch version:', doc.version);\n            }\n        });\n        return { changedDocuments, existenceChangedKeys };\n    });\n}\n/**\n * Returns true if the newTargetData should be persisted during an update of\n * an active target. TargetData should always be persisted when a target is\n * being released and should not call this function.\n *\n * While the target is active, TargetData updates can be omitted when nothing\n * about the target has changed except metadata like the resume token or\n * snapshot version. Occasionally it's worth the extra write to prevent these\n * values from getting too stale after a crash, but this doesn't have to be\n * too frequent.\n */\nfunction shouldPersistTargetData(oldTargetData, newTargetData, change) {\n    // Always persist target data if we don't already have a resume token.\n    if (oldTargetData.resumeToken.approximateByteSize() === 0) {\n        return true;\n    }\n    // Don't allow resume token changes to be buffered indefinitely. This\n    // allows us to be reasonably up-to-date after a crash and avoids needing\n    // to loop over all active queries on shutdown. Especially in the browser\n    // we may not get time to do anything interesting while the current tab is\n    // closing.\n    const timeDelta = newTargetData.snapshotVersion.toMicroseconds() -\n        oldTargetData.snapshotVersion.toMicroseconds();\n    if (timeDelta >= RESUME_TOKEN_MAX_AGE_MICROS) {\n        return true;\n    }\n    // Otherwise if the only thing that has changed about a target is its resume\n    // token it's not worth persisting. Note that the RemoteStore keeps an\n    // in-memory view of the currently active targets which includes the current\n    // resume token, so stream failure or user changes will still use an\n    // up-to-date resume token regardless of what we do here.\n    const changes = change.addedDocuments.size +\n        change.modifiedDocuments.size +\n        change.removedDocuments.size;\n    return changes > 0;\n}\n/**\n * Notifies local store of the changed views to locally pin documents.\n */\nasync function localStoreNotifyLocalViewChanges(localStore, viewChanges) {\n    const localStoreImpl = debugCast(localStore);\n    try {\n        await localStoreImpl.persistence.runTransaction('notifyLocalViewChanges', 'readwrite', txn => {\n            return PersistencePromise.forEach(viewChanges, (viewChange) => {\n                return PersistencePromise.forEach(viewChange.addedKeys, (key) => localStoreImpl.persistence.referenceDelegate.addReference(txn, viewChange.targetId, key)).next(() => PersistencePromise.forEach(viewChange.removedKeys, (key) => localStoreImpl.persistence.referenceDelegate.removeReference(txn, viewChange.targetId, key)));\n            });\n        });\n    }\n    catch (e) {\n        if (isIndexedDbTransactionError(e)) {\n            // If `notifyLocalViewChanges` fails, we did not advance the sequence\n            // number for the documents that were included in this transaction.\n            // This might trigger them to be deleted earlier than they otherwise\n            // would have, but it should not invalidate the integrity of the data.\n            logDebug(LOG_TAG$b, 'Failed to update sequence numbers: ' + e);\n        }\n        else {\n            throw e;\n        }\n    }\n    for (const viewChange of viewChanges) {\n        const targetId = viewChange.targetId;\n        if (!viewChange.fromCache) {\n            const targetData = localStoreImpl.targetDataByTarget.get(targetId);\n            // Advance the last limbo free snapshot version\n            const lastLimboFreeSnapshotVersion = targetData.snapshotVersion;\n            const updatedTargetData = targetData.withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion);\n            localStoreImpl.targetDataByTarget =\n                localStoreImpl.targetDataByTarget.insert(targetId, updatedTargetData);\n            // TODO(b/272564316): Apply the optimization done on other platforms.\n            // This is a problem for web because saving the updated targetData from\n            // non-primary client conflicts with what primary client saved.\n        }\n    }\n}\n/**\n * Gets the mutation batch after the passed in batchId in the mutation queue\n * or null if empty.\n * @param afterBatchId - If provided, the batch to search after.\n * @returns The next mutation or null if there wasn't one.\n */\nfunction localStoreGetNextMutationBatch(localStore, afterBatchId) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Get next mutation batch', 'readonly', txn => {\n        if (afterBatchId === undefined) {\n            afterBatchId = BATCHID_UNKNOWN;\n        }\n        return localStoreImpl.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);\n    });\n}\n/**\n * Reads the current value of a Document with a given key or null if not\n * found - used for testing.\n */\nfunction localStoreReadDocument(localStore, key) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('read document', 'readonly', txn => localStoreImpl.localDocuments.getDocument(txn, key));\n}\n/**\n * Assigns the given target an internal ID so that its results can be pinned so\n * they don't get GC'd. A target must be allocated in the local store before\n * the store can be used to manage its view.\n *\n * Allocating an already allocated `Target` will return the existing `TargetData`\n * for that `Target`.\n */\nfunction localStoreAllocateTarget(localStore, target) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence\n        .runTransaction('Allocate target', 'readwrite', txn => {\n        let targetData;\n        return localStoreImpl.targetCache\n            .getTargetData(txn, target)\n            .next((cached) => {\n            if (cached) {\n                // This target has been listened to previously, so reuse the\n                // previous targetID.\n                // TODO(mcg): freshen last accessed date?\n                targetData = cached;\n                return PersistencePromise.resolve(targetData);\n            }\n            else {\n                return localStoreImpl.targetCache\n                    .allocateTargetId(txn)\n                    .next(targetId => {\n                    targetData = new TargetData(target, targetId, \"TargetPurposeListen\" /* TargetPurpose.Listen */, txn.currentSequenceNumber);\n                    return localStoreImpl.targetCache\n                        .addTargetData(txn, targetData)\n                        .next(() => targetData);\n                });\n            }\n        });\n    })\n        .then(targetData => {\n        // If Multi-Tab is enabled, the existing target data may be newer than\n        // the in-memory data\n        const cachedTargetData = localStoreImpl.targetDataByTarget.get(targetData.targetId);\n        if (cachedTargetData === null ||\n            targetData.snapshotVersion.compareTo(cachedTargetData.snapshotVersion) >\n                0) {\n            localStoreImpl.targetDataByTarget =\n                localStoreImpl.targetDataByTarget.insert(targetData.targetId, targetData);\n            localStoreImpl.targetIdByTarget.set(target, targetData.targetId);\n        }\n        return targetData;\n    });\n}\n/**\n * Returns the TargetData as seen by the LocalStore, including updates that may\n * have not yet been persisted to the TargetCache.\n */\n// Visible for testing.\nfunction localStoreGetTargetData(localStore, transaction, target) {\n    const localStoreImpl = debugCast(localStore);\n    const targetId = localStoreImpl.targetIdByTarget.get(target);\n    if (targetId !== undefined) {\n        return PersistencePromise.resolve(localStoreImpl.targetDataByTarget.get(targetId));\n    }\n    else {\n        return localStoreImpl.targetCache.getTargetData(transaction, target);\n    }\n}\n/**\n * Unpins all the documents associated with the given target. If\n * `keepPersistedTargetData` is set to false and Eager GC enabled, the method\n * directly removes the associated target data from the target cache.\n *\n * Releasing a non-existing `Target` is a no-op.\n */\n// PORTING NOTE: `keepPersistedTargetData` is multi-tab only.\nasync function localStoreReleaseTarget(localStore, targetId, keepPersistedTargetData) {\n    const localStoreImpl = debugCast(localStore);\n    const targetData = localStoreImpl.targetDataByTarget.get(targetId);\n    const mode = keepPersistedTargetData ? 'readwrite' : 'readwrite-primary';\n    try {\n        if (!keepPersistedTargetData) {\n            await localStoreImpl.persistence.runTransaction('Release target', mode, txn => {\n                return localStoreImpl.persistence.referenceDelegate.removeTarget(txn, targetData);\n            });\n        }\n    }\n    catch (e) {\n        if (isIndexedDbTransactionError(e)) {\n            // All `releaseTarget` does is record the final metadata state for the\n            // target, but we've been recording this periodically during target\n            // activity. If we lose this write this could cause a very slight\n            // difference in the order of target deletion during GC, but we\n            // don't define exact LRU semantics so this is acceptable.\n            logDebug(LOG_TAG$b, `Failed to update sequence numbers for target ${targetId}: ${e}`);\n        }\n        else {\n            throw e;\n        }\n    }\n    localStoreImpl.targetDataByTarget =\n        localStoreImpl.targetDataByTarget.remove(targetId);\n    localStoreImpl.targetIdByTarget.delete(targetData.target);\n}\n/**\n * Runs the specified query against the local store and returns the results,\n * potentially taking advantage of query data from previous executions (such\n * as the set of remote keys).\n *\n * @param usePreviousResults - Whether results from previous executions can\n * be used to optimize this query execution.\n */\nfunction localStoreExecuteQuery(localStore, query, usePreviousResults) {\n    const localStoreImpl = debugCast(localStore);\n    let lastLimboFreeSnapshotVersion = SnapshotVersion.min();\n    let remoteKeys = documentKeySet();\n    return localStoreImpl.persistence.runTransaction('Execute query', 'readwrite', // Use readwrite instead of readonly so indexes can be created\n    // Use readwrite instead of readonly so indexes can be created\n    txn => {\n        return localStoreGetTargetData(localStoreImpl, txn, queryToTarget(query))\n            .next(targetData => {\n            if (targetData) {\n                lastLimboFreeSnapshotVersion =\n                    targetData.lastLimboFreeSnapshotVersion;\n                return localStoreImpl.targetCache\n                    .getMatchingKeysForTargetId(txn, targetData.targetId)\n                    .next(result => {\n                    remoteKeys = result;\n                });\n            }\n        })\n            .next(() => localStoreImpl.queryEngine.getDocumentsMatchingQuery(txn, query, usePreviousResults\n            ? lastLimboFreeSnapshotVersion\n            : SnapshotVersion.min(), usePreviousResults ? remoteKeys : documentKeySet()))\n            .next(documents => {\n            setMaxReadTime(localStoreImpl, queryCollectionGroup(query), documents);\n            return { documents, remoteKeys };\n        });\n    });\n}\nfunction applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer) {\n    const batch = batchResult.batch;\n    const docKeys = batch.keys();\n    let promiseChain = PersistencePromise.resolve();\n    docKeys.forEach(docKey => {\n        promiseChain = promiseChain\n            .next(() => documentBuffer.getEntry(txn, docKey))\n            .next(doc => {\n            const ackVersion = batchResult.docVersions.get(docKey);\n            hardAssert(ackVersion !== null, 0xbd9d);\n            if (doc.version.compareTo(ackVersion) < 0) {\n                batch.applyToRemoteDocument(doc, batchResult);\n                if (doc.isValidDocument()) {\n                    // We use the commitVersion as the readTime rather than the\n                    // document's updateTime since the updateTime is not advanced\n                    // for updates that do not modify the underlying document.\n                    doc.setReadTime(batchResult.commitVersion);\n                    documentBuffer.addEntry(doc);\n                }\n            }\n        });\n    });\n    return promiseChain.next(() => localStoreImpl.mutationQueue.removeMutationBatch(txn, batch));\n}\n/** Returns the local view of the documents affected by a mutation batch. */\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreLookupMutationDocuments(localStore, batchId) {\n    const localStoreImpl = debugCast(localStore);\n    const mutationQueueImpl = debugCast(localStoreImpl.mutationQueue);\n    return localStoreImpl.persistence.runTransaction('Lookup mutation documents', 'readonly', txn => {\n        return mutationQueueImpl.lookupMutationKeys(txn, batchId).next(keys => {\n            if (keys) {\n                return localStoreImpl.localDocuments.getDocuments(txn, keys);\n            }\n            else {\n                return PersistencePromise.resolve(null);\n            }\n        });\n    });\n}\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreRemoveCachedMutationBatchMetadata(localStore, batchId) {\n    const mutationQueueImpl = debugCast(debugCast(localStore, LocalStoreImpl).mutationQueue);\n    mutationQueueImpl.removeCachedMutationKeys(batchId);\n}\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreGetActiveClients(localStore) {\n    const persistenceImpl = debugCast(debugCast(localStore, LocalStoreImpl).persistence);\n    return persistenceImpl.getActiveClients();\n}\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreGetCachedTarget(localStore, targetId) {\n    const localStoreImpl = debugCast(localStore);\n    const targetCacheImpl = debugCast(localStoreImpl.targetCache);\n    const cachedTargetData = localStoreImpl.targetDataByTarget.get(targetId);\n    if (cachedTargetData) {\n        return Promise.resolve(cachedTargetData.target);\n    }\n    else {\n        return localStoreImpl.persistence.runTransaction('Get target data', 'readonly', txn => {\n            return targetCacheImpl\n                .getTargetDataForTarget(txn, targetId)\n                .next(targetData => (targetData ? targetData.target : null));\n        });\n    }\n}\n/**\n * Returns the set of documents that have been updated since the last call.\n * If this is the first call, returns the set of changes since client\n * initialization. Further invocations will return document that have changed\n * since the prior call.\n */\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreGetNewDocumentChanges(localStore, collectionGroup) {\n    const localStoreImpl = debugCast(localStore);\n    // Get the current maximum read time for the collection. This should always\n    // exist, but to reduce the chance for regressions we default to\n    // SnapshotVersion.Min()\n    // TODO(indexing): Consider removing the default value.\n    const readTime = localStoreImpl.collectionGroupReadTime.get(collectionGroup) ||\n        SnapshotVersion.min();\n    return localStoreImpl.persistence\n        .runTransaction('Get new document changes', 'readonly', txn => localStoreImpl.remoteDocuments.getAllFromCollectionGroup(txn, collectionGroup, newIndexOffsetSuccessorFromReadTime(readTime, INITIAL_LARGEST_BATCH_ID), \n    /* limit= */ Number.MAX_SAFE_INTEGER))\n        .then(changedDocs => {\n        setMaxReadTime(localStoreImpl, collectionGroup, changedDocs);\n        return changedDocs;\n    });\n}\n/** Sets the collection group's maximum read time from the given documents. */\n// PORTING NOTE: Multi-Tab only.\nfunction setMaxReadTime(localStoreImpl, collectionGroup, changedDocs) {\n    let readTime = localStoreImpl.collectionGroupReadTime.get(collectionGroup) ||\n        SnapshotVersion.min();\n    changedDocs.forEach((_, doc) => {\n        if (doc.readTime.compareTo(readTime) > 0) {\n            readTime = doc.readTime;\n        }\n    });\n    localStoreImpl.collectionGroupReadTime.set(collectionGroup, readTime);\n}\n/**\n * Creates a new target using the given bundle name, which will be used to\n * hold the keys of all documents from the bundle in query-document mappings.\n * This ensures that the loaded documents do not get garbage collected\n * right away.\n */\nfunction umbrellaTarget(bundleName) {\n    // It is OK that the path used for the query is not valid, because this will\n    // not be read and queried.\n    return queryToTarget(newQueryForPath(ResourcePath.fromString(`__bundle__/docs/${bundleName}`)));\n}\n/**\n * Applies the documents from a bundle to the \"ground-state\" (remote)\n * documents.\n *\n * LocalDocuments are re-calculated if there are remaining mutations in the\n * queue.\n */\nasync function localStoreApplyBundledDocuments(localStore, bundleConverter, documents, bundleName) {\n    const localStoreImpl = debugCast(localStore);\n    let documentKeys = documentKeySet();\n    let documentMap = mutableDocumentMap();\n    for (const bundleDoc of documents) {\n        const documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);\n        if (bundleDoc.document) {\n            documentKeys = documentKeys.add(documentKey);\n        }\n        const doc = bundleConverter.toMutableDocument(bundleDoc);\n        doc.setReadTime(bundleConverter.toSnapshotVersion(bundleDoc.metadata.readTime));\n        documentMap = documentMap.insert(documentKey, doc);\n    }\n    const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\n        trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\n    });\n    // Allocates a target to hold all document keys from the bundle, such that\n    // they will not get garbage collected right away.\n    const umbrellaTargetData = await localStoreAllocateTarget(localStoreImpl, umbrellaTarget(bundleName));\n    return localStoreImpl.persistence.runTransaction('Apply bundle documents', 'readwrite', txn => {\n        return populateDocumentChangeBuffer(txn, documentBuffer, documentMap)\n            .next(documentChangeResult => {\n            documentBuffer.apply(txn);\n            return documentChangeResult;\n        })\n            .next(documentChangeResult => {\n            return localStoreImpl.targetCache\n                .removeMatchingKeysForTargetId(txn, umbrellaTargetData.targetId)\n                .next(() => localStoreImpl.targetCache.addMatchingKeys(txn, documentKeys, umbrellaTargetData.targetId))\n                .next(() => localStoreImpl.localDocuments.getLocalViewOfDocuments(txn, documentChangeResult.changedDocuments, documentChangeResult.existenceChangedKeys))\n                .next(() => documentChangeResult.changedDocuments);\n        });\n    });\n}\n/**\n * Returns a promise of a boolean to indicate if the given bundle has already\n * been loaded and the create time is newer than the current loading bundle.\n */\nfunction localStoreHasNewerBundle(localStore, bundleMetadata) {\n    const localStoreImpl = debugCast(localStore);\n    const currentReadTime = fromVersion(bundleMetadata.createTime);\n    return localStoreImpl.persistence\n        .runTransaction('hasNewerBundle', 'readonly', transaction => {\n        return localStoreImpl.bundleCache.getBundleMetadata(transaction, bundleMetadata.id);\n    })\n        .then(cached => {\n        return !!cached && cached.createTime.compareTo(currentReadTime) >= 0;\n    });\n}\n/**\n * Saves the given `BundleMetadata` to local persistence.\n */\nfunction localStoreSaveBundle(localStore, bundleMetadata) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Save bundle', 'readwrite', transaction => {\n        return localStoreImpl.bundleCache.saveBundleMetadata(transaction, bundleMetadata);\n    });\n}\n/**\n * Returns a promise of a `NamedQuery` associated with given query name. Promise\n * resolves to undefined if no persisted data can be found.\n */\nfunction localStoreGetNamedQuery(localStore, queryName) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Get named query', 'readonly', transaction => localStoreImpl.bundleCache.getNamedQuery(transaction, queryName));\n}\n/**\n * Saves the given `NamedQuery` to local persistence.\n */\nasync function localStoreSaveNamedQuery(localStore, query, documents = documentKeySet()) {\n    // Allocate a target for the named query such that it can be resumed\n    // from associated read time if users use it to listen.\n    // NOTE: this also means if no corresponding target exists, the new target\n    // will remain active and will not get collected, unless users happen to\n    // unlisten the query somehow.\n    const allocated = await localStoreAllocateTarget(localStore, queryToTarget(fromBundledQuery(query.bundledQuery)));\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Save named query', 'readwrite', transaction => {\n        const readTime = fromVersion(query.readTime);\n        // Simply save the query itself if it is older than what the SDK already\n        // has.\n        if (allocated.snapshotVersion.compareTo(readTime) >= 0) {\n            return localStoreImpl.bundleCache.saveNamedQuery(transaction, query);\n        }\n        // Update existing target data because the query from the bundle is newer.\n        const newTargetData = allocated.withResumeToken(ByteString.EMPTY_BYTE_STRING, readTime);\n        localStoreImpl.targetDataByTarget =\n            localStoreImpl.targetDataByTarget.insert(newTargetData.targetId, newTargetData);\n        return localStoreImpl.targetCache\n            .updateTargetData(transaction, newTargetData)\n            .next(() => localStoreImpl.targetCache.removeMatchingKeysForTargetId(transaction, allocated.targetId))\n            .next(() => localStoreImpl.targetCache.addMatchingKeys(transaction, documents, allocated.targetId))\n            .next(() => localStoreImpl.bundleCache.saveNamedQuery(transaction, query));\n    });\n}\nasync function localStoreConfigureFieldIndexes(localStore, newFieldIndexes) {\n    const localStoreImpl = debugCast(localStore);\n    const indexManager = localStoreImpl.indexManager;\n    const promises = [];\n    return localStoreImpl.persistence.runTransaction('Configure indexes', 'readwrite', transaction => indexManager\n        .getFieldIndexes(transaction)\n        .next(oldFieldIndexes => diffArrays(oldFieldIndexes, newFieldIndexes, fieldIndexSemanticComparator, fieldIndex => {\n        promises.push(indexManager.addFieldIndex(transaction, fieldIndex));\n    }, fieldIndex => {\n        promises.push(indexManager.deleteFieldIndex(transaction, fieldIndex));\n    }))\n        .next(() => PersistencePromise.waitFor(promises)));\n}\nfunction localStoreSetIndexAutoCreationEnabled(localStore, isEnabled) {\n    const localStoreImpl = debugCast(localStore);\n    localStoreImpl.queryEngine.indexAutoCreationEnabled = isEnabled;\n}\nfunction localStoreDeleteAllFieldIndexes(localStore) {\n    const localStoreImpl = debugCast(localStore);\n    const indexManager = localStoreImpl.indexManager;\n    return localStoreImpl.persistence.runTransaction('Delete All Indexes', 'readwrite', transaction => indexManager.deleteAllFieldIndexes(transaction));\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A tracker to keep a record of important details during database local query\n * execution.\n */\nclass QueryContext {\n    constructor() {\n        /**\n         * Counts the number of documents passed through during local query execution.\n         */\n        this._documentReadCount = 0;\n    }\n    get documentReadCount() {\n        return this._documentReadCount;\n    }\n    incrementDocumentReadCount(amount) {\n        this._documentReadCount += amount;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_INDEX_AUTO_CREATION_MIN_COLLECTION_SIZE = 100;\n/**\n * This cost represents the evaluation result of\n * (([index, docKey] + [docKey, docContent]) per document in the result set)\n * / ([docKey, docContent] per documents in full collection scan) coming from\n * experiment [enter PR experiment URL here].\n */\nfunction getDefaultRelativeIndexReadCostPerDocument() {\n    // These values were derived from an experiment where several members of the\n    // Firestore SDK team ran a performance test in various environments.\n    // Googlers can see b/299284287 for details.\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isSafari)()) {\n        return 8;\n    }\n    else if (getAndroidVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) > 0) {\n        return 6;\n    }\n    else {\n        return 4;\n    }\n}\n/**\n * The Firestore query engine.\n *\n * Firestore queries can be executed in three modes. The Query Engine determines\n * what mode to use based on what data is persisted. The mode only determines\n * the runtime complexity of the query - the result set is equivalent across all\n * implementations.\n *\n * The Query engine will use indexed-based execution if a user has configured\n * any index that can be used to execute query (via `setIndexConfiguration()`).\n * Otherwise, the engine will try to optimize the query by re-using a previously\n * persisted query result. If that is not possible, the query will be executed\n * via a full collection scan.\n *\n * Index-based execution is the default when available. The query engine\n * supports partial indexed execution and merges the result from the index\n * lookup with documents that have not yet been indexed. The index evaluation\n * matches the backend's format and as such, the SDK can use indexing for all\n * queries that the backend supports.\n *\n * If no index exists, the query engine tries to take advantage of the target\n * document mapping in the TargetCache. These mappings exists for all queries\n * that have been synced with the backend at least once and allow the query\n * engine to only read documents that previously matched a query plus any\n * documents that were edited after the query was last listened to.\n *\n * There are some cases when this optimization is not guaranteed to produce\n * the same results as full collection scans. In these cases, query\n * processing falls back to full scans. These cases are:\n *\n * - Limit queries where a document that matched the query previously no longer\n *   matches the query.\n *\n * - Limit queries where a document edit may cause the document to sort below\n *   another document that is in the local cache.\n *\n * - Queries that have never been CURRENT or free of limbo documents.\n */\nclass QueryEngine {\n    constructor() {\n        this.initialized = false;\n        this.indexAutoCreationEnabled = false;\n        /**\n         * SDK only decides whether it should create index when collection size is\n         * larger than this.\n         */\n        this.indexAutoCreationMinCollectionSize = DEFAULT_INDEX_AUTO_CREATION_MIN_COLLECTION_SIZE;\n        this.relativeIndexReadCostPerDocument = getDefaultRelativeIndexReadCostPerDocument();\n    }\n    /** Sets the document view to query against. */\n    initialize(localDocuments, indexManager) {\n        this.localDocumentsView = localDocuments;\n        this.indexManager = indexManager;\n        this.initialized = true;\n    }\n    /** Returns all local documents matching the specified query. */\n    getDocumentsMatchingQuery(transaction, query, lastLimboFreeSnapshotVersion, remoteKeys) {\n        // Stores the result from executing the query; using this object is more\n        // convenient than passing the result between steps of the persistence\n        // transaction and improves readability comparatively.\n        const queryResult = { result: null };\n        return this.performQueryUsingIndex(transaction, query)\n            .next(result => {\n            queryResult.result = result;\n        })\n            .next(() => {\n            if (queryResult.result) {\n                return;\n            }\n            return this.performQueryUsingRemoteKeys(transaction, query, remoteKeys, lastLimboFreeSnapshotVersion).next(result => {\n                queryResult.result = result;\n            });\n        })\n            .next(() => {\n            if (queryResult.result) {\n                return;\n            }\n            const context = new QueryContext();\n            return this.executeFullCollectionScan(transaction, query, context).next(result => {\n                queryResult.result = result;\n                if (this.indexAutoCreationEnabled) {\n                    return this.createCacheIndexes(transaction, query, context, result.size);\n                }\n            });\n        })\n            .next(() => queryResult.result);\n    }\n    createCacheIndexes(transaction, query, context, resultSize) {\n        if (context.documentReadCount < this.indexAutoCreationMinCollectionSize) {\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.DEBUG) {\n                logDebug('QueryEngine', 'SDK will not create cache indexes for query:', stringifyQuery(query), 'since it only creates cache indexes for collection contains', 'more than or equal to', this.indexAutoCreationMinCollectionSize, 'documents');\n            }\n            return PersistencePromise.resolve();\n        }\n        if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.DEBUG) {\n            logDebug('QueryEngine', 'Query:', stringifyQuery(query), 'scans', context.documentReadCount, 'local documents and returns', resultSize, 'documents as results.');\n        }\n        if (context.documentReadCount >\n            this.relativeIndexReadCostPerDocument * resultSize) {\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.DEBUG) {\n                logDebug('QueryEngine', 'The SDK decides to create cache indexes for query:', stringifyQuery(query), 'as using cache indexes may help improve performance.');\n            }\n            return this.indexManager.createTargetIndexes(transaction, queryToTarget(query));\n        }\n        return PersistencePromise.resolve();\n    }\n    /**\n     * Performs an indexed query that evaluates the query based on a collection's\n     * persisted index values. Returns `null` if an index is not available.\n     */\n    performQueryUsingIndex(transaction, query) {\n        if (queryMatchesAllDocuments(query)) {\n            // Queries that match all documents don't benefit from using\n            // key-based lookups. It is more efficient to scan all documents in a\n            // collection, rather than to perform individual lookups.\n            return PersistencePromise.resolve(null);\n        }\n        let target = queryToTarget(query);\n        return this.indexManager\n            .getIndexType(transaction, target)\n            .next(indexType => {\n            if (indexType === 0 /* IndexType.NONE */) {\n                // The target cannot be served from any index.\n                return null;\n            }\n            if (query.limit !== null && indexType === 1 /* IndexType.PARTIAL */) {\n                // We cannot apply a limit for targets that are served using a partial\n                // index. If a partial index will be used to serve the target, the\n                // query may return a superset of documents that match the target\n                // (e.g. if the index doesn't include all the target's filters), or\n                // may return the correct set of documents in the wrong order (e.g. if\n                // the index doesn't include a segment for one of the orderBys).\n                // Therefore, a limit should not be applied in such cases.\n                query = queryWithLimit(query, null, \"F\" /* LimitType.First */);\n                target = queryToTarget(query);\n            }\n            return this.indexManager\n                .getDocumentsMatchingTarget(transaction, target)\n                .next(keys => {\n                const sortedKeys = documentKeySet(...keys);\n                return this.localDocumentsView\n                    .getDocuments(transaction, sortedKeys)\n                    .next(indexedDocuments => {\n                    return this.indexManager\n                        .getMinOffset(transaction, target)\n                        .next(offset => {\n                        const previousResults = this.applyQuery(query, indexedDocuments);\n                        if (this.needsRefill(query, previousResults, sortedKeys, offset.readTime)) {\n                            // A limit query whose boundaries change due to local\n                            // edits can be re-run against the cache by excluding the\n                            // limit. This ensures that all documents that match the\n                            // query's filters are included in the result set. The SDK\n                            // can then apply the limit once all local edits are\n                            // incorporated.\n                            return this.performQueryUsingIndex(transaction, queryWithLimit(query, null, \"F\" /* LimitType.First */));\n                        }\n                        return this.appendRemainingResults(transaction, previousResults, query, offset);\n                    });\n                });\n            });\n        });\n    }\n    /**\n     * Performs a query based on the target's persisted query mapping. Returns\n     * `null` if the mapping is not available or cannot be used.\n     */\n    performQueryUsingRemoteKeys(transaction, query, remoteKeys, lastLimboFreeSnapshotVersion) {\n        if (queryMatchesAllDocuments(query)) {\n            // Queries that match all documents don't benefit from using\n            // key-based lookups. It is more efficient to scan all documents in a\n            // collection, rather than to perform individual lookups.\n            return PersistencePromise.resolve(null);\n        }\n        // Queries that have never seen a snapshot without limbo free documents\n        // should also be run as a full collection scan.\n        if (lastLimboFreeSnapshotVersion.isEqual(SnapshotVersion.min())) {\n            return PersistencePromise.resolve(null);\n        }\n        return this.localDocumentsView.getDocuments(transaction, remoteKeys).next(documents => {\n            const previousResults = this.applyQuery(query, documents);\n            if (this.needsRefill(query, previousResults, remoteKeys, lastLimboFreeSnapshotVersion)) {\n                return PersistencePromise.resolve(null);\n            }\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.DEBUG) {\n                logDebug('QueryEngine', 'Re-using previous result from %s to execute query: %s', lastLimboFreeSnapshotVersion.toString(), stringifyQuery(query));\n            }\n            // Retrieve all results for documents that were updated since the last\n            // limbo-document free remote snapshot.\n            return this.appendRemainingResults(transaction, previousResults, query, newIndexOffsetSuccessorFromReadTime(lastLimboFreeSnapshotVersion, INITIAL_LARGEST_BATCH_ID)).next(results => results);\n        });\n    }\n    /** Applies the query filter and sorting to the provided documents.  */\n    applyQuery(query, documents) {\n        // Sort the documents and re-apply the query filter since previously\n        // matching documents do not necessarily still match the query.\n        let queryResults = new SortedSet(newQueryComparator(query));\n        documents.forEach((_, maybeDoc) => {\n            if (queryMatches(query, maybeDoc)) {\n                queryResults = queryResults.add(maybeDoc);\n            }\n        });\n        return queryResults;\n    }\n    /**\n     * Determines if a limit query needs to be refilled from cache, making it\n     * ineligible for index-free execution.\n     *\n     * @param query - The query.\n     * @param sortedPreviousResults - The documents that matched the query when it\n     * was last synchronized, sorted by the query's comparator.\n     * @param remoteKeys - The document keys that matched the query at the last\n     * snapshot.\n     * @param limboFreeSnapshotVersion - The version of the snapshot when the\n     * query was last synchronized.\n     */\n    needsRefill(query, sortedPreviousResults, remoteKeys, limboFreeSnapshotVersion) {\n        if (query.limit === null) {\n            // Queries without limits do not need to be refilled.\n            return false;\n        }\n        if (remoteKeys.size !== sortedPreviousResults.size) {\n            // The query needs to be refilled if a previously matching document no\n            // longer matches.\n            return true;\n        }\n        // Limit queries are not eligible for index-free query execution if there is\n        // a potential that an older document from cache now sorts before a document\n        // that was previously part of the limit. This, however, can only happen if\n        // the document at the edge of the limit goes out of limit.\n        // If a document that is not the limit boundary sorts differently,\n        // the boundary of the limit itself did not change and documents from cache\n        // will continue to be \"rejected\" by this boundary. Therefore, we can ignore\n        // any modifications that don't affect the last document.\n        const docAtLimitEdge = query.limitType === \"F\" /* LimitType.First */\n            ? sortedPreviousResults.last()\n            : sortedPreviousResults.first();\n        if (!docAtLimitEdge) {\n            // We don't need to refill the query if there were already no documents.\n            return false;\n        }\n        return (docAtLimitEdge.hasPendingWrites ||\n            docAtLimitEdge.version.compareTo(limboFreeSnapshotVersion) > 0);\n    }\n    executeFullCollectionScan(transaction, query, context) {\n        if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.DEBUG) {\n            logDebug('QueryEngine', 'Using full collection scan to execute query:', stringifyQuery(query));\n        }\n        return this.localDocumentsView.getDocumentsMatchingQuery(transaction, query, IndexOffset.min(), context);\n    }\n    /**\n     * Combines the results from an indexed execution with the remaining documents\n     * that have not yet been indexed.\n     */\n    appendRemainingResults(transaction, indexedResults, query, offset) {\n        // Retrieve all results for documents that were updated since the offset.\n        return this.localDocumentsView\n            .getDocumentsMatchingQuery(transaction, query, offset)\n            .next(remainingResults => {\n            // Merge with existing results\n            indexedResults.forEach(d => {\n                remainingResults = remainingResults.insert(d.key, d);\n            });\n            return remainingResults;\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// The format of the LocalStorage key that stores the client state is:\n//     firestore_clients_<persistence_prefix>_<instance_key>\nconst CLIENT_STATE_KEY_PREFIX = 'firestore_clients';\n/** Assembles the key for a client state in WebStorage */\nfunction createWebStorageClientStateKey(persistenceKey, clientId) {\n    return `${CLIENT_STATE_KEY_PREFIX}_${persistenceKey}_${clientId}`;\n}\n// The format of the WebStorage key that stores the mutation state is:\n//     firestore_mutations_<persistence_prefix>_<batch_id>\n//     (for unauthenticated users)\n// or: firestore_mutations_<persistence_prefix>_<batch_id>_<user_uid>\n//\n// 'user_uid' is last to avoid needing to escape '_' characters that it might\n// contain.\nconst MUTATION_BATCH_KEY_PREFIX = 'firestore_mutations';\n/** Assembles the key for a mutation batch in WebStorage */\nfunction createWebStorageMutationBatchKey(persistenceKey, user, batchId) {\n    let mutationKey = `${MUTATION_BATCH_KEY_PREFIX}_${persistenceKey}_${batchId}`;\n    if (user.isAuthenticated()) {\n        mutationKey += `_${user.uid}`;\n    }\n    return mutationKey;\n}\n// The format of the WebStorage key that stores a query target's metadata is:\n//     firestore_targets_<persistence_prefix>_<target_id>\nconst QUERY_TARGET_KEY_PREFIX = 'firestore_targets';\n/** Assembles the key for a query state in WebStorage */\nfunction createWebStorageQueryTargetMetadataKey(persistenceKey, targetId) {\n    return `${QUERY_TARGET_KEY_PREFIX}_${persistenceKey}_${targetId}`;\n}\n// The WebStorage prefix that stores the primary tab's online state. The\n// format of the key is:\n//     firestore_online_state_<persistence_prefix>\nconst ONLINE_STATE_KEY_PREFIX = 'firestore_online_state';\n/** Assembles the key for the online state of the primary tab. */\nfunction createWebStorageOnlineStateKey(persistenceKey) {\n    return `${ONLINE_STATE_KEY_PREFIX}_${persistenceKey}`;\n}\n// The WebStorage prefix that plays as a event to indicate the remote documents\n// might have changed due to some secondary tabs loading a bundle.\n// format of the key is:\n//     firestore_bundle_loaded_v2_<persistenceKey>\n// The version ending with \"v2\" stores the list of modified collection groups.\nconst BUNDLE_LOADED_KEY_PREFIX = 'firestore_bundle_loaded_v2';\nfunction createBundleLoadedKey(persistenceKey) {\n    return `${BUNDLE_LOADED_KEY_PREFIX}_${persistenceKey}`;\n}\n// The WebStorage key prefix for the key that stores the last sequence number allocated. The key\n// looks like 'firestore_sequence_number_<persistence_prefix>'.\nconst SEQUENCE_NUMBER_KEY_PREFIX = 'firestore_sequence_number';\n/** Assembles the key for the current sequence number. */\nfunction createWebStorageSequenceNumberKey(persistenceKey) {\n    return `${SEQUENCE_NUMBER_KEY_PREFIX}_${persistenceKey}`;\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$a = 'SharedClientState';\n/**\n * Holds the state of a mutation batch, including its user ID, batch ID and\n * whether the batch is 'pending', 'acknowledged' or 'rejected'.\n */\n// Visible for testing\nclass MutationMetadata {\n    constructor(user, batchId, state, error) {\n        this.user = user;\n        this.batchId = batchId;\n        this.state = state;\n        this.error = error;\n    }\n    /**\n     * Parses a MutationMetadata from its JSON representation in WebStorage.\n     * Logs a warning and returns null if the format of the data is not valid.\n     */\n    static fromWebStorageEntry(user, batchId, value) {\n        const mutationBatch = JSON.parse(value);\n        let validData = typeof mutationBatch === 'object' &&\n            ['pending', 'acknowledged', 'rejected'].indexOf(mutationBatch.state) !==\n                -1 &&\n            (mutationBatch.error === undefined ||\n                typeof mutationBatch.error === 'object');\n        let firestoreError = undefined;\n        if (validData && mutationBatch.error) {\n            validData =\n                typeof mutationBatch.error.message === 'string' &&\n                    typeof mutationBatch.error.code === 'string';\n            if (validData) {\n                firestoreError = new FirestoreError(mutationBatch.error.code, mutationBatch.error.message);\n            }\n        }\n        if (validData) {\n            return new MutationMetadata(user, batchId, mutationBatch.state, firestoreError);\n        }\n        else {\n            logError(LOG_TAG$a, `Failed to parse mutation state for ID '${batchId}': ${value}`);\n            return null;\n        }\n    }\n    toWebStorageJSON() {\n        const batchMetadata = {\n            state: this.state,\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\n        };\n        if (this.error) {\n            batchMetadata.error = {\n                code: this.error.code,\n                message: this.error.message\n            };\n        }\n        return JSON.stringify(batchMetadata);\n    }\n}\n/**\n * Holds the state of a query target, including its target ID and whether the\n * target is 'not-current', 'current' or 'rejected'.\n */\n// Visible for testing\nclass QueryTargetMetadata {\n    constructor(targetId, state, error) {\n        this.targetId = targetId;\n        this.state = state;\n        this.error = error;\n    }\n    /**\n     * Parses a QueryTargetMetadata from its JSON representation in WebStorage.\n     * Logs a warning and returns null if the format of the data is not valid.\n     */\n    static fromWebStorageEntry(targetId, value) {\n        const targetState = JSON.parse(value);\n        let validData = typeof targetState === 'object' &&\n            ['not-current', 'current', 'rejected'].indexOf(targetState.state) !==\n                -1 &&\n            (targetState.error === undefined ||\n                typeof targetState.error === 'object');\n        let firestoreError = undefined;\n        if (validData && targetState.error) {\n            validData =\n                typeof targetState.error.message === 'string' &&\n                    typeof targetState.error.code === 'string';\n            if (validData) {\n                firestoreError = new FirestoreError(targetState.error.code, targetState.error.message);\n            }\n        }\n        if (validData) {\n            return new QueryTargetMetadata(targetId, targetState.state, firestoreError);\n        }\n        else {\n            logError(LOG_TAG$a, `Failed to parse target state for ID '${targetId}': ${value}`);\n            return null;\n        }\n    }\n    toWebStorageJSON() {\n        const targetState = {\n            state: this.state,\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\n        };\n        if (this.error) {\n            targetState.error = {\n                code: this.error.code,\n                message: this.error.message\n            };\n        }\n        return JSON.stringify(targetState);\n    }\n}\n/**\n * This class represents the immutable ClientState for a client read from\n * WebStorage, containing the list of active query targets.\n */\nclass RemoteClientState {\n    constructor(clientId, activeTargetIds) {\n        this.clientId = clientId;\n        this.activeTargetIds = activeTargetIds;\n    }\n    /**\n     * Parses a RemoteClientState from the JSON representation in WebStorage.\n     * Logs a warning and returns null if the format of the data is not valid.\n     */\n    static fromWebStorageEntry(clientId, value) {\n        const clientState = JSON.parse(value);\n        let validData = typeof clientState === 'object' &&\n            clientState.activeTargetIds instanceof Array;\n        let activeTargetIdsSet = targetIdSet();\n        for (let i = 0; validData && i < clientState.activeTargetIds.length; ++i) {\n            validData = isSafeInteger(clientState.activeTargetIds[i]);\n            activeTargetIdsSet = activeTargetIdsSet.add(clientState.activeTargetIds[i]);\n        }\n        if (validData) {\n            return new RemoteClientState(clientId, activeTargetIdsSet);\n        }\n        else {\n            logError(LOG_TAG$a, `Failed to parse client data for instance '${clientId}': ${value}`);\n            return null;\n        }\n    }\n}\n/**\n * This class represents the online state for all clients participating in\n * multi-tab. The online state is only written to by the primary client, and\n * used in secondary clients to update their query views.\n */\nclass SharedOnlineState {\n    constructor(clientId, onlineState) {\n        this.clientId = clientId;\n        this.onlineState = onlineState;\n    }\n    /**\n     * Parses a SharedOnlineState from its JSON representation in WebStorage.\n     * Logs a warning and returns null if the format of the data is not valid.\n     */\n    static fromWebStorageEntry(value) {\n        const onlineState = JSON.parse(value);\n        const validData = typeof onlineState === 'object' &&\n            ['Unknown', 'Online', 'Offline'].indexOf(onlineState.onlineState) !==\n                -1 &&\n            typeof onlineState.clientId === 'string';\n        if (validData) {\n            return new SharedOnlineState(onlineState.clientId, onlineState.onlineState);\n        }\n        else {\n            logError(LOG_TAG$a, `Failed to parse online state: ${value}`);\n            return null;\n        }\n    }\n}\n/**\n * Metadata state of the local client. Unlike `RemoteClientState`, this class is\n * mutable and keeps track of all pending mutations, which allows us to\n * update the range of pending mutation batch IDs as new mutations are added or\n * removed.\n *\n * The data in `LocalClientState` is not read from WebStorage and instead\n * updated via its instance methods. The updated state can be serialized via\n * `toWebStorageJSON()`.\n */\n// Visible for testing.\nclass LocalClientState {\n    constructor() {\n        this.activeTargetIds = targetIdSet();\n    }\n    addQueryTarget(targetId) {\n        this.activeTargetIds = this.activeTargetIds.add(targetId);\n    }\n    removeQueryTarget(targetId) {\n        this.activeTargetIds = this.activeTargetIds.delete(targetId);\n    }\n    /**\n     * Converts this entry into a JSON-encoded format we can use for WebStorage.\n     * Does not encode `clientId` as it is part of the key in WebStorage.\n     */\n    toWebStorageJSON() {\n        const data = {\n            activeTargetIds: this.activeTargetIds.toArray(),\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\n        };\n        return JSON.stringify(data);\n    }\n}\n/**\n * `WebStorageSharedClientState` uses WebStorage (window.localStorage) as the\n * backing store for the SharedClientState. It keeps track of all active\n * clients and supports modifications of the local client's data.\n */\nclass WebStorageSharedClientState {\n    constructor(window, queue, persistenceKey, localClientId, initialUser) {\n        this.window = window;\n        this.queue = queue;\n        this.persistenceKey = persistenceKey;\n        this.localClientId = localClientId;\n        this.syncEngine = null;\n        this.onlineStateHandler = null;\n        this.sequenceNumberHandler = null;\n        this.storageListener = this.handleWebStorageEvent.bind(this);\n        this.activeClients = new SortedMap(primitiveComparator);\n        this.started = false;\n        /**\n         * Captures WebStorage events that occur before `start()` is called. These\n         * events are replayed once `WebStorageSharedClientState` is started.\n         */\n        this.earlyEvents = [];\n        // Escape the special characters mentioned here:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n        const escapedPersistenceKey = persistenceKey.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n        this.storage = this.window.localStorage;\n        this.currentUser = initialUser;\n        this.localClientStorageKey = createWebStorageClientStateKey(this.persistenceKey, this.localClientId);\n        this.sequenceNumberKey = createWebStorageSequenceNumberKey(this.persistenceKey);\n        this.activeClients = this.activeClients.insert(this.localClientId, new LocalClientState());\n        this.clientStateKeyRe = new RegExp(`^${CLIENT_STATE_KEY_PREFIX}_${escapedPersistenceKey}_([^_]*)$`);\n        this.mutationBatchKeyRe = new RegExp(`^${MUTATION_BATCH_KEY_PREFIX}_${escapedPersistenceKey}_(\\\\d+)(?:_(.*))?$`);\n        this.queryTargetKeyRe = new RegExp(`^${QUERY_TARGET_KEY_PREFIX}_${escapedPersistenceKey}_(\\\\d+)$`);\n        this.onlineStateKey = createWebStorageOnlineStateKey(this.persistenceKey);\n        this.bundleLoadedKey = createBundleLoadedKey(this.persistenceKey);\n        // Rather than adding the storage observer during start(), we add the\n        // storage observer during initialization. This ensures that we collect\n        // events before other components populate their initial state (during their\n        // respective start() calls). Otherwise, we might for example miss a\n        // mutation that is added after LocalStore's start() processed the existing\n        // mutations but before we observe WebStorage events.\n        this.window.addEventListener('storage', this.storageListener);\n    }\n    /** Returns 'true' if WebStorage is available in the current environment. */\n    static isAvailable(window) {\n        return !!(window && window.localStorage);\n    }\n    async start() {\n        // Retrieve the list of existing clients to backfill the data in\n        // SharedClientState.\n        const existingClients = await this.syncEngine.getActiveClients();\n        for (const clientId of existingClients) {\n            if (clientId === this.localClientId) {\n                continue;\n            }\n            const storageItem = this.getItem(createWebStorageClientStateKey(this.persistenceKey, clientId));\n            if (storageItem) {\n                const clientState = RemoteClientState.fromWebStorageEntry(clientId, storageItem);\n                if (clientState) {\n                    this.activeClients = this.activeClients.insert(clientState.clientId, clientState);\n                }\n            }\n        }\n        this.persistClientState();\n        // Check if there is an existing online state and call the callback handler\n        // if applicable.\n        const onlineStateJSON = this.storage.getItem(this.onlineStateKey);\n        if (onlineStateJSON) {\n            const onlineState = this.fromWebStorageOnlineState(onlineStateJSON);\n            if (onlineState) {\n                this.handleOnlineStateEvent(onlineState);\n            }\n        }\n        for (const event of this.earlyEvents) {\n            this.handleWebStorageEvent(event);\n        }\n        this.earlyEvents = [];\n        // Register a window unload hook to remove the client metadata entry from\n        // WebStorage even if `shutdown()` was not called.\n        this.window.addEventListener('pagehide', () => this.shutdown());\n        this.started = true;\n    }\n    writeSequenceNumber(sequenceNumber) {\n        this.setItem(this.sequenceNumberKey, JSON.stringify(sequenceNumber));\n    }\n    getAllActiveQueryTargets() {\n        return this.extractActiveQueryTargets(this.activeClients);\n    }\n    isActiveQueryTarget(targetId) {\n        let found = false;\n        this.activeClients.forEach((key, value) => {\n            if (value.activeTargetIds.has(targetId)) {\n                found = true;\n            }\n        });\n        return found;\n    }\n    addPendingMutation(batchId) {\n        this.persistMutationState(batchId, 'pending');\n    }\n    updateMutationState(batchId, state, error) {\n        this.persistMutationState(batchId, state, error);\n        // Once a final mutation result is observed by other clients, they no longer\n        // access the mutation's metadata entry. Since WebStorage replays events\n        // in order, it is safe to delete the entry right after updating it.\n        this.removeMutationState(batchId);\n    }\n    addLocalQueryTarget(targetId, addToActiveTargetIds = true) {\n        let queryState = 'not-current';\n        // Lookup an existing query state if the target ID was already registered\n        // by another tab\n        if (this.isActiveQueryTarget(targetId)) {\n            const storageItem = this.storage.getItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));\n            if (storageItem) {\n                const metadata = QueryTargetMetadata.fromWebStorageEntry(targetId, storageItem);\n                if (metadata) {\n                    queryState = metadata.state;\n                }\n            }\n        }\n        // If the query is listening to cache only, the target ID should not be registered with the\n        // local Firestore client as an active watch target.\n        if (addToActiveTargetIds) {\n            this.localClientState.addQueryTarget(targetId);\n        }\n        this.persistClientState();\n        return queryState;\n    }\n    removeLocalQueryTarget(targetId) {\n        this.localClientState.removeQueryTarget(targetId);\n        this.persistClientState();\n    }\n    isLocalQueryTarget(targetId) {\n        return this.localClientState.activeTargetIds.has(targetId);\n    }\n    clearQueryState(targetId) {\n        this.removeItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));\n    }\n    updateQueryState(targetId, state, error) {\n        this.persistQueryTargetState(targetId, state, error);\n    }\n    handleUserChange(user, removedBatchIds, addedBatchIds) {\n        removedBatchIds.forEach(batchId => {\n            this.removeMutationState(batchId);\n        });\n        this.currentUser = user;\n        addedBatchIds.forEach(batchId => {\n            this.addPendingMutation(batchId);\n        });\n    }\n    setOnlineState(onlineState) {\n        this.persistOnlineState(onlineState);\n    }\n    notifyBundleLoaded(collectionGroups) {\n        this.persistBundleLoadedState(collectionGroups);\n    }\n    shutdown() {\n        if (this.started) {\n            this.window.removeEventListener('storage', this.storageListener);\n            this.removeItem(this.localClientStorageKey);\n            this.started = false;\n        }\n    }\n    getItem(key) {\n        const value = this.storage.getItem(key);\n        logDebug(LOG_TAG$a, 'READ', key, value);\n        return value;\n    }\n    setItem(key, value) {\n        logDebug(LOG_TAG$a, 'SET', key, value);\n        this.storage.setItem(key, value);\n    }\n    removeItem(key) {\n        logDebug(LOG_TAG$a, 'REMOVE', key);\n        this.storage.removeItem(key);\n    }\n    handleWebStorageEvent(event) {\n        // Note: The function is typed to take Event to be interface-compatible with\n        // `Window.addEventListener`.\n        const storageEvent = event;\n        if (storageEvent.storageArea === this.storage) {\n            logDebug(LOG_TAG$a, 'EVENT', storageEvent.key, storageEvent.newValue);\n            if (storageEvent.key === this.localClientStorageKey) {\n                logError('Received WebStorage notification for local change. Another client might have ' +\n                    'garbage-collected our state');\n                return;\n            }\n            this.queue.enqueueRetryable(async () => {\n                if (!this.started) {\n                    this.earlyEvents.push(storageEvent);\n                    return;\n                }\n                if (storageEvent.key === null) {\n                    return;\n                }\n                if (this.clientStateKeyRe.test(storageEvent.key)) {\n                    if (storageEvent.newValue != null) {\n                        const clientState = this.fromWebStorageClientState(storageEvent.key, storageEvent.newValue);\n                        if (clientState) {\n                            return this.handleClientStateEvent(clientState.clientId, clientState);\n                        }\n                    }\n                    else {\n                        const clientId = this.fromWebStorageClientStateKey(storageEvent.key);\n                        return this.handleClientStateEvent(clientId, null);\n                    }\n                }\n                else if (this.mutationBatchKeyRe.test(storageEvent.key)) {\n                    if (storageEvent.newValue !== null) {\n                        const mutationMetadata = this.fromWebStorageMutationMetadata(storageEvent.key, storageEvent.newValue);\n                        if (mutationMetadata) {\n                            return this.handleMutationBatchEvent(mutationMetadata);\n                        }\n                    }\n                }\n                else if (this.queryTargetKeyRe.test(storageEvent.key)) {\n                    if (storageEvent.newValue !== null) {\n                        const queryTargetMetadata = this.fromWebStorageQueryTargetMetadata(storageEvent.key, storageEvent.newValue);\n                        if (queryTargetMetadata) {\n                            return this.handleQueryTargetEvent(queryTargetMetadata);\n                        }\n                    }\n                }\n                else if (storageEvent.key === this.onlineStateKey) {\n                    if (storageEvent.newValue !== null) {\n                        const onlineState = this.fromWebStorageOnlineState(storageEvent.newValue);\n                        if (onlineState) {\n                            return this.handleOnlineStateEvent(onlineState);\n                        }\n                    }\n                }\n                else if (storageEvent.key === this.sequenceNumberKey) {\n                    const sequenceNumber = fromWebStorageSequenceNumber(storageEvent.newValue);\n                    if (sequenceNumber !== ListenSequence.INVALID) {\n                        this.sequenceNumberHandler(sequenceNumber);\n                    }\n                }\n                else if (storageEvent.key === this.bundleLoadedKey) {\n                    const collectionGroups = this.fromWebStoreBundleLoadedState(storageEvent.newValue);\n                    await Promise.all(collectionGroups.map(cg => this.syncEngine.synchronizeWithChangedDocuments(cg)));\n                }\n            });\n        }\n    }\n    get localClientState() {\n        return this.activeClients.get(this.localClientId);\n    }\n    persistClientState() {\n        this.setItem(this.localClientStorageKey, this.localClientState.toWebStorageJSON());\n    }\n    persistMutationState(batchId, state, error) {\n        const mutationState = new MutationMetadata(this.currentUser, batchId, state, error);\n        const mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);\n        this.setItem(mutationKey, mutationState.toWebStorageJSON());\n    }\n    removeMutationState(batchId) {\n        const mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);\n        this.removeItem(mutationKey);\n    }\n    persistOnlineState(onlineState) {\n        const entry = {\n            clientId: this.localClientId,\n            onlineState\n        };\n        this.storage.setItem(this.onlineStateKey, JSON.stringify(entry));\n    }\n    persistQueryTargetState(targetId, state, error) {\n        const targetKey = createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId);\n        const targetMetadata = new QueryTargetMetadata(targetId, state, error);\n        this.setItem(targetKey, targetMetadata.toWebStorageJSON());\n    }\n    persistBundleLoadedState(collectionGroups) {\n        const json = JSON.stringify(Array.from(collectionGroups));\n        this.setItem(this.bundleLoadedKey, json);\n    }\n    /**\n     * Parses a client state key in WebStorage. Returns null if the key does not\n     * match the expected key format.\n     */\n    fromWebStorageClientStateKey(key) {\n        const match = this.clientStateKeyRe.exec(key);\n        return match ? match[1] : null;\n    }\n    /**\n     * Parses a client state in WebStorage. Returns 'null' if the value could not\n     * be parsed.\n     */\n    fromWebStorageClientState(key, value) {\n        const clientId = this.fromWebStorageClientStateKey(key);\n        return RemoteClientState.fromWebStorageEntry(clientId, value);\n    }\n    /**\n     * Parses a mutation batch state in WebStorage. Returns 'null' if the value\n     * could not be parsed.\n     */\n    fromWebStorageMutationMetadata(key, value) {\n        const match = this.mutationBatchKeyRe.exec(key);\n        const batchId = Number(match[1]);\n        const userId = match[2] !== undefined ? match[2] : null;\n        return MutationMetadata.fromWebStorageEntry(new User(userId), batchId, value);\n    }\n    /**\n     * Parses a query target state from WebStorage. Returns 'null' if the value\n     * could not be parsed.\n     */\n    fromWebStorageQueryTargetMetadata(key, value) {\n        const match = this.queryTargetKeyRe.exec(key);\n        const targetId = Number(match[1]);\n        return QueryTargetMetadata.fromWebStorageEntry(targetId, value);\n    }\n    /**\n     * Parses an online state from WebStorage. Returns 'null' if the value\n     * could not be parsed.\n     */\n    fromWebStorageOnlineState(value) {\n        return SharedOnlineState.fromWebStorageEntry(value);\n    }\n    fromWebStoreBundleLoadedState(value) {\n        return JSON.parse(value);\n    }\n    async handleMutationBatchEvent(mutationBatch) {\n        if (mutationBatch.user.uid !== this.currentUser.uid) {\n            logDebug(LOG_TAG$a, `Ignoring mutation for non-active user ${mutationBatch.user.uid}`);\n            return;\n        }\n        return this.syncEngine.applyBatchState(mutationBatch.batchId, mutationBatch.state, mutationBatch.error);\n    }\n    handleQueryTargetEvent(targetMetadata) {\n        return this.syncEngine.applyTargetState(targetMetadata.targetId, targetMetadata.state, targetMetadata.error);\n    }\n    handleClientStateEvent(clientId, clientState) {\n        const updatedClients = clientState\n            ? this.activeClients.insert(clientId, clientState)\n            : this.activeClients.remove(clientId);\n        const existingTargets = this.extractActiveQueryTargets(this.activeClients);\n        const newTargets = this.extractActiveQueryTargets(updatedClients);\n        const addedTargets = [];\n        const removedTargets = [];\n        newTargets.forEach(targetId => {\n            if (!existingTargets.has(targetId)) {\n                addedTargets.push(targetId);\n            }\n        });\n        existingTargets.forEach(targetId => {\n            if (!newTargets.has(targetId)) {\n                removedTargets.push(targetId);\n            }\n        });\n        return this.syncEngine.applyActiveTargetsChange(addedTargets, removedTargets).then(() => {\n            this.activeClients = updatedClients;\n        });\n    }\n    handleOnlineStateEvent(onlineState) {\n        // We check whether the client that wrote this online state is still active\n        // by comparing its client ID to the list of clients kept active in\n        // IndexedDb. If a client does not update their IndexedDb client state\n        // within 5 seconds, it is considered inactive and we don't emit an online\n        // state event.\n        if (this.activeClients.get(onlineState.clientId)) {\n            this.onlineStateHandler(onlineState.onlineState);\n        }\n    }\n    extractActiveQueryTargets(clients) {\n        let activeTargets = targetIdSet();\n        clients.forEach((kev, value) => {\n            activeTargets = activeTargets.unionWith(value.activeTargetIds);\n        });\n        return activeTargets;\n    }\n}\nfunction fromWebStorageSequenceNumber(seqString) {\n    let sequenceNumber = ListenSequence.INVALID;\n    if (seqString != null) {\n        try {\n            const parsed = JSON.parse(seqString);\n            hardAssert(typeof parsed === 'number', 0x77ac, { seqString });\n            sequenceNumber = parsed;\n        }\n        catch (e) {\n            logError(LOG_TAG$a, 'Failed to read sequence number from WebStorage', e);\n        }\n    }\n    return sequenceNumber;\n}\n/**\n * `MemorySharedClientState` is a simple implementation of SharedClientState for\n * clients using memory persistence. The state in this class remains fully\n * isolated and no synchronization is performed.\n */\nclass MemorySharedClientState {\n    constructor() {\n        this.localState = new LocalClientState();\n        this.queryState = {};\n        this.onlineStateHandler = null;\n        this.sequenceNumberHandler = null;\n    }\n    addPendingMutation(batchId) {\n        // No op.\n    }\n    updateMutationState(batchId, state, error) {\n        // No op.\n    }\n    addLocalQueryTarget(targetId, addToActiveTargetIds = true) {\n        if (addToActiveTargetIds) {\n            this.localState.addQueryTarget(targetId);\n        }\n        return this.queryState[targetId] || 'not-current';\n    }\n    updateQueryState(targetId, state, error) {\n        this.queryState[targetId] = state;\n    }\n    removeLocalQueryTarget(targetId) {\n        this.localState.removeQueryTarget(targetId);\n    }\n    isLocalQueryTarget(targetId) {\n        return this.localState.activeTargetIds.has(targetId);\n    }\n    clearQueryState(targetId) {\n        delete this.queryState[targetId];\n    }\n    getAllActiveQueryTargets() {\n        return this.localState.activeTargetIds;\n    }\n    isActiveQueryTarget(targetId) {\n        return this.localState.activeTargetIds.has(targetId);\n    }\n    start() {\n        this.localState = new LocalClientState();\n        return Promise.resolve();\n    }\n    handleUserChange(user, removedBatchIds, addedBatchIds) {\n        // No op.\n    }\n    setOnlineState(onlineState) {\n        // No op.\n    }\n    shutdown() { }\n    writeSequenceNumber(sequenceNumber) { }\n    notifyBundleLoaded(collectionGroups) {\n        // No op.\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass NoopConnectivityMonitor {\n    addCallback(callback) {\n        // No-op.\n    }\n    shutdown() {\n        // No-op.\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides a simple helper class that implements the Stream interface to\n * bridge to other implementations that are streams but do not implement the\n * interface. The stream callbacks are invoked with the callOn... methods.\n */\nclass StreamBridge {\n    constructor(args) {\n        this.sendFn = args.sendFn;\n        this.closeFn = args.closeFn;\n    }\n    onConnected(callback) {\n        this.wrappedOnConnected = callback;\n    }\n    onOpen(callback) {\n        this.wrappedOnOpen = callback;\n    }\n    onClose(callback) {\n        this.wrappedOnClose = callback;\n    }\n    onMessage(callback) {\n        this.wrappedOnMessage = callback;\n    }\n    close() {\n        this.closeFn();\n    }\n    send(msg) {\n        this.sendFn(msg);\n    }\n    callOnConnected() {\n        this.wrappedOnConnected();\n    }\n    callOnOpen() {\n        this.wrappedOnOpen();\n    }\n    callOnClose(err) {\n        this.wrappedOnClose(err);\n    }\n    callOnMessage(msg) {\n        this.wrappedOnMessage(msg);\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The value returned from the most recent invocation of\n * `generateUniqueDebugId()`, or null if it has never been invoked.\n */\nlet lastUniqueDebugId = null;\n/**\n * Generates and returns an initial value for `lastUniqueDebugId`.\n *\n * The returned value is randomly selected from a range of integers that are\n * represented as 8 hexadecimal digits. This means that (within reason) any\n * numbers generated by incrementing the returned number by 1 will also be\n * represented by 8 hexadecimal digits. This leads to all \"IDs\" having the same\n * length when converted to a hexadecimal string, making reading logs containing\n * these IDs easier to follow. And since the return value is randomly selected\n * it will help to differentiate between logs from different executions.\n */\nfunction generateInitialUniqueDebugId() {\n    const minResult = 0x10000000;\n    const maxResult = 0x90000000;\n    const resultRange = maxResult - minResult;\n    const resultOffset = Math.round(resultRange * Math.random());\n    return minResult + resultOffset;\n}\n/**\n * Generates and returns a unique ID as a hexadecimal string.\n *\n * The returned ID is intended to be used in debug logging messages to help\n * correlate log messages that may be spatially separated in the logs, but\n * logically related. For example, a network connection could include the same\n * \"debug ID\" string in all of its log messages to help trace a specific\n * connection over time.\n *\n * @returns the 10-character generated ID (e.g. \"0xa1b2c3d4\").\n */\nfunction generateUniqueDebugId() {\n    if (lastUniqueDebugId === null) {\n        lastUniqueDebugId = generateInitialUniqueDebugId();\n    }\n    else {\n        lastUniqueDebugId++;\n    }\n    return '0x' + lastUniqueDebugId.toString(16);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Utilities for dealing with node.js-style APIs. See nodePromise for more\n * details.\n */\n/**\n * Creates a node-style callback that resolves or rejects a new Promise. The\n * callback is passed to the given action which can then use the callback as\n * a parameter to a node-style function.\n *\n * The intent is to directly bridge a node-style function (which takes a\n * callback) into a Promise without manually converting between the node-style\n * callback and the promise at each call.\n *\n * In effect it allows you to convert:\n *\n * @example\n * new Promise((resolve: (value?: fs.Stats) => void,\n *              reject: (error?: any) => void) => {\n *   fs.stat(path, (error?: any, stat?: fs.Stats) => {\n *     if (error) {\n *       reject(error);\n *     } else {\n *       resolve(stat);\n *     }\n *   });\n * });\n *\n * Into\n * @example\n * nodePromise((callback: NodeCallback<fs.Stats>) => {\n *   fs.stat(path, callback);\n * });\n *\n * @param action - a function that takes a node-style callback as an argument\n *     and then uses that callback to invoke some node-style API.\n * @returns a new Promise which will be rejected if the callback is given the\n *     first Error parameter or will resolve to the value given otherwise.\n */\nfunction nodePromise(action) {\n    return new Promise((resolve, reject) => {\n        action((error, value) => {\n            if (error) {\n                reject(error);\n            }\n            else {\n                resolve(value);\n            }\n        });\n    });\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// TODO: Fetch runtime version from grpc-js/package.json instead\n// when there's a cleaner way to dynamic require JSON in both Node ESM and CJS\nconst grpcVersion = '1.9.15';\nconst LOG_TAG$9 = 'GrpcConnection';\nconst X_GOOG_API_CLIENT_VALUE = `gl-node/${process.versions.node} fire/${SDK_VERSION} grpc/${grpcVersion}`;\nfunction createMetadata(databasePath, authToken, appCheckToken, appId, apiKey) {\n    hardAssert(authToken === null || authToken.type === 'OAuth', 0x9048);\n    const metadata = new _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_6__.Metadata();\n    if (authToken) {\n        authToken.headers.forEach((value, key) => metadata.set(key, value));\n    }\n    if (appCheckToken) {\n        appCheckToken.headers.forEach((value, key) => metadata.set(key, value));\n    }\n    if (appId) {\n        metadata.set('X-Firebase-GMPID', appId);\n    }\n    metadata.set('X-Goog-Api-Client', X_GOOG_API_CLIENT_VALUE);\n    // These headers are used to improve routing and project isolation by the\n    // backend.\n    // TODO(b/199767712): We are keeping 'Google-Cloud-Resource-Prefix' until Emulators can be\n    // released with cl/428820046. Currently blocked because Emulators are now built with Java\n    // 11 from Google3.\n    metadata.set('Google-Cloud-Resource-Prefix', databasePath);\n    metadata.set('x-goog-request-params', databasePath);\n    if (apiKey) {\n        metadata.set('X-Goog-Api-Key', apiKey);\n    }\n    return metadata;\n}\n/**\n * A Connection implemented by GRPC-Node.\n */\nclass GrpcConnection {\n    get shouldResourcePathBeIncludedInRequest() {\n        // Both `invokeRPC()` and `invokeStreamingRPC()` ignore their `path` arguments, and expect\n        // the \"path\" to be part of the given `request`.\n        return true;\n    }\n    constructor(protos, databaseInfo) {\n        this.databaseInfo = databaseInfo;\n        // We cache stubs for the most-recently-used token.\n        this.cachedStub = null;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.firestore = protos['google']['firestore']['v1'];\n        this.databasePath = `projects/${databaseInfo.databaseId.projectId}/databases/${databaseInfo.databaseId.database}`;\n    }\n    /** made protected for testing */\n    ensureActiveStub() {\n        if (!this.cachedStub) {\n            logDebug(LOG_TAG$9, 'Creating Firestore stub.');\n            const credentials = this.databaseInfo.ssl\n                ? _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_6__.credentials.createSsl()\n                : _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_6__.credentials.createInsecure();\n            this.cachedStub = new this.firestore.Firestore(this.databaseInfo.host, credentials);\n        }\n        return this.cachedStub;\n    }\n    invokeRPC(rpcName, path, request, authToken, appCheckToken) {\n        const streamId = generateUniqueDebugId();\n        const stub = this.ensureActiveStub();\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId, this.databaseInfo.apiKey);\n        const jsonRequest = { database: this.databasePath, ...request };\n        return nodePromise((callback) => {\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} invoked with request:`, request);\n            return stub[rpcName](jsonRequest, metadata, (grpcError, value) => {\n                if (grpcError) {\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} failed with error:`, grpcError);\n                    callback(new FirestoreError(mapCodeFromRpcCode(grpcError.code), grpcError.message));\n                }\n                else {\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} completed with response:`, value);\n                    callback(undefined, value);\n                }\n            });\n        });\n    }\n    invokeStreamingRPC(rpcName, path, request, authToken, appCheckToken, expectedResponseCount) {\n        const streamId = generateUniqueDebugId();\n        const results = [];\n        const responseDeferred = new Deferred();\n        logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} invoked (streaming) with request:`, request);\n        const stub = this.ensureActiveStub();\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId, this.databaseInfo.apiKey);\n        const jsonRequest = { ...request, database: this.databasePath };\n        const stream = stub[rpcName](jsonRequest, metadata);\n        let callbackFired = false;\n        stream.on('data', (response) => {\n            logDebug(LOG_TAG$9, `RPC ${rpcName} ${streamId} received result:`, response);\n            results.push(response);\n            if (expectedResponseCount !== undefined &&\n                results.length === expectedResponseCount) {\n                callbackFired = true;\n                responseDeferred.resolve(results);\n            }\n        });\n        stream.on('end', () => {\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} completed.`);\n            if (!callbackFired) {\n                callbackFired = true;\n                responseDeferred.resolve(results);\n            }\n        });\n        stream.on('error', (grpcError) => {\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} failed with error:`, grpcError);\n            const code = mapCodeFromRpcCode(grpcError.code);\n            responseDeferred.reject(new FirestoreError(code, grpcError.message));\n        });\n        return responseDeferred.promise;\n    }\n    // TODO(mikelehen): This \"method\" is a monster. Should be refactored.\n    openStream(rpcName, authToken, appCheckToken) {\n        const streamId = generateUniqueDebugId();\n        const stub = this.ensureActiveStub();\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId, this.databaseInfo.apiKey);\n        const grpcStream = stub[rpcName](metadata);\n        let closed = false;\n        const close = (err) => {\n            if (!closed) {\n                closed = true;\n                stream.callOnClose(err);\n                grpcStream.end();\n            }\n        };\n        const stream = new StreamBridge({\n            sendFn: (msg) => {\n                if (!closed) {\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} sending:`, msg);\n                    try {\n                        grpcStream.write(msg);\n                    }\n                    catch (e) {\n                        // This probably means we didn't conform to the proto.  Make sure to\n                        // log the message we sent.\n                        logError('Failure sending:', msg);\n                        logError('Error:', e);\n                        throw e;\n                    }\n                }\n                else {\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} ` +\n                        'not sending because gRPC stream is closed:', msg);\n                }\n            },\n            closeFn: () => {\n                logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} closed locally via close().`);\n                close();\n            }\n        });\n        let onConnectedSent = false;\n        grpcStream.on('data', (msg) => {\n            if (!closed) {\n                logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} received:`, msg);\n                // Emulate the \"onConnected\" event that WebChannelConnection sends.\n                if (!onConnectedSent) {\n                    stream.callOnConnected();\n                    onConnectedSent = true;\n                }\n                stream.callOnMessage(msg);\n            }\n        });\n        grpcStream.on('end', () => {\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} ended.`);\n            close();\n        });\n        grpcStream.on('error', (grpcError) => {\n            if (!closed) {\n                logWarn(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} error. Code:`, grpcError.code, 'Message:', grpcError.message);\n                const code = mapCodeFromRpcCode(grpcError.code);\n                close(new FirestoreError(code, grpcError.message));\n            }\n        });\n        logDebug(LOG_TAG$9, `Opening RPC '${rpcName}' stream ${streamId} ` +\n            `to ${this.databaseInfo.host}`);\n        // TODO(dimond): Since grpc has no explicit open status (or does it?) we\n        // simulate an onOpen in the next loop after the stream had it's listeners\n        // registered\n        setTimeout(() => {\n            stream.callOnOpen();\n        }, 0);\n        return stream;\n    }\n    /**\n     * Closes and cleans up any resources associated with the GrpcConnection.\n     * If a gRPC client has been generated for this connection, the gRPC client\n     * is closed. Failure to call terminate on a GrpcConnection can result\n     * in leaked resources of the gRPC client.\n     */\n    terminate() {\n        if (this.cachedStub) {\n            this.cachedStub.close();\n            this.cachedStub = undefined;\n        }\n    }\n}\n\nconst nested = {\n\tgoogle: {\n\t\tnested: {\n\t\t\tprotobuf: {\n\t\t\t\toptions: {\n\t\t\t\t\tgo_package: \"github.com/golang/protobuf/protoc-gen-go/descriptor;descriptor\",\n\t\t\t\t\tjava_package: \"com.google.protobuf\",\n\t\t\t\t\tjava_outer_classname: \"DescriptorProtos\",\n\t\t\t\t\tcsharp_namespace: \"Google.Protobuf.Reflection\",\n\t\t\t\t\tobjc_class_prefix: \"GPB\",\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\toptimize_for: \"SPEED\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tStruct: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tValue: {\n\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\tkind: {\n\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\"nullValue\",\n\t\t\t\t\t\t\t\t\t\"numberValue\",\n\t\t\t\t\t\t\t\t\t\"stringValue\",\n\t\t\t\t\t\t\t\t\t\"boolValue\",\n\t\t\t\t\t\t\t\t\t\"structValue\",\n\t\t\t\t\t\t\t\t\t\"listValue\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tnullValue: {\n\t\t\t\t\t\t\t\ttype: \"NullValue\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumberValue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tboolValue: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstructValue: {\n\t\t\t\t\t\t\t\ttype: \"Struct\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlistValue: {\n\t\t\t\t\t\t\t\ttype: \"ListValue\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tNullValue: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tNULL_VALUE: 0\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tListValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tTimestamp: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tseconds: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnanos: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileDescriptorSet: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tfile: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FileDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"package\": {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpublicDependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 10,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tpacked: false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tweakDependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 11,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tpacked: false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessageType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"DescriptorProto\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tenumType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tservice: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ServiceDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textension: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"FileOptions\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsourceCodeInfo: {\n\t\t\t\t\t\t\t\ttype: \"SourceCodeInfo\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsyntax: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textension: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnestedType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"DescriptorProto\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tenumType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textensionRange: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ExtensionRange\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toneofDecl: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"OneofDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"MessageOptions\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\treservedRange: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ReservedRange\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\treservedName: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tExtensionRange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ExtensionRangeOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tReservedRange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tExtensionRangeOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tFieldDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumber: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlabel: {\n\t\t\t\t\t\t\t\ttype: \"Label\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttype: {\n\t\t\t\t\t\t\t\ttype: \"Type\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttypeName: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textendee: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdefaultValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toneofIndex: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjsonName: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"FieldOptions\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tTYPE_DOUBLE: 1,\n\t\t\t\t\t\t\t\t\tTYPE_FLOAT: 2,\n\t\t\t\t\t\t\t\t\tTYPE_INT64: 3,\n\t\t\t\t\t\t\t\t\tTYPE_UINT64: 4,\n\t\t\t\t\t\t\t\t\tTYPE_INT32: 5,\n\t\t\t\t\t\t\t\t\tTYPE_FIXED64: 6,\n\t\t\t\t\t\t\t\t\tTYPE_FIXED32: 7,\n\t\t\t\t\t\t\t\t\tTYPE_BOOL: 8,\n\t\t\t\t\t\t\t\t\tTYPE_STRING: 9,\n\t\t\t\t\t\t\t\t\tTYPE_GROUP: 10,\n\t\t\t\t\t\t\t\t\tTYPE_MESSAGE: 11,\n\t\t\t\t\t\t\t\t\tTYPE_BYTES: 12,\n\t\t\t\t\t\t\t\t\tTYPE_UINT32: 13,\n\t\t\t\t\t\t\t\t\tTYPE_ENUM: 14,\n\t\t\t\t\t\t\t\t\tTYPE_SFIXED32: 15,\n\t\t\t\t\t\t\t\t\tTYPE_SFIXED64: 16,\n\t\t\t\t\t\t\t\t\tTYPE_SINT32: 17,\n\t\t\t\t\t\t\t\t\tTYPE_SINT64: 18\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tLabel: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tLABEL_OPTIONAL: 1,\n\t\t\t\t\t\t\t\t\tLABEL_REQUIRED: 2,\n\t\t\t\t\t\t\t\t\tLABEL_REPEATED: 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tOneofDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"OneofOptions\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEnumDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumValueDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"EnumOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\treservedRange: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumReservedRange\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\treservedName: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tEnumReservedRange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEnumValueDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumber: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"EnumValueOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tServiceDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmethod: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"MethodDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"ServiceOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tMethodDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tinputType: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toutputType: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"MethodOptions\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tclientStreaming: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 5,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tserverStreaming: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 6,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tjavaPackage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaOuterClassname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaMultipleFiles: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 10,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaGenerateEqualsAndHash: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 20,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tdeprecated: true\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaStringCheckUtf8: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 27,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptimizeFor: {\n\t\t\t\t\t\t\t\ttype: \"OptimizeMode\",\n\t\t\t\t\t\t\t\tid: 9,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"SPEED\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgoPackage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tccGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 16,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 17,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpyGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 18,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tphpGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 42,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 23,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tccEnableArenas: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 31,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tobjcClassPrefix: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 36\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcsharpNamespace: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 37\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tswiftPrefix: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 39\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tphpClassPrefix: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 40\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tphpNamespace: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 41\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tphpMetadataNamespace: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 44\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trubyPackage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 45\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t38,\n\t\t\t\t\t\t\t\t38\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tOptimizeMode: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tSPEED: 1,\n\t\t\t\t\t\t\t\t\tCODE_SIZE: 2,\n\t\t\t\t\t\t\t\t\tLITE_RUNTIME: 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tMessageOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tmessageSetWireFormat: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnoStandardDescriptorAccessor: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmapEntry: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t8,\n\t\t\t\t\t\t\t\t8\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t9,\n\t\t\t\t\t\t\t\t9\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tFieldOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tctype: {\n\t\t\t\t\t\t\t\ttype: \"CType\",\n\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"STRING\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpacked: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjstype: {\n\t\t\t\t\t\t\t\ttype: \"JSType\",\n\t\t\t\t\t\t\t\tid: 6,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"JS_NORMAL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlazy: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 5,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tweak: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 10,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t4,\n\t\t\t\t\t\t\t\t4\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tCType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tSTRING: 0,\n\t\t\t\t\t\t\t\t\tCORD: 1,\n\t\t\t\t\t\t\t\t\tSTRING_PIECE: 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tJSType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tJS_NORMAL: 0,\n\t\t\t\t\t\t\t\t\tJS_STRING: 1,\n\t\t\t\t\t\t\t\t\tJS_NUMBER: 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tOneofOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tEnumOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tallowAlias: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t5,\n\t\t\t\t\t\t\t\t5\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tEnumValueOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tServiceOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 33,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tMethodOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 33,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tidempotencyLevel: {\n\t\t\t\t\t\t\t\ttype: \"IdempotencyLevel\",\n\t\t\t\t\t\t\t\tid: 34,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"IDEMPOTENCY_UNKNOWN\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tIdempotencyLevel: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tIDEMPOTENCY_UNKNOWN: 0,\n\t\t\t\t\t\t\t\t\tNO_SIDE_EFFECTS: 1,\n\t\t\t\t\t\t\t\t\tIDEMPOTENT: 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tUninterpretedOption: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"NamePart\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tidentifierValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpositiveIntValue: {\n\t\t\t\t\t\t\t\ttype: \"uint64\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnegativeIntValue: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdoubleValue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\taggregateValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tNamePart: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tnamePart: {\n\t\t\t\t\t\t\t\t\t\trule: \"required\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tisExtension: {\n\t\t\t\t\t\t\t\t\t\trule: \"required\",\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tSourceCodeInfo: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tlocation: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Location\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tLocation: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tspan: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tleadingComments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttrailingComments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tleadingDetachedComments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tGeneratedCodeInfo: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tannotation: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Annotation\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tAnnotation: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tsourceFile: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbegin: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tDoubleValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFloatValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"float\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tInt64Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tUInt64Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"uint64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tInt32Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tUInt32Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"uint32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tBoolValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tStringValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tBytesValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEmpty: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tAny: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\ttype_url: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tDuration: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tseconds: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnanos: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tfirestore: {\n\t\t\t\tnested: {\n\t\t\t\t\tv1: {\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tcsharp_namespace: \"Google.Cloud.Firestore.V1\",\n\t\t\t\t\t\t\tgo_package: \"cloud.google.com/go/firestore/apiv1/firestorepb;firestorepb\",\n\t\t\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\t\t\tjava_outer_classname: \"QueryProfileProto\",\n\t\t\t\t\t\t\tjava_package: \"com.google.firestore.v1\",\n\t\t\t\t\t\t\tobjc_class_prefix: \"GCFS\",\n\t\t\t\t\t\t\tphp_namespace: \"Google\\\\Cloud\\\\Firestore\\\\V1\",\n\t\t\t\t\t\t\truby_package: \"Google::Cloud::Firestore::V1\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tAggregationResult: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\taggregateFields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocument: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcreateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tValue: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tvalueType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"nullValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"booleanValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"integerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"doubleValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"timestampValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"stringValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"bytesValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"referenceValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"geoPointValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"arrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"mapValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"fieldReferenceValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"functionValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"pipelineValue\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tnullValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.NullValue\",\n\t\t\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbooleanValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tintegerValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdoubleValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttimestampValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 17\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbytesValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 18\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treferenceValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tgeoPointValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.type.LatLng\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tarrayValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmapValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"MapValue\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfieldReferenceValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 19\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfunctionValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Function\",\n\t\t\t\t\t\t\t\t\t\tid: 20\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpipelineValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Pipeline\",\n\t\t\t\t\t\t\t\t\t\tid: 21\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tArrayValue: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMapValue: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"Function\": {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPipeline: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstages: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Stage\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tStage: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBitSequence: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tbitmap: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpadding: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBloomFilter: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tbits: {\n\t\t\t\t\t\t\t\t\t\ttype: \"BitSequence\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\thashCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentMask: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfieldPaths: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPrecondition: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconditionType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"exists\",\n\t\t\t\t\t\t\t\t\t\t\t\"updateTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\texists: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTransactionOptions: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tmode: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"readOnly\",\n\t\t\t\t\t\t\t\t\t\t\t\"readWrite\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\treadOnly: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ReadOnly\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadWrite: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ReadWrite\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tReadWrite: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tretryTransaction: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tReadOnly: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tFirestore: {\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"(google.api.default_host)\": \"firestore.googleapis.com\",\n\t\t\t\t\t\t\t\t\t\"(google.api.oauth_scopes)\": \"https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/datastore\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tmethods: {\n\t\t\t\t\t\t\t\t\tGetDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"GetDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).get\": \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tget: \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListDocuments: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListDocumentsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListDocumentsResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).get\": \"/v1/{parent=projects/*/databases/*/documents/*/**}/{collection_id}\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tget: \"/v1/{parent=projects/*/databases/*/documents/*/**}/{collection_id}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tUpdateDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"UpdateDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).patch\": \"/v1/{document.name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"document\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"document,update_mask\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpatch: \"/v1/{document.name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"document\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"document,update_mask\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tDeleteDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"DeleteDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"google.protobuf.Empty\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).delete\": \"/v1/{name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"name\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"delete\": \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"name\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBatchGetDocuments: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BatchGetDocumentsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BatchGetDocumentsResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:batchGet\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:batchGet\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBeginTransaction: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BeginTransactionRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BeginTransactionResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:beginTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:beginTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCommit: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"CommitRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"CommitResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:commit\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,writes\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:commit\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,writes\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRollback: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RollbackRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"google.protobuf.Empty\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:rollback\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,transaction\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:rollback\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,transaction\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRunQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RunQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"RunQueryResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tExecutePipeline: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ExecutePipelineRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ExecutePipelineResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:executePipeline\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:executePipeline\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRunAggregationQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RunAggregationQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"RunAggregationQueryResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tPartitionQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"PartitionQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"PartitionQueryResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tWrite: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"WriteRequest\",\n\t\t\t\t\t\t\t\t\t\trequestStream: true,\n\t\t\t\t\t\t\t\t\t\tresponseType: \"WriteResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:write\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:write\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListen: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListenRequest\",\n\t\t\t\t\t\t\t\t\t\trequestStream: true,\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListenResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:listen\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:listen\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListCollectionIds: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListCollectionIdsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListCollectionIdsResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"parent\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"parent\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBatchWrite: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BatchWriteRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BatchWriteResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:batchWrite\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:batchWrite\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCreateDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"CreateDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents/**}/{collection_id}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"document\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/**}/{collection_id}\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"document\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tGetDocumentRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListDocumentsRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tshowMissing: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListDocumentsResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCreateDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 4,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tUpdateDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateMask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDeleteDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchGetDocumentsRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchGetDocumentsResponse: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tresult: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"found\",\n\t\t\t\t\t\t\t\t\t\t\t\"missing\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfound: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmissing: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBeginTransactionRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBeginTransactionResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCommitRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCommitResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcommitTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRollbackRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tskippedResults: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tExecutePipelineRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tpipelineType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredPipeline\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredPipeline: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredPipeline\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tExecutePipelineResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\texecutionTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunAggregationQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredAggregationQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredAggregationQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunAggregationQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tresult: {\n\t\t\t\t\t\t\t\t\t\ttype: \"AggregationResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPartitionQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpartitionCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPartitionQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpartitions: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstreamId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcommitTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListenRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\ttargetChange: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"addTarget\",\n\t\t\t\t\t\t\t\t\t\t\t\"removeTarget\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\taddTarget: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Target\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremoveTarget: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListenResponse: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tresponseType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"targetChange\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentChange\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentDelete\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentRemove\",\n\t\t\t\t\t\t\t\t\t\t\t\"filter\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetChange: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TargetChange\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentChange: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentChange\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentDelete: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentDelete\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentRemove: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentRemove\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfilter: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ExistenceFilter\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTarget: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\ttargetType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"query\",\n\t\t\t\t\t\t\t\t\t\t\t\"documents\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"resumeToken\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tquery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"QueryTarget\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentsTarget\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tonce: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\texpectedCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int32Value\",\n\t\t\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tDocumentsTarget: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tQueryTarget: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTargetChange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetChangeType: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TargetChangeType\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcause: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.rpc.Status\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tTargetChangeType: {\n\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\tNO_CHANGE: 0,\n\t\t\t\t\t\t\t\t\t\t\tADD: 1,\n\t\t\t\t\t\t\t\t\t\t\tREMOVE: 2,\n\t\t\t\t\t\t\t\t\t\t\tCURRENT: 3,\n\t\t\t\t\t\t\t\t\t\t\tRESET: 4\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListCollectionIdsRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListCollectionIdsResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tcollectionIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchWriteRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchWriteResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"google.rpc.Status\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStructuredPipeline: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpipeline: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Pipeline\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStructuredQuery: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tselect: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Projection\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfrom: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"CollectionSelector\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twhere: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Filter\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Order\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstartAt: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tendAt: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toffset: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlimit: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int32Value\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tCollectionSelector: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tallDescendants: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFilter: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tfilterType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"compositeFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"fieldFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"unaryFilter\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcompositeFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"CompositeFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfieldFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tunaryFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"UnaryFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCompositeFilter: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfilters: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Filter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tAND: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tOR: 2\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFieldFilter: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tLESS_THAN: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tLESS_THAN_OR_EQUAL: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\tGREATER_THAN: 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\tGREATER_THAN_OR_EQUAL: 4,\n\t\t\t\t\t\t\t\t\t\t\t\t\tEQUAL: 5,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNOT_EQUAL: 6,\n\t\t\t\t\t\t\t\t\t\t\t\t\tARRAY_CONTAINS: 7,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIN: 8,\n\t\t\t\t\t\t\t\t\t\t\t\t\tARRAY_CONTAINS_ANY: 9,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNOT_IN: 10\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tUnaryFilter: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\toperandType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"field\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NAN: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NULL: 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NOT_NAN: 4,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NOT_NULL: 5\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tOrder: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tdirection: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Direction\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFieldReference: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfieldPath: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tProjection: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tDirection: {\n\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\tDIRECTION_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\tASCENDING: 1,\n\t\t\t\t\t\t\t\t\t\t\tDESCENDING: 2\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStructuredAggregationQuery: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\taggregations: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Aggregation\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tAggregation: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\toperator: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"count\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"sum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"avg\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcount: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Count\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tsum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Sum\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tavg: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Avg\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\talias: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tCount: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tupTo: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int64Value\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tSum: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery.FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tAvg: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery.FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCursor: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbefore: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWrite: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\toperation: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"update\",\n\t\t\t\t\t\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\t\t\t\t\t\"verify\",\n\t\t\t\t\t\t\t\t\t\t\t\"transform\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tupdate: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"delete\": {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tverify: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransform: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateMask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTransforms: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentTransform.FieldTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentTransform: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfieldTransforms: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"FieldTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tFieldTransform: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\ttransformType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"setToServerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"increment\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"maximum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"minimum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"appendMissingElements\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"removeAllFromArray\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfieldPath: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tsetToServerValue: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ServerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tincrement: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tmaximum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tminimum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tappendMissingElements: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tremoveAllFromArray: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tServerValue: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tSERVER_VALUE_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tREQUEST_TIME: 1\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteResult: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransformResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentChange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentDelete: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentRemove: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tExistenceFilter: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tunchangedNames: {\n\t\t\t\t\t\t\t\t\t\ttype: \"BloomFilter\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tExplainOptions: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tanalyze: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"OPTIONAL\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tExplainMetrics: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tplanSummary: {\n\t\t\t\t\t\t\t\t\t\ttype: \"PlanSummary\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\texecutionStats: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ExecutionStats\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPlanSummary: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tindexesUsed: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Struct\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tExecutionStats: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tresultsReturned: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\texecutionDuration: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Duration\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadOperations: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdebugStats: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Struct\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\ttype: {\n\t\t\t\toptions: {\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/type/latlng;latlng\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"LatLngProto\",\n\t\t\t\t\tjava_package: \"com.google.type\",\n\t\t\t\t\tobjc_class_prefix: \"GTP\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tLatLng: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tlatitude: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlongitude: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tapi: {\n\t\t\t\toptions: {\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/api;api\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"LaunchStageProto\",\n\t\t\t\t\tjava_package: \"com.google.api\",\n\t\t\t\t\tobjc_class_prefix: \"GAPI\",\n\t\t\t\t\tcc_enable_arenas: true\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\thttp: {\n\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\tid: 72295728,\n\t\t\t\t\t\textend: \"google.protobuf.MethodOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tHttp: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\trules: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfullyDecodeReservedExpansion: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tHttpRule: {\n\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\tpattern: {\n\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\"get\",\n\t\t\t\t\t\t\t\t\t\"put\",\n\t\t\t\t\t\t\t\t\t\"post\",\n\t\t\t\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\t\t\t\"patch\",\n\t\t\t\t\t\t\t\t\t\"custom\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tselector: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tget: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tput: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpost: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"delete\": {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpatch: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcustom: {\n\t\t\t\t\t\t\t\ttype: \"CustomHttpPattern\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tresponseBody: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tadditionalBindings: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tCustomHttpPattern: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tkind: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmethodSignature: {\n\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1051,\n\t\t\t\t\t\textend: \"google.protobuf.MethodOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tdefaultHost: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1049,\n\t\t\t\t\t\textend: \"google.protobuf.ServiceOptions\"\n\t\t\t\t\t},\n\t\t\t\t\toauthScopes: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1050,\n\t\t\t\t\t\textend: \"google.protobuf.ServiceOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tfieldBehavior: {\n\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\ttype: \"google.api.FieldBehavior\",\n\t\t\t\t\t\tid: 1052,\n\t\t\t\t\t\textend: \"google.protobuf.FieldOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tFieldBehavior: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tFIELD_BEHAVIOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\tOPTIONAL: 1,\n\t\t\t\t\t\t\tREQUIRED: 2,\n\t\t\t\t\t\t\tOUTPUT_ONLY: 3,\n\t\t\t\t\t\t\tINPUT_ONLY: 4,\n\t\t\t\t\t\t\tIMMUTABLE: 5,\n\t\t\t\t\t\t\tUNORDERED_LIST: 6,\n\t\t\t\t\t\t\tNON_EMPTY_DEFAULT: 7\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tLaunchStage: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tLAUNCH_STAGE_UNSPECIFIED: 0,\n\t\t\t\t\t\t\tUNIMPLEMENTED: 6,\n\t\t\t\t\t\t\tPRELAUNCH: 7,\n\t\t\t\t\t\t\tEARLY_ACCESS: 1,\n\t\t\t\t\t\t\tALPHA: 2,\n\t\t\t\t\t\t\tBETA: 3,\n\t\t\t\t\t\t\tGA: 4,\n\t\t\t\t\t\t\tDEPRECATED: 5\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\trpc: {\n\t\t\t\toptions: {\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/rpc/status;status\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"StatusProto\",\n\t\t\t\t\tjava_package: \"com.google.rpc\",\n\t\t\t\t\tobjc_class_prefix: \"RPC\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tStatus: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tcode: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdetails: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"google.protobuf.Any\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nvar protos = {\n\tnested: nested\n};\n\nvar protos$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  nested: nested,\n  'default': protos\n});\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Used by tests so we can match @grpc/proto-loader behavior. */\nconst protoLoaderOptions = {\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: false\n};\n/**\n * Loads the protocol buffer definitions for Firestore.\n *\n * @returns The GrpcObject representing our protos.\n */\nfunction loadProtos() {\n    const packageDefinition = _grpc_proto_loader__WEBPACK_IMPORTED_MODULE_7__.fromJSON(protos$1, protoLoaderOptions);\n    return _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_6__.loadPackageDefinition(packageDefinition);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Loads the GRPC stack */\nfunction newConnection(databaseInfo) {\n    const protos = loadProtos();\n    return new GrpcConnection(protos, databaseInfo);\n}\n/** Return the Platform-specific connectivity monitor. */\nfunction newConnectivityMonitor() {\n    return new NoopConnectivityMonitor();\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** The Platform's 'window' implementation or null if not available. */\nfunction getWindow() {\n    if (process.env.USE_MOCK_PERSISTENCE === 'YES') {\n        // eslint-disable-next-line no-restricted-globals\n        return window;\n    }\n    return null;\n}\n/** The Platform's 'document' implementation or null if not available. */\nfunction getDocument() {\n    return null;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction newSerializer(databaseId) {\n    return new JsonProtoSerializer(databaseId, /* useProto3Json= */ false);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$8 = 'ExponentialBackoff';\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nconst DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\nconst DEFAULT_BACKOFF_FACTOR = 1.5;\n/** Maximum backoff time in milliseconds */\nconst DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\nclass ExponentialBackoff {\n    constructor(\n    /**\n     * The AsyncQueue to run backoff operations on.\n     */\n    queue, \n    /**\n     * The ID to use when scheduling backoff operations on the AsyncQueue.\n     */\n    timerId, \n    /**\n     * The initial delay (used as the base delay on the first retry attempt).\n     * Note that jitter will still be applied, so the actual delay could be as\n     * little as 0.5*initialDelayMs.\n     */\n    initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS, \n    /**\n     * The multiplier to use to determine the extended base delay after each\n     * attempt.\n     */\n    backoffFactor = DEFAULT_BACKOFF_FACTOR, \n    /**\n     * The maximum base delay after which no further backoff is performed.\n     * Note that jitter will still be applied, so the actual delay could be as\n     * much as 1.5*maxDelayMs.\n     */\n    maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS) {\n        this.queue = queue;\n        this.timerId = timerId;\n        this.initialDelayMs = initialDelayMs;\n        this.backoffFactor = backoffFactor;\n        this.maxDelayMs = maxDelayMs;\n        this.currentBaseMs = 0;\n        this.timerPromise = null;\n        /** The last backoff attempt, as epoch milliseconds. */\n        this.lastAttemptTime = Date.now();\n        this.reset();\n    }\n    /**\n     * Resets the backoff delay.\n     *\n     * The very next backoffAndWait() will have no delay. If it is called again\n     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n     * subsequent ones will increase according to the backoffFactor.\n     */\n    reset() {\n        this.currentBaseMs = 0;\n    }\n    /**\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\n     * RESOURCE_EXHAUSTED error).\n     */\n    resetToMax() {\n        this.currentBaseMs = this.maxDelayMs;\n    }\n    /**\n     * Returns a promise that resolves after currentDelayMs, and increases the\n     * delay for any subsequent attempts. If there was a pending backoff operation\n     * already, it will be canceled.\n     */\n    backoffAndRun(op) {\n        // Cancel any pending backoff operation.\n        this.cancel();\n        // First schedule using the current base (which may be 0 and should be\n        // honored as such).\n        const desiredDelayWithJitterMs = Math.floor(this.currentBaseMs + this.jitterDelayMs());\n        // Guard against lastAttemptTime being in the future due to a clock change.\n        const delaySoFarMs = Math.max(0, Date.now() - this.lastAttemptTime);\n        // Guard against the backoff delay already being past.\n        const remainingDelayMs = Math.max(0, desiredDelayWithJitterMs - delaySoFarMs);\n        if (remainingDelayMs > 0) {\n            logDebug(LOG_TAG$8, `Backing off for ${remainingDelayMs} ms ` +\n                `(base delay: ${this.currentBaseMs} ms, ` +\n                `delay with jitter: ${desiredDelayWithJitterMs} ms, ` +\n                `last attempt: ${delaySoFarMs} ms ago)`);\n        }\n        this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, remainingDelayMs, () => {\n            this.lastAttemptTime = Date.now();\n            return op();\n        });\n        // Apply backoff factor to determine next delay and ensure it is within\n        // bounds.\n        this.currentBaseMs *= this.backoffFactor;\n        if (this.currentBaseMs < this.initialDelayMs) {\n            this.currentBaseMs = this.initialDelayMs;\n        }\n        if (this.currentBaseMs > this.maxDelayMs) {\n            this.currentBaseMs = this.maxDelayMs;\n        }\n    }\n    skipBackoff() {\n        if (this.timerPromise !== null) {\n            this.timerPromise.skipDelay();\n            this.timerPromise = null;\n        }\n    }\n    cancel() {\n        if (this.timerPromise !== null) {\n            this.timerPromise.cancel();\n            this.timerPromise = null;\n        }\n    }\n    /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n    jitterDelayMs() {\n        return (Math.random() - 0.5) * this.currentBaseMs;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$7 = 'PersistentStream';\n/** The time a stream stays open after it is marked idle. */\nconst IDLE_TIMEOUT_MS = 60 * 1000;\n/** The time a stream stays open until we consider it healthy. */\nconst HEALTHY_TIMEOUT_MS = 10 * 1000;\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *   - Closing idle streams after 60 seconds of inactivity\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be start()ed before messages can\n * be sent and received. The PersistentStream will call the onOpen() function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a start() fail, PersistentStream will call the registered onClose()\n * listener with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\nclass PersistentStream {\n    constructor(queue, connectionTimerId, idleTimerId, healthTimerId, connection, authCredentialsProvider, appCheckCredentialsProvider, listener) {\n        this.queue = queue;\n        this.idleTimerId = idleTimerId;\n        this.healthTimerId = healthTimerId;\n        this.connection = connection;\n        this.authCredentialsProvider = authCredentialsProvider;\n        this.appCheckCredentialsProvider = appCheckCredentialsProvider;\n        this.listener = listener;\n        this.state = 0 /* PersistentStreamState.Initial */;\n        /**\n         * A close count that's incremented every time the stream is closed; used by\n         * getCloseGuardedDispatcher() to invalidate callbacks that happen after\n         * close.\n         */\n        this.closeCount = 0;\n        this.idleTimer = null;\n        this.healthCheck = null;\n        this.stream = null;\n        /**\n         * Count of response messages received.\n         */\n        this.responseCount = 0;\n        this.backoff = new ExponentialBackoff(queue, connectionTimerId);\n    }\n    /**\n     * Returns true if start() has been called and no error has occurred. True\n     * indicates the stream is open or in the process of opening (which\n     * encompasses respecting backoff, getting auth tokens, and starting the\n     * actual RPC). Use isOpen() to determine if the stream is open and ready for\n     * outbound requests.\n     */\n    isStarted() {\n        return (this.state === 1 /* PersistentStreamState.Starting */ ||\n            this.state === 5 /* PersistentStreamState.Backoff */ ||\n            this.isOpen());\n    }\n    /**\n     * Returns true if the underlying RPC is open (the onOpen() listener has been\n     * called) and the stream is ready for outbound requests.\n     */\n    isOpen() {\n        return (this.state === 2 /* PersistentStreamState.Open */ ||\n            this.state === 3 /* PersistentStreamState.Healthy */);\n    }\n    /**\n     * Starts the RPC. Only allowed if isStarted() returns false. The stream is\n     * not immediately ready for use: onOpen() will be invoked when the RPC is\n     * ready for outbound requests, at which point isOpen() will return true.\n     *\n     * When start returns, isStarted() will return true.\n     */\n    start() {\n        this.responseCount = 0;\n        if (this.state === 4 /* PersistentStreamState.Error */) {\n            this.performBackoff();\n            return;\n        }\n        this.auth();\n    }\n    /**\n     * Stops the RPC. This call is idempotent and allowed regardless of the\n     * current isStarted() state.\n     *\n     * When stop returns, isStarted() and isOpen() will both return false.\n     */\n    async stop() {\n        if (this.isStarted()) {\n            await this.close(0 /* PersistentStreamState.Initial */);\n        }\n    }\n    /**\n     * After an error the stream will usually back off on the next attempt to\n     * start it. If the error warrants an immediate restart of the stream, the\n     * sender can use this to indicate that the receiver should not back off.\n     *\n     * Each error will call the onClose() listener. That function can decide to\n     * inhibit backoff if required.\n     */\n    inhibitBackoff() {\n        this.state = 0 /* PersistentStreamState.Initial */;\n        this.backoff.reset();\n    }\n    /**\n     * Marks this stream as idle. If no further actions are performed on the\n     * stream for one minute, the stream will automatically close itself and\n     * notify the stream's onClose() handler with Status.OK. The stream will then\n     * be in a !isStarted() state, requiring the caller to start the stream again\n     * before further use.\n     *\n     * Only streams that are in state 'Open' can be marked idle, as all other\n     * states imply pending network operations.\n     */\n    markIdle() {\n        // Starts the idle time if we are in state 'Open' and are not yet already\n        // running a timer (in which case the previous idle timeout still applies).\n        if (this.isOpen() && this.idleTimer === null) {\n            this.idleTimer = this.queue.enqueueAfterDelay(this.idleTimerId, IDLE_TIMEOUT_MS, () => this.handleIdleCloseTimer());\n        }\n    }\n    /** Sends a message to the underlying stream. */\n    sendRequest(msg) {\n        this.cancelIdleCheck();\n        this.stream.send(msg);\n    }\n    /** Called by the idle timer when the stream should close due to inactivity. */\n    async handleIdleCloseTimer() {\n        if (this.isOpen()) {\n            // When timing out an idle stream there's no reason to force the stream into backoff when\n            // it restarts so set the stream state to Initial instead of Error.\n            return this.close(0 /* PersistentStreamState.Initial */);\n        }\n    }\n    /** Marks the stream as active again. */\n    cancelIdleCheck() {\n        if (this.idleTimer) {\n            this.idleTimer.cancel();\n            this.idleTimer = null;\n        }\n    }\n    /** Cancels the health check delayed operation. */\n    cancelHealthCheck() {\n        if (this.healthCheck) {\n            this.healthCheck.cancel();\n            this.healthCheck = null;\n        }\n    }\n    /**\n     * Closes the stream and cleans up as necessary:\n     *\n     * * closes the underlying GRPC stream;\n     * * calls the onClose handler with the given 'error';\n     * * sets internal stream state to 'finalState';\n     * * adjusts the backoff timer based on the error\n     *\n     * A new stream can be opened by calling start().\n     *\n     * @param finalState - the intended state of the stream after closing.\n     * @param error - the error the connection was closed with.\n     */\n    async close(finalState, error) {\n        // Cancel any outstanding timers (they're guaranteed not to execute).\n        this.cancelIdleCheck();\n        this.cancelHealthCheck();\n        this.backoff.cancel();\n        // Invalidates any stream-related callbacks (e.g. from auth or the\n        // underlying stream), guaranteeing they won't execute.\n        this.closeCount++;\n        if (finalState !== 4 /* PersistentStreamState.Error */) {\n            // If this is an intentional close ensure we don't delay our next connection attempt.\n            this.backoff.reset();\n        }\n        else if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n            // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)\n            logError(error.toString());\n            logError('Using maximum backoff delay to prevent overloading the backend.');\n            this.backoff.resetToMax();\n        }\n        else if (error &&\n            error.code === Code.UNAUTHENTICATED &&\n            this.state !== 3 /* PersistentStreamState.Healthy */) {\n            // \"unauthenticated\" error means the token was rejected. This should rarely\n            // happen since both Auth and AppCheck ensure a sufficient TTL when we\n            // request a token. If a user manually resets their system clock this can\n            // fail, however. In this case, we should get a Code.UNAUTHENTICATED error\n            // before we received the first message and we need to invalidate the token\n            // to ensure that we fetch a new token.\n            this.authCredentialsProvider.invalidateToken();\n            this.appCheckCredentialsProvider.invalidateToken();\n        }\n        // Clean up the underlying stream because we are no longer interested in events.\n        if (this.stream !== null) {\n            this.tearDown();\n            this.stream.close();\n            this.stream = null;\n        }\n        // This state must be assigned before calling onClose() to allow the callback to\n        // inhibit backoff or otherwise manipulate the state in its non-started state.\n        this.state = finalState;\n        // Notify the listener that the stream closed.\n        await this.listener.onClose(error);\n    }\n    /**\n     * Can be overridden to perform additional cleanup before the stream is closed.\n     * Calling super.tearDown() is not required.\n     */\n    tearDown() { }\n    auth() {\n        this.state = 1 /* PersistentStreamState.Starting */;\n        const dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);\n        // TODO(mikelehen): Just use dispatchIfNotClosed, but see TODO below.\n        const closeCount = this.closeCount;\n        Promise.all([\n            this.authCredentialsProvider.getToken(),\n            this.appCheckCredentialsProvider.getToken()\n        ]).then(([authToken, appCheckToken]) => {\n            // Stream can be stopped while waiting for authentication.\n            // TODO(mikelehen): We really should just use dispatchIfNotClosed\n            // and let this dispatch onto the queue, but that opened a spec test can\n            // of worms that I don't want to deal with in this PR.\n            if (this.closeCount === closeCount) {\n                // Normally we'd have to schedule the callback on the AsyncQueue.\n                // However, the following calls are safe to be called outside the\n                // AsyncQueue since they don't chain asynchronous calls\n                this.startStream(authToken, appCheckToken);\n            }\n        }, (error) => {\n            dispatchIfNotClosed(() => {\n                const rpcError = new FirestoreError(Code.UNKNOWN, 'Fetching auth token failed: ' + error.message);\n                return this.handleStreamClose(rpcError);\n            });\n        });\n    }\n    startStream(authToken, appCheckToken) {\n        const dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);\n        this.stream = this.startRpc(authToken, appCheckToken);\n        this.stream.onConnected(() => {\n            dispatchIfNotClosed(() => this.listener.onConnected());\n        });\n        this.stream.onOpen(() => {\n            dispatchIfNotClosed(() => {\n                this.state = 2 /* PersistentStreamState.Open */;\n                this.healthCheck = this.queue.enqueueAfterDelay(this.healthTimerId, HEALTHY_TIMEOUT_MS, () => {\n                    if (this.isOpen()) {\n                        this.state = 3 /* PersistentStreamState.Healthy */;\n                    }\n                    return Promise.resolve();\n                });\n                return this.listener.onOpen();\n            });\n        });\n        this.stream.onClose((error) => {\n            dispatchIfNotClosed(() => {\n                return this.handleStreamClose(error);\n            });\n        });\n        this.stream.onMessage((msg) => {\n            dispatchIfNotClosed(() => {\n                if (++this.responseCount === 1) {\n                    return this.onFirst(msg);\n                }\n                else {\n                    return this.onNext(msg);\n                }\n            });\n        });\n    }\n    performBackoff() {\n        this.state = 5 /* PersistentStreamState.Backoff */;\n        this.backoff.backoffAndRun(async () => {\n            this.state = 0 /* PersistentStreamState.Initial */;\n            this.start();\n        });\n    }\n    // Visible for tests\n    handleStreamClose(error) {\n        logDebug(LOG_TAG$7, `close with error: ${error}`);\n        this.stream = null;\n        // In theory the stream could close cleanly, however, in our current model\n        // we never expect this to happen because if we stop a stream ourselves,\n        // this callback will never be called. To prevent cases where we retry\n        // without a backoff accidentally, we set the stream to error in all cases.\n        return this.close(4 /* PersistentStreamState.Error */, error);\n    }\n    /**\n     * Returns a \"dispatcher\" function that dispatches operations onto the\n     * AsyncQueue but only runs them if closeCount remains unchanged. This allows\n     * us to turn auth / stream callbacks into no-ops if the stream is closed /\n     * re-opened, etc.\n     */\n    getCloseGuardedDispatcher(startCloseCount) {\n        return (fn) => {\n            this.queue.enqueueAndForget(() => {\n                if (this.closeCount === startCloseCount) {\n                    return fn();\n                }\n                else {\n                    logDebug(LOG_TAG$7, 'stream callback skipped by getCloseGuardedDispatcher.');\n                    return Promise.resolve();\n                }\n            });\n        };\n    }\n}\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the onOpen() listener, any number of\n * listen() and unlisten() calls can be made to control what changes will be\n * sent from the server for ListenResponses.\n */\nclass PersistentListenStream extends PersistentStream {\n    constructor(queue, connection, authCredentials, appCheckCredentials, serializer, listener) {\n        super(queue, \"listen_stream_connection_backoff\" /* TimerId.ListenStreamConnectionBackoff */, \"listen_stream_idle\" /* TimerId.ListenStreamIdle */, \"health_check_timeout\" /* TimerId.HealthCheckTimeout */, connection, authCredentials, appCheckCredentials, listener);\n        this.serializer = serializer;\n    }\n    startRpc(authToken, appCheckToken) {\n        return this.connection.openStream('Listen', authToken, appCheckToken);\n    }\n    onFirst(watchChangeProto) {\n        return this.onNext(watchChangeProto);\n    }\n    onNext(watchChangeProto) {\n        // A successful response means the stream is healthy\n        this.backoff.reset();\n        const watchChange = fromWatchChange(this.serializer, watchChangeProto);\n        const snapshot = versionFromListenResponse(watchChangeProto);\n        return this.listener.onWatchChange(watchChange, snapshot);\n    }\n    /**\n     * Registers interest in the results of the given target. If the target\n     * includes a resumeToken it will be included in the request. Results that\n     * affect the target will be streamed back as WatchChange messages that\n     * reference the targetId.\n     */\n    watch(targetData) {\n        const request = {};\n        request.database = getEncodedDatabaseId(this.serializer);\n        request.addTarget = toTarget(this.serializer, targetData);\n        const labels = toListenRequestLabels(this.serializer, targetData);\n        if (labels) {\n            request.labels = labels;\n        }\n        this.sendRequest(request);\n    }\n    /**\n     * Unregisters interest in the results of the target associated with the\n     * given targetId.\n     */\n    unwatch(targetId) {\n        const request = {};\n        request.database = getEncodedDatabaseId(this.serializer);\n        request.removeTarget = targetId;\n        this.sendRequest(request);\n    }\n}\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\nclass PersistentWriteStream extends PersistentStream {\n    constructor(queue, connection, authCredentials, appCheckCredentials, serializer, listener) {\n        super(queue, \"write_stream_connection_backoff\" /* TimerId.WriteStreamConnectionBackoff */, \"write_stream_idle\" /* TimerId.WriteStreamIdle */, \"health_check_timeout\" /* TimerId.HealthCheckTimeout */, connection, authCredentials, appCheckCredentials, listener);\n        this.serializer = serializer;\n    }\n    /**\n     * Tracks whether or not a handshake has been successfully exchanged and\n     * the stream is ready to accept mutations.\n     */\n    get handshakeComplete() {\n        return this.responseCount > 0;\n    }\n    // Override of PersistentStream.start\n    start() {\n        this.lastStreamToken = undefined;\n        super.start();\n    }\n    tearDown() {\n        if (this.handshakeComplete) {\n            this.writeMutations([]);\n        }\n    }\n    startRpc(authToken, appCheckToken) {\n        return this.connection.openStream('Write', authToken, appCheckToken);\n    }\n    onFirst(responseProto) {\n        // Always capture the last stream token.\n        hardAssert(!!responseProto.streamToken, 0x7a5a);\n        this.lastStreamToken = responseProto.streamToken;\n        // The first response is always the handshake response\n        hardAssert(!responseProto.writeResults || responseProto.writeResults.length === 0, 0xda08);\n        return this.listener.onHandshakeComplete();\n    }\n    onNext(responseProto) {\n        // Always capture the last stream token.\n        hardAssert(!!responseProto.streamToken, 0x3186);\n        this.lastStreamToken = responseProto.streamToken;\n        // A successful first write response means the stream is healthy,\n        // Note, that we could consider a successful handshake healthy, however,\n        // the write itself might be causing an error we want to back off from.\n        this.backoff.reset();\n        const results = fromWriteResults(responseProto.writeResults, responseProto.commitTime);\n        const commitVersion = fromVersion(responseProto.commitTime);\n        return this.listener.onMutationResult(commitVersion, results);\n    }\n    /**\n     * Sends an initial streamToken to the server, performing the handshake\n     * required to make the StreamingWrite RPC work. Subsequent\n     * calls should wait until onHandshakeComplete was called.\n     */\n    writeHandshake() {\n        // TODO(dimond): Support stream resumption. We intentionally do not set the\n        // stream token on the handshake, ignoring any stream token we might have.\n        const request = {};\n        request.database = getEncodedDatabaseId(this.serializer);\n        this.sendRequest(request);\n    }\n    /** Sends a group of mutations to the Firestore backend to apply. */\n    writeMutations(mutations) {\n        const request = {\n            streamToken: this.lastStreamToken,\n            writes: mutations.map(mutation => toMutation(this.serializer, mutation))\n        };\n        this.sendRequest(request);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Datastore and its related methods are a wrapper around the external Google\n * Cloud Datastore grpc API, which provides an interface that is more convenient\n * for the rest of the client SDK architecture to consume.\n */\nclass Datastore {\n}\n/**\n * An implementation of Datastore that exposes additional state for internal\n * consumption.\n */\nclass DatastoreImpl extends Datastore {\n    constructor(authCredentials, appCheckCredentials, connection, serializer) {\n        super();\n        this.authCredentials = authCredentials;\n        this.appCheckCredentials = appCheckCredentials;\n        this.connection = connection;\n        this.serializer = serializer;\n        this.terminated = false;\n    }\n    verifyInitialized() {\n        if (this.terminated) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');\n        }\n    }\n    /** Invokes the provided RPC with auth and AppCheck tokens. */\n    invokeRPC(rpcName, databaseId, resourcePath, request) {\n        this.verifyInitialized();\n        return Promise.all([\n            this.authCredentials.getToken(),\n            this.appCheckCredentials.getToken()\n        ])\n            .then(([authToken, appCheckToken]) => {\n            return this.connection.invokeRPC(rpcName, toResourcePath(databaseId, resourcePath), request, authToken, appCheckToken);\n        })\n            .catch((error) => {\n            if (error.name === 'FirebaseError') {\n                if (error.code === Code.UNAUTHENTICATED) {\n                    this.authCredentials.invalidateToken();\n                    this.appCheckCredentials.invalidateToken();\n                }\n                throw error;\n            }\n            else {\n                throw new FirestoreError(Code.UNKNOWN, error.toString());\n            }\n        });\n    }\n    /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */\n    invokeStreamingRPC(rpcName, databaseId, resourcePath, request, expectedResponseCount) {\n        this.verifyInitialized();\n        return Promise.all([\n            this.authCredentials.getToken(),\n            this.appCheckCredentials.getToken()\n        ])\n            .then(([authToken, appCheckToken]) => {\n            return this.connection.invokeStreamingRPC(rpcName, toResourcePath(databaseId, resourcePath), request, authToken, appCheckToken, expectedResponseCount);\n        })\n            .catch((error) => {\n            if (error.name === 'FirebaseError') {\n                if (error.code === Code.UNAUTHENTICATED) {\n                    this.authCredentials.invalidateToken();\n                    this.appCheckCredentials.invalidateToken();\n                }\n                throw error;\n            }\n            else {\n                throw new FirestoreError(Code.UNKNOWN, error.toString());\n            }\n        });\n    }\n    terminate() {\n        this.terminated = true;\n        this.connection.terminate();\n    }\n}\n// TODO(firestorexp): Make sure there is only one Datastore instance per\n// firestore-exp client.\nfunction newDatastore(authCredentials, appCheckCredentials, connection, serializer) {\n    return new DatastoreImpl(authCredentials, appCheckCredentials, connection, serializer);\n}\nasync function invokeCommitRpc(datastore, mutations) {\n    const datastoreImpl = debugCast(datastore);\n    const request = {\n        writes: mutations.map(m => toMutation(datastoreImpl.serializer, m))\n    };\n    await datastoreImpl.invokeRPC('Commit', datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), request);\n}\nasync function invokeBatchGetDocumentsRpc(datastore, keys) {\n    const datastoreImpl = debugCast(datastore);\n    const request = {\n        documents: keys.map(k => toName(datastoreImpl.serializer, k))\n    };\n    const response = await datastoreImpl.invokeStreamingRPC('BatchGetDocuments', datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), request, keys.length);\n    const docs = new Map();\n    response.forEach(proto => {\n        const doc = fromBatchGetDocumentsResponse(datastoreImpl.serializer, proto);\n        docs.set(doc.key.toString(), doc);\n    });\n    const result = [];\n    keys.forEach(key => {\n        const doc = docs.get(key.toString());\n        hardAssert(!!doc, 0xd7c2, {\n            key\n        });\n        result.push(doc);\n    });\n    return result;\n}\nasync function invokeExecutePipeline(datastore, structuredPipeline) {\n    const datastoreImpl = debugCast(datastore);\n    const executePipelineRequest = {\n        database: getEncodedDatabaseId(datastoreImpl.serializer),\n        structuredPipeline: structuredPipeline._toProto(datastoreImpl.serializer)\n    };\n    const response = await datastoreImpl.invokeStreamingRPC('ExecutePipeline', datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), executePipelineRequest);\n    const result = [];\n    response.forEach(proto => {\n        if (!proto.results || proto.results.length === 0) {\n            result.push(fromPipelineResponse(datastoreImpl.serializer, proto));\n        }\n        else {\n            return proto.results.forEach(document => result.push(fromPipelineResponse(datastoreImpl.serializer, proto, document)));\n        }\n    });\n    return result;\n}\nasync function invokeRunAggregationQueryRpc(datastore, query, aggregates) {\n    const datastoreImpl = debugCast(datastore);\n    const { request, aliasMap, parent } = toRunAggregationQueryRequest(datastoreImpl.serializer, queryToAggregateTarget(query), aggregates);\n    if (!datastoreImpl.connection.shouldResourcePathBeIncludedInRequest) {\n        delete request.parent;\n    }\n    const response = await datastoreImpl.invokeStreamingRPC('RunAggregationQuery', datastoreImpl.serializer.databaseId, parent, request, \n    /*expectedResponseCount=*/ 1);\n    // Omit RunAggregationQueryResponse that only contain readTimes.\n    const filteredResult = response.filter(proto => !!proto.result);\n    hardAssert(filteredResult.length === 1, 0xfcd7);\n    // Remap the short-form aliases that were sent to the server\n    // to the client-side aliases. Users will access the results\n    // using the client-side alias.\n    const unmappedAggregateFields = filteredResult[0].result?.aggregateFields;\n    const remappedFields = Object.keys(unmappedAggregateFields).reduce((accumulator, key) => {\n        accumulator[aliasMap[key]] = unmappedAggregateFields[key];\n        return accumulator;\n    }, {});\n    return remappedFields;\n}\nfunction newPersistentWriteStream(datastore, queue, listener) {\n    const datastoreImpl = debugCast(datastore);\n    datastoreImpl.verifyInitialized();\n    return new PersistentWriteStream(queue, datastoreImpl.connection, datastoreImpl.authCredentials, datastoreImpl.appCheckCredentials, datastoreImpl.serializer, listener);\n}\nfunction newPersistentWatchStream(datastore, queue, listener) {\n    const datastoreImpl = debugCast(datastore);\n    datastoreImpl.verifyInitialized();\n    return new PersistentListenStream(queue, datastoreImpl.connection, datastoreImpl.authCredentials, datastoreImpl.appCheckCredentials, datastoreImpl.serializer, listener);\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$6 = 'OnlineStateTracker';\n// To deal with transient failures, we allow multiple stream attempts before\n// giving up and transitioning from OnlineState.Unknown to Offline.\n// TODO(mikelehen): This used to be set to 2 as a mitigation for b/66228394.\n// @jdimond thinks that bug is sufficiently fixed so that we can set this back\n// to 1. If that works okay, we could potentially remove this logic entirely.\nconst MAX_WATCH_STREAM_FAILURES = 1;\n// To deal with stream attempts that don't succeed or fail in a timely manner,\n// we have a timeout for OnlineState to reach Online or Offline.\n// If the timeout is reached, we transition to Offline rather than waiting\n// indefinitely.\nconst ONLINE_STATE_TIMEOUT_MS = 10 * 1000;\n/**\n * A component used by the RemoteStore to track the OnlineState (that is,\n * whether or not the client as a whole should be considered to be online or\n * offline), implementing the appropriate heuristics.\n *\n * In particular, when the client is trying to connect to the backend, we\n * allow up to MAX_WATCH_STREAM_FAILURES within ONLINE_STATE_TIMEOUT_MS for\n * a connection to succeed. If we have too many failures or the timeout elapses,\n * then we set the OnlineState to Offline, and the client will behave as if\n * it is offline (get()s will return cached data, etc.).\n */\nclass OnlineStateTracker {\n    constructor(asyncQueue, onlineStateHandler) {\n        this.asyncQueue = asyncQueue;\n        this.onlineStateHandler = onlineStateHandler;\n        /** The current OnlineState. */\n        this.state = \"Unknown\" /* OnlineState.Unknown */;\n        /**\n         * A count of consecutive failures to open the stream. If it reaches the\n         * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to\n         * Offline.\n         */\n        this.watchStreamFailures = 0;\n        /**\n         * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we\n         * transition from OnlineState.Unknown to OnlineState.Offline without waiting\n         * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).\n         */\n        this.onlineStateTimer = null;\n        /**\n         * Whether the client should log a warning message if it fails to connect to\n         * the backend (initially true, cleared after a successful stream, or if we've\n         * logged the message already).\n         */\n        this.shouldWarnClientIsOffline = true;\n    }\n    /**\n     * Called by RemoteStore when a watch stream is started (including on each\n     * backoff attempt).\n     *\n     * If this is the first attempt, it sets the OnlineState to Unknown and starts\n     * the onlineStateTimer.\n     */\n    handleWatchStreamStart() {\n        if (this.watchStreamFailures === 0) {\n            this.setAndBroadcast(\"Unknown\" /* OnlineState.Unknown */);\n            this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(\"online_state_timeout\" /* TimerId.OnlineStateTimeout */, ONLINE_STATE_TIMEOUT_MS, () => {\n                this.onlineStateTimer = null;\n                this.logClientOfflineWarningIfNecessary(`Backend didn't respond within ${ONLINE_STATE_TIMEOUT_MS / 1000} ` +\n                    `seconds.`);\n                this.setAndBroadcast(\"Offline\" /* OnlineState.Offline */);\n                // NOTE: handleWatchStreamFailure() will continue to increment\n                // watchStreamFailures even though we are already marked Offline,\n                // but this is non-harmful.\n                return Promise.resolve();\n            });\n        }\n    }\n    /**\n     * Updates our OnlineState as appropriate after the watch stream reports a\n     * failure. The first failure moves us to the 'Unknown' state. We then may\n     * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we\n     * actually transition to the 'Offline' state.\n     */\n    handleWatchStreamFailure(error) {\n        if (this.state === \"Online\" /* OnlineState.Online */) {\n            this.setAndBroadcast(\"Unknown\" /* OnlineState.Unknown */);\n        }\n        else {\n            this.watchStreamFailures++;\n            if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {\n                this.clearOnlineStateTimer();\n                this.logClientOfflineWarningIfNecessary(`Connection failed ${MAX_WATCH_STREAM_FAILURES} ` +\n                    `times. Most recent error: ${error.toString()}`);\n                this.setAndBroadcast(\"Offline\" /* OnlineState.Offline */);\n            }\n        }\n    }\n    /**\n     * Explicitly sets the OnlineState to the specified state.\n     *\n     * Note that this resets our timers / failure counters, etc. used by our\n     * Offline heuristics, so must not be used in place of\n     * handleWatchStreamStart() and handleWatchStreamFailure().\n     */\n    set(newState) {\n        this.clearOnlineStateTimer();\n        this.watchStreamFailures = 0;\n        if (newState === \"Online\" /* OnlineState.Online */) {\n            // We've connected to watch at least once. Don't warn the developer\n            // about being offline going forward.\n            this.shouldWarnClientIsOffline = false;\n        }\n        this.setAndBroadcast(newState);\n    }\n    setAndBroadcast(newState) {\n        if (newState !== this.state) {\n            this.state = newState;\n            this.onlineStateHandler(newState);\n        }\n    }\n    logClientOfflineWarningIfNecessary(details) {\n        const message = `Could not reach Cloud Firestore backend. ${details}\\n` +\n            `This typically indicates that your device does not have a healthy ` +\n            `Internet connection at the moment. The client will operate in offline ` +\n            `mode until it is able to successfully connect to the backend.`;\n        if (this.shouldWarnClientIsOffline) {\n            logError(message);\n            this.shouldWarnClientIsOffline = false;\n        }\n        else {\n            logDebug(LOG_TAG$6, message);\n        }\n    }\n    clearOnlineStateTimer() {\n        if (this.onlineStateTimer !== null) {\n            this.onlineStateTimer.cancel();\n            this.onlineStateTimer = null;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$5 = 'RemoteStore';\n// TODO(b/35853402): Negotiate this with the stream.\nconst MAX_PENDING_WRITES = 10;\nclass RemoteStoreImpl {\n    constructor(\n    /**\n     * The local store, used to fill the write pipeline with outbound mutations.\n     */\n    localStore, \n    /** The client-side proxy for interacting with the backend. */\n    datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {\n        this.localStore = localStore;\n        this.datastore = datastore;\n        this.asyncQueue = asyncQueue;\n        this.remoteSyncer = {};\n        /**\n         * A list of up to MAX_PENDING_WRITES writes that we have fetched from the\n         * LocalStore via fillWritePipeline() and have or will send to the write\n         * stream.\n         *\n         * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or\n         * restart the write stream. When the stream is established the writes in the\n         * pipeline will be sent in order.\n         *\n         * Writes remain in writePipeline until they are acknowledged by the backend\n         * and thus will automatically be re-sent if the stream is interrupted /\n         * restarted before they're acknowledged.\n         *\n         * Write responses from the backend are linked to their originating request\n         * purely based on order, and so we can just shift() writes from the front of\n         * the writePipeline as we receive responses.\n         */\n        this.writePipeline = [];\n        /**\n         * A mapping of watched targets that the client cares about tracking and the\n         * user has explicitly called a 'listen' for this target.\n         *\n         * These targets may or may not have been sent to or acknowledged by the\n         * server. On re-establishing the listen stream, these targets should be sent\n         * to the server. The targets removed with unlistens are removed eagerly\n         * without waiting for confirmation from the listen stream.\n         */\n        this.listenTargets = new Map();\n        /**\n         * A set of reasons for why the RemoteStore may be offline. If empty, the\n         * RemoteStore may start its network connections.\n         */\n        this.offlineCauses = new Set();\n        /**\n         * Event handlers that get called when the network is disabled or enabled.\n         *\n         * PORTING NOTE: These functions are used on the Web client to create the\n         * underlying streams (to support tree-shakeable streams). On Android and iOS,\n         * the streams are created during construction of RemoteStore.\n         */\n        this.onNetworkStatusChange = [];\n        this.connectivityMonitor = connectivityMonitor;\n        this.connectivityMonitor.addCallback((_) => {\n            asyncQueue.enqueueAndForget(async () => {\n                // Porting Note: Unlike iOS, `restartNetwork()` is called even when the\n                // network becomes unreachable as we don't have any other way to tear\n                // down our streams.\n                if (canUseNetwork(this)) {\n                    logDebug(LOG_TAG$5, 'Restarting streams for network reachability change.');\n                    await restartNetwork(this);\n                }\n            });\n        });\n        this.onlineStateTracker = new OnlineStateTracker(asyncQueue, onlineStateHandler);\n    }\n}\nfunction newRemoteStore(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {\n    return new RemoteStoreImpl(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor);\n}\n/** Re-enables the network. Idempotent. */\nfunction remoteStoreEnableNetwork(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    remoteStoreImpl.offlineCauses.delete(0 /* OfflineCause.UserDisabled */);\n    return enableNetworkInternal(remoteStoreImpl);\n}\nasync function enableNetworkInternal(remoteStoreImpl) {\n    if (canUseNetwork(remoteStoreImpl)) {\n        for (const networkStatusHandler of remoteStoreImpl.onNetworkStatusChange) {\n            await networkStatusHandler(/* enabled= */ true);\n        }\n    }\n}\n/**\n * Temporarily disables the network. The network can be re-enabled using\n * enableNetwork().\n */\nasync function remoteStoreDisableNetwork(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    remoteStoreImpl.offlineCauses.add(0 /* OfflineCause.UserDisabled */);\n    await disableNetworkInternal(remoteStoreImpl);\n    // Set the OnlineState to Offline so get()s return from cache, etc.\n    remoteStoreImpl.onlineStateTracker.set(\"Offline\" /* OnlineState.Offline */);\n}\nasync function disableNetworkInternal(remoteStoreImpl) {\n    for (const networkStatusHandler of remoteStoreImpl.onNetworkStatusChange) {\n        await networkStatusHandler(/* enabled= */ false);\n    }\n}\nasync function remoteStoreShutdown(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    logDebug(LOG_TAG$5, 'RemoteStore shutting down.');\n    remoteStoreImpl.offlineCauses.add(5 /* OfflineCause.Shutdown */);\n    await disableNetworkInternal(remoteStoreImpl);\n    remoteStoreImpl.connectivityMonitor.shutdown();\n    // Set the OnlineState to Unknown (rather than Offline) to avoid potentially\n    // triggering spurious listener events with cached data, etc.\n    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n}\n/**\n * Starts new listen for the given target. Uses resume token if provided. It\n * is a no-op if the target of given `TargetData` is already being listened to.\n */\nfunction remoteStoreListen(remoteStore, targetData) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    if (remoteStoreImpl.listenTargets.has(targetData.targetId)) {\n        return;\n    }\n    // Mark this as something the client is currently listening for.\n    remoteStoreImpl.listenTargets.set(targetData.targetId, targetData);\n    if (shouldStartWatchStream(remoteStoreImpl)) {\n        // The listen will be sent in onWatchStreamOpen\n        startWatchStream(remoteStoreImpl);\n    }\n    else if (ensureWatchStream(remoteStoreImpl).isOpen()) {\n        sendWatchRequest(remoteStoreImpl, targetData);\n    }\n}\n/**\n * Removes the listen from server. It is a no-op if the given target id is\n * not being listened to.\n */\nfunction remoteStoreUnlisten(remoteStore, targetId) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    const watchStream = ensureWatchStream(remoteStoreImpl);\n    remoteStoreImpl.listenTargets.delete(targetId);\n    if (watchStream.isOpen()) {\n        sendUnwatchRequest(remoteStoreImpl, targetId);\n    }\n    if (remoteStoreImpl.listenTargets.size === 0) {\n        if (watchStream.isOpen()) {\n            watchStream.markIdle();\n        }\n        else if (canUseNetwork(remoteStoreImpl)) {\n            // Revert to OnlineState.Unknown if the watch stream is not open and we\n            // have no listeners, since without any listens to send we cannot\n            // confirm if the stream is healthy and upgrade to OnlineState.Online.\n            remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n        }\n    }\n}\n/**\n * We need to increment the expected number of pending responses we're due\n * from watch so we wait for the ack to process any messages from this target.\n */\nfunction sendWatchRequest(remoteStoreImpl, targetData) {\n    remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetData.targetId);\n    if (targetData.resumeToken.approximateByteSize() > 0 ||\n        targetData.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {\n        const expectedCount = remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetData.targetId).size;\n        targetData = targetData.withExpectedCount(expectedCount);\n    }\n    ensureWatchStream(remoteStoreImpl).watch(targetData);\n}\n/**\n * We need to increment the expected number of pending responses we're due\n * from watch so we wait for the removal on the server before we process any\n * messages from this target.\n */\nfunction sendUnwatchRequest(remoteStoreImpl, targetId) {\n    remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetId);\n    ensureWatchStream(remoteStoreImpl).unwatch(targetId);\n}\nfunction startWatchStream(remoteStoreImpl) {\n    remoteStoreImpl.watchChangeAggregator = new WatchChangeAggregator({\n        getRemoteKeysForTarget: targetId => remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetId),\n        getTargetDataForTarget: targetId => remoteStoreImpl.listenTargets.get(targetId) || null,\n        getDatabaseId: () => remoteStoreImpl.datastore.serializer.databaseId\n    });\n    ensureWatchStream(remoteStoreImpl).start();\n    remoteStoreImpl.onlineStateTracker.handleWatchStreamStart();\n}\n/**\n * Returns whether the watch stream should be started because it's necessary\n * and has not yet been started.\n */\nfunction shouldStartWatchStream(remoteStoreImpl) {\n    return (canUseNetwork(remoteStoreImpl) &&\n        !ensureWatchStream(remoteStoreImpl).isStarted() &&\n        remoteStoreImpl.listenTargets.size > 0);\n}\nfunction canUseNetwork(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    return remoteStoreImpl.offlineCauses.size === 0;\n}\nfunction cleanUpWatchStreamState(remoteStoreImpl) {\n    remoteStoreImpl.watchChangeAggregator = undefined;\n}\nasync function onWatchStreamConnected(remoteStoreImpl) {\n    // Mark the client as online since we got a \"connected\" notification.\n    remoteStoreImpl.onlineStateTracker.set(\"Online\" /* OnlineState.Online */);\n}\nasync function onWatchStreamOpen(remoteStoreImpl) {\n    remoteStoreImpl.listenTargets.forEach((targetData, targetId) => {\n        sendWatchRequest(remoteStoreImpl, targetData);\n    });\n}\nasync function onWatchStreamClose(remoteStoreImpl, error) {\n    cleanUpWatchStreamState(remoteStoreImpl);\n    // If we still need the watch stream, retry the connection.\n    if (shouldStartWatchStream(remoteStoreImpl)) {\n        remoteStoreImpl.onlineStateTracker.handleWatchStreamFailure(error);\n        startWatchStream(remoteStoreImpl);\n    }\n    else {\n        // No need to restart watch stream because there are no active targets.\n        // The online state is set to unknown because there is no active attempt\n        // at establishing a connection\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n    }\n}\nasync function onWatchStreamChange(remoteStoreImpl, watchChange, snapshotVersion) {\n    // Mark the client as online since we got a message from the server\n    remoteStoreImpl.onlineStateTracker.set(\"Online\" /* OnlineState.Online */);\n    if (watchChange instanceof WatchTargetChange &&\n        watchChange.state === 2 /* WatchTargetChangeState.Removed */ &&\n        watchChange.cause) {\n        // There was an error on a target, don't wait for a consistent snapshot\n        // to raise events\n        try {\n            await handleTargetError(remoteStoreImpl, watchChange);\n        }\n        catch (e) {\n            logDebug(LOG_TAG$5, 'Failed to remove targets %s: %s ', watchChange.targetIds.join(','), e);\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\n        }\n        return;\n    }\n    if (watchChange instanceof DocumentWatchChange) {\n        remoteStoreImpl.watchChangeAggregator.handleDocumentChange(watchChange);\n    }\n    else if (watchChange instanceof ExistenceFilterChange) {\n        remoteStoreImpl.watchChangeAggregator.handleExistenceFilter(watchChange);\n    }\n    else {\n        remoteStoreImpl.watchChangeAggregator.handleTargetChange(watchChange);\n    }\n    if (!snapshotVersion.isEqual(SnapshotVersion.min())) {\n        try {\n            const lastRemoteSnapshotVersion = await localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);\n            if (snapshotVersion.compareTo(lastRemoteSnapshotVersion) >= 0) {\n                // We have received a target change with a global snapshot if the snapshot\n                // version is not equal to SnapshotVersion.min().\n                await raiseWatchSnapshot(remoteStoreImpl, snapshotVersion);\n            }\n        }\n        catch (e) {\n            logDebug(LOG_TAG$5, 'Failed to raise snapshot:', e);\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\n        }\n    }\n}\n/**\n * Recovery logic for IndexedDB errors that takes the network offline until\n * `op` succeeds. Retries are scheduled with backoff using\n * `enqueueRetryable()`. If `op()` is not provided, IndexedDB access is\n * validated via a generic operation.\n *\n * The returned Promise is resolved once the network is disabled and before\n * any retry attempt.\n */\nasync function disableNetworkUntilRecovery(remoteStoreImpl, e, op) {\n    if (isIndexedDbTransactionError(e)) {\n        remoteStoreImpl.offlineCauses.add(1 /* OfflineCause.IndexedDbFailed */);\n        // Disable network and raise offline snapshots\n        await disableNetworkInternal(remoteStoreImpl);\n        remoteStoreImpl.onlineStateTracker.set(\"Offline\" /* OnlineState.Offline */);\n        if (!op) {\n            // Use a simple read operation to determine if IndexedDB recovered.\n            // Ideally, we would expose a health check directly on SimpleDb, but\n            // RemoteStore only has access to persistence through LocalStore.\n            op = () => localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);\n        }\n        // Probe IndexedDB periodically and re-enable network\n        remoteStoreImpl.asyncQueue.enqueueRetryable(async () => {\n            logDebug(LOG_TAG$5, 'Retrying IndexedDB access');\n            await op();\n            remoteStoreImpl.offlineCauses.delete(1 /* OfflineCause.IndexedDbFailed */);\n            await enableNetworkInternal(remoteStoreImpl);\n        });\n    }\n    else {\n        throw e;\n    }\n}\n/**\n * Executes `op`. If `op` fails, takes the network offline until `op`\n * succeeds. Returns after the first attempt.\n */\nfunction executeWithRecovery(remoteStoreImpl, op) {\n    return op().catch(e => disableNetworkUntilRecovery(remoteStoreImpl, e, op));\n}\n/**\n * Takes a batch of changes from the Datastore, repackages them as a\n * RemoteEvent, and passes that on to the listener, which is typically the\n * SyncEngine.\n */\nfunction raiseWatchSnapshot(remoteStoreImpl, snapshotVersion) {\n    const remoteEvent = remoteStoreImpl.watchChangeAggregator.createRemoteEvent(snapshotVersion);\n    // Update in-memory resume tokens. LocalStore will update the\n    // persistent view of these when applying the completed RemoteEvent.\n    remoteEvent.targetChanges.forEach((change, targetId) => {\n        if (change.resumeToken.approximateByteSize() > 0) {\n            const targetData = remoteStoreImpl.listenTargets.get(targetId);\n            // A watched target might have been removed already.\n            if (targetData) {\n                remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(change.resumeToken, snapshotVersion));\n            }\n        }\n    });\n    // Re-establish listens for the targets that have been invalidated by\n    // existence filter mismatches.\n    remoteEvent.targetMismatches.forEach((targetId, targetPurpose) => {\n        const targetData = remoteStoreImpl.listenTargets.get(targetId);\n        if (!targetData) {\n            // A watched target might have been removed already.\n            return;\n        }\n        // Clear the resume token for the target, since we're in a known mismatch\n        // state.\n        remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(ByteString.EMPTY_BYTE_STRING, targetData.snapshotVersion));\n        // Cause a hard reset by unwatching and rewatching immediately, but\n        // deliberately don't send a resume token so that we get a full update.\n        sendUnwatchRequest(remoteStoreImpl, targetId);\n        // Mark the target we send as being on behalf of an existence filter\n        // mismatch, but don't actually retain that in listenTargets. This ensures\n        // that we flag the first re-listen this way without impacting future\n        // listens of this target (that might happen e.g. on reconnect).\n        const requestTargetData = new TargetData(targetData.target, targetId, targetPurpose, targetData.sequenceNumber);\n        sendWatchRequest(remoteStoreImpl, requestTargetData);\n    });\n    return remoteStoreImpl.remoteSyncer.applyRemoteEvent(remoteEvent);\n}\n/** Handles an error on a target */\nasync function handleTargetError(remoteStoreImpl, watchChange) {\n    const error = watchChange.cause;\n    for (const targetId of watchChange.targetIds) {\n        // A watched target might have been removed already.\n        if (remoteStoreImpl.listenTargets.has(targetId)) {\n            await remoteStoreImpl.remoteSyncer.rejectListen(targetId, error);\n            remoteStoreImpl.listenTargets.delete(targetId);\n            remoteStoreImpl.watchChangeAggregator.removeTarget(targetId);\n        }\n    }\n}\n/**\n * Attempts to fill our write pipeline with writes from the LocalStore.\n *\n * Called internally to bootstrap or refill the write pipeline and by\n * SyncEngine whenever there are new mutations to process.\n *\n * Starts the write stream if necessary.\n */\nasync function fillWritePipeline(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    const writeStream = ensureWriteStream(remoteStoreImpl);\n    let lastBatchIdRetrieved = remoteStoreImpl.writePipeline.length > 0\n        ? remoteStoreImpl.writePipeline[remoteStoreImpl.writePipeline.length - 1]\n            .batchId\n        : BATCHID_UNKNOWN;\n    while (canAddToWritePipeline(remoteStoreImpl)) {\n        try {\n            const batch = await localStoreGetNextMutationBatch(remoteStoreImpl.localStore, lastBatchIdRetrieved);\n            if (batch === null) {\n                if (remoteStoreImpl.writePipeline.length === 0) {\n                    writeStream.markIdle();\n                }\n                break;\n            }\n            else {\n                lastBatchIdRetrieved = batch.batchId;\n                addToWritePipeline(remoteStoreImpl, batch);\n            }\n        }\n        catch (e) {\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\n        }\n    }\n    if (shouldStartWriteStream(remoteStoreImpl)) {\n        startWriteStream(remoteStoreImpl);\n    }\n}\n/**\n * Returns true if we can add to the write pipeline (i.e. the network is\n * enabled and the write pipeline is not full).\n */\nfunction canAddToWritePipeline(remoteStoreImpl) {\n    return (canUseNetwork(remoteStoreImpl) &&\n        remoteStoreImpl.writePipeline.length < MAX_PENDING_WRITES);\n}\n/**\n * Queues additional writes to be sent to the write stream, sending them\n * immediately if the write stream is established.\n */\nfunction addToWritePipeline(remoteStoreImpl, batch) {\n    remoteStoreImpl.writePipeline.push(batch);\n    const writeStream = ensureWriteStream(remoteStoreImpl);\n    if (writeStream.isOpen() && writeStream.handshakeComplete) {\n        writeStream.writeMutations(batch.mutations);\n    }\n}\nfunction shouldStartWriteStream(remoteStoreImpl) {\n    return (canUseNetwork(remoteStoreImpl) &&\n        !ensureWriteStream(remoteStoreImpl).isStarted() &&\n        remoteStoreImpl.writePipeline.length > 0);\n}\nfunction startWriteStream(remoteStoreImpl) {\n    ensureWriteStream(remoteStoreImpl).start();\n}\nasync function onWriteStreamOpen(remoteStoreImpl) {\n    ensureWriteStream(remoteStoreImpl).writeHandshake();\n}\nasync function onWriteHandshakeComplete(remoteStoreImpl) {\n    const writeStream = ensureWriteStream(remoteStoreImpl);\n    // Send the write pipeline now that the stream is established.\n    for (const batch of remoteStoreImpl.writePipeline) {\n        writeStream.writeMutations(batch.mutations);\n    }\n}\nasync function onMutationResult(remoteStoreImpl, commitVersion, results) {\n    const batch = remoteStoreImpl.writePipeline.shift();\n    const success = MutationBatchResult.from(batch, commitVersion, results);\n    await executeWithRecovery(remoteStoreImpl, () => remoteStoreImpl.remoteSyncer.applySuccessfulWrite(success));\n    // It's possible that with the completion of this mutation another\n    // slot has freed up.\n    await fillWritePipeline(remoteStoreImpl);\n}\nasync function onWriteStreamClose(remoteStoreImpl, error) {\n    // If the write stream closed after the write handshake completes, a write\n    // operation failed and we fail the pending operation.\n    if (error && ensureWriteStream(remoteStoreImpl).handshakeComplete) {\n        // This error affects the actual write.\n        await handleWriteError(remoteStoreImpl, error);\n    }\n    // The write stream might have been started by refilling the write\n    // pipeline for failed writes\n    if (shouldStartWriteStream(remoteStoreImpl)) {\n        startWriteStream(remoteStoreImpl);\n    }\n}\nasync function handleWriteError(remoteStoreImpl, error) {\n    // Only handle permanent errors here. If it's transient, just let the retry\n    // logic kick in.\n    if (isPermanentWriteError(error.code)) {\n        // This was a permanent error, the request itself was the problem\n        // so it's not going to succeed if we resend it.\n        const batch = remoteStoreImpl.writePipeline.shift();\n        // In this case it's also unlikely that the server itself is melting\n        // down -- this was just a bad request so inhibit backoff on the next\n        // restart.\n        ensureWriteStream(remoteStoreImpl).inhibitBackoff();\n        await executeWithRecovery(remoteStoreImpl, () => remoteStoreImpl.remoteSyncer.rejectFailedWrite(batch.batchId, error));\n        // It's possible that with the completion of this mutation\n        // another slot has freed up.\n        await fillWritePipeline(remoteStoreImpl);\n    }\n}\nasync function restartNetwork(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    remoteStoreImpl.offlineCauses.add(4 /* OfflineCause.ConnectivityChange */);\n    await disableNetworkInternal(remoteStoreImpl);\n    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n    remoteStoreImpl.offlineCauses.delete(4 /* OfflineCause.ConnectivityChange */);\n    await enableNetworkInternal(remoteStoreImpl);\n}\nasync function remoteStoreHandleCredentialChange(remoteStore, user) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    remoteStoreImpl.asyncQueue.verifyOperationInProgress();\n    logDebug(LOG_TAG$5, 'RemoteStore received new credentials');\n    const usesNetwork = canUseNetwork(remoteStoreImpl);\n    // Tear down and re-create our network streams. This will ensure we get a\n    // fresh auth token for the new user and re-fill the write pipeline with\n    // new mutations from the LocalStore (since mutations are per-user).\n    remoteStoreImpl.offlineCauses.add(3 /* OfflineCause.CredentialChange */);\n    await disableNetworkInternal(remoteStoreImpl);\n    if (usesNetwork) {\n        // Don't set the network status to Unknown if we are offline.\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n    }\n    await remoteStoreImpl.remoteSyncer.handleCredentialChange(user);\n    remoteStoreImpl.offlineCauses.delete(3 /* OfflineCause.CredentialChange */);\n    await enableNetworkInternal(remoteStoreImpl);\n}\n/**\n * Toggles the network state when the client gains or loses its primary lease.\n */\nasync function remoteStoreApplyPrimaryState(remoteStore, isPrimary) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    if (isPrimary) {\n        remoteStoreImpl.offlineCauses.delete(2 /* OfflineCause.IsSecondary */);\n        await enableNetworkInternal(remoteStoreImpl);\n    }\n    else if (!isPrimary) {\n        remoteStoreImpl.offlineCauses.add(2 /* OfflineCause.IsSecondary */);\n        await disableNetworkInternal(remoteStoreImpl);\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n    }\n}\n/**\n * If not yet initialized, registers the WatchStream and its network state\n * callback with `remoteStoreImpl`. Returns the existing stream if one is\n * already available.\n *\n * PORTING NOTE: On iOS and Android, the WatchStream gets registered on startup.\n * This is not done on Web to allow it to be tree-shaken.\n */\nfunction ensureWatchStream(remoteStoreImpl) {\n    if (!remoteStoreImpl.watchStream) {\n        // Create stream (but note that it is not started yet).\n        remoteStoreImpl.watchStream = newPersistentWatchStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {\n            onConnected: onWatchStreamConnected.bind(null, remoteStoreImpl),\n            onOpen: onWatchStreamOpen.bind(null, remoteStoreImpl),\n            onClose: onWatchStreamClose.bind(null, remoteStoreImpl),\n            onWatchChange: onWatchStreamChange.bind(null, remoteStoreImpl)\n        });\n        remoteStoreImpl.onNetworkStatusChange.push(async (enabled) => {\n            if (enabled) {\n                remoteStoreImpl.watchStream.inhibitBackoff();\n                if (shouldStartWatchStream(remoteStoreImpl)) {\n                    startWatchStream(remoteStoreImpl);\n                }\n                else {\n                    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n                }\n            }\n            else {\n                await remoteStoreImpl.watchStream.stop();\n                cleanUpWatchStreamState(remoteStoreImpl);\n            }\n        });\n    }\n    return remoteStoreImpl.watchStream;\n}\n/**\n * If not yet initialized, registers the WriteStream and its network state\n * callback with `remoteStoreImpl`. Returns the existing stream if one is\n * already available.\n *\n * PORTING NOTE: On iOS and Android, the WriteStream gets registered on startup.\n * This is not done on Web to allow it to be tree-shaken.\n */\nfunction ensureWriteStream(remoteStoreImpl) {\n    if (!remoteStoreImpl.writeStream) {\n        // Create stream (but note that it is not started yet).\n        remoteStoreImpl.writeStream = newPersistentWriteStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {\n            onConnected: () => Promise.resolve(),\n            onOpen: onWriteStreamOpen.bind(null, remoteStoreImpl),\n            onClose: onWriteStreamClose.bind(null, remoteStoreImpl),\n            onHandshakeComplete: onWriteHandshakeComplete.bind(null, remoteStoreImpl),\n            onMutationResult: onMutationResult.bind(null, remoteStoreImpl)\n        });\n        remoteStoreImpl.onNetworkStatusChange.push(async (enabled) => {\n            if (enabled) {\n                remoteStoreImpl.writeStream.inhibitBackoff();\n                // This will start the write stream if necessary.\n                await fillWritePipeline(remoteStoreImpl);\n            }\n            else {\n                await remoteStoreImpl.writeStream.stop();\n                if (remoteStoreImpl.writePipeline.length > 0) {\n                    logDebug(LOG_TAG$5, `Stopping write stream with ${remoteStoreImpl.writePipeline.length} pending writes`);\n                    remoteStoreImpl.writePipeline = [];\n                }\n            }\n        });\n    }\n    return remoteStoreImpl.writeStream;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$4 = 'AsyncQueue';\n/**\n * Represents an operation scheduled to be run in the future on an AsyncQueue.\n *\n * It is created via DelayedOperation.createAndSchedule().\n *\n * Supports cancellation (via cancel()) and early execution (via skipDelay()).\n *\n * Note: We implement `PromiseLike` instead of `Promise`, as the `Promise` type\n * in newer versions of TypeScript defines `finally`, which is not available in\n * IE.\n */\nclass DelayedOperation {\n    constructor(asyncQueue, timerId, targetTimeMs, op, removalCallback) {\n        this.asyncQueue = asyncQueue;\n        this.timerId = timerId;\n        this.targetTimeMs = targetTimeMs;\n        this.op = op;\n        this.removalCallback = removalCallback;\n        this.deferred = new Deferred();\n        this.then = this.deferred.promise.then.bind(this.deferred.promise);\n        // It's normal for the deferred promise to be canceled (due to cancellation)\n        // and so we attach a dummy catch callback to avoid\n        // 'UnhandledPromiseRejectionWarning' log spam.\n        this.deferred.promise.catch(err => { });\n    }\n    get promise() {\n        return this.deferred.promise;\n    }\n    /**\n     * Creates and returns a DelayedOperation that has been scheduled to be\n     * executed on the provided asyncQueue after the provided delayMs.\n     *\n     * @param asyncQueue - The queue to schedule the operation on.\n     * @param id - A Timer ID identifying the type of operation this is.\n     * @param delayMs - The delay (ms) before the operation should be scheduled.\n     * @param op - The operation to run.\n     * @param removalCallback - A callback to be called synchronously once the\n     *   operation is executed or canceled, notifying the AsyncQueue to remove it\n     *   from its delayedOperations list.\n     *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and\n     *   the DelayedOperation class public.\n     */\n    static createAndSchedule(asyncQueue, timerId, delayMs, op, removalCallback) {\n        const targetTime = Date.now() + delayMs;\n        const delayedOp = new DelayedOperation(asyncQueue, timerId, targetTime, op, removalCallback);\n        delayedOp.start(delayMs);\n        return delayedOp;\n    }\n    /**\n     * Starts the timer. This is called immediately after construction by\n     * createAndSchedule().\n     */\n    start(delayMs) {\n        this.timerHandle = setTimeout(() => this.handleDelayElapsed(), delayMs);\n    }\n    /**\n     * Queues the operation to run immediately (if it hasn't already been run or\n     * canceled).\n     */\n    skipDelay() {\n        return this.handleDelayElapsed();\n    }\n    /**\n     * Cancels the operation if it hasn't already been executed or canceled. The\n     * promise will be rejected.\n     *\n     * As long as the operation has not yet been run, calling cancel() provides a\n     * guarantee that the operation will not be run.\n     */\n    cancel(reason) {\n        if (this.timerHandle !== null) {\n            this.clearTimeout();\n            this.deferred.reject(new FirestoreError(Code.CANCELLED, 'Operation cancelled' + (reason ? ': ' + reason : '')));\n        }\n    }\n    handleDelayElapsed() {\n        this.asyncQueue.enqueueAndForget(() => {\n            if (this.timerHandle !== null) {\n                this.clearTimeout();\n                return this.op().then(result => {\n                    return this.deferred.resolve(result);\n                });\n            }\n            else {\n                return Promise.resolve();\n            }\n        });\n    }\n    clearTimeout() {\n        if (this.timerHandle !== null) {\n            this.removalCallback(this);\n            clearTimeout(this.timerHandle);\n            this.timerHandle = null;\n        }\n    }\n}\n/**\n * Returns a FirestoreError that can be surfaced to the user if the provided\n * error is an IndexedDbTransactionError. Re-throws the error otherwise.\n */\nfunction wrapInUserErrorIfRecoverable(e, msg) {\n    logError(LOG_TAG$4, `${msg}: ${e}`);\n    if (isIndexedDbTransactionError(e)) {\n        return new FirestoreError(Code.UNAVAILABLE, `${msg}: ${e}`);\n    }\n    else {\n        throw e;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\n * in order specified by the provided comparator. We always add a document key\n * comparator on top of what is provided to guarantee document equality based on\n * the key.\n */\nclass DocumentSet {\n    /**\n     * Returns an empty copy of the existing DocumentSet, using the same\n     * comparator.\n     */\n    static emptySet(oldSet) {\n        return new DocumentSet(oldSet.comparator);\n    }\n    /** The default ordering is by key if the comparator is omitted */\n    constructor(comp) {\n        // We are adding document key comparator to the end as it's the only\n        // guaranteed unique property of a document.\n        if (comp) {\n            this.comparator = (d1, d2) => comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);\n        }\n        else {\n            this.comparator = (d1, d2) => DocumentKey.comparator(d1.key, d2.key);\n        }\n        this.keyedMap = documentMap();\n        this.sortedSet = new SortedMap(this.comparator);\n    }\n    has(key) {\n        return this.keyedMap.get(key) != null;\n    }\n    get(key) {\n        return this.keyedMap.get(key);\n    }\n    first() {\n        return this.sortedSet.minKey();\n    }\n    last() {\n        return this.sortedSet.maxKey();\n    }\n    isEmpty() {\n        return this.sortedSet.isEmpty();\n    }\n    /**\n     * Returns the index of the provided key in the document set, or -1 if the\n     * document key is not present in the set;\n     */\n    indexOf(key) {\n        const doc = this.keyedMap.get(key);\n        return doc ? this.sortedSet.indexOf(doc) : -1;\n    }\n    get size() {\n        return this.sortedSet.size;\n    }\n    /** Iterates documents in order defined by \"comparator\" */\n    forEach(cb) {\n        this.sortedSet.inorderTraversal((k, v) => {\n            cb(k);\n            return false;\n        });\n    }\n    /** Inserts or updates a document with the same key */\n    add(doc) {\n        // First remove the element if we have it.\n        const set = this.delete(doc.key);\n        return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));\n    }\n    /** Deletes a document with a given key */\n    delete(key) {\n        const doc = this.get(key);\n        if (!doc) {\n            return this;\n        }\n        return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\n    }\n    isEqual(other) {\n        if (!(other instanceof DocumentSet)) {\n            return false;\n        }\n        if (this.size !== other.size) {\n            return false;\n        }\n        const thisIt = this.sortedSet.getIterator();\n        const otherIt = other.sortedSet.getIterator();\n        while (thisIt.hasNext()) {\n            const thisDoc = thisIt.getNext().key;\n            const otherDoc = otherIt.getNext().key;\n            if (!thisDoc.isEqual(otherDoc)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    toString() {\n        const docStrings = [];\n        this.forEach(doc => {\n            docStrings.push(doc.toString());\n        });\n        if (docStrings.length === 0) {\n            return 'DocumentSet ()';\n        }\n        else {\n            return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\n        }\n    }\n    copy(keyedMap, sortedSet) {\n        const newSet = new DocumentSet();\n        newSet.comparator = this.comparator;\n        newSet.keyedMap = keyedMap;\n        newSet.sortedSet = sortedSet;\n        return newSet;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * DocumentChangeSet keeps track of a set of changes to docs in a query, merging\n * duplicate events for the same doc.\n */\nclass DocumentChangeSet {\n    constructor() {\n        this.changeMap = new SortedMap(DocumentKey.comparator);\n    }\n    track(change) {\n        const key = change.doc.key;\n        const oldChange = this.changeMap.get(key);\n        if (!oldChange) {\n            this.changeMap = this.changeMap.insert(key, change);\n            return;\n        }\n        // Merge the new change with the existing change.\n        if (change.type !== 0 /* ChangeType.Added */ &&\n            oldChange.type === 3 /* ChangeType.Metadata */) {\n            this.changeMap = this.changeMap.insert(key, change);\n        }\n        else if (change.type === 3 /* ChangeType.Metadata */ &&\n            oldChange.type !== 1 /* ChangeType.Removed */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: oldChange.type,\n                doc: change.doc\n            });\n        }\n        else if (change.type === 2 /* ChangeType.Modified */ &&\n            oldChange.type === 2 /* ChangeType.Modified */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: 2 /* ChangeType.Modified */,\n                doc: change.doc\n            });\n        }\n        else if (change.type === 2 /* ChangeType.Modified */ &&\n            oldChange.type === 0 /* ChangeType.Added */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: 0 /* ChangeType.Added */,\n                doc: change.doc\n            });\n        }\n        else if (change.type === 1 /* ChangeType.Removed */ &&\n            oldChange.type === 0 /* ChangeType.Added */) {\n            this.changeMap = this.changeMap.remove(key);\n        }\n        else if (change.type === 1 /* ChangeType.Removed */ &&\n            oldChange.type === 2 /* ChangeType.Modified */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: 1 /* ChangeType.Removed */,\n                doc: oldChange.doc\n            });\n        }\n        else if (change.type === 0 /* ChangeType.Added */ &&\n            oldChange.type === 1 /* ChangeType.Removed */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: 2 /* ChangeType.Modified */,\n                doc: change.doc\n            });\n        }\n        else {\n            // This includes these cases, which don't make sense:\n            // Added->Added\n            // Removed->Removed\n            // Modified->Added\n            // Removed->Modified\n            // Metadata->Added\n            // Removed->Metadata\n            fail(0xf76d, {\n                change,\n                oldChange\n            });\n        }\n    }\n    getChanges() {\n        const changes = [];\n        this.changeMap.inorderTraversal((key, change) => {\n            changes.push(change);\n        });\n        return changes;\n    }\n}\nclass ViewSnapshot {\n    constructor(query, docs, oldDocs, docChanges, mutatedKeys, fromCache, syncStateChanged, excludesMetadataChanges, hasCachedResults) {\n        this.query = query;\n        this.docs = docs;\n        this.oldDocs = oldDocs;\n        this.docChanges = docChanges;\n        this.mutatedKeys = mutatedKeys;\n        this.fromCache = fromCache;\n        this.syncStateChanged = syncStateChanged;\n        this.excludesMetadataChanges = excludesMetadataChanges;\n        this.hasCachedResults = hasCachedResults;\n    }\n    /** Returns a view snapshot as if all documents in the snapshot were added. */\n    static fromInitialDocuments(query, documents, mutatedKeys, fromCache, hasCachedResults) {\n        const changes = [];\n        documents.forEach(doc => {\n            changes.push({ type: 0 /* ChangeType.Added */, doc });\n        });\n        return new ViewSnapshot(query, documents, DocumentSet.emptySet(documents), changes, mutatedKeys, fromCache, \n        /* syncStateChanged= */ true, \n        /* excludesMetadataChanges= */ false, hasCachedResults);\n    }\n    get hasPendingWrites() {\n        return !this.mutatedKeys.isEmpty();\n    }\n    isEqual(other) {\n        if (this.fromCache !== other.fromCache ||\n            this.hasCachedResults !== other.hasCachedResults ||\n            this.syncStateChanged !== other.syncStateChanged ||\n            !this.mutatedKeys.isEqual(other.mutatedKeys) ||\n            !queryEquals(this.query, other.query) ||\n            !this.docs.isEqual(other.docs) ||\n            !this.oldDocs.isEqual(other.oldDocs)) {\n            return false;\n        }\n        const changes = this.docChanges;\n        const otherChanges = other.docChanges;\n        if (changes.length !== otherChanges.length) {\n            return false;\n        }\n        for (let i = 0; i < changes.length; i++) {\n            if (changes[i].type !== otherChanges[i].type ||\n                !changes[i].doc.isEqual(otherChanges[i].doc)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Holds the listeners and the last received ViewSnapshot for a query being\n * tracked by EventManager.\n */\nclass QueryListenersInfo {\n    constructor() {\n        this.viewSnap = undefined;\n        this.listeners = [];\n    }\n    // Helper methods that checks if the query has listeners that listening to remote store\n    hasRemoteListeners() {\n        return this.listeners.some(listener => listener.listensToRemoteStore());\n    }\n}\nfunction newEventManager() {\n    return new EventManagerImpl();\n}\nclass EventManagerImpl {\n    constructor() {\n        this.queries = newQueriesObjectMap();\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\n        this.snapshotsInSyncListeners = new Set();\n    }\n    terminate() {\n        errorAllTargets(this, new FirestoreError(Code.ABORTED, 'Firestore shutting down'));\n    }\n}\nfunction newQueriesObjectMap() {\n    return new ObjectMap(q => canonifyQuery(q), queryEquals);\n}\nasync function eventManagerListen(eventManager, listener) {\n    const eventManagerImpl = debugCast(eventManager);\n    let listenerAction = 3 /* ListenerSetupAction.NoActionRequired */;\n    const query = listener.query;\n    let queryInfo = eventManagerImpl.queries.get(query);\n    if (!queryInfo) {\n        queryInfo = new QueryListenersInfo();\n        listenerAction = listener.listensToRemoteStore()\n            ? 0 /* ListenerSetupAction.InitializeLocalListenAndRequireWatchConnection */\n            : 1 /* ListenerSetupAction.InitializeLocalListenOnly */;\n    }\n    else if (!queryInfo.hasRemoteListeners() &&\n        listener.listensToRemoteStore()) {\n        // Query has been listening to local cache, and tries to add a new listener sourced from watch.\n        listenerAction = 2 /* ListenerSetupAction.RequireWatchConnectionOnly */;\n    }\n    try {\n        switch (listenerAction) {\n            case 0 /* ListenerSetupAction.InitializeLocalListenAndRequireWatchConnection */:\n                queryInfo.viewSnap = await eventManagerImpl.onListen(query, \n                /** enableRemoteListen= */ true);\n                break;\n            case 1 /* ListenerSetupAction.InitializeLocalListenOnly */:\n                queryInfo.viewSnap = await eventManagerImpl.onListen(query, \n                /** enableRemoteListen= */ false);\n                break;\n            case 2 /* ListenerSetupAction.RequireWatchConnectionOnly */:\n                await eventManagerImpl.onFirstRemoteStoreListen(query);\n                break;\n            default:\n                break;\n        }\n    }\n    catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Initialization of query '${stringifyQuery(listener.query)}' failed`);\n        listener.onError(firestoreError);\n        return;\n    }\n    eventManagerImpl.queries.set(query, queryInfo);\n    queryInfo.listeners.push(listener);\n    // Run global snapshot listeners if a consistent snapshot has been emitted.\n    listener.applyOnlineStateChange(eventManagerImpl.onlineState);\n    if (queryInfo.viewSnap) {\n        const raisedEvent = listener.onViewSnapshot(queryInfo.viewSnap);\n        if (raisedEvent) {\n            raiseSnapshotsInSyncEvent(eventManagerImpl);\n        }\n    }\n}\nasync function eventManagerUnlisten(eventManager, listener) {\n    const eventManagerImpl = debugCast(eventManager);\n    const query = listener.query;\n    let listenerAction = 3 /* ListenerRemovalAction.NoActionRequired */;\n    const queryInfo = eventManagerImpl.queries.get(query);\n    if (queryInfo) {\n        const i = queryInfo.listeners.indexOf(listener);\n        if (i >= 0) {\n            queryInfo.listeners.splice(i, 1);\n            if (queryInfo.listeners.length === 0) {\n                listenerAction = listener.listensToRemoteStore()\n                    ? 0 /* ListenerRemovalAction.TerminateLocalListenAndRequireWatchDisconnection */\n                    : 1 /* ListenerRemovalAction.TerminateLocalListenOnly */;\n            }\n            else if (!queryInfo.hasRemoteListeners() &&\n                listener.listensToRemoteStore()) {\n                // The removed listener is the last one that sourced from watch.\n                listenerAction = 2 /* ListenerRemovalAction.RequireWatchDisconnectionOnly */;\n            }\n        }\n    }\n    switch (listenerAction) {\n        case 0 /* ListenerRemovalAction.TerminateLocalListenAndRequireWatchDisconnection */:\n            eventManagerImpl.queries.delete(query);\n            return eventManagerImpl.onUnlisten(query, \n            /** disableRemoteListen= */ true);\n        case 1 /* ListenerRemovalAction.TerminateLocalListenOnly */:\n            eventManagerImpl.queries.delete(query);\n            return eventManagerImpl.onUnlisten(query, \n            /** disableRemoteListen= */ false);\n        case 2 /* ListenerRemovalAction.RequireWatchDisconnectionOnly */:\n            return eventManagerImpl.onLastRemoteStoreUnlisten(query);\n        default:\n            return;\n    }\n}\nfunction eventManagerOnWatchChange(eventManager, viewSnaps) {\n    const eventManagerImpl = debugCast(eventManager);\n    let raisedEvent = false;\n    for (const viewSnap of viewSnaps) {\n        const query = viewSnap.query;\n        const queryInfo = eventManagerImpl.queries.get(query);\n        if (queryInfo) {\n            for (const listener of queryInfo.listeners) {\n                if (listener.onViewSnapshot(viewSnap)) {\n                    raisedEvent = true;\n                }\n            }\n            queryInfo.viewSnap = viewSnap;\n        }\n    }\n    if (raisedEvent) {\n        raiseSnapshotsInSyncEvent(eventManagerImpl);\n    }\n}\nfunction eventManagerOnWatchError(eventManager, query, error) {\n    const eventManagerImpl = debugCast(eventManager);\n    const queryInfo = eventManagerImpl.queries.get(query);\n    if (queryInfo) {\n        for (const listener of queryInfo.listeners) {\n            listener.onError(error);\n        }\n    }\n    // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()\n    // after an error.\n    eventManagerImpl.queries.delete(query);\n}\nfunction eventManagerOnOnlineStateChange(eventManager, onlineState) {\n    const eventManagerImpl = debugCast(eventManager);\n    eventManagerImpl.onlineState = onlineState;\n    let raisedEvent = false;\n    eventManagerImpl.queries.forEach((_, queryInfo) => {\n        for (const listener of queryInfo.listeners) {\n            // Run global snapshot listeners if a consistent snapshot has been emitted.\n            if (listener.applyOnlineStateChange(onlineState)) {\n                raisedEvent = true;\n            }\n        }\n    });\n    if (raisedEvent) {\n        raiseSnapshotsInSyncEvent(eventManagerImpl);\n    }\n}\nfunction addSnapshotsInSyncListener(eventManager, observer) {\n    const eventManagerImpl = debugCast(eventManager);\n    eventManagerImpl.snapshotsInSyncListeners.add(observer);\n    // Immediately fire an initial event, indicating all existing listeners\n    // are in-sync.\n    observer.next();\n}\nfunction removeSnapshotsInSyncListener(eventManager, observer) {\n    const eventManagerImpl = debugCast(eventManager);\n    eventManagerImpl.snapshotsInSyncListeners.delete(observer);\n}\nfunction errorAllTargets(eventManager, error) {\n    const eventManagerImpl = debugCast(eventManager);\n    const queries = eventManagerImpl.queries;\n    // Prevent further access by clearing ObjectMap.\n    eventManagerImpl.queries = newQueriesObjectMap();\n    queries.forEach((_, queryInfo) => {\n        for (const listener of queryInfo.listeners) {\n            listener.onError(error);\n        }\n    });\n}\n// Call all global snapshot listeners that have been set.\nfunction raiseSnapshotsInSyncEvent(eventManagerImpl) {\n    eventManagerImpl.snapshotsInSyncListeners.forEach(observer => {\n        observer.next();\n    });\n}\nvar ListenerDataSource;\n(function (ListenerDataSource) {\n    /** Listen to both cache and server changes */\n    ListenerDataSource[\"Default\"] = \"default\";\n    /** Listen to changes in cache only */\n    ListenerDataSource[\"Cache\"] = \"cache\";\n})(ListenerDataSource || (ListenerDataSource = {}));\n/**\n * QueryListener takes a series of internal view snapshots and determines\n * when to raise the event.\n *\n * It uses an Observer to dispatch events.\n */\nclass QueryListener {\n    constructor(query, queryObserver, options) {\n        this.query = query;\n        this.queryObserver = queryObserver;\n        /**\n         * Initial snapshots (e.g. from cache) may not be propagated to the wrapped\n         * observer. This flag is set to true once we've actually raised an event.\n         */\n        this.raisedInitialEvent = false;\n        this.snap = null;\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\n        this.options = options || {};\n    }\n    /**\n     * Applies the new ViewSnapshot to this listener, raising a user-facing event\n     * if applicable (depending on what changed, whether the user has opted into\n     * metadata-only changes, etc.). Returns true if a user-facing event was\n     * indeed raised.\n     */\n    onViewSnapshot(snap) {\n        if (!this.options.includeMetadataChanges) {\n            // Remove the metadata only changes.\n            const docChanges = [];\n            for (const docChange of snap.docChanges) {\n                if (docChange.type !== 3 /* ChangeType.Metadata */) {\n                    docChanges.push(docChange);\n                }\n            }\n            snap = new ViewSnapshot(snap.query, snap.docs, snap.oldDocs, docChanges, snap.mutatedKeys, snap.fromCache, snap.syncStateChanged, \n            /* excludesMetadataChanges= */ true, snap.hasCachedResults);\n        }\n        let raisedEvent = false;\n        if (!this.raisedInitialEvent) {\n            if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {\n                this.raiseInitialEvent(snap);\n                raisedEvent = true;\n            }\n        }\n        else if (this.shouldRaiseEvent(snap)) {\n            this.queryObserver.next(snap);\n            raisedEvent = true;\n        }\n        this.snap = snap;\n        return raisedEvent;\n    }\n    onError(error) {\n        this.queryObserver.error(error);\n    }\n    /** Returns whether a snapshot was raised. */\n    applyOnlineStateChange(onlineState) {\n        this.onlineState = onlineState;\n        let raisedEvent = false;\n        if (this.snap &&\n            !this.raisedInitialEvent &&\n            this.shouldRaiseInitialEvent(this.snap, onlineState)) {\n            this.raiseInitialEvent(this.snap);\n            raisedEvent = true;\n        }\n        return raisedEvent;\n    }\n    shouldRaiseInitialEvent(snap, onlineState) {\n        // Always raise the first event when we're synced\n        if (!snap.fromCache) {\n            return true;\n        }\n        // Always raise event if listening to cache\n        if (!this.listensToRemoteStore()) {\n            return true;\n        }\n        // NOTE: We consider OnlineState.Unknown as online (it should become Offline\n        // or Online if we wait long enough).\n        const maybeOnline = onlineState !== \"Offline\" /* OnlineState.Offline */;\n        // Don't raise the event if we're online, aren't synced yet (checked\n        // above) and are waiting for a sync.\n        if (this.options.waitForSyncWhenOnline && maybeOnline) {\n            return false;\n        }\n        // Raise data from cache if we have any documents, have cached results before,\n        // or we are offline.\n        return (!snap.docs.isEmpty() ||\n            snap.hasCachedResults ||\n            onlineState === \"Offline\" /* OnlineState.Offline */);\n    }\n    shouldRaiseEvent(snap) {\n        // We don't need to handle includeDocumentMetadataChanges here because\n        // the Metadata only changes have already been stripped out if needed.\n        // At this point the only changes we will see are the ones we should\n        // propagate.\n        if (snap.docChanges.length > 0) {\n            return true;\n        }\n        const hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;\n        if (snap.syncStateChanged || hasPendingWritesChanged) {\n            return this.options.includeMetadataChanges === true;\n        }\n        // Generally we should have hit one of the cases above, but it's possible\n        // to get here if there were only metadata docChanges and they got\n        // stripped out.\n        return false;\n    }\n    raiseInitialEvent(snap) {\n        snap = ViewSnapshot.fromInitialDocuments(snap.query, snap.docs, snap.mutatedKeys, snap.fromCache, snap.hasCachedResults);\n        this.raisedInitialEvent = true;\n        this.queryObserver.next(snap);\n    }\n    listensToRemoteStore() {\n        return this.options.source !== ListenerDataSource.Cache;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A set of changes to what documents are currently in view and out of view for\n * a given query. These changes are sent to the LocalStore by the View (via\n * the SyncEngine) and are used to pin / unpin documents as appropriate.\n */\nclass LocalViewChanges {\n    constructor(targetId, fromCache, addedKeys, removedKeys) {\n        this.targetId = targetId;\n        this.fromCache = fromCache;\n        this.addedKeys = addedKeys;\n        this.removedKeys = removedKeys;\n    }\n    static fromSnapshot(targetId, viewSnapshot) {\n        let addedKeys = documentKeySet();\n        let removedKeys = documentKeySet();\n        for (const docChange of viewSnapshot.docChanges) {\n            switch (docChange.type) {\n                case 0 /* ChangeType.Added */:\n                    addedKeys = addedKeys.add(docChange.doc.key);\n                    break;\n                case 1 /* ChangeType.Removed */:\n                    removedKeys = removedKeys.add(docChange.doc.key);\n                    break;\n                // do nothing\n            }\n        }\n        return new LocalViewChanges(targetId, viewSnapshot.fromCache, addedKeys, removedKeys);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Helper to convert objects from bundles to model objects in the SDK.\n */\nclass BundleConverterImpl {\n    constructor(serializer) {\n        this.serializer = serializer;\n    }\n    toDocumentKey(name) {\n        return fromName(this.serializer, name);\n    }\n    /**\n     * Converts a BundleDocument to a MutableDocument.\n     */\n    toMutableDocument(bundledDoc) {\n        if (bundledDoc.metadata.exists) {\n            return fromDocument(this.serializer, bundledDoc.document, false);\n        }\n        else {\n            return MutableDocument.newNoDocument(this.toDocumentKey(bundledDoc.metadata.name), this.toSnapshotVersion(bundledDoc.metadata.readTime));\n        }\n    }\n    toSnapshotVersion(time) {\n        return fromVersion(time);\n    }\n}\n/**\n * A class to process the elements from a bundle, and optionally load them into local\n * storage and provide progress update while loading.\n */\nclass BundleLoader {\n    constructor(bundleMetadata, serializer) {\n        this.bundleMetadata = bundleMetadata;\n        this.serializer = serializer;\n        /** Batched queries to be saved into storage */\n        this._queries = [];\n        /** Batched documents to be saved into storage */\n        this._documents = [];\n        /** The collection groups affected by this bundle. */\n        this.collectionGroups = new Set();\n        this.progress = bundleInitialProgress(bundleMetadata);\n    }\n    /**\n     * Returns the named queries that have been parsed from the SizeBundleElements added by\n     * calling {@link adSizedElement}.\n     */\n    get queries() {\n        return this._queries;\n    }\n    /**\n     * Returns the BundledDocuments that have been parsed from the SizeBundleElements added by\n     * calling {@link addSizedElement}.\n     */\n    get documents() {\n        return this._documents;\n    }\n    /**\n     * Adds an element from the bundle to the loader.\n     *\n     * Returns a new progress if adding the element leads to a new progress,\n     * otherwise returns null.\n     */\n    addSizedElement(element) {\n        this.progress.bytesLoaded += element.byteLength;\n        let documentsLoaded = this.progress.documentsLoaded;\n        if (element.payload.namedQuery) {\n            this._queries.push(element.payload.namedQuery);\n        }\n        else if (element.payload.documentMetadata) {\n            this._documents.push({ metadata: element.payload.documentMetadata });\n            if (!element.payload.documentMetadata.exists) {\n                ++documentsLoaded;\n            }\n            const path = ResourcePath.fromString(element.payload.documentMetadata.name);\n            this.collectionGroups.add(path.get(path.length - 2));\n        }\n        else if (element.payload.document) {\n            this._documents[this._documents.length - 1].document =\n                element.payload.document;\n            ++documentsLoaded;\n        }\n        if (documentsLoaded !== this.progress.documentsLoaded) {\n            this.progress.documentsLoaded = documentsLoaded;\n            return { ...this.progress };\n        }\n        return null;\n    }\n    getQueryDocumentMapping(documents) {\n        const queryDocumentMap = new Map();\n        const bundleConverter = new BundleConverterImpl(this.serializer);\n        for (const bundleDoc of documents) {\n            if (bundleDoc.metadata.queries) {\n                const documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);\n                for (const queryName of bundleDoc.metadata.queries) {\n                    const documentKeys = (queryDocumentMap.get(queryName) || documentKeySet()).add(documentKey);\n                    queryDocumentMap.set(queryName, documentKeys);\n                }\n            }\n        }\n        return queryDocumentMap;\n    }\n    /**\n     * Update the progress to 'Success' and return the updated progress.\n     */\n    async completeAndStoreAsync(localStore) {\n        const changedDocs = await localStoreApplyBundledDocuments(localStore, new BundleConverterImpl(this.serializer), this._documents, this.bundleMetadata.id);\n        const queryDocumentMap = this.getQueryDocumentMapping(this.documents);\n        for (const q of this._queries) {\n            await localStoreSaveNamedQuery(localStore, q, queryDocumentMap.get(q.name));\n        }\n        this.progress.taskState = 'Success';\n        return {\n            progress: this.progress,\n            changedCollectionGroups: this.collectionGroups,\n            changedDocs\n        };\n    }\n}\n/**\n * Returns a `LoadBundleTaskProgress` representing the initial progress of\n * loading a bundle.\n */\nfunction bundleInitialProgress(metadata) {\n    return {\n        taskState: 'Running',\n        documentsLoaded: 0,\n        bytesLoaded: 0,\n        totalDocuments: metadata.totalDocuments,\n        totalBytes: metadata.totalBytes\n    };\n}\n/**\n * Returns a `LoadBundleTaskProgress` representing the progress that the loading\n * has succeeded.\n */\nfunction bundleSuccessProgress(metadata) {\n    return {\n        taskState: 'Success',\n        documentsLoaded: metadata.totalDocuments,\n        bytesLoaded: metadata.totalBytes,\n        totalDocuments: metadata.totalDocuments,\n        totalBytes: metadata.totalBytes\n    };\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass AddedLimboDocument {\n    constructor(key) {\n        this.key = key;\n    }\n}\nclass RemovedLimboDocument {\n    constructor(key) {\n        this.key = key;\n    }\n}\n/**\n * View is responsible for computing the final merged truth of what docs are in\n * a query. It gets notified of local and remote changes to docs, and applies\n * the query filters and limits to determine the most correct possible results.\n */\nclass View {\n    constructor(query, \n    /** Documents included in the remote target */\n    _syncedDocuments) {\n        this.query = query;\n        this._syncedDocuments = _syncedDocuments;\n        this.syncState = null;\n        this.hasCachedResults = false;\n        /**\n         * A flag whether the view is current with the backend. A view is considered\n         * current after it has seen the current flag from the backend and did not\n         * lose consistency within the watch stream (e.g. because of an existence\n         * filter mismatch).\n         */\n        this.current = false;\n        /** Documents in the view but not in the remote target */\n        this.limboDocuments = documentKeySet();\n        /** Document Keys that have local changes */\n        this.mutatedKeys = documentKeySet();\n        this.docComparator = newQueryComparator(query);\n        this.documentSet = new DocumentSet(this.docComparator);\n    }\n    /**\n     * The set of remote documents that the server has told us belongs to the target associated with\n     * this view.\n     */\n    get syncedDocuments() {\n        return this._syncedDocuments;\n    }\n    /**\n     * Iterates over a set of doc changes, applies the query limit, and computes\n     * what the new results should be, what the changes were, and whether we may\n     * need to go back to the local cache for more results. Does not make any\n     * changes to the view.\n     * @param docChanges - The doc changes to apply to this view.\n     * @param previousChanges - If this is being called with a refill, then start\n     *        with this set of docs and changes instead of the current view.\n     * @returns a new set of docs, changes, and refill flag.\n     */\n    computeDocChanges(docChanges, previousChanges) {\n        const changeSet = previousChanges\n            ? previousChanges.changeSet\n            : new DocumentChangeSet();\n        const oldDocumentSet = previousChanges\n            ? previousChanges.documentSet\n            : this.documentSet;\n        let newMutatedKeys = previousChanges\n            ? previousChanges.mutatedKeys\n            : this.mutatedKeys;\n        let newDocumentSet = oldDocumentSet;\n        let needsRefill = false;\n        // Track the last doc in a (full) limit. This is necessary, because some\n        // update (a delete, or an update moving a doc past the old limit) might\n        // mean there is some other document in the local cache that either should\n        // come (1) between the old last limit doc and the new last document, in the\n        // case of updates, or (2) after the new last document, in the case of\n        // deletes. So we keep this doc at the old limit to compare the updates to.\n        //\n        // Note that this should never get used in a refill (when previousChanges is\n        // set), because there will only be adds -- no deletes or updates.\n        const lastDocInLimit = this.query.limitType === \"F\" /* LimitType.First */ &&\n            oldDocumentSet.size === this.query.limit\n            ? oldDocumentSet.last()\n            : null;\n        const firstDocInLimit = this.query.limitType === \"L\" /* LimitType.Last */ &&\n            oldDocumentSet.size === this.query.limit\n            ? oldDocumentSet.first()\n            : null;\n        docChanges.inorderTraversal((key, entry) => {\n            const oldDoc = oldDocumentSet.get(key);\n            const newDoc = queryMatches(this.query, entry) ? entry : null;\n            const oldDocHadPendingMutations = oldDoc\n                ? this.mutatedKeys.has(oldDoc.key)\n                : false;\n            const newDocHasPendingMutations = newDoc\n                ? newDoc.hasLocalMutations ||\n                    // We only consider committed mutations for documents that were\n                    // mutated during the lifetime of the view.\n                    (this.mutatedKeys.has(newDoc.key) && newDoc.hasCommittedMutations)\n                : false;\n            let changeApplied = false;\n            // Calculate change\n            if (oldDoc && newDoc) {\n                const docsEqual = oldDoc.data.isEqual(newDoc.data);\n                if (!docsEqual) {\n                    if (!this.shouldWaitForSyncedDocument(oldDoc, newDoc)) {\n                        changeSet.track({\n                            type: 2 /* ChangeType.Modified */,\n                            doc: newDoc\n                        });\n                        changeApplied = true;\n                        if ((lastDocInLimit &&\n                            this.docComparator(newDoc, lastDocInLimit) > 0) ||\n                            (firstDocInLimit &&\n                                this.docComparator(newDoc, firstDocInLimit) < 0)) {\n                            // This doc moved from inside the limit to outside the limit.\n                            // That means there may be some other doc in the local cache\n                            // that should be included instead.\n                            needsRefill = true;\n                        }\n                    }\n                }\n                else if (oldDocHadPendingMutations !== newDocHasPendingMutations) {\n                    changeSet.track({ type: 3 /* ChangeType.Metadata */, doc: newDoc });\n                    changeApplied = true;\n                }\n            }\n            else if (!oldDoc && newDoc) {\n                changeSet.track({ type: 0 /* ChangeType.Added */, doc: newDoc });\n                changeApplied = true;\n            }\n            else if (oldDoc && !newDoc) {\n                changeSet.track({ type: 1 /* ChangeType.Removed */, doc: oldDoc });\n                changeApplied = true;\n                if (lastDocInLimit || firstDocInLimit) {\n                    // A doc was removed from a full limit query. We'll need to\n                    // requery from the local cache to see if we know about some other\n                    // doc that should be in the results.\n                    needsRefill = true;\n                }\n            }\n            if (changeApplied) {\n                if (newDoc) {\n                    newDocumentSet = newDocumentSet.add(newDoc);\n                    if (newDocHasPendingMutations) {\n                        newMutatedKeys = newMutatedKeys.add(key);\n                    }\n                    else {\n                        newMutatedKeys = newMutatedKeys.delete(key);\n                    }\n                }\n                else {\n                    newDocumentSet = newDocumentSet.delete(key);\n                    newMutatedKeys = newMutatedKeys.delete(key);\n                }\n            }\n        });\n        // Drop documents out to meet limit/limitToLast requirement.\n        if (this.query.limit !== null) {\n            while (newDocumentSet.size > this.query.limit) {\n                const oldDoc = this.query.limitType === \"F\" /* LimitType.First */\n                    ? newDocumentSet.last()\n                    : newDocumentSet.first();\n                newDocumentSet = newDocumentSet.delete(oldDoc.key);\n                newMutatedKeys = newMutatedKeys.delete(oldDoc.key);\n                changeSet.track({ type: 1 /* ChangeType.Removed */, doc: oldDoc });\n            }\n        }\n        return {\n            documentSet: newDocumentSet,\n            changeSet,\n            needsRefill,\n            mutatedKeys: newMutatedKeys\n        };\n    }\n    shouldWaitForSyncedDocument(oldDoc, newDoc) {\n        // We suppress the initial change event for documents that were modified as\n        // part of a write acknowledgment (e.g. when the value of a server transform\n        // is applied) as Watch will send us the same document again.\n        // By suppressing the event, we only raise two user visible events (one with\n        // `hasPendingWrites` and the final state of the document) instead of three\n        // (one with `hasPendingWrites`, the modified document with\n        // `hasPendingWrites` and the final state of the document).\n        return (oldDoc.hasLocalMutations &&\n            newDoc.hasCommittedMutations &&\n            !newDoc.hasLocalMutations);\n    }\n    /**\n     * Updates the view with the given ViewDocumentChanges and optionally updates\n     * limbo docs and sync state from the provided target change.\n     * @param docChanges - The set of changes to make to the view's docs.\n     * @param limboResolutionEnabled - Whether to update limbo documents based on\n     *        this change.\n     * @param targetChange - A target change to apply for computing limbo docs and\n     *        sync state.\n     * @param targetIsPendingReset - Whether the target is pending to reset due to\n     *        existence filter mismatch. If not explicitly specified, it is treated\n     *        equivalently to `false`.\n     * @returns A new ViewChange with the given docs, changes, and sync state.\n     */\n    // PORTING NOTE: The iOS/Android clients always compute limbo document changes.\n    applyChanges(docChanges, limboResolutionEnabled, targetChange, targetIsPendingReset) {\n        const oldDocs = this.documentSet;\n        this.documentSet = docChanges.documentSet;\n        this.mutatedKeys = docChanges.mutatedKeys;\n        // Sort changes based on type and query comparator\n        const changes = docChanges.changeSet.getChanges();\n        changes.sort((c1, c2) => {\n            return (compareChangeType(c1.type, c2.type) ||\n                this.docComparator(c1.doc, c2.doc));\n        });\n        this.applyTargetChange(targetChange);\n        targetIsPendingReset = targetIsPendingReset ?? false;\n        const limboChanges = limboResolutionEnabled && !targetIsPendingReset\n            ? this.updateLimboDocuments()\n            : [];\n        // We are at synced state if there is no limbo docs are waiting to be resolved, view is current\n        // with the backend, and the query is not pending to reset due to existence filter mismatch.\n        const synced = this.limboDocuments.size === 0 && this.current && !targetIsPendingReset;\n        const newSyncState = synced ? 1 /* SyncState.Synced */ : 0 /* SyncState.Local */;\n        const syncStateChanged = newSyncState !== this.syncState;\n        this.syncState = newSyncState;\n        if (changes.length === 0 && !syncStateChanged) {\n            // no changes\n            return { limboChanges };\n        }\n        else {\n            const snap = new ViewSnapshot(this.query, docChanges.documentSet, oldDocs, changes, docChanges.mutatedKeys, newSyncState === 0 /* SyncState.Local */, syncStateChanged, \n            /* excludesMetadataChanges= */ false, targetChange\n                ? targetChange.resumeToken.approximateByteSize() > 0\n                : false);\n            return {\n                snapshot: snap,\n                limboChanges\n            };\n        }\n    }\n    /**\n     * Applies an OnlineState change to the view, potentially generating a\n     * ViewChange if the view's syncState changes as a result.\n     */\n    applyOnlineStateChange(onlineState) {\n        if (this.current && onlineState === \"Offline\" /* OnlineState.Offline */) {\n            // If we're offline, set `current` to false and then call applyChanges()\n            // to refresh our syncState and generate a ViewChange as appropriate. We\n            // are guaranteed to get a new TargetChange that sets `current` back to\n            // true once the client is back online.\n            this.current = false;\n            return this.applyChanges({\n                documentSet: this.documentSet,\n                changeSet: new DocumentChangeSet(),\n                mutatedKeys: this.mutatedKeys,\n                needsRefill: false\n            }, \n            /* limboResolutionEnabled= */ false);\n        }\n        else {\n            // No effect, just return a no-op ViewChange.\n            return { limboChanges: [] };\n        }\n    }\n    /**\n     * Returns whether the doc for the given key should be in limbo.\n     */\n    shouldBeInLimbo(key) {\n        // If the remote end says it's part of this query, it's not in limbo.\n        if (this._syncedDocuments.has(key)) {\n            return false;\n        }\n        // The local store doesn't think it's a result, so it shouldn't be in limbo.\n        if (!this.documentSet.has(key)) {\n            return false;\n        }\n        // If there are local changes to the doc, they might explain why the server\n        // doesn't know that it's part of the query. So don't put it in limbo.\n        // TODO(klimt): Ideally, we would only consider changes that might actually\n        // affect this specific query.\n        if (this.documentSet.get(key).hasLocalMutations) {\n            return false;\n        }\n        // Everything else is in limbo.\n        return true;\n    }\n    /**\n     * Updates syncedDocuments, current, and limbo docs based on the given change.\n     * Returns the list of changes to which docs are in limbo.\n     */\n    applyTargetChange(targetChange) {\n        if (targetChange) {\n            targetChange.addedDocuments.forEach(key => (this._syncedDocuments = this._syncedDocuments.add(key)));\n            targetChange.modifiedDocuments.forEach(key => {\n            });\n            targetChange.removedDocuments.forEach(key => (this._syncedDocuments = this._syncedDocuments.delete(key)));\n            this.current = targetChange.current;\n        }\n    }\n    updateLimboDocuments() {\n        // We can only determine limbo documents when we're in-sync with the server.\n        if (!this.current) {\n            return [];\n        }\n        // TODO(klimt): Do this incrementally so that it's not quadratic when\n        // updating many documents.\n        const oldLimboDocuments = this.limboDocuments;\n        this.limboDocuments = documentKeySet();\n        this.documentSet.forEach(doc => {\n            if (this.shouldBeInLimbo(doc.key)) {\n                this.limboDocuments = this.limboDocuments.add(doc.key);\n            }\n        });\n        // Diff the new limbo docs with the old limbo docs.\n        const changes = [];\n        oldLimboDocuments.forEach(key => {\n            if (!this.limboDocuments.has(key)) {\n                changes.push(new RemovedLimboDocument(key));\n            }\n        });\n        this.limboDocuments.forEach(key => {\n            if (!oldLimboDocuments.has(key)) {\n                changes.push(new AddedLimboDocument(key));\n            }\n        });\n        return changes;\n    }\n    /**\n     * Update the in-memory state of the current view with the state read from\n     * persistence.\n     *\n     * We update the query view whenever a client's primary status changes:\n     * - When a client transitions from primary to secondary, it can miss\n     *   LocalStorage updates and its query views may temporarily not be\n     *   synchronized with the state on disk.\n     * - For secondary to primary transitions, the client needs to update the list\n     *   of `syncedDocuments` since secondary clients update their query views\n     *   based purely on synthesized RemoteEvents.\n     *\n     * @param queryResult.documents - The documents that match the query according\n     * to the LocalStore.\n     * @param queryResult.remoteKeys - The keys of the documents that match the\n     * query according to the backend.\n     *\n     * @returns The ViewChange that resulted from this synchronization.\n     */\n    // PORTING NOTE: Multi-tab only.\n    synchronizeWithPersistedState(queryResult) {\n        this._syncedDocuments = queryResult.remoteKeys;\n        this.limboDocuments = documentKeySet();\n        const docChanges = this.computeDocChanges(queryResult.documents);\n        return this.applyChanges(docChanges, /* limboResolutionEnabled= */ true);\n    }\n    /**\n     * Returns a view snapshot as if this query was just listened to. Contains\n     * a document add for every existing document and the `fromCache` and\n     * `hasPendingWrites` status of the already established view.\n     */\n    // PORTING NOTE: Multi-tab only.\n    computeInitialSnapshot() {\n        return ViewSnapshot.fromInitialDocuments(this.query, this.documentSet, this.mutatedKeys, this.syncState === 0 /* SyncState.Local */, this.hasCachedResults);\n    }\n}\nfunction compareChangeType(c1, c2) {\n    const order = (change) => {\n        switch (change) {\n            case 0 /* ChangeType.Added */:\n                return 1;\n            case 2 /* ChangeType.Modified */:\n                return 2;\n            case 3 /* ChangeType.Metadata */:\n                // A metadata change is converted to a modified change at the public\n                // api layer.  Since we sort by document key and then change type,\n                // metadata and modified changes must be sorted equivalently.\n                return 2;\n            case 1 /* ChangeType.Removed */:\n                return 0;\n            default:\n                return fail(0x4f35, { change });\n        }\n    };\n    return order(c1) - order(c2);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$3 = 'SyncEngine';\n/**\n * QueryView contains all of the data that SyncEngine needs to keep track of for\n * a particular query.\n */\nclass QueryView {\n    constructor(\n    /**\n     * The query itself.\n     */\n    query, \n    /**\n     * The target number created by the client that is used in the watch\n     * stream to identify this query.\n     */\n    targetId, \n    /**\n     * The view is responsible for computing the final merged truth of what\n     * docs are in the query. It gets notified of local and remote changes,\n     * and applies the query filters and limits to determine the most correct\n     * possible results.\n     */\n    view) {\n        this.query = query;\n        this.targetId = targetId;\n        this.view = view;\n    }\n}\n/** Tracks a limbo resolution. */\nclass LimboResolution {\n    constructor(key) {\n        this.key = key;\n        /**\n         * Set to true once we've received a document. This is used in\n         * getRemoteKeysForTarget() and ultimately used by WatchChangeAggregator to\n         * decide whether it needs to manufacture a delete event for the target once\n         * the target is CURRENT.\n         */\n        this.receivedDocument = false;\n    }\n}\n/**\n * An implementation of `SyncEngine` coordinating with other parts of SDK.\n *\n * The parts of SyncEngine that act as a callback to RemoteStore need to be\n * registered individually. This is done in `syncEngineWrite()` and\n * `syncEngineListen()` (as well as `applyPrimaryState()`) as these methods\n * serve as entry points to RemoteStore's functionality.\n *\n * Note: some field defined in this class might have public access level, but\n * the class is not exported so they are only accessible from this module.\n * This is useful to implement optional features (like bundles) in free\n * functions, such that they are tree-shakeable.\n */\nclass SyncEngineImpl {\n    constructor(localStore, remoteStore, eventManager, \n    // PORTING NOTE: Manages state synchronization in multi-tab environments.\n    sharedClientState, currentUser, maxConcurrentLimboResolutions) {\n        this.localStore = localStore;\n        this.remoteStore = remoteStore;\n        this.eventManager = eventManager;\n        this.sharedClientState = sharedClientState;\n        this.currentUser = currentUser;\n        this.maxConcurrentLimboResolutions = maxConcurrentLimboResolutions;\n        this.syncEngineListener = {};\n        this.queryViewsByQuery = new ObjectMap(q => canonifyQuery(q), queryEquals);\n        this.queriesByTarget = new Map();\n        /**\n         * The keys of documents that are in limbo for which we haven't yet started a\n         * limbo resolution query. The strings in this set are the result of calling\n         * `key.path.canonicalString()` where `key` is a `DocumentKey` object.\n         *\n         * The `Set` type was chosen because it provides efficient lookup and removal\n         * of arbitrary elements and it also maintains insertion order, providing the\n         * desired queue-like FIFO semantics.\n         */\n        this.enqueuedLimboResolutions = new Set();\n        /**\n         * Keeps track of the target ID for each document that is in limbo with an\n         * active target.\n         */\n        this.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);\n        /**\n         * Keeps track of the information about an active limbo resolution for each\n         * active target ID that was started for the purpose of limbo resolution.\n         */\n        this.activeLimboResolutionsByTarget = new Map();\n        this.limboDocumentRefs = new ReferenceSet();\n        /** Stores user completion handlers, indexed by User and BatchId. */\n        this.mutationUserCallbacks = {};\n        /** Stores user callbacks waiting for all pending writes to be acknowledged. */\n        this.pendingWritesCallbacks = new Map();\n        this.limboTargetIdGenerator = TargetIdGenerator.forSyncEngine();\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\n        // The primary state is set to `true` or `false` immediately after Firestore\n        // startup. In the interim, a client should only be considered primary if\n        // `isPrimary` is true.\n        this._isPrimaryClient = undefined;\n    }\n    get isPrimaryClient() {\n        return this._isPrimaryClient === true;\n    }\n}\nfunction newSyncEngine(localStore, remoteStore, eventManager, \n// PORTING NOTE: Manages state synchronization in multi-tab environments.\nsharedClientState, currentUser, maxConcurrentLimboResolutions, isPrimary) {\n    const syncEngine = new SyncEngineImpl(localStore, remoteStore, eventManager, sharedClientState, currentUser, maxConcurrentLimboResolutions);\n    if (isPrimary) {\n        syncEngine._isPrimaryClient = true;\n    }\n    return syncEngine;\n}\n/**\n * Initiates the new listen, resolves promise when listen enqueued to the\n * server. All the subsequent view snapshots or errors are sent to the\n * subscribed handlers. Returns the initial snapshot.\n */\nasync function syncEngineListen(syncEngine, query, shouldListenToRemote = true) {\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\n    let viewSnapshot;\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n    if (queryView) {\n        // PORTING NOTE: With Multi-Tab Web, it is possible that a query view\n        // already exists when EventManager calls us for the first time. This\n        // happens when the primary tab is already listening to this query on\n        // behalf of another tab and the user of the primary also starts listening\n        // to the query. EventManager will not have an assigned target ID in this\n        // case and calls `listen` to obtain this ID.\n        syncEngineImpl.sharedClientState.addLocalQueryTarget(queryView.targetId);\n        viewSnapshot = queryView.view.computeInitialSnapshot();\n    }\n    else {\n        viewSnapshot = await allocateTargetAndMaybeListen(syncEngineImpl, query, shouldListenToRemote, \n        /** shouldInitializeView= */ true);\n    }\n    return viewSnapshot;\n}\n/** Query has been listening to the cache, and tries to initiate the remote store listen */\nasync function triggerRemoteStoreListen(syncEngine, query) {\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\n    await allocateTargetAndMaybeListen(syncEngineImpl, query, \n    /** shouldListenToRemote= */ true, \n    /** shouldInitializeView= */ false);\n}\nasync function allocateTargetAndMaybeListen(syncEngineImpl, query, shouldListenToRemote, shouldInitializeView) {\n    const targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(query));\n    const targetId = targetData.targetId;\n    // PORTING NOTE: When the query is listening to cache only, we skip sending it over to Watch by\n    // not registering it in shared client state, and directly calculate initial snapshots and\n    // subsequent updates from cache. Otherwise, register the target ID with local Firestore client\n    // as active watch target.\n    const status = syncEngineImpl.sharedClientState.addLocalQueryTarget(targetId, \n    /* addToActiveTargetIds= */ shouldListenToRemote);\n    let viewSnapshot;\n    if (shouldInitializeView) {\n        viewSnapshot = await initializeViewAndComputeSnapshot(syncEngineImpl, query, targetId, status === 'current', targetData.resumeToken);\n    }\n    if (syncEngineImpl.isPrimaryClient && shouldListenToRemote) {\n        remoteStoreListen(syncEngineImpl.remoteStore, targetData);\n    }\n    return viewSnapshot;\n}\n/**\n * Registers a view for a previously unknown query and computes its initial\n * snapshot.\n */\nasync function initializeViewAndComputeSnapshot(syncEngineImpl, query, targetId, current, resumeToken) {\n    // PORTING NOTE: On Web only, we inject the code that registers new Limbo\n    // targets based on view changes. This allows us to only depend on Limbo\n    // changes when user code includes queries.\n    syncEngineImpl.applyDocChanges = (queryView, changes, remoteEvent) => applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent);\n    const queryResult = await localStoreExecuteQuery(syncEngineImpl.localStore, query, \n    /* usePreviousResults= */ true);\n    const view = new View(query, queryResult.remoteKeys);\n    const viewDocChanges = view.computeDocChanges(queryResult.documents);\n    const synthesizedTargetChange = TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current && syncEngineImpl.onlineState !== \"Offline\" /* OnlineState.Offline */, resumeToken);\n    const viewChange = view.applyChanges(viewDocChanges, \n    /* limboResolutionEnabled= */ syncEngineImpl.isPrimaryClient, synthesizedTargetChange);\n    updateTrackedLimbos(syncEngineImpl, targetId, viewChange.limboChanges);\n    const data = new QueryView(query, targetId, view);\n    syncEngineImpl.queryViewsByQuery.set(query, data);\n    if (syncEngineImpl.queriesByTarget.has(targetId)) {\n        syncEngineImpl.queriesByTarget.get(targetId).push(query);\n    }\n    else {\n        syncEngineImpl.queriesByTarget.set(targetId, [query]);\n    }\n    return viewChange.snapshot;\n}\n/** Stops listening to the query. */\nasync function syncEngineUnlisten(syncEngine, query, shouldUnlistenToRemote) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n    // Only clean up the query view and target if this is the only query mapped\n    // to the target.\n    const queries = syncEngineImpl.queriesByTarget.get(queryView.targetId);\n    if (queries.length > 1) {\n        syncEngineImpl.queriesByTarget.set(queryView.targetId, queries.filter(q => !queryEquals(q, query)));\n        syncEngineImpl.queryViewsByQuery.delete(query);\n        return;\n    }\n    // No other queries are mapped to the target, clean up the query and the target.\n    if (syncEngineImpl.isPrimaryClient) {\n        // We need to remove the local query target first to allow us to verify\n        // whether any other client is still interested in this target.\n        syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);\n        const targetRemainsActive = syncEngineImpl.sharedClientState.isActiveQueryTarget(queryView.targetId);\n        if (!targetRemainsActive) {\n            await localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, \n            /*keepPersistedTargetData=*/ false)\n                .then(() => {\n                syncEngineImpl.sharedClientState.clearQueryState(queryView.targetId);\n                if (shouldUnlistenToRemote) {\n                    remoteStoreUnlisten(syncEngineImpl.remoteStore, queryView.targetId);\n                }\n                removeAndCleanupTarget(syncEngineImpl, queryView.targetId);\n            })\n                .catch(ignoreIfPrimaryLeaseLoss);\n        }\n    }\n    else {\n        removeAndCleanupTarget(syncEngineImpl, queryView.targetId);\n        await localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, \n        /*keepPersistedTargetData=*/ true);\n    }\n}\n/** Unlistens to the remote store while still listening to the cache. */\nasync function triggerRemoteStoreUnlisten(syncEngine, query) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n    const queries = syncEngineImpl.queriesByTarget.get(queryView.targetId);\n    if (syncEngineImpl.isPrimaryClient && queries.length === 1) {\n        // PORTING NOTE: Unregister the target ID with local Firestore client as\n        // watch target.\n        syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);\n        remoteStoreUnlisten(syncEngineImpl.remoteStore, queryView.targetId);\n    }\n}\n/**\n * Initiates the write of local mutation batch which involves adding the\n * writes to the mutation queue, notifying the remote store about new\n * mutations and raising events for any changes this write caused.\n *\n * The promise returned by this call is resolved when the above steps\n * have completed, *not* when the write was acked by the backend. The\n * userCallback is resolved once the write was acked/rejected by the\n * backend (or failed locally for any other reason).\n */\nasync function syncEngineWrite(syncEngine, batch, userCallback) {\n    const syncEngineImpl = syncEngineEnsureWriteCallbacks(syncEngine);\n    try {\n        const result = await localStoreWriteLocally(syncEngineImpl.localStore, batch);\n        syncEngineImpl.sharedClientState.addPendingMutation(result.batchId);\n        addMutationCallback(syncEngineImpl, result.batchId, userCallback);\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.changes);\n        await fillWritePipeline(syncEngineImpl.remoteStore);\n    }\n    catch (e) {\n        // If we can't persist the mutation, we reject the user callback and\n        // don't send the mutation. The user can then retry the write.\n        const error = wrapInUserErrorIfRecoverable(e, `Failed to persist write`);\n        userCallback.reject(error);\n    }\n}\n/**\n * Applies one remote event to the sync engine, notifying any views of the\n * changes, and releasing any pending mutation batches that would become\n * visible because of the snapshot version the remote event contains.\n */\nasync function syncEngineApplyRemoteEvent(syncEngine, remoteEvent) {\n    const syncEngineImpl = debugCast(syncEngine);\n    try {\n        const changes = await localStoreApplyRemoteEventToLocalCache(syncEngineImpl.localStore, remoteEvent);\n        // Update `receivedDocument` as appropriate for any limbo targets.\n        remoteEvent.targetChanges.forEach((targetChange, targetId) => {\n            const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\n            if (limboResolution) {\n                // Since this is a limbo resolution lookup, it's for a single document\n                // and it could be added, modified, or removed, but not a combination.\n                hardAssert(targetChange.addedDocuments.size +\n                    targetChange.modifiedDocuments.size +\n                    targetChange.removedDocuments.size <=\n                    1, 0x5858);\n                if (targetChange.addedDocuments.size > 0) {\n                    limboResolution.receivedDocument = true;\n                }\n                else if (targetChange.modifiedDocuments.size > 0) {\n                    hardAssert(limboResolution.receivedDocument, 0x390f);\n                }\n                else if (targetChange.removedDocuments.size > 0) {\n                    hardAssert(limboResolution.receivedDocument, 0xa4f3);\n                    limboResolution.receivedDocument = false;\n                }\n                else {\n                    // This was probably just a CURRENT targetChange or similar.\n                }\n            }\n        });\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, remoteEvent);\n    }\n    catch (error) {\n        await ignoreIfPrimaryLeaseLoss(error);\n    }\n}\n/**\n * Applies an OnlineState change to the sync engine and notifies any views of\n * the change.\n */\nfunction syncEngineApplyOnlineStateChange(syncEngine, onlineState, source) {\n    const syncEngineImpl = debugCast(syncEngine);\n    // If we are the secondary client, we explicitly ignore the remote store's\n    // online state (the local client may go offline, even though the primary\n    // tab remains online) and only apply the primary tab's online state from\n    // SharedClientState.\n    if ((syncEngineImpl.isPrimaryClient &&\n        source === 0 /* OnlineStateSource.RemoteStore */) ||\n        (!syncEngineImpl.isPrimaryClient &&\n            source === 1 /* OnlineStateSource.SharedClientState */)) {\n        const newViewSnapshots = [];\n        syncEngineImpl.queryViewsByQuery.forEach((query, queryView) => {\n            const viewChange = queryView.view.applyOnlineStateChange(onlineState);\n            if (viewChange.snapshot) {\n                newViewSnapshots.push(viewChange.snapshot);\n            }\n        });\n        eventManagerOnOnlineStateChange(syncEngineImpl.eventManager, onlineState);\n        if (newViewSnapshots.length) {\n            syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);\n        }\n        syncEngineImpl.onlineState = onlineState;\n        if (syncEngineImpl.isPrimaryClient) {\n            syncEngineImpl.sharedClientState.setOnlineState(onlineState);\n        }\n    }\n}\n/**\n * Rejects the listen for the given targetID. This can be triggered by the\n * backend for any active target.\n *\n * @param syncEngine - The sync engine implementation.\n * @param targetId - The targetID corresponds to one previously initiated by the\n * user as part of TargetData passed to listen() on RemoteStore.\n * @param err - A description of the condition that has forced the rejection.\n * Nearly always this will be an indication that the user is no longer\n * authorized to see the data matching the target.\n */\nasync function syncEngineRejectListen(syncEngine, targetId, err) {\n    const syncEngineImpl = debugCast(syncEngine);\n    // PORTING NOTE: Multi-tab only.\n    syncEngineImpl.sharedClientState.updateQueryState(targetId, 'rejected', err);\n    const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\n    const limboKey = limboResolution && limboResolution.key;\n    if (limboKey) {\n        // TODO(klimt): We really only should do the following on permission\n        // denied errors, but we don't have the cause code here.\n        // It's a limbo doc. Create a synthetic event saying it was deleted.\n        // This is kind of a hack. Ideally, we would have a method in the local\n        // store to purge a document. However, it would be tricky to keep all of\n        // the local store's invariants with another method.\n        let documentUpdates = new SortedMap(DocumentKey.comparator);\n        // TODO(b/217189216): This limbo document should ideally have a read time,\n        // so that it is picked up by any read-time based scans. The backend,\n        // however, does not send a read time for target removals.\n        documentUpdates = documentUpdates.insert(limboKey, MutableDocument.newNoDocument(limboKey, SnapshotVersion.min()));\n        const resolvedLimboDocuments = documentKeySet().add(limboKey);\n        const event = new RemoteEvent(SnapshotVersion.min(), \n        /* targetChanges= */ new Map(), \n        /* targetMismatches= */ new SortedMap(primitiveComparator), documentUpdates, resolvedLimboDocuments);\n        await syncEngineApplyRemoteEvent(syncEngineImpl, event);\n        // Since this query failed, we won't want to manually unlisten to it.\n        // We only remove it from bookkeeping after we successfully applied the\n        // RemoteEvent. If `applyRemoteEvent()` throws, we want to re-listen to\n        // this query when the RemoteStore restarts the Watch stream, which should\n        // re-trigger the target failure.\n        syncEngineImpl.activeLimboTargetsByKey =\n            syncEngineImpl.activeLimboTargetsByKey.remove(limboKey);\n        syncEngineImpl.activeLimboResolutionsByTarget.delete(targetId);\n        pumpEnqueuedLimboResolutions(syncEngineImpl);\n    }\n    else {\n        await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \n        /* keepPersistedTargetData */ false)\n            .then(() => removeAndCleanupTarget(syncEngineImpl, targetId, err))\n            .catch(ignoreIfPrimaryLeaseLoss);\n    }\n}\nasync function syncEngineApplySuccessfulWrite(syncEngine, mutationBatchResult) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const batchId = mutationBatchResult.batch.batchId;\n    try {\n        const changes = await localStoreAcknowledgeBatch(syncEngineImpl.localStore, mutationBatchResult);\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught\n        // up), so we raise user callbacks first so that they consistently happen\n        // before listen events.\n        processUserCallback(syncEngineImpl, batchId, /*error=*/ null);\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\n        syncEngineImpl.sharedClientState.updateMutationState(batchId, 'acknowledged');\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);\n    }\n    catch (error) {\n        await ignoreIfPrimaryLeaseLoss(error);\n    }\n}\nasync function syncEngineRejectFailedWrite(syncEngine, batchId, error) {\n    const syncEngineImpl = debugCast(syncEngine);\n    try {\n        const changes = await localStoreRejectBatch(syncEngineImpl.localStore, batchId);\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught up),\n        // so we raise user callbacks first so that they consistently happen before\n        // listen events.\n        processUserCallback(syncEngineImpl, batchId, error);\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\n        syncEngineImpl.sharedClientState.updateMutationState(batchId, 'rejected', error);\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);\n    }\n    catch (error) {\n        await ignoreIfPrimaryLeaseLoss(error);\n    }\n}\n/**\n * Registers a user callback that resolves when all pending mutations at the moment of calling\n * are acknowledged .\n */\nasync function syncEngineRegisterPendingWritesCallback(syncEngine, callback) {\n    const syncEngineImpl = debugCast(syncEngine);\n    if (!canUseNetwork(syncEngineImpl.remoteStore)) {\n        logDebug(LOG_TAG$3, 'The network is disabled. The task returned by ' +\n            \"'awaitPendingWrites()' will not complete until the network is enabled.\");\n    }\n    try {\n        const highestBatchId = await localStoreGetHighestUnacknowledgedBatchId(syncEngineImpl.localStore);\n        if (highestBatchId === BATCHID_UNKNOWN) {\n            // Trigger the callback right away if there is no pending writes at the moment.\n            callback.resolve();\n            return;\n        }\n        const callbacks = syncEngineImpl.pendingWritesCallbacks.get(highestBatchId) || [];\n        callbacks.push(callback);\n        syncEngineImpl.pendingWritesCallbacks.set(highestBatchId, callbacks);\n    }\n    catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(e, 'Initialization of waitForPendingWrites() operation failed');\n        callback.reject(firestoreError);\n    }\n}\n/**\n * Triggers the callbacks that are waiting for this batch id to get acknowledged by server,\n * if there are any.\n */\nfunction triggerPendingWritesCallbacks(syncEngineImpl, batchId) {\n    (syncEngineImpl.pendingWritesCallbacks.get(batchId) || []).forEach(callback => {\n        callback.resolve();\n    });\n    syncEngineImpl.pendingWritesCallbacks.delete(batchId);\n}\n/** Reject all outstanding callbacks waiting for pending writes to complete. */\nfunction rejectOutstandingPendingWritesCallbacks(syncEngineImpl, errorMessage) {\n    syncEngineImpl.pendingWritesCallbacks.forEach(callbacks => {\n        callbacks.forEach(callback => {\n            callback.reject(new FirestoreError(Code.CANCELLED, errorMessage));\n        });\n    });\n    syncEngineImpl.pendingWritesCallbacks.clear();\n}\nfunction addMutationCallback(syncEngineImpl, batchId, callback) {\n    let newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];\n    if (!newCallbacks) {\n        newCallbacks = new SortedMap(primitiveComparator);\n    }\n    newCallbacks = newCallbacks.insert(batchId, callback);\n    syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] =\n        newCallbacks;\n}\n/**\n * Resolves or rejects the user callback for the given batch and then discards\n * it.\n */\nfunction processUserCallback(syncEngine, batchId, error) {\n    const syncEngineImpl = debugCast(syncEngine);\n    let newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];\n    // NOTE: Mutations restored from persistence won't have callbacks, so it's\n    // okay for there to be no callback for this ID.\n    if (newCallbacks) {\n        const callback = newCallbacks.get(batchId);\n        if (callback) {\n            if (error) {\n                callback.reject(error);\n            }\n            else {\n                callback.resolve();\n            }\n            newCallbacks = newCallbacks.remove(batchId);\n        }\n        syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] =\n            newCallbacks;\n    }\n}\nfunction removeAndCleanupTarget(syncEngineImpl, targetId, error = null) {\n    syncEngineImpl.sharedClientState.removeLocalQueryTarget(targetId);\n    for (const query of syncEngineImpl.queriesByTarget.get(targetId)) {\n        syncEngineImpl.queryViewsByQuery.delete(query);\n        if (error) {\n            syncEngineImpl.syncEngineListener.onWatchError(query, error);\n        }\n    }\n    syncEngineImpl.queriesByTarget.delete(targetId);\n    if (syncEngineImpl.isPrimaryClient) {\n        const limboKeys = syncEngineImpl.limboDocumentRefs.removeReferencesForId(targetId);\n        limboKeys.forEach(limboKey => {\n            const isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboKey);\n            if (!isReferenced) {\n                // We removed the last reference for this key\n                removeLimboTarget(syncEngineImpl, limboKey);\n            }\n        });\n    }\n}\nfunction removeLimboTarget(syncEngineImpl, key) {\n    syncEngineImpl.enqueuedLimboResolutions.delete(key.path.canonicalString());\n    // It's possible that the target already got removed because the query failed. In that case,\n    // the key won't exist in `limboTargetsByKey`. Only do the cleanup if we still have the target.\n    const limboTargetId = syncEngineImpl.activeLimboTargetsByKey.get(key);\n    if (limboTargetId === null) {\n        // This target already got removed, because the query failed.\n        return;\n    }\n    remoteStoreUnlisten(syncEngineImpl.remoteStore, limboTargetId);\n    syncEngineImpl.activeLimboTargetsByKey =\n        syncEngineImpl.activeLimboTargetsByKey.remove(key);\n    syncEngineImpl.activeLimboResolutionsByTarget.delete(limboTargetId);\n    pumpEnqueuedLimboResolutions(syncEngineImpl);\n}\nfunction updateTrackedLimbos(syncEngineImpl, targetId, limboChanges) {\n    for (const limboChange of limboChanges) {\n        if (limboChange instanceof AddedLimboDocument) {\n            syncEngineImpl.limboDocumentRefs.addReference(limboChange.key, targetId);\n            trackLimboChange(syncEngineImpl, limboChange);\n        }\n        else if (limboChange instanceof RemovedLimboDocument) {\n            logDebug(LOG_TAG$3, 'Document no longer in limbo: ' + limboChange.key);\n            syncEngineImpl.limboDocumentRefs.removeReference(limboChange.key, targetId);\n            const isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboChange.key);\n            if (!isReferenced) {\n                // We removed the last reference for this key\n                removeLimboTarget(syncEngineImpl, limboChange.key);\n            }\n        }\n        else {\n            fail(0x4d4f, { limboChange });\n        }\n    }\n}\nfunction trackLimboChange(syncEngineImpl, limboChange) {\n    const key = limboChange.key;\n    const keyString = key.path.canonicalString();\n    if (!syncEngineImpl.activeLimboTargetsByKey.get(key) &&\n        !syncEngineImpl.enqueuedLimboResolutions.has(keyString)) {\n        logDebug(LOG_TAG$3, 'New document in limbo: ' + key);\n        syncEngineImpl.enqueuedLimboResolutions.add(keyString);\n        pumpEnqueuedLimboResolutions(syncEngineImpl);\n    }\n}\n/**\n * Starts listens for documents in limbo that are enqueued for resolution,\n * subject to a maximum number of concurrent resolutions.\n *\n * Without bounding the number of concurrent resolutions, the server can fail\n * with \"resource exhausted\" errors which can lead to pathological client\n * behavior as seen in https://github.com/firebase/firebase-js-sdk/issues/2683.\n */\nfunction pumpEnqueuedLimboResolutions(syncEngineImpl) {\n    while (syncEngineImpl.enqueuedLimboResolutions.size > 0 &&\n        syncEngineImpl.activeLimboTargetsByKey.size <\n            syncEngineImpl.maxConcurrentLimboResolutions) {\n        const keyString = syncEngineImpl.enqueuedLimboResolutions\n            .values()\n            .next().value;\n        syncEngineImpl.enqueuedLimboResolutions.delete(keyString);\n        const key = new DocumentKey(ResourcePath.fromString(keyString));\n        const limboTargetId = syncEngineImpl.limboTargetIdGenerator.next();\n        syncEngineImpl.activeLimboResolutionsByTarget.set(limboTargetId, new LimboResolution(key));\n        syncEngineImpl.activeLimboTargetsByKey =\n            syncEngineImpl.activeLimboTargetsByKey.insert(key, limboTargetId);\n        remoteStoreListen(syncEngineImpl.remoteStore, new TargetData(queryToTarget(newQueryForPath(key.path)), limboTargetId, \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */, ListenSequence.INVALID));\n    }\n}\nasync function syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, changes, remoteEvent) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const newSnaps = [];\n    const docChangesInAllViews = [];\n    const queriesProcessed = [];\n    if (syncEngineImpl.queryViewsByQuery.isEmpty()) {\n        // Return early since `onWatchChange()` might not have been assigned yet.\n        return;\n    }\n    syncEngineImpl.queryViewsByQuery.forEach((_, queryView) => {\n        queriesProcessed.push(syncEngineImpl\n            .applyDocChanges(queryView, changes, remoteEvent)\n            .then(viewSnapshot => {\n            // If there are changes, or we are handling a global snapshot, notify\n            // secondary clients to update query state.\n            if (viewSnapshot || remoteEvent) {\n                if (syncEngineImpl.isPrimaryClient) {\n                    // Query state is set to `current` if:\n                    // - There is a view change and it is up-to-date, or,\n                    // - There is a global snapshot, the Target is current, and no changes to be resolved\n                    const isCurrent = viewSnapshot\n                        ? !viewSnapshot.fromCache\n                        : remoteEvent?.targetChanges.get(queryView.targetId)?.current;\n                    syncEngineImpl.sharedClientState.updateQueryState(queryView.targetId, isCurrent ? 'current' : 'not-current');\n                }\n            }\n            // Update views if there are actual changes.\n            if (!!viewSnapshot) {\n                newSnaps.push(viewSnapshot);\n                const docChanges = LocalViewChanges.fromSnapshot(queryView.targetId, viewSnapshot);\n                docChangesInAllViews.push(docChanges);\n            }\n        }));\n    });\n    await Promise.all(queriesProcessed);\n    syncEngineImpl.syncEngineListener.onWatchChange(newSnaps);\n    await localStoreNotifyLocalViewChanges(syncEngineImpl.localStore, docChangesInAllViews);\n}\nasync function applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent) {\n    let viewDocChanges = queryView.view.computeDocChanges(changes);\n    if (viewDocChanges.needsRefill) {\n        // The query has a limit and some docs were removed, so we need\n        // to re-run the query against the local store to make sure we\n        // didn't lose any good docs that had been past the limit.\n        viewDocChanges = await localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, \n        /* usePreviousResults= */ false).then(({ documents }) => {\n            return queryView.view.computeDocChanges(documents, viewDocChanges);\n        });\n    }\n    const targetChange = remoteEvent && remoteEvent.targetChanges.get(queryView.targetId);\n    const targetIsPendingReset = remoteEvent && remoteEvent.targetMismatches.get(queryView.targetId) != null;\n    const viewChange = queryView.view.applyChanges(viewDocChanges, \n    /* limboResolutionEnabled= */ syncEngineImpl.isPrimaryClient, targetChange, targetIsPendingReset);\n    updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewChange.limboChanges);\n    return viewChange.snapshot;\n}\nasync function syncEngineHandleCredentialChange(syncEngine, user) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const userChanged = !syncEngineImpl.currentUser.isEqual(user);\n    if (userChanged) {\n        logDebug(LOG_TAG$3, 'User change. New user:', user.toKey());\n        const result = await localStoreHandleUserChange(syncEngineImpl.localStore, user);\n        syncEngineImpl.currentUser = user;\n        // Fails tasks waiting for pending writes requested by previous user.\n        rejectOutstandingPendingWritesCallbacks(syncEngineImpl, \"'waitForPendingWrites' promise is rejected due to a user change.\");\n        // TODO(b/114226417): Consider calling this only in the primary tab.\n        syncEngineImpl.sharedClientState.handleUserChange(user, result.removedBatchIds, result.addedBatchIds);\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.affectedDocuments);\n    }\n}\nfunction syncEngineGetRemoteKeysForTarget(syncEngine, targetId) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\n    if (limboResolution && limboResolution.receivedDocument) {\n        return documentKeySet().add(limboResolution.key);\n    }\n    else {\n        let keySet = documentKeySet();\n        const queries = syncEngineImpl.queriesByTarget.get(targetId);\n        if (!queries) {\n            return keySet;\n        }\n        for (const query of queries) {\n            const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n            keySet = keySet.unionWith(queryView.view.syncedDocuments);\n        }\n        return keySet;\n    }\n}\n/**\n * Reconcile the list of synced documents in an existing view with those\n * from persistence.\n */\nasync function synchronizeViewAndComputeSnapshot(syncEngine, queryView) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const queryResult = await localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, \n    /* usePreviousResults= */ true);\n    const viewSnapshot = queryView.view.synchronizeWithPersistedState(queryResult);\n    if (syncEngineImpl.isPrimaryClient) {\n        updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewSnapshot.limboChanges);\n    }\n    return viewSnapshot;\n}\n/**\n * Retrieves newly changed documents from remote document cache and raises\n * snapshots if needed.\n */\n// PORTING NOTE: Multi-Tab only.\nasync function syncEngineSynchronizeWithChangedDocuments(syncEngine, collectionGroup) {\n    const syncEngineImpl = debugCast(syncEngine);\n    return localStoreGetNewDocumentChanges(syncEngineImpl.localStore, collectionGroup).then(changes => syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes));\n}\n/** Applies a mutation state to an existing batch.  */\n// PORTING NOTE: Multi-Tab only.\nasync function syncEngineApplyBatchState(syncEngine, batchId, batchState, error) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const documents = await localStoreLookupMutationDocuments(syncEngineImpl.localStore, batchId);\n    if (documents === null) {\n        // A throttled tab may not have seen the mutation before it was completed\n        // and removed from the mutation queue, in which case we won't have cached\n        // the affected documents. In this case we can safely ignore the update\n        // since that means we didn't apply the mutation locally at all (if we\n        // had, we would have cached the affected documents), and so we will just\n        // see any resulting document changes via normal remote document updates\n        // as applicable.\n        logDebug(LOG_TAG$3, 'Cannot apply mutation batch with id: ' + batchId);\n        return;\n    }\n    if (batchState === 'pending') {\n        // If we are the primary client, we need to send this write to the\n        // backend. Secondary clients will ignore these writes since their remote\n        // connection is disabled.\n        await fillWritePipeline(syncEngineImpl.remoteStore);\n    }\n    else if (batchState === 'acknowledged' || batchState === 'rejected') {\n        // NOTE: Both these methods are no-ops for batches that originated from\n        // other clients.\n        processUserCallback(syncEngineImpl, batchId, error ? error : null);\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\n        localStoreRemoveCachedMutationBatchMetadata(syncEngineImpl.localStore, batchId);\n    }\n    else {\n        fail(0x1a40, `Unknown batchState`, { batchState });\n    }\n    await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, documents);\n}\n/** Applies a query target change from a different tab. */\n// PORTING NOTE: Multi-Tab only.\nasync function syncEngineApplyPrimaryState(syncEngine, isPrimary) {\n    const syncEngineImpl = debugCast(syncEngine);\n    ensureWatchCallbacks(syncEngineImpl);\n    syncEngineEnsureWriteCallbacks(syncEngineImpl);\n    if (isPrimary === true && syncEngineImpl._isPrimaryClient !== true) {\n        // Secondary tabs only maintain Views for their local listeners and the\n        // Views internal state may not be 100% populated (in particular\n        // secondary tabs don't track syncedDocuments, the set of documents the\n        // server considers to be in the target). So when a secondary becomes\n        // primary, we need to need to make sure that all views for all targets\n        // match the state on disk.\n        const activeTargets = syncEngineImpl.sharedClientState.getAllActiveQueryTargets();\n        const activeQueries = await synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets.toArray());\n        syncEngineImpl._isPrimaryClient = true;\n        await remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, true);\n        for (const targetData of activeQueries) {\n            remoteStoreListen(syncEngineImpl.remoteStore, targetData);\n        }\n    }\n    else if (isPrimary === false && syncEngineImpl._isPrimaryClient !== false) {\n        const activeTargets = [];\n        let p = Promise.resolve();\n        syncEngineImpl.queriesByTarget.forEach((_, targetId) => {\n            if (syncEngineImpl.sharedClientState.isLocalQueryTarget(targetId)) {\n                activeTargets.push(targetId);\n            }\n            else {\n                p = p.then(() => {\n                    removeAndCleanupTarget(syncEngineImpl, targetId);\n                    return localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \n                    /*keepPersistedTargetData=*/ true);\n                });\n            }\n            remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\n        });\n        await p;\n        await synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets);\n        resetLimboDocuments(syncEngineImpl);\n        syncEngineImpl._isPrimaryClient = false;\n        await remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, false);\n    }\n}\n// PORTING NOTE: Multi-Tab only.\nfunction resetLimboDocuments(syncEngine) {\n    const syncEngineImpl = debugCast(syncEngine);\n    syncEngineImpl.activeLimboResolutionsByTarget.forEach((_, targetId) => {\n        remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\n    });\n    syncEngineImpl.limboDocumentRefs.removeAllReferences();\n    syncEngineImpl.activeLimboResolutionsByTarget = new Map();\n    syncEngineImpl.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);\n}\n/**\n * Reconcile the query views of the provided query targets with the state from\n * persistence. Raises snapshots for any changes that affect the local\n * client and returns the updated state of all target's query data.\n *\n * @param syncEngine - The sync engine implementation\n * @param targets - the list of targets with views that need to be recomputed\n * @param transitionToPrimary - `true` iff the tab transitions from a secondary\n * tab to a primary tab\n */\n// PORTING NOTE: Multi-Tab only.\nasync function synchronizeQueryViewsAndRaiseSnapshots(syncEngine, targets, transitionToPrimary) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const activeQueries = [];\n    const newViewSnapshots = [];\n    for (const targetId of targets) {\n        let targetData;\n        const queries = syncEngineImpl.queriesByTarget.get(targetId);\n        if (queries && queries.length !== 0) {\n            // For queries that have a local View, we fetch their current state\n            // from LocalStore (as the resume token and the snapshot version\n            // might have changed) and reconcile their views with the persisted\n            // state (the list of syncedDocuments may have gotten out of sync).\n            targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(queries[0]));\n            for (const query of queries) {\n                const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n                const viewChange = await synchronizeViewAndComputeSnapshot(syncEngineImpl, queryView);\n                if (viewChange.snapshot) {\n                    newViewSnapshots.push(viewChange.snapshot);\n                }\n            }\n        }\n        else {\n            // For queries that never executed on this client, we need to\n            // allocate the target in LocalStore and initialize a new View.\n            const target = await localStoreGetCachedTarget(syncEngineImpl.localStore, targetId);\n            targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, target);\n            await initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetId, \n            /*current=*/ false, targetData.resumeToken);\n        }\n        activeQueries.push(targetData);\n    }\n    syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);\n    return activeQueries;\n}\n/**\n * Creates a `Query` object from the specified `Target`. There is no way to\n * obtain the original `Query`, so we synthesize a `Query` from the `Target`\n * object.\n *\n * The synthesized result might be different from the original `Query`, but\n * since the synthesized `Query` should return the same results as the\n * original one (only the presentation of results might differ), the potential\n * difference will not cause issues.\n */\n// PORTING NOTE: Multi-Tab only.\nfunction synthesizeTargetToQuery(target) {\n    return newQuery(target.path, target.collectionGroup, target.orderBy, target.filters, target.limit, \"F\" /* LimitType.First */, target.startAt, target.endAt);\n}\n/** Returns the IDs of the clients that are currently active. */\n// PORTING NOTE: Multi-Tab only.\nfunction syncEngineGetActiveClients(syncEngine) {\n    const syncEngineImpl = debugCast(syncEngine);\n    return localStoreGetActiveClients(syncEngineImpl.localStore);\n}\n/** Applies a query target change from a different tab. */\n// PORTING NOTE: Multi-Tab only.\nasync function syncEngineApplyTargetState(syncEngine, targetId, state, error) {\n    const syncEngineImpl = debugCast(syncEngine);\n    if (syncEngineImpl._isPrimaryClient) {\n        // If we receive a target state notification via WebStorage, we are\n        // either already secondary or another tab has taken the primary lease.\n        logDebug(LOG_TAG$3, 'Ignoring unexpected query state notification.');\n        return;\n    }\n    const query = syncEngineImpl.queriesByTarget.get(targetId);\n    if (query && query.length > 0) {\n        switch (state) {\n            case 'current':\n            case 'not-current': {\n                const changes = await localStoreGetNewDocumentChanges(syncEngineImpl.localStore, queryCollectionGroup(query[0]));\n                const synthesizedRemoteEvent = RemoteEvent.createSynthesizedRemoteEventForCurrentChange(targetId, state === 'current', ByteString.EMPTY_BYTE_STRING);\n                await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, synthesizedRemoteEvent);\n                break;\n            }\n            case 'rejected': {\n                await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \n                /* keepPersistedTargetData */ true);\n                removeAndCleanupTarget(syncEngineImpl, targetId, error);\n                break;\n            }\n            default:\n                fail(0xfa9b, state);\n        }\n    }\n}\n/** Adds or removes Watch targets for queries from different tabs. */\nasync function syncEngineApplyActiveTargetsChange(syncEngine, added, removed) {\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\n    if (!syncEngineImpl._isPrimaryClient) {\n        return;\n    }\n    for (const targetId of added) {\n        // A target is already listening to remote store if it is already registered to\n        // sharedClientState.\n        const targetAlreadyListeningToRemoteStore = syncEngineImpl.queriesByTarget.has(targetId) &&\n            syncEngineImpl.sharedClientState.isActiveQueryTarget(targetId);\n        if (targetAlreadyListeningToRemoteStore) {\n            logDebug(LOG_TAG$3, 'Adding an already active target ' + targetId);\n            continue;\n        }\n        const target = await localStoreGetCachedTarget(syncEngineImpl.localStore, targetId);\n        const targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, target);\n        await initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetData.targetId, \n        /*current=*/ false, targetData.resumeToken);\n        remoteStoreListen(syncEngineImpl.remoteStore, targetData);\n    }\n    for (const targetId of removed) {\n        // Check that the target is still active since the target might have been\n        // removed if it has been rejected by the backend.\n        if (!syncEngineImpl.queriesByTarget.has(targetId)) {\n            continue;\n        }\n        // Release queries that are still active.\n        await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \n        /* keepPersistedTargetData */ false)\n            .then(() => {\n            remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\n            removeAndCleanupTarget(syncEngineImpl, targetId);\n        })\n            .catch(ignoreIfPrimaryLeaseLoss);\n    }\n}\nfunction ensureWatchCallbacks(syncEngine) {\n    const syncEngineImpl = debugCast(syncEngine);\n    syncEngineImpl.remoteStore.remoteSyncer.applyRemoteEvent =\n        syncEngineApplyRemoteEvent.bind(null, syncEngineImpl);\n    syncEngineImpl.remoteStore.remoteSyncer.getRemoteKeysForTarget =\n        syncEngineGetRemoteKeysForTarget.bind(null, syncEngineImpl);\n    syncEngineImpl.remoteStore.remoteSyncer.rejectListen =\n        syncEngineRejectListen.bind(null, syncEngineImpl);\n    syncEngineImpl.syncEngineListener.onWatchChange =\n        eventManagerOnWatchChange.bind(null, syncEngineImpl.eventManager);\n    syncEngineImpl.syncEngineListener.onWatchError =\n        eventManagerOnWatchError.bind(null, syncEngineImpl.eventManager);\n    return syncEngineImpl;\n}\nfunction syncEngineEnsureWriteCallbacks(syncEngine) {\n    const syncEngineImpl = debugCast(syncEngine);\n    syncEngineImpl.remoteStore.remoteSyncer.applySuccessfulWrite =\n        syncEngineApplySuccessfulWrite.bind(null, syncEngineImpl);\n    syncEngineImpl.remoteStore.remoteSyncer.rejectFailedWrite =\n        syncEngineRejectFailedWrite.bind(null, syncEngineImpl);\n    return syncEngineImpl;\n}\n/**\n * Loads a Firestore bundle into the SDK. The returned promise resolves when\n * the bundle finished loading.\n *\n * @param syncEngine - SyncEngine to use.\n * @param bundleReader - Bundle to load into the SDK.\n * @param task - LoadBundleTask used to update the loading progress to public API.\n */\nfunction syncEngineLoadBundle(syncEngine, bundleReader, task) {\n    const syncEngineImpl = debugCast(syncEngine);\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    loadBundleImpl(syncEngineImpl, bundleReader, task).then(collectionGroups => {\n        syncEngineImpl.sharedClientState.notifyBundleLoaded(collectionGroups);\n    });\n}\n/** Loads a bundle and returns the list of affected collection groups. */\nasync function loadBundleImpl(syncEngine, reader, task) {\n    try {\n        const metadata = await reader.getMetadata();\n        const skip = await localStoreHasNewerBundle(syncEngine.localStore, metadata);\n        if (skip) {\n            await reader.close();\n            task._completeWith(bundleSuccessProgress(metadata));\n            return Promise.resolve(new Set());\n        }\n        task._updateProgress(bundleInitialProgress(metadata));\n        const loader = new BundleLoader(metadata, reader.serializer);\n        let element = await reader.nextElement();\n        while (element) {\n            ;\n            const progress = await loader.addSizedElement(element);\n            if (progress) {\n                task._updateProgress(progress);\n            }\n            element = await reader.nextElement();\n        }\n        const result = await loader.completeAndStoreAsync(syncEngine.localStore);\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, result.changedDocs, \n        /* remoteEvent */ undefined);\n        // Save metadata, so loading the same bundle will skip.\n        await localStoreSaveBundle(syncEngine.localStore, metadata);\n        task._completeWith(result.progress);\n        return Promise.resolve(result.changedCollectionGroups);\n    }\n    catch (e) {\n        logWarn(LOG_TAG$3, `Loading bundle failed with ${e}`);\n        task._failWith(e);\n        return Promise.resolve(new Set());\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides all components needed for Firestore with in-memory persistence.\n * Uses EagerGC garbage collection.\n */\nclass MemoryOfflineComponentProvider {\n    constructor() {\n        this.kind = 'memory';\n        this.synchronizeTabs = false;\n    }\n    async initialize(cfg) {\n        this.serializer = newSerializer(cfg.databaseInfo.databaseId);\n        this.sharedClientState = this.createSharedClientState(cfg);\n        this.persistence = this.createPersistence(cfg);\n        await this.persistence.start();\n        this.localStore = this.createLocalStore(cfg);\n        this.gcScheduler = this.createGarbageCollectionScheduler(cfg, this.localStore);\n        this.indexBackfillerScheduler = this.createIndexBackfillerScheduler(cfg, this.localStore);\n    }\n    createGarbageCollectionScheduler(cfg, localStore) {\n        return null;\n    }\n    createIndexBackfillerScheduler(cfg, localStore) {\n        return null;\n    }\n    createLocalStore(cfg) {\n        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);\n    }\n    createPersistence(cfg) {\n        return new MemoryPersistence(MemoryEagerDelegate.factory, this.serializer);\n    }\n    createSharedClientState(cfg) {\n        return new MemorySharedClientState();\n    }\n    async terminate() {\n        this.gcScheduler?.stop();\n        this.indexBackfillerScheduler?.stop();\n        this.sharedClientState.shutdown();\n        await this.persistence.shutdown();\n    }\n}\nMemoryOfflineComponentProvider.provider = {\n    build: () => new MemoryOfflineComponentProvider()\n};\nclass LruGcMemoryOfflineComponentProvider extends MemoryOfflineComponentProvider {\n    constructor(cacheSizeBytes) {\n        super();\n        this.cacheSizeBytes = cacheSizeBytes;\n    }\n    createGarbageCollectionScheduler(cfg, localStore) {\n        hardAssert(this.persistence.referenceDelegate instanceof MemoryLruDelegate, 0xb743);\n        const garbageCollector = this.persistence.referenceDelegate.garbageCollector;\n        return new LruScheduler(garbageCollector, cfg.asyncQueue, localStore);\n    }\n    createPersistence(cfg) {\n        const lruParams = this.cacheSizeBytes !== undefined\n            ? LruParams.withCacheSize(this.cacheSizeBytes)\n            : LruParams.DEFAULT;\n        return new MemoryPersistence(p => MemoryLruDelegate.factory(p, lruParams), this.serializer);\n    }\n}\n/**\n * Provides all components needed for Firestore with IndexedDB persistence.\n */\nclass IndexedDbOfflineComponentProvider extends MemoryOfflineComponentProvider {\n    constructor(onlineComponentProvider, cacheSizeBytes, forceOwnership) {\n        super();\n        this.onlineComponentProvider = onlineComponentProvider;\n        this.cacheSizeBytes = cacheSizeBytes;\n        this.forceOwnership = forceOwnership;\n        this.kind = 'persistent';\n        this.synchronizeTabs = false;\n    }\n    async initialize(cfg) {\n        await super.initialize(cfg);\n        await this.onlineComponentProvider.initialize(this, cfg);\n        // Enqueue writes from a previous session\n        await syncEngineEnsureWriteCallbacks(this.onlineComponentProvider.syncEngine);\n        await fillWritePipeline(this.onlineComponentProvider.remoteStore);\n        // NOTE: This will immediately call the listener, so we make sure to\n        // set it after localStore / remoteStore are started.\n        await this.persistence.setPrimaryStateListener(() => {\n            if (this.gcScheduler && !this.gcScheduler.started) {\n                this.gcScheduler.start();\n            }\n            if (this.indexBackfillerScheduler &&\n                !this.indexBackfillerScheduler.started) {\n                this.indexBackfillerScheduler.start();\n            }\n            return Promise.resolve();\n        });\n    }\n    createLocalStore(cfg) {\n        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);\n    }\n    createGarbageCollectionScheduler(cfg, localStore) {\n        const garbageCollector = this.persistence.referenceDelegate.garbageCollector;\n        return new LruScheduler(garbageCollector, cfg.asyncQueue, localStore);\n    }\n    createIndexBackfillerScheduler(cfg, localStore) {\n        const indexBackfiller = new IndexBackfiller(localStore, this.persistence);\n        return new IndexBackfillerScheduler(cfg.asyncQueue, indexBackfiller);\n    }\n    createPersistence(cfg) {\n        const persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);\n        const lruParams = this.cacheSizeBytes !== undefined\n            ? LruParams.withCacheSize(this.cacheSizeBytes)\n            : LruParams.DEFAULT;\n        return new IndexedDbPersistence(this.synchronizeTabs, persistenceKey, cfg.clientId, lruParams, cfg.asyncQueue, getWindow(), getDocument(), this.serializer, this.sharedClientState, !!this.forceOwnership);\n    }\n    createSharedClientState(cfg) {\n        return new MemorySharedClientState();\n    }\n}\n/**\n * Provides all components needed for Firestore with multi-tab IndexedDB\n * persistence.\n *\n * In the legacy client, this provider is used to provide both multi-tab and\n * non-multi-tab persistence since we cannot tell at build time whether\n * `synchronizeTabs` will be enabled.\n */\nclass MultiTabOfflineComponentProvider extends IndexedDbOfflineComponentProvider {\n    constructor(onlineComponentProvider, cacheSizeBytes) {\n        super(onlineComponentProvider, cacheSizeBytes, /* forceOwnership= */ false);\n        this.onlineComponentProvider = onlineComponentProvider;\n        this.cacheSizeBytes = cacheSizeBytes;\n        this.synchronizeTabs = true;\n    }\n    async initialize(cfg) {\n        await super.initialize(cfg);\n        const syncEngine = this.onlineComponentProvider.syncEngine;\n        if (this.sharedClientState instanceof WebStorageSharedClientState) {\n            this.sharedClientState.syncEngine = {\n                applyBatchState: syncEngineApplyBatchState.bind(null, syncEngine),\n                applyTargetState: syncEngineApplyTargetState.bind(null, syncEngine),\n                applyActiveTargetsChange: syncEngineApplyActiveTargetsChange.bind(null, syncEngine),\n                getActiveClients: syncEngineGetActiveClients.bind(null, syncEngine),\n                synchronizeWithChangedDocuments: syncEngineSynchronizeWithChangedDocuments.bind(null, syncEngine)\n            };\n            await this.sharedClientState.start();\n        }\n        // NOTE: This will immediately call the listener, so we make sure to\n        // set it after localStore / remoteStore are started.\n        await this.persistence.setPrimaryStateListener(async (isPrimary) => {\n            await syncEngineApplyPrimaryState(this.onlineComponentProvider.syncEngine, isPrimary);\n            if (this.gcScheduler) {\n                if (isPrimary && !this.gcScheduler.started) {\n                    this.gcScheduler.start();\n                }\n                else if (!isPrimary) {\n                    this.gcScheduler.stop();\n                }\n            }\n            if (this.indexBackfillerScheduler) {\n                if (isPrimary && !this.indexBackfillerScheduler.started) {\n                    this.indexBackfillerScheduler.start();\n                }\n                else if (!isPrimary) {\n                    this.indexBackfillerScheduler.stop();\n                }\n            }\n        });\n    }\n    createSharedClientState(cfg) {\n        const window = getWindow();\n        if (!WebStorageSharedClientState.isAvailable(window)) {\n            throw new FirestoreError(Code.UNIMPLEMENTED, 'IndexedDB persistence is only available on platforms that support LocalStorage.');\n        }\n        const persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);\n        return new WebStorageSharedClientState(window, cfg.asyncQueue, persistenceKey, cfg.clientId, cfg.initialUser);\n    }\n}\n/**\n * Initializes and wires the components that are needed to interface with the\n * network.\n */\nclass OnlineComponentProvider {\n    async initialize(offlineComponentProvider, cfg) {\n        if (this.localStore) {\n            // OnlineComponentProvider may get initialized multiple times if\n            // multi-tab persistence is used.\n            return;\n        }\n        this.localStore = offlineComponentProvider.localStore;\n        this.sharedClientState = offlineComponentProvider.sharedClientState;\n        this.datastore = this.createDatastore(cfg);\n        this.remoteStore = this.createRemoteStore(cfg);\n        this.eventManager = this.createEventManager(cfg);\n        this.syncEngine = this.createSyncEngine(cfg, \n        /* startAsPrimary=*/ !offlineComponentProvider.synchronizeTabs);\n        this.sharedClientState.onlineStateHandler = onlineState => syncEngineApplyOnlineStateChange(this.syncEngine, onlineState, 1 /* OnlineStateSource.SharedClientState */);\n        this.remoteStore.remoteSyncer.handleCredentialChange =\n            syncEngineHandleCredentialChange.bind(null, this.syncEngine);\n        await remoteStoreApplyPrimaryState(this.remoteStore, this.syncEngine.isPrimaryClient);\n    }\n    createEventManager(cfg) {\n        return newEventManager();\n    }\n    createDatastore(cfg) {\n        const serializer = newSerializer(cfg.databaseInfo.databaseId);\n        const connection = newConnection(cfg.databaseInfo);\n        return newDatastore(cfg.authCredentials, cfg.appCheckCredentials, connection, serializer);\n    }\n    createRemoteStore(cfg) {\n        return newRemoteStore(this.localStore, this.datastore, cfg.asyncQueue, onlineState => syncEngineApplyOnlineStateChange(this.syncEngine, onlineState, 0 /* OnlineStateSource.RemoteStore */), newConnectivityMonitor());\n    }\n    createSyncEngine(cfg, startAsPrimary) {\n        return newSyncEngine(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, cfg.initialUser, cfg.maxConcurrentLimboResolutions, startAsPrimary);\n    }\n    async terminate() {\n        await remoteStoreShutdown(this.remoteStore);\n        this.datastore?.terminate();\n        this.eventManager?.terminate();\n    }\n}\nOnlineComponentProvider.provider = {\n    build: () => new OnlineComponentProvider()\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * How many bytes to read each time when `ReadableStreamReader.read()` is\n * called. Only applicable for byte streams that we control (e.g. those backed\n * by an UInt8Array).\n */\nconst DEFAULT_BYTES_PER_READ = 10240;\n/**\n * Builds a `ByteStreamReader` from a UInt8Array.\n * @param source - The data source to use.\n * @param bytesPerRead - How many bytes each `read()` from the returned reader\n *        will read.\n */\nfunction toByteStreamReaderHelper(source, bytesPerRead = DEFAULT_BYTES_PER_READ) {\n    let readFrom = 0;\n    // The TypeScript definition for ReadableStreamReader changed. We use\n    // `any` here to allow this code to compile with different versions.\n    // See https://github.com/microsoft/TypeScript/issues/42970\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const reader = {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        async read() {\n            if (readFrom < source.byteLength) {\n                const result = {\n                    value: source.slice(readFrom, readFrom + bytesPerRead),\n                    done: false\n                };\n                readFrom += bytesPerRead;\n                return result;\n            }\n            return { done: true };\n        },\n        async cancel() { },\n        releaseLock() { },\n        closed: Promise.resolve()\n    };\n    return reader;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * On Node, only supported data source is a `Uint8Array` for now.\n */\nfunction toByteStreamReader(source, bytesPerRead) {\n    if (!(source instanceof Uint8Array)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `NodePlatform.toByteStreamReader expects source to be Uint8Array, got ${valueDescription(source)}`);\n    }\n    return toByteStreamReaderHelper(source, bytesPerRead);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * A wrapper implementation of Observer<T> that will dispatch events\n * asynchronously. To allow immediate silencing, a mute call is added which\n * causes events scheduled to no longer be raised.\n */\nclass AsyncObserver {\n    constructor(observer) {\n        this.observer = observer;\n        /**\n         * When set to true, will not raise future events. Necessary to deal with\n         * async detachment of listener.\n         */\n        this.muted = false;\n    }\n    next(value) {\n        if (this.muted) {\n            return;\n        }\n        if (this.observer.next) {\n            this.scheduleEvent(this.observer.next, value);\n        }\n    }\n    error(error) {\n        if (this.muted) {\n            return;\n        }\n        if (this.observer.error) {\n            this.scheduleEvent(this.observer.error, error);\n        }\n        else {\n            logError('Uncaught Error in snapshot listener:', error.toString());\n        }\n    }\n    mute() {\n        this.muted = true;\n    }\n    scheduleEvent(eventHandler, event) {\n        setTimeout(() => {\n            if (!this.muted) {\n                eventHandler(event);\n            }\n        }, 0);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A complete element in the bundle stream, together with the byte length it\n * occupies in the stream.\n */\nclass SizedBundleElement {\n    constructor(payload, \n    // How many bytes this element takes to store in the bundle.\n    byteLength) {\n        this.payload = payload;\n        this.byteLength = byteLength;\n    }\n    isBundleMetadata() {\n        return 'metadata' in this.payload;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A class representing a bundle.\n *\n * Takes a bundle stream or buffer, and presents abstractions to read bundled\n * elements out of the underlying content.\n */\nclass BundleReaderImpl {\n    constructor(\n    /** The reader to read from underlying binary bundle data source. */\n    reader, serializer) {\n        this.reader = reader;\n        this.serializer = serializer;\n        /** Cached bundle metadata. */\n        this.metadata = new Deferred();\n        /**\n         * Internal buffer to hold bundle content, accumulating incomplete element\n         * content.\n         */\n        this.buffer = new Uint8Array();\n        this.textDecoder = newTextDecoder();\n        // Read the metadata (which is the first element).\n        this.nextElementImpl().then(element => {\n            if (element && element.isBundleMetadata()) {\n                this.metadata.resolve(element.payload.metadata);\n            }\n            else {\n                this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is\n             ${JSON.stringify(element?.payload)}`));\n            }\n        }, error => this.metadata.reject(error));\n    }\n    close() {\n        return this.reader.cancel();\n    }\n    async getMetadata() {\n        return this.metadata.promise;\n    }\n    async nextElement() {\n        // Makes sure metadata is read before proceeding.\n        await this.getMetadata();\n        return this.nextElementImpl();\n    }\n    /**\n     * Reads from the head of internal buffer, and pulling more data from\n     * underlying stream if a complete element cannot be found, until an\n     * element(including the prefixed length and the JSON string) is found.\n     *\n     * Once a complete element is read, it is dropped from internal buffer.\n     *\n     * Returns either the bundled element, or null if we have reached the end of\n     * the stream.\n     */\n    async nextElementImpl() {\n        const lengthBuffer = await this.readLength();\n        if (lengthBuffer === null) {\n            return null;\n        }\n        const lengthString = this.textDecoder.decode(lengthBuffer);\n        const length = Number(lengthString);\n        if (isNaN(length)) {\n            this.raiseError(`length string (${lengthString}) is not valid number`);\n        }\n        const jsonString = await this.readJsonString(length);\n        return new SizedBundleElement(JSON.parse(jsonString), lengthBuffer.length + length);\n    }\n    /** First index of '{' from the underlying buffer. */\n    indexOfOpenBracket() {\n        return this.buffer.findIndex(v => v === '{'.charCodeAt(0));\n    }\n    /**\n     * Reads from the beginning of the internal buffer, until the first '{', and\n     * return the content.\n     *\n     * If reached end of the stream, returns a null.\n     */\n    async readLength() {\n        while (this.indexOfOpenBracket() < 0) {\n            const done = await this.pullMoreDataToBuffer();\n            if (done) {\n                break;\n            }\n        }\n        // Broke out of the loop because underlying stream is closed, and there\n        // happens to be no more data to process.\n        if (this.buffer.length === 0) {\n            return null;\n        }\n        const position = this.indexOfOpenBracket();\n        // Broke out of the loop because underlying stream is closed, but still\n        // cannot find an open bracket.\n        if (position < 0) {\n            this.raiseError('Reached the end of bundle when a length string is expected.');\n        }\n        const result = this.buffer.slice(0, position);\n        // Update the internal buffer to drop the read length.\n        this.buffer = this.buffer.slice(position);\n        return result;\n    }\n    /**\n     * Reads from a specified position from the internal buffer, for a specified\n     * number of bytes, pulling more data from the underlying stream if needed.\n     *\n     * Returns a string decoded from the read bytes.\n     */\n    async readJsonString(length) {\n        while (this.buffer.length < length) {\n            const done = await this.pullMoreDataToBuffer();\n            if (done) {\n                this.raiseError('Reached the end of bundle when more is expected.');\n            }\n        }\n        const result = this.textDecoder.decode(this.buffer.slice(0, length));\n        // Update the internal buffer to drop the read json string.\n        this.buffer = this.buffer.slice(length);\n        return result;\n    }\n    raiseError(message) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.reader.cancel();\n        throw new Error(`Invalid bundle format: ${message}`);\n    }\n    /**\n     * Pulls more data from underlying stream to internal buffer.\n     * Returns a boolean indicating whether the stream is finished.\n     */\n    async pullMoreDataToBuffer() {\n        const result = await this.reader.read();\n        if (!result.done) {\n            const newBuffer = new Uint8Array(this.buffer.length + result.value.length);\n            newBuffer.set(this.buffer);\n            newBuffer.set(result.value, this.buffer.length);\n            this.buffer = newBuffer;\n        }\n        return result.done;\n    }\n}\nfunction newBundleReader(reader, serializer) {\n    return new BundleReaderImpl(reader, serializer);\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A class that can parse a bundle form the string serialization of a bundle.\n */\nclass BundleReaderSyncImpl {\n    constructor(bundleData, serializer) {\n        this.bundleData = bundleData;\n        this.serializer = serializer;\n        this.cursor = 0;\n        this.elements = [];\n        let element = this.nextElement();\n        if (element && element.isBundleMetadata()) {\n            this.metadata = element;\n        }\n        else {\n            throw new Error(`The first element of the bundle is not a metadata object, it is\n         ${JSON.stringify(element?.payload)}`);\n        }\n        do {\n            element = this.nextElement();\n            if (element !== null) {\n                this.elements.push(element);\n            }\n        } while (element !== null);\n    }\n    /* Returns the parsed metadata of the bundle. */\n    getMetadata() {\n        return this.metadata;\n    }\n    /* Returns the DocumentSnapshot or NamedQuery elements of the bundle. */\n    getElements() {\n        return this.elements;\n    }\n    /**\n     * Parses the next element of the bundle.\n     *\n     * @returns a SizedBundleElement representation of the next element in the bundle, or null if\n     * no more elements exist.\n     */\n    nextElement() {\n        if (this.cursor === this.bundleData.length) {\n            return null;\n        }\n        const length = this.readLength();\n        const jsonString = this.readJsonString(length);\n        return new SizedBundleElement(JSON.parse(jsonString), length);\n    }\n    /**\n     * Reads from a specified position from the bundleData string, for a specified\n     * number of bytes.\n     *\n     * @param length - how many characters to read.\n     * @returns a string parsed from the bundle.\n     */\n    readJsonString(length) {\n        if (this.cursor + length > this.bundleData.length) {\n            throw new FirestoreError(Code.INTERNAL, 'Reached the end of bundle when more is expected.');\n        }\n        const result = this.bundleData.slice(this.cursor, (this.cursor += length));\n        return result;\n    }\n    /**\n     * Reads from the current cursor until the first '{'.\n     *\n     * @returns  A string to integer represention of the parsed value.\n     * @throws An {@link Error} if the cursor has reached the end of the stream, since lengths\n     * prefix bundle objects.\n     */\n    readLength() {\n        const startIndex = this.cursor;\n        let curIndex = this.cursor;\n        while (curIndex < this.bundleData.length) {\n            if (this.bundleData[curIndex] === '{') {\n                if (curIndex === startIndex) {\n                    throw new Error('First character is a bracket and not a number');\n                }\n                this.cursor = curIndex;\n                return Number(this.bundleData.slice(startIndex, curIndex));\n            }\n            curIndex++;\n        }\n        throw new Error('Reached the end of bundle when more is expected.');\n    }\n}\n/**\n *  Creates an instance of BundleReader without exposing the BundleReaderSyncImpl class type.\n */\nfunction newBundleReaderSync(bundleData, serializer) {\n    return new BundleReaderSyncImpl(bundleData, serializer);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Internal transaction object responsible for accumulating the mutations to\n * perform and the base versions for any documents read.\n */\nclass Transaction {\n    constructor(datastore) {\n        this.datastore = datastore;\n        // The version of each document that was read during this transaction.\n        this.readVersions = new Map();\n        this.mutations = [];\n        this.committed = false;\n        /**\n         * A deferred usage error that occurred previously in this transaction that\n         * will cause the transaction to fail once it actually commits.\n         */\n        this.lastTransactionError = null;\n        /**\n         * Set of documents that have been written in the transaction.\n         *\n         * When there's more than one write to the same key in a transaction, any\n         * writes after the first are handled differently.\n         */\n        this.writtenDocs = new Set();\n    }\n    async lookup(keys) {\n        this.ensureCommitNotCalled();\n        if (this.mutations.length > 0) {\n            this.lastTransactionError = new FirestoreError(Code.INVALID_ARGUMENT, 'Firestore transactions require all reads to be executed before all writes.');\n            throw this.lastTransactionError;\n        }\n        const docs = await invokeBatchGetDocumentsRpc(this.datastore, keys);\n        docs.forEach(doc => this.recordVersion(doc));\n        return docs;\n    }\n    set(key, data) {\n        this.write(data.toMutation(key, this.precondition(key)));\n        this.writtenDocs.add(key.toString());\n    }\n    update(key, data) {\n        try {\n            this.write(data.toMutation(key, this.preconditionForUpdate(key)));\n        }\n        catch (e) {\n            this.lastTransactionError = e;\n        }\n        this.writtenDocs.add(key.toString());\n    }\n    delete(key) {\n        this.write(new DeleteMutation(key, this.precondition(key)));\n        this.writtenDocs.add(key.toString());\n    }\n    async commit() {\n        this.ensureCommitNotCalled();\n        if (this.lastTransactionError) {\n            throw this.lastTransactionError;\n        }\n        const unwritten = this.readVersions;\n        // For each mutation, note that the doc was written.\n        this.mutations.forEach(mutation => {\n            unwritten.delete(mutation.key.toString());\n        });\n        // For each document that was read but not written to, we want to perform\n        // a `verify` operation.\n        unwritten.forEach((_, path) => {\n            const key = DocumentKey.fromPath(path);\n            this.mutations.push(new VerifyMutation(key, this.precondition(key)));\n        });\n        await invokeCommitRpc(this.datastore, this.mutations);\n        this.committed = true;\n    }\n    recordVersion(doc) {\n        let docVersion;\n        if (doc.isFoundDocument()) {\n            docVersion = doc.version;\n        }\n        else if (doc.isNoDocument()) {\n            // Represent a deleted doc using SnapshotVersion.min().\n            docVersion = SnapshotVersion.min();\n        }\n        else {\n            throw fail(0xc542, {\n                documentName: doc.constructor.name\n            });\n        }\n        const existingVersion = this.readVersions.get(doc.key.toString());\n        if (existingVersion) {\n            if (!docVersion.isEqual(existingVersion)) {\n                // This transaction will fail no matter what.\n                throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');\n            }\n        }\n        else {\n            this.readVersions.set(doc.key.toString(), docVersion);\n        }\n    }\n    /**\n     * Returns the version of this document when it was read in this transaction,\n     * as a precondition, or no precondition if it was not read.\n     */\n    precondition(key) {\n        const version = this.readVersions.get(key.toString());\n        if (!this.writtenDocs.has(key.toString()) && version) {\n            if (version.isEqual(SnapshotVersion.min())) {\n                return Precondition.exists(false);\n            }\n            else {\n                return Precondition.updateTime(version);\n            }\n        }\n        else {\n            return Precondition.none();\n        }\n    }\n    /**\n     * Returns the precondition for a document if the operation is an update.\n     */\n    preconditionForUpdate(key) {\n        const version = this.readVersions.get(key.toString());\n        // The first time a document is written, we want to take into account the\n        // read time and existence\n        if (!this.writtenDocs.has(key.toString()) && version) {\n            if (version.isEqual(SnapshotVersion.min())) {\n                // The document doesn't exist, so fail the transaction.\n                // This has to be validated locally because you can't send a\n                // precondition that a document does not exist without changing the\n                // semantics of the backend write to be an insert. This is the reverse\n                // of what we want, since we want to assert that the document doesn't\n                // exist but then send the update and have it fail. Since we can't\n                // express that to the backend, we have to validate locally.\n                // Note: this can change once we can send separate verify writes in the\n                // transaction.\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't update a document that doesn't exist.\");\n            }\n            // Document exists, base precondition on document update time.\n            return Precondition.updateTime(version);\n        }\n        else {\n            // Document was not read, so we just use the preconditions for a blind\n            // update.\n            return Precondition.exists(true);\n        }\n    }\n    write(mutation) {\n        this.ensureCommitNotCalled();\n        this.mutations.push(mutation);\n    }\n    ensureCommitNotCalled() {\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * TransactionRunner encapsulates the logic needed to run and retry transactions\n * with backoff.\n */\nclass TransactionRunner {\n    constructor(asyncQueue, datastore, options, updateFunction, deferred) {\n        this.asyncQueue = asyncQueue;\n        this.datastore = datastore;\n        this.options = options;\n        this.updateFunction = updateFunction;\n        this.deferred = deferred;\n        this.attemptsRemaining = options.maxAttempts;\n        this.backoff = new ExponentialBackoff(this.asyncQueue, \"transaction_retry\" /* TimerId.TransactionRetry */);\n    }\n    /** Runs the transaction and sets the result on deferred. */\n    run() {\n        this.attemptsRemaining -= 1;\n        this.runWithBackOff();\n    }\n    runWithBackOff() {\n        this.backoff.backoffAndRun(async () => {\n            const transaction = new Transaction(this.datastore);\n            const userPromise = this.tryRunUpdateFunction(transaction);\n            if (userPromise) {\n                userPromise\n                    .then(result => {\n                    this.asyncQueue.enqueueAndForget(() => {\n                        return transaction\n                            .commit()\n                            .then(() => {\n                            this.deferred.resolve(result);\n                        })\n                            .catch(commitError => {\n                            this.handleTransactionError(commitError);\n                        });\n                    });\n                })\n                    .catch(userPromiseError => {\n                    this.handleTransactionError(userPromiseError);\n                });\n            }\n        });\n    }\n    tryRunUpdateFunction(transaction) {\n        try {\n            const userPromise = this.updateFunction(transaction);\n            if (isNullOrUndefined(userPromise) ||\n                !userPromise.catch ||\n                !userPromise.then) {\n                this.deferred.reject(Error('Transaction callback must return a Promise'));\n                return null;\n            }\n            return userPromise;\n        }\n        catch (error) {\n            // Do not retry errors thrown by user provided updateFunction.\n            this.deferred.reject(error);\n            return null;\n        }\n    }\n    handleTransactionError(error) {\n        if (this.attemptsRemaining > 0 && this.isRetryableTransactionError(error)) {\n            this.attemptsRemaining -= 1;\n            this.asyncQueue.enqueueAndForget(() => {\n                this.runWithBackOff();\n                return Promise.resolve();\n            });\n        }\n        else {\n            this.deferred.reject(error);\n        }\n    }\n    isRetryableTransactionError(error) {\n        if (error?.name === 'FirebaseError') {\n            // In transactions, the backend will fail outdated reads with FAILED_PRECONDITION and\n            // non-matching document versions with ABORTED. These errors should be retried.\n            const code = error.code;\n            return (code === 'aborted' ||\n                code === 'failed-precondition' ||\n                code === 'already-exists' ||\n                !isPermanentError(code));\n        }\n        return false;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$2 = 'FirestoreClient';\nconst MAX_CONCURRENT_LIMBO_RESOLUTIONS = 100;\n/** DOMException error code constants. */\nconst DOM_EXCEPTION_INVALID_STATE = 11;\nconst DOM_EXCEPTION_ABORTED = 20;\nconst DOM_EXCEPTION_QUOTA_EXCEEDED = 22;\n/**\n * FirestoreClient is a top-level class that constructs and owns all of the //\n * pieces of the client SDK architecture. It is responsible for creating the //\n * async queue that is shared by all of the other components in the system. //\n */\nclass FirestoreClient {\n    constructor(authCredentials, appCheckCredentials, \n    /**\n     * Asynchronous queue responsible for all of our internal processing. When\n     * we get incoming work from the user (via public API) or the network\n     * (incoming GRPC messages), we should always schedule onto this queue.\n     * This ensures all of our work is properly serialized (e.g. we don't\n     * start processing a new operation while the previous one is waiting for\n     * an async I/O to complete).\n     */\n    asyncQueue, \n    /**\n     * Exposed for testing\n     */\n    _databaseInfo, componentProvider) {\n        this.authCredentials = authCredentials;\n        this.appCheckCredentials = appCheckCredentials;\n        this.asyncQueue = asyncQueue;\n        this._databaseInfo = _databaseInfo;\n        this.user = User.UNAUTHENTICATED;\n        this.clientId = AutoId.newId();\n        this.authCredentialListener = () => Promise.resolve();\n        this.appCheckCredentialListener = () => Promise.resolve();\n        this._uninitializedComponentsProvider = componentProvider;\n        this.authCredentials.start(asyncQueue, async (user) => {\n            logDebug(LOG_TAG$2, 'Received user=', user.uid);\n            await this.authCredentialListener(user);\n            this.user = user;\n        });\n        this.appCheckCredentials.start(asyncQueue, newAppCheckToken => {\n            logDebug(LOG_TAG$2, 'Received new app check token=', newAppCheckToken);\n            return this.appCheckCredentialListener(newAppCheckToken, this.user);\n        });\n    }\n    get configuration() {\n        return {\n            asyncQueue: this.asyncQueue,\n            databaseInfo: this._databaseInfo,\n            clientId: this.clientId,\n            authCredentials: this.authCredentials,\n            appCheckCredentials: this.appCheckCredentials,\n            initialUser: this.user,\n            maxConcurrentLimboResolutions: MAX_CONCURRENT_LIMBO_RESOLUTIONS\n        };\n    }\n    setCredentialChangeListener(listener) {\n        this.authCredentialListener = listener;\n    }\n    setAppCheckTokenChangeListener(listener) {\n        this.appCheckCredentialListener = listener;\n    }\n    terminate() {\n        this.asyncQueue.enterRestrictedMode();\n        const deferred = new Deferred();\n        this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {\n            try {\n                if (this._onlineComponents) {\n                    await this._onlineComponents.terminate();\n                }\n                if (this._offlineComponents) {\n                    await this._offlineComponents.terminate();\n                }\n                // The credentials provider must be terminated after shutting down the\n                // RemoteStore as it will prevent the RemoteStore from retrieving auth\n                // tokens.\n                this.authCredentials.shutdown();\n                this.appCheckCredentials.shutdown();\n                deferred.resolve();\n            }\n            catch (e) {\n                const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to shutdown persistence`);\n                deferred.reject(firestoreError);\n            }\n        });\n        return deferred.promise;\n    }\n}\nasync function setOfflineComponentProvider(client, offlineComponentProvider) {\n    client.asyncQueue.verifyOperationInProgress();\n    logDebug(LOG_TAG$2, 'Initializing OfflineComponentProvider');\n    const configuration = client.configuration;\n    await offlineComponentProvider.initialize(configuration);\n    let currentUser = configuration.initialUser;\n    client.setCredentialChangeListener(async (user) => {\n        if (!currentUser.isEqual(user)) {\n            await localStoreHandleUserChange(offlineComponentProvider.localStore, user);\n            currentUser = user;\n        }\n    });\n    // When a user calls clearPersistence() in one client, all other clients\n    // need to be terminated to allow the delete to succeed.\n    offlineComponentProvider.persistence.setDatabaseDeletedListener(() => client.terminate());\n    client._offlineComponents = offlineComponentProvider;\n}\nasync function setOnlineComponentProvider(client, onlineComponentProvider) {\n    client.asyncQueue.verifyOperationInProgress();\n    const offlineComponents = await ensureOfflineComponents(client);\n    logDebug(LOG_TAG$2, 'Initializing OnlineComponentProvider');\n    await onlineComponentProvider.initialize(offlineComponents, client.configuration);\n    // The CredentialChangeListener of the online component provider takes\n    // precedence over the offline component provider.\n    client.setCredentialChangeListener(user => remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user));\n    client.setAppCheckTokenChangeListener((_, user) => remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user));\n    client._onlineComponents = onlineComponentProvider;\n}\n/**\n * Decides whether the provided error allows us to gracefully disable\n * persistence (as opposed to crashing the client).\n */\nfunction canFallbackFromIndexedDbError(error) {\n    if (error.name === 'FirebaseError') {\n        return (error.code === Code.FAILED_PRECONDITION ||\n            error.code === Code.UNIMPLEMENTED);\n    }\n    else if (typeof DOMException !== 'undefined' &&\n        error instanceof DOMException) {\n        // There are a few known circumstances where we can open IndexedDb but\n        // trying to read/write will fail (e.g. quota exceeded). For\n        // well-understood cases, we attempt to detect these and then gracefully\n        // fall back to memory persistence.\n        // NOTE: Rather than continue to add to this list, we could decide to\n        // always fall back, with the risk that we might accidentally hide errors\n        // representing actual SDK bugs.\n        return (\n        // When the browser is out of quota we could get either quota exceeded\n        // or an aborted error depending on whether the error happened during\n        // schema migration.\n        error.code === DOM_EXCEPTION_QUOTA_EXCEEDED ||\n            error.code === DOM_EXCEPTION_ABORTED ||\n            // Firefox Private Browsing mode disables IndexedDb and returns\n            // INVALID_STATE for any usage.\n            error.code === DOM_EXCEPTION_INVALID_STATE);\n    }\n    return true;\n}\nasync function ensureOfflineComponents(client) {\n    if (!client._offlineComponents) {\n        if (client._uninitializedComponentsProvider) {\n            logDebug(LOG_TAG$2, 'Using user provided OfflineComponentProvider');\n            try {\n                await setOfflineComponentProvider(client, client._uninitializedComponentsProvider._offline);\n            }\n            catch (e) {\n                const error = e;\n                if (!canFallbackFromIndexedDbError(error)) {\n                    throw error;\n                }\n                logWarn('Error using user provided cache. Falling back to ' +\n                    'memory cache: ' +\n                    error);\n                await setOfflineComponentProvider(client, new MemoryOfflineComponentProvider());\n            }\n        }\n        else {\n            logDebug(LOG_TAG$2, 'Using default OfflineComponentProvider');\n            await setOfflineComponentProvider(client, new LruGcMemoryOfflineComponentProvider(undefined));\n        }\n    }\n    return client._offlineComponents;\n}\nasync function ensureOnlineComponents(client) {\n    if (!client._onlineComponents) {\n        if (client._uninitializedComponentsProvider) {\n            logDebug(LOG_TAG$2, 'Using user provided OnlineComponentProvider');\n            await setOnlineComponentProvider(client, client._uninitializedComponentsProvider._online);\n        }\n        else {\n            logDebug(LOG_TAG$2, 'Using default OnlineComponentProvider');\n            await setOnlineComponentProvider(client, new OnlineComponentProvider());\n        }\n    }\n    return client._onlineComponents;\n}\nfunction getPersistence(client) {\n    return ensureOfflineComponents(client).then(c => c.persistence);\n}\nfunction getLocalStore(client) {\n    return ensureOfflineComponents(client).then(c => c.localStore);\n}\nfunction getRemoteStore(client) {\n    return ensureOnlineComponents(client).then(c => c.remoteStore);\n}\nfunction getSyncEngine(client) {\n    return ensureOnlineComponents(client).then(c => c.syncEngine);\n}\nfunction getDatastore$1(client) {\n    return ensureOnlineComponents(client).then(c => c.datastore);\n}\nasync function getEventManager(client) {\n    const onlineComponentProvider = await ensureOnlineComponents(client);\n    const eventManager = onlineComponentProvider.eventManager;\n    eventManager.onListen = syncEngineListen.bind(null, onlineComponentProvider.syncEngine);\n    eventManager.onUnlisten = syncEngineUnlisten.bind(null, onlineComponentProvider.syncEngine);\n    eventManager.onFirstRemoteStoreListen = triggerRemoteStoreListen.bind(null, onlineComponentProvider.syncEngine);\n    eventManager.onLastRemoteStoreUnlisten = triggerRemoteStoreUnlisten.bind(null, onlineComponentProvider.syncEngine);\n    return eventManager;\n}\n/** Enables the network connection and re-enqueues all pending operations. */\nfunction firestoreClientEnableNetwork(client) {\n    return client.asyncQueue.enqueue(async () => {\n        const persistence = await getPersistence(client);\n        const remoteStore = await getRemoteStore(client);\n        persistence.setNetworkEnabled(true);\n        return remoteStoreEnableNetwork(remoteStore);\n    });\n}\n/** Disables the network connection. Pending operations will not complete. */\nfunction firestoreClientDisableNetwork(client) {\n    return client.asyncQueue.enqueue(async () => {\n        const persistence = await getPersistence(client);\n        const remoteStore = await getRemoteStore(client);\n        persistence.setNetworkEnabled(false);\n        return remoteStoreDisableNetwork(remoteStore);\n    });\n}\n/**\n * Returns a Promise that resolves when all writes that were pending at the time\n * this method was called received server acknowledgement. An acknowledgement\n * can be either acceptance or rejection.\n */\nfunction firestoreClientWaitForPendingWrites(client) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const syncEngine = await getSyncEngine(client);\n        return syncEngineRegisterPendingWritesCallback(syncEngine, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientListen(client, query, options, observer) {\n    const wrappedObserver = new AsyncObserver(observer);\n    const listener = new QueryListener(query, wrappedObserver, options);\n    client.asyncQueue.enqueueAndForget(async () => {\n        const eventManager = await getEventManager(client);\n        return eventManagerListen(eventManager, listener);\n    });\n    return () => {\n        wrappedObserver.mute();\n        client.asyncQueue.enqueueAndForget(async () => {\n            const eventManager = await getEventManager(client);\n            return eventManagerUnlisten(eventManager, listener);\n        });\n    };\n}\nfunction firestoreClientGetDocumentFromLocalCache(client, docKey) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const localStore = await getLocalStore(client);\n        return readDocumentFromCache(localStore, docKey, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientGetDocumentViaSnapshotListener(client, key, options = {}) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const eventManager = await getEventManager(client);\n        return readDocumentViaSnapshotListener(eventManager, client.asyncQueue, key, options, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientGetDocumentsFromLocalCache(client, query) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const localStore = await getLocalStore(client);\n        return executeQueryFromCache(localStore, query, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientGetDocumentsViaSnapshotListener(client, query, options = {}) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const eventManager = await getEventManager(client);\n        return executeQueryViaSnapshotListener(eventManager, client.asyncQueue, query, options, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientRunAggregateQuery(client, query, aggregates) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        // Implement and call executeAggregateQueryViaSnapshotListener, similar\n        // to the implementation in firestoreClientGetDocumentsViaSnapshotListener\n        // above\n        try {\n            // TODO(b/277628384): check `canUseNetwork()` and handle multi-tab.\n            const datastore = await getDatastore$1(client);\n            deferred.resolve(invokeRunAggregationQueryRpc(datastore, query, aggregates));\n        }\n        catch (e) {\n            deferred.reject(e);\n        }\n    });\n    return deferred.promise;\n}\nfunction firestoreClientExecutePipeline(client, pipeline) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        try {\n            const datastore = await getDatastore$1(client);\n            deferred.resolve(invokeExecutePipeline(datastore, pipeline));\n        }\n        catch (e) {\n            deferred.reject(e);\n        }\n    });\n    return deferred.promise;\n}\nfunction firestoreClientWrite(client, mutations) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const syncEngine = await getSyncEngine(client);\n        return syncEngineWrite(syncEngine, mutations, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientAddSnapshotsInSyncListener(client, observer) {\n    const wrappedObserver = new AsyncObserver(observer);\n    client.asyncQueue.enqueueAndForget(async () => {\n        const eventManager = await getEventManager(client);\n        return addSnapshotsInSyncListener(eventManager, wrappedObserver);\n    });\n    return () => {\n        wrappedObserver.mute();\n        client.asyncQueue.enqueueAndForget(async () => {\n            const eventManager = await getEventManager(client);\n            return removeSnapshotsInSyncListener(eventManager, wrappedObserver);\n        });\n    };\n}\n/**\n * Takes an updateFunction in which a set of reads and writes can be performed\n * atomically. In the updateFunction, the client can read and write values\n * using the supplied transaction object. After the updateFunction, all\n * changes will be committed. If a retryable error occurs (ex: some other\n * client has changed any of the data referenced), then the updateFunction\n * will be called again after a backoff. If the updateFunction still fails\n * after all retries, then the transaction will be rejected.\n *\n * The transaction object passed to the updateFunction contains methods for\n * accessing documents and collections. Unlike other datastore access, data\n * accessed with the transaction will not reflect local changes that have not\n * been committed. For this reason, it is required that all reads are\n * performed before any writes. Transactions must be performed while online.\n */\nfunction firestoreClientTransaction(client, updateFunction, options) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const datastore = await getDatastore$1(client);\n        new TransactionRunner(client.asyncQueue, datastore, options, updateFunction, deferred).run();\n    });\n    return deferred.promise;\n}\nasync function readDocumentFromCache(localStore, docKey, result) {\n    try {\n        const document = await localStoreReadDocument(localStore, docKey);\n        if (document.isFoundDocument()) {\n            result.resolve(document);\n        }\n        else if (document.isNoDocument()) {\n            result.resolve(null);\n        }\n        else {\n            result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from cache. (However, this document may ' +\n                \"exist on the server. Run again without setting 'source' in \" +\n                'the GetOptions to attempt to retrieve the document from the ' +\n                'server.)'));\n        }\n    }\n    catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to get document '${docKey} from cache`);\n        result.reject(firestoreError);\n    }\n}\n/**\n * Retrieves a latency-compensated document from the backend via a\n * SnapshotListener.\n */\nfunction readDocumentViaSnapshotListener(eventManager, asyncQueue, key, options, result) {\n    const wrappedObserver = new AsyncObserver({\n        next: (snap) => {\n            // Mute and remove query first before passing event to user to avoid\n            // user actions affecting the now stale query.\n            wrappedObserver.mute();\n            asyncQueue.enqueueAndForget(() => eventManagerUnlisten(eventManager, listener));\n            const exists = snap.docs.has(key);\n            if (!exists && snap.fromCache) {\n                // TODO(dimond): If we're online and the document doesn't\n                // exist then we resolve with a doc.exists set to false. If\n                // we're offline however, we reject the Promise in this\n                // case. Two options: 1) Cache the negative response from\n                // the server so we can deliver that even when you're\n                // offline 2) Actually reject the Promise in the online case\n                // if the document doesn't exist.\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document because the client is offline.'));\n            }\n            else if (exists &&\n                snap.fromCache &&\n                options &&\n                options.source === 'server') {\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from server. (However, this ' +\n                    'document does exist in the local cache. Run again ' +\n                    'without setting source to \"server\" to ' +\n                    'retrieve the cached document.)'));\n            }\n            else {\n                result.resolve(snap);\n            }\n        },\n        error: e => result.reject(e)\n    });\n    const listener = new QueryListener(newQueryForPath(key.path), wrappedObserver, {\n        includeMetadataChanges: true,\n        waitForSyncWhenOnline: true\n    });\n    return eventManagerListen(eventManager, listener);\n}\nasync function executeQueryFromCache(localStore, query, result) {\n    try {\n        const queryResult = await localStoreExecuteQuery(localStore, query, \n        /* usePreviousResults= */ true);\n        const view = new View(query, queryResult.remoteKeys);\n        const viewDocChanges = view.computeDocChanges(queryResult.documents);\n        const viewChange = view.applyChanges(viewDocChanges, \n        /* limboResolutionEnabled= */ false);\n        result.resolve(viewChange.snapshot);\n    }\n    catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to execute query '${query} against cache`);\n        result.reject(firestoreError);\n    }\n}\n/**\n * Retrieves a latency-compensated query snapshot from the backend via a\n * SnapshotListener.\n */\nfunction executeQueryViaSnapshotListener(eventManager, asyncQueue, query, options, result) {\n    const wrappedObserver = new AsyncObserver({\n        next: snapshot => {\n            // Mute and remove query first before passing event to user to avoid\n            // user actions affecting the now stale query.\n            wrappedObserver.mute();\n            asyncQueue.enqueueAndForget(() => eventManagerUnlisten(eventManager, listener));\n            if (snapshot.fromCache && options.source === 'server') {\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get documents from server. (However, these ' +\n                    'documents may exist in the local cache. Run again ' +\n                    'without setting source to \"server\" to ' +\n                    'retrieve the cached documents.)'));\n            }\n            else {\n                result.resolve(snapshot);\n            }\n        },\n        error: e => result.reject(e)\n    });\n    const listener = new QueryListener(query, wrappedObserver, {\n        includeMetadataChanges: true,\n        waitForSyncWhenOnline: true\n    });\n    return eventManagerListen(eventManager, listener);\n}\nfunction firestoreClientLoadBundle(client, databaseId, data, resultTask) {\n    const reader = createBundleReader(data, newSerializer(databaseId));\n    client.asyncQueue.enqueueAndForget(async () => {\n        syncEngineLoadBundle(await getSyncEngine(client), reader, resultTask);\n    });\n}\nfunction firestoreClientGetNamedQuery(client, queryName) {\n    return client.asyncQueue.enqueue(async () => localStoreGetNamedQuery(await getLocalStore(client), queryName));\n}\nfunction createBundleReader(data, serializer) {\n    let content;\n    if (typeof data === 'string') {\n        content = newTextEncoder().encode(data);\n    }\n    else {\n        content = data;\n    }\n    return newBundleReader(toByteStreamReader(content), serializer);\n}\nfunction createBundleReaderSync(bundleData, serializer) {\n    return newBundleReaderSync(bundleData, serializer);\n}\nfunction firestoreClientSetIndexConfiguration(client, indexes) {\n    return client.asyncQueue.enqueue(async () => {\n        return localStoreConfigureFieldIndexes(await getLocalStore(client), indexes);\n    });\n}\nfunction firestoreClientSetPersistentCacheIndexAutoCreationEnabled(client, isEnabled) {\n    return client.asyncQueue.enqueue(async () => {\n        return localStoreSetIndexAutoCreationEnabled(await getLocalStore(client), isEnabled);\n    });\n}\nfunction firestoreClientDeleteAllFieldIndexes(client) {\n    return client.asyncQueue.enqueue(async () => {\n        return localStoreDeleteAllFieldIndexes(await getLocalStore(client));\n    });\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Compares two `ExperimentalLongPollingOptions` objects for equality.\n */\nfunction longPollingOptionsEqual(options1, options2) {\n    return options1.timeoutSeconds === options2.timeoutSeconds;\n}\n/**\n * Creates and returns a new `ExperimentalLongPollingOptions` with the same\n * option values as the given instance.\n */\nfunction cloneLongPollingOptions(options) {\n    const clone = {};\n    if (options.timeoutSeconds !== undefined) {\n        clone.timeoutSeconds = options.timeoutSeconds;\n    }\n    return clone;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$1 = 'ComponentProvider';\n/**\n * An instance map that ensures only one Datastore exists per Firestore\n * instance.\n */\nconst datastoreInstances = new Map();\n/**\n * Returns an initialized and started Datastore for the given Firestore\n * instance. Callers must invoke removeComponents() when the Firestore\n * instance is terminated.\n */\nfunction getDatastore(firestore) {\n    if (firestore._terminated) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');\n    }\n    if (!datastoreInstances.has(firestore)) {\n        logDebug(LOG_TAG$1, 'Initializing Datastore');\n        const databaseInfo = makeDatabaseInfo(firestore._databaseId, firestore.app.options.appId || '', firestore._persistenceKey, firestore.app.options.apiKey, firestore._freezeSettings());\n        const connection = newConnection(databaseInfo);\n        const serializer = newSerializer(firestore._databaseId);\n        const datastore = newDatastore(firestore._authCredentials, firestore._appCheckCredentials, connection, serializer);\n        datastoreInstances.set(firestore, datastore);\n    }\n    return datastoreInstances.get(firestore);\n}\n/**\n * Removes all components associated with the provided instance. Must be called\n * when the `Firestore` instance is terminated.\n */\nfunction removeComponents(firestore) {\n    const datastore = datastoreInstances.get(firestore);\n    if (datastore) {\n        logDebug(LOG_TAG$1, 'Removing Datastore');\n        datastoreInstances.delete(firestore);\n        datastore.terminate();\n    }\n}\nfunction makeDatabaseInfo(databaseId, appId, persistenceKey, apiKey, settings) {\n    return new DatabaseInfo(databaseId, appId, persistenceKey, settings.host, settings.ssl, settings.experimentalForceLongPolling, settings.experimentalAutoDetectLongPolling, cloneLongPollingOptions(settings.experimentalLongPollingOptions), settings.useFetchStreams, settings.isUsingEmulator, apiKey);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// settings() defaults:\nconst DEFAULT_HOST = 'firestore.googleapis.com';\nconst DEFAULT_SSL = true;\n// The minimum long-polling timeout is hardcoded on the server. The value here\n// should be kept in sync with the value used by the server, as the server will\n// silently ignore a value below the minimum and fall back to the default.\n// Googlers see b/266868871 for relevant discussion.\nconst MIN_LONG_POLLING_TIMEOUT_SECONDS = 5;\n// No maximum long-polling timeout is configured in the server, and defaults to\n// 30 seconds, which is what Watch appears to use.\n// Googlers see b/266868871 for relevant discussion.\nconst MAX_LONG_POLLING_TIMEOUT_SECONDS = 30;\n// Whether long-polling auto-detected is enabled by default.\nconst DEFAULT_AUTO_DETECT_LONG_POLLING = true;\n/**\n * A concrete type describing all the values that can be applied via a\n * user-supplied `FirestoreSettings` object. This is a separate type so that\n * defaults can be supplied and the value can be checked for equality.\n */\nclass FirestoreSettingsImpl {\n    constructor(settings) {\n        if (settings.host === undefined) {\n            if (settings.ssl !== undefined) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\n            }\n            this.host = DEFAULT_HOST;\n            this.ssl = DEFAULT_SSL;\n        }\n        else {\n            this.host = settings.host;\n            this.ssl = settings.ssl ?? DEFAULT_SSL;\n        }\n        this.isUsingEmulator = settings.emulatorOptions !== undefined;\n        this.credentials = settings.credentials;\n        this.ignoreUndefinedProperties = !!settings.ignoreUndefinedProperties;\n        this.localCache = settings.localCache;\n        if (settings.cacheSizeBytes === undefined) {\n            this.cacheSizeBytes = LRU_DEFAULT_CACHE_SIZE_BYTES;\n        }\n        else {\n            if (settings.cacheSizeBytes !== LRU_COLLECTION_DISABLED &&\n                settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);\n            }\n            else {\n                this.cacheSizeBytes = settings.cacheSizeBytes;\n            }\n        }\n        validateIsNotUsedTogether('experimentalForceLongPolling', settings.experimentalForceLongPolling, 'experimentalAutoDetectLongPolling', settings.experimentalAutoDetectLongPolling);\n        this.experimentalForceLongPolling = !!settings.experimentalForceLongPolling;\n        if (this.experimentalForceLongPolling) {\n            this.experimentalAutoDetectLongPolling = false;\n        }\n        else if (settings.experimentalAutoDetectLongPolling === undefined) {\n            this.experimentalAutoDetectLongPolling = DEFAULT_AUTO_DETECT_LONG_POLLING;\n        }\n        else {\n            // For backwards compatibility, coerce the value to boolean even though\n            // the TypeScript compiler has narrowed the type to boolean already.\n            // noinspection PointlessBooleanExpressionJS\n            this.experimentalAutoDetectLongPolling =\n                !!settings.experimentalAutoDetectLongPolling;\n        }\n        this.experimentalLongPollingOptions = cloneLongPollingOptions(settings.experimentalLongPollingOptions ?? {});\n        validateLongPollingOptions(this.experimentalLongPollingOptions);\n        this.useFetchStreams = !!settings.useFetchStreams;\n    }\n    isEqual(other) {\n        return (this.host === other.host &&\n            this.ssl === other.ssl &&\n            this.credentials === other.credentials &&\n            this.cacheSizeBytes === other.cacheSizeBytes &&\n            this.experimentalForceLongPolling ===\n                other.experimentalForceLongPolling &&\n            this.experimentalAutoDetectLongPolling ===\n                other.experimentalAutoDetectLongPolling &&\n            longPollingOptionsEqual(this.experimentalLongPollingOptions, other.experimentalLongPollingOptions) &&\n            this.ignoreUndefinedProperties === other.ignoreUndefinedProperties &&\n            this.useFetchStreams === other.useFetchStreams);\n    }\n}\nfunction validateLongPollingOptions(options) {\n    if (options.timeoutSeconds !== undefined) {\n        if (isNaN(options.timeoutSeconds)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ` +\n                `${options.timeoutSeconds} (must not be NaN)`);\n        }\n        if (options.timeoutSeconds < MIN_LONG_POLLING_TIMEOUT_SECONDS) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} ` +\n                `(minimum allowed value is ${MIN_LONG_POLLING_TIMEOUT_SECONDS})`);\n        }\n        if (options.timeoutSeconds > MAX_LONG_POLLING_TIMEOUT_SECONDS) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} ` +\n                `(maximum allowed value is ${MAX_LONG_POLLING_TIMEOUT_SECONDS})`);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The Cloud Firestore service interface.\n *\n * Do not call this constructor directly. Instead, use {@link (getFirestore:1)}.\n */\nclass Firestore$1 {\n    /** @hideconstructor */\n    constructor(_authCredentials, _appCheckCredentials, _databaseId, _app) {\n        this._authCredentials = _authCredentials;\n        this._appCheckCredentials = _appCheckCredentials;\n        this._databaseId = _databaseId;\n        this._app = _app;\n        /**\n         * Whether it's a Firestore or Firestore Lite instance.\n         */\n        this.type = 'firestore-lite';\n        this._persistenceKey = '(lite)';\n        this._settings = new FirestoreSettingsImpl({});\n        this._settingsFrozen = false;\n        this._emulatorOptions = {};\n        // A task that is assigned when the terminate() is invoked and resolved when\n        // all components have shut down. Otherwise, Firestore is not terminated,\n        // which can mean either the FirestoreClient is in the process of starting,\n        // or restarting.\n        this._terminateTask = 'notTerminated';\n    }\n    /**\n     * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service\n     * instance.\n     */\n    get app() {\n        if (!this._app) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is \" +\n                'not available');\n        }\n        return this._app;\n    }\n    get _initialized() {\n        return this._settingsFrozen;\n    }\n    get _terminated() {\n        return this._terminateTask !== 'notTerminated';\n    }\n    _setSettings(settings) {\n        if (this._settingsFrozen) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' +\n                'be changed. You can only modify settings before calling any other ' +\n                'methods on a Firestore object.');\n        }\n        this._settings = new FirestoreSettingsImpl(settings);\n        this._emulatorOptions = settings.emulatorOptions || {};\n        if (settings.credentials !== undefined) {\n            this._authCredentials = makeAuthCredentialsProvider(settings.credentials);\n        }\n    }\n    _getSettings() {\n        return this._settings;\n    }\n    _getEmulatorOptions() {\n        return this._emulatorOptions;\n    }\n    _freezeSettings() {\n        this._settingsFrozen = true;\n        return this._settings;\n    }\n    _delete() {\n        // The `_terminateTask` must be assigned future that completes when\n        // terminate is complete. The existence of this future puts SDK in state\n        // that will not accept further API interaction.\n        if (this._terminateTask === 'notTerminated') {\n            this._terminateTask = this._terminate();\n        }\n        return this._terminateTask;\n    }\n    async _restart() {\n        // The `_terminateTask` must equal 'notTerminated' after restart to\n        // signal that client is in a state that accepts API calls.\n        if (this._terminateTask === 'notTerminated') {\n            await this._terminate();\n        }\n        else {\n            this._terminateTask = 'notTerminated';\n        }\n    }\n    /** Returns a JSON-serializable representation of this `Firestore` instance. */\n    toJSON() {\n        return {\n            app: this._app,\n            databaseId: this._databaseId,\n            settings: this._settings\n        };\n    }\n    /**\n     * Terminates all components used by this client. Subclasses can override\n     * this method to clean up their own dependencies, but must also call this\n     * method.\n     *\n     * Only ever called once.\n     */\n    _terminate() {\n        removeComponents(this);\n        return Promise.resolve();\n    }\n}\n/**\n * Modify this instance to communicate with the Cloud Firestore emulator.\n *\n * Note: This must be called before this instance has been used to do any\n * operations.\n *\n * @param firestore - The `Firestore` instance to configure to connect to the\n * emulator.\n * @param host - the emulator host (ex: localhost).\n * @param port - the emulator port (ex: 9000).\n * @param options.mockUserToken - the mock auth token to use for unit testing\n * Security Rules.\n */\nfunction connectFirestoreEmulator(firestore, host, port, options = {}) {\n    firestore = cast(firestore, Firestore$1);\n    const useSsl = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isCloudWorkstation)(host);\n    const settings = firestore._getSettings();\n    const existingConfig = {\n        ...settings,\n        emulatorOptions: firestore._getEmulatorOptions()\n    };\n    const newHostSetting = `${host}:${port}`;\n    if (useSsl) {\n        void (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.pingServer)(`https://${newHostSetting}`);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.updateEmulatorBanner)('Firestore', true);\n    }\n    if (settings.host !== DEFAULT_HOST && settings.host !== newHostSetting) {\n        logWarn('Host has been set in both settings() and connectFirestoreEmulator(), emulator host ' +\n            'will be used.');\n    }\n    const newConfig = {\n        ...settings,\n        host: newHostSetting,\n        ssl: useSsl,\n        emulatorOptions: options\n    };\n    // No-op if the new configuration matches the current configuration. This supports SSR\n    // enviornments which might call `connectFirestoreEmulator` multiple times as a standard practice.\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(newConfig, existingConfig)) {\n        return;\n    }\n    firestore._setSettings(newConfig);\n    if (options.mockUserToken) {\n        let token;\n        let user;\n        if (typeof options.mockUserToken === 'string') {\n            token = options.mockUserToken;\n            user = User.MOCK_USER;\n        }\n        else {\n            // Let createMockUserToken validate first (catches common mistakes like\n            // invalid field \"uid\" and missing field \"sub\" / \"user_id\".)\n            token = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.createMockUserToken)(options.mockUserToken, firestore._app?.options.projectId);\n            const uid = options.mockUserToken.sub || options.mockUserToken.user_id;\n            if (!uid) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"mockUserToken must contain 'sub' or 'user_id' field!\");\n            }\n            user = new User(uid);\n        }\n        firestore._authCredentials = new EmulatorAuthCredentialsProvider(new OAuthToken(token, user));\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `Query` refers to a query which you can read or listen to. You can also\n * construct refined `Query` objects by adding filters and ordering.\n */\nclass Query {\n    // This is the lite version of the Query class in the main SDK.\n    /** @hideconstructor protected */\n    constructor(firestore, \n    /**\n     * If provided, the `FirestoreDataConverter` associated with this instance.\n     */\n    converter, _query) {\n        this.converter = converter;\n        this._query = _query;\n        /** The type of this Firestore reference. */\n        this.type = 'query';\n        this.firestore = firestore;\n    }\n    withConverter(converter) {\n        return new Query(this.firestore, converter, this._query);\n    }\n}\n/**\n * A `DocumentReference` refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist.\n */\nclass DocumentReference {\n    /** @hideconstructor */\n    constructor(firestore, \n    /**\n     * If provided, the `FirestoreDataConverter` associated with this instance.\n     */\n    converter, _key) {\n        this.converter = converter;\n        this._key = _key;\n        /** The type of this Firestore reference. */\n        this.type = 'document';\n        this.firestore = firestore;\n    }\n    get _path() {\n        return this._key.path;\n    }\n    /**\n     * The document's identifier within its collection.\n     */\n    get id() {\n        return this._key.path.lastSegment();\n    }\n    /**\n     * A string representing the path of the referenced document (relative\n     * to the root of the database).\n     */\n    get path() {\n        return this._key.path.canonicalString();\n    }\n    /**\n     * The collection this `DocumentReference` belongs to.\n     */\n    get parent() {\n        return new CollectionReference(this.firestore, this.converter, this._key.path.popLast());\n    }\n    withConverter(converter) {\n        return new DocumentReference(this.firestore, converter, this._key);\n    }\n    /**\n     * Returns a JSON-serializable representation of this `DocumentReference` instance.\n     *\n     * @returns a JSON representation of this object.\n     */\n    toJSON() {\n        return {\n            type: DocumentReference._jsonSchemaVersion,\n            referencePath: this._key.toString()\n        };\n    }\n    static fromJSON(firestore, json, converter) {\n        if (validateJSON(json, DocumentReference._jsonSchema)) {\n            return new DocumentReference(firestore, converter ? converter : null, new DocumentKey(ResourcePath.fromString(json.referencePath)));\n        }\n    }\n}\nDocumentReference._jsonSchemaVersion = 'firestore/documentReference/1.0';\nDocumentReference._jsonSchema = {\n    type: property('string', DocumentReference._jsonSchemaVersion),\n    referencePath: property('string')\n};\n/**\n * A `CollectionReference` object can be used for adding documents, getting\n * document references, and querying for documents (using {@link (query:1)}).\n */\nclass CollectionReference extends Query {\n    /** @hideconstructor */\n    constructor(firestore, converter, _path) {\n        super(firestore, converter, newQueryForPath(_path));\n        this._path = _path;\n        /** The type of this Firestore reference. */\n        this.type = 'collection';\n    }\n    /** The collection's identifier. */\n    get id() {\n        return this._query.path.lastSegment();\n    }\n    /**\n     * A string representing the path of the referenced collection (relative\n     * to the root of the database).\n     */\n    get path() {\n        return this._query.path.canonicalString();\n    }\n    /**\n     * A reference to the containing `DocumentReference` if this is a\n     * subcollection. If this isn't a subcollection, the reference is null.\n     */\n    get parent() {\n        const parentPath = this._path.popLast();\n        if (parentPath.isEmpty()) {\n            return null;\n        }\n        else {\n            return new DocumentReference(this.firestore, \n            /* converter= */ null, new DocumentKey(parentPath));\n        }\n    }\n    withConverter(converter) {\n        return new CollectionReference(this.firestore, converter, this._path);\n    }\n}\nfunction isCollectionReference(val) {\n    return val instanceof CollectionReference;\n}\nfunction collection(parent, path, ...pathSegments) {\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(parent);\n    validateNonEmptyArgument('collection', 'path', path);\n    if (parent instanceof Firestore$1) {\n        const absolutePath = ResourcePath.fromString(path, ...pathSegments);\n        validateCollectionPath(absolutePath);\n        return new CollectionReference(parent, /* converter= */ null, absolutePath);\n    }\n    else {\n        if (!(parent instanceof DocumentReference) &&\n            !(parent instanceof CollectionReference)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Expected first argument to collection() to be a CollectionReference, ' +\n                'a DocumentReference or FirebaseFirestore');\n        }\n        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));\n        validateCollectionPath(absolutePath);\n        return new CollectionReference(parent.firestore, \n        /* converter= */ null, absolutePath);\n    }\n}\n// TODO(firestorelite): Consider using ErrorFactory -\n// https://github.com/firebase/firebase-js-sdk/blob/0131e1f/packages/util/src/errors.ts#L106\n/**\n * Creates and returns a new `Query` instance that includes all documents in the\n * database that are contained in a collection or subcollection with the\n * given `collectionId`.\n *\n * @param firestore - A reference to the root `Firestore` instance.\n * @param collectionId - Identifies the collections to query over. Every\n * collection or subcollection with this ID as the last segment of its path\n * will be included. Cannot contain a slash.\n * @returns The created `Query`.\n */\nfunction collectionGroup(firestore, collectionId) {\n    firestore = cast(firestore, Firestore$1);\n    validateNonEmptyArgument('collectionGroup', 'collection id', collectionId);\n    if (collectionId.indexOf('/') >= 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection ID '${collectionId}' passed to function ` +\n            `collectionGroup(). Collection IDs must not contain '/'.`);\n    }\n    return new Query(firestore, \n    /* converter= */ null, newQueryForCollectionGroup(collectionId));\n}\nfunction doc(parent, path, ...pathSegments) {\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(parent);\n    // We allow omission of 'pathString' but explicitly prohibit passing in both\n    // 'undefined' and 'null'.\n    if (arguments.length === 1) {\n        path = AutoId.newId();\n    }\n    validateNonEmptyArgument('doc', 'path', path);\n    if (parent instanceof Firestore$1) {\n        const absolutePath = ResourcePath.fromString(path, ...pathSegments);\n        validateDocumentPath(absolutePath);\n        return new DocumentReference(parent, \n        /* converter= */ null, new DocumentKey(absolutePath));\n    }\n    else {\n        if (!(parent instanceof DocumentReference) &&\n            !(parent instanceof CollectionReference)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Expected first argument to doc() to be a CollectionReference, ' +\n                'a DocumentReference or FirebaseFirestore');\n        }\n        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));\n        validateDocumentPath(absolutePath);\n        return new DocumentReference(parent.firestore, parent instanceof CollectionReference ? parent.converter : null, new DocumentKey(absolutePath));\n    }\n}\n/**\n * Returns true if the provided references are equal.\n *\n * @param left - A reference to compare.\n * @param right - A reference to compare.\n * @returns true if the references point to the same location in the same\n * Firestore database.\n */\nfunction refEqual(left, right) {\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(left);\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(right);\n    if ((left instanceof DocumentReference ||\n        left instanceof CollectionReference) &&\n        (right instanceof DocumentReference || right instanceof CollectionReference)) {\n        return (left.firestore === right.firestore &&\n            left.path === right.path &&\n            left.converter === right.converter);\n    }\n    return false;\n}\n/**\n * Returns true if the provided queries point to the same collection and apply\n * the same constraints.\n *\n * @param left - A `Query` to compare.\n * @param right - A `Query` to compare.\n * @returns true if the references point to the same location in the same\n * Firestore database.\n */\nfunction queryEqual(left, right) {\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(left);\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(right);\n    if (left instanceof Query && right instanceof Query) {\n        return (left.firestore === right.firestore &&\n            queryEquals(left._query, right._query) &&\n            left.converter === right.converter);\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG = 'AsyncQueue';\nclass AsyncQueueImpl {\n    constructor(tail = Promise.resolve()) {\n        // A list of retryable operations. Retryable operations are run in order and\n        // retried with backoff.\n        this.retryableOps = [];\n        // Is this AsyncQueue being shut down? Once it is set to true, it will not\n        // be changed again.\n        this._isShuttingDown = false;\n        // Operations scheduled to be queued in the future. Operations are\n        // automatically removed after they are run or canceled.\n        this.delayedOperations = [];\n        // visible for testing\n        this.failure = null;\n        // Flag set while there's an outstanding AsyncQueue operation, used for\n        // assertion sanity-checks.\n        this.operationInProgress = false;\n        // Enabled during shutdown on Safari to prevent future access to IndexedDB.\n        this.skipNonRestrictedTasks = false;\n        // List of TimerIds to fast-forward delays for.\n        this.timerIdsToSkip = [];\n        // Backoff timer used to schedule retries for retryable operations\n        this.backoff = new ExponentialBackoff(this, \"async_queue_retry\" /* TimerId.AsyncQueueRetry */);\n        // Visibility handler that triggers an immediate retry of all retryable\n        // operations. Meant to speed up recovery when we regain file system access\n        // after page comes into foreground.\n        this.visibilityHandler = () => {\n            this.backoff.skipBackoff();\n        };\n        this.tail = tail;\n    }\n    get isShuttingDown() {\n        return this._isShuttingDown;\n    }\n    /**\n     * Adds a new operation to the queue without waiting for it to complete (i.e.\n     * we ignore the Promise result).\n     */\n    enqueueAndForget(op) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.enqueue(op);\n    }\n    enqueueAndForgetEvenWhileRestricted(op) {\n        this.verifyNotFailed();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.enqueueInternal(op);\n    }\n    enterRestrictedMode(purgeExistingTasks) {\n        if (!this._isShuttingDown) {\n            this._isShuttingDown = true;\n            this.skipNonRestrictedTasks = purgeExistingTasks || false;\n        }\n    }\n    enqueue(op) {\n        this.verifyNotFailed();\n        if (this._isShuttingDown) {\n            // Return a Promise which never resolves.\n            return new Promise(() => { });\n        }\n        // Create a deferred Promise that we can return to the callee. This\n        // allows us to return a \"hanging Promise\" only to the callee and still\n        // advance the queue even when the operation is not run.\n        const task = new Deferred();\n        return this.enqueueInternal(() => {\n            if (this._isShuttingDown && this.skipNonRestrictedTasks) {\n                // We do not resolve 'task'\n                return Promise.resolve();\n            }\n            op().then(task.resolve, task.reject);\n            return task.promise;\n        }).then(() => task.promise);\n    }\n    enqueueRetryable(op) {\n        this.enqueueAndForget(() => {\n            this.retryableOps.push(op);\n            return this.retryNextOp();\n        });\n    }\n    /**\n     * Runs the next operation from the retryable queue. If the operation fails,\n     * reschedules with backoff.\n     */\n    async retryNextOp() {\n        if (this.retryableOps.length === 0) {\n            return;\n        }\n        try {\n            await this.retryableOps[0]();\n            this.retryableOps.shift();\n            this.backoff.reset();\n        }\n        catch (e) {\n            if (isIndexedDbTransactionError(e)) {\n                logDebug(LOG_TAG, 'Operation failed with retryable error: ' + e);\n            }\n            else {\n                throw e; // Failure will be handled by AsyncQueue\n            }\n        }\n        if (this.retryableOps.length > 0) {\n            // If there are additional operations, we re-schedule `retryNextOp()`.\n            // This is necessary to run retryable operations that failed during\n            // their initial attempt since we don't know whether they are already\n            // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`\n            // needs to  be re-run, we will run `op1`, `op1`, `op2` using the\n            // already enqueued calls to `retryNextOp()`. `op3()` will then run in the\n            // call scheduled here.\n            // Since `backoffAndRun()` cancels an existing backoff and schedules a\n            // new backoff on every call, there is only ever a single additional\n            // operation in the queue.\n            this.backoff.backoffAndRun(() => this.retryNextOp());\n        }\n    }\n    enqueueInternal(op) {\n        const newTail = this.tail.then(() => {\n            this.operationInProgress = true;\n            return op()\n                .catch((error) => {\n                this.failure = error;\n                this.operationInProgress = false;\n                const message = getMessageOrStack(error);\n                logError('INTERNAL UNHANDLED ERROR: ', message);\n                // Re-throw the error so that this.tail becomes a rejected Promise and\n                // all further attempts to chain (via .then) will just short-circuit\n                // and return the rejected Promise.\n                throw error;\n            })\n                .then(result => {\n                this.operationInProgress = false;\n                return result;\n            });\n        });\n        this.tail = newTail;\n        return newTail;\n    }\n    enqueueAfterDelay(timerId, delayMs, op) {\n        this.verifyNotFailed();\n        // Fast-forward delays for timerIds that have been overridden.\n        if (this.timerIdsToSkip.indexOf(timerId) > -1) {\n            delayMs = 0;\n        }\n        const delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, removedOp => this.removeDelayedOperation(removedOp));\n        this.delayedOperations.push(delayedOp);\n        return delayedOp;\n    }\n    verifyNotFailed() {\n        if (this.failure) {\n            fail(0xb815, {\n                messageOrStack: getMessageOrStack(this.failure)\n            });\n        }\n    }\n    verifyOperationInProgress() {\n    }\n    /**\n     * Waits until all currently queued tasks are finished executing. Delayed\n     * operations are not run.\n     */\n    async drain() {\n        // Operations in the queue prior to draining may have enqueued additional\n        // operations. Keep draining the queue until the tail is no longer advanced,\n        // which indicates that no more new operations were enqueued and that all\n        // operations were executed.\n        let currentTail;\n        do {\n            currentTail = this.tail;\n            await currentTail;\n        } while (currentTail !== this.tail);\n    }\n    /**\n     * For Tests: Determine if a delayed operation with a particular TimerId\n     * exists.\n     */\n    containsDelayedOperation(timerId) {\n        for (const op of this.delayedOperations) {\n            if (op.timerId === timerId) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * For Tests: Runs some or all delayed operations early.\n     *\n     * @param lastTimerId - Delayed operations up to and including this TimerId\n     * will be drained. Pass TimerId.All to run all delayed operations.\n     * @returns a Promise that resolves once all operations have been run.\n     */\n    runAllDelayedOperationsUntil(lastTimerId) {\n        // Note that draining may generate more delayed ops, so we do that first.\n        return this.drain().then(() => {\n            // Run ops in the same order they'd run if they ran naturally.\n            /* eslint-disable-next-line @typescript-eslint/no-floating-promises */\n            this.delayedOperations.sort((a, b) => a.targetTimeMs - b.targetTimeMs);\n            for (const op of this.delayedOperations) {\n                op.skipDelay();\n                if (lastTimerId !== \"all\" /* TimerId.All */ && op.timerId === lastTimerId) {\n                    break;\n                }\n            }\n            return this.drain();\n        });\n    }\n    /**\n     * For Tests: Skip all subsequent delays for a timer id.\n     */\n    skipDelaysForTimerId(timerId) {\n        this.timerIdsToSkip.push(timerId);\n    }\n    /** Called once a DelayedOperation is run or canceled. */\n    removeDelayedOperation(op) {\n        // NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.\n        const index = this.delayedOperations.indexOf(op);\n        /* eslint-disable-next-line @typescript-eslint/no-floating-promises */\n        this.delayedOperations.splice(index, 1);\n    }\n}\n/**\n * Chrome includes Error.message in Error.stack. Other browsers do not.\n * This returns expected output of message + stack when available.\n * @param error - Error or FirestoreError\n */\nfunction getMessageOrStack(error) {\n    let message = error.message || '';\n    if (error.stack) {\n        if (error.stack.includes(error.message)) {\n            message = error.stack;\n        }\n        else {\n            message = error.message + '\\n' + error.stack;\n        }\n    }\n    return message;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents the task of loading a Firestore bundle. It provides progress of bundle\n * loading, as well as task completion and error events.\n *\n * The API is compatible with `Promise<LoadBundleTaskProgress>`.\n */\nclass LoadBundleTask {\n    constructor() {\n        this._progressObserver = {};\n        this._taskCompletionResolver = new Deferred();\n        this._lastProgress = {\n            taskState: 'Running',\n            totalBytes: 0,\n            totalDocuments: 0,\n            bytesLoaded: 0,\n            documentsLoaded: 0\n        };\n    }\n    /**\n     * Registers functions to listen to bundle loading progress events.\n     * @param next - Called when there is a progress update from bundle loading. Typically `next` calls occur\n     *   each time a Firestore document is loaded from the bundle.\n     * @param error - Called when an error occurs during bundle loading. The task aborts after reporting the\n     *   error, and there should be no more updates after this.\n     * @param complete - Called when the loading task is complete.\n     */\n    onProgress(next, error, complete) {\n        this._progressObserver = {\n            next,\n            error,\n            complete\n        };\n    }\n    /**\n     * Implements the `Promise<LoadBundleTaskProgress>.catch` interface.\n     *\n     * @param onRejected - Called when an error occurs during bundle loading.\n     */\n    catch(onRejected) {\n        return this._taskCompletionResolver.promise.catch(onRejected);\n    }\n    /**\n     * Implements the `Promise<LoadBundleTaskProgress>.then` interface.\n     *\n     * @param onFulfilled - Called on the completion of the loading task with a final `LoadBundleTaskProgress` update.\n     *   The update will always have its `taskState` set to `\"Success\"`.\n     * @param onRejected - Called when an error occurs during bundle loading.\n     */\n    then(onFulfilled, onRejected) {\n        return this._taskCompletionResolver.promise.then(onFulfilled, onRejected);\n    }\n    /**\n     * Notifies all observers that bundle loading has completed, with a provided\n     * `LoadBundleTaskProgress` object.\n     *\n     * @private\n     */\n    _completeWith(progress) {\n        this._updateProgress(progress);\n        if (this._progressObserver.complete) {\n            this._progressObserver.complete();\n        }\n        this._taskCompletionResolver.resolve(progress);\n    }\n    /**\n     * Notifies all observers that bundle loading has failed, with a provided\n     * `Error` as the reason.\n     *\n     * @private\n     */\n    _failWith(error) {\n        this._lastProgress.taskState = 'Error';\n        if (this._progressObserver.next) {\n            this._progressObserver.next(this._lastProgress);\n        }\n        if (this._progressObserver.error) {\n            this._progressObserver.error(error);\n        }\n        this._taskCompletionResolver.reject(error);\n    }\n    /**\n     * Notifies a progress update of loading a bundle.\n     * @param progress - The new progress.\n     *\n     * @private\n     */\n    _updateProgress(progress) {\n        this._lastProgress = progress;\n        if (this._progressObserver.next) {\n            this._progressObserver.next(progress);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Constant used to indicate the LRU garbage collection should be disabled.\n * Set this value as the `cacheSizeBytes` on the settings passed to the\n * {@link Firestore} instance.\n */\nconst CACHE_SIZE_UNLIMITED = LRU_COLLECTION_DISABLED;\n/**\n * The Cloud Firestore service interface.\n *\n * Do not call this constructor directly. Instead, use {@link (getFirestore:1)}.\n */\nclass Firestore extends Firestore$1 {\n    /** @hideconstructor */\n    constructor(authCredentialsProvider, appCheckCredentialsProvider, databaseId, app) {\n        super(authCredentialsProvider, appCheckCredentialsProvider, databaseId, app);\n        /**\n         * Whether it's a {@link Firestore} or Firestore Lite instance.\n         */\n        this.type = 'firestore';\n        this._queue = new AsyncQueueImpl();\n        this._persistenceKey = app?.name || '[DEFAULT]';\n    }\n    async _terminate() {\n        if (this._firestoreClient) {\n            const terminate = this._firestoreClient.terminate();\n            this._queue = new AsyncQueueImpl(terminate);\n            this._firestoreClient = undefined;\n            await terminate;\n        }\n    }\n}\n/**\n * Initializes a new instance of {@link Firestore} with the provided settings.\n * Can only be called before any other function, including\n * {@link (getFirestore:1)}. If the custom settings are empty, this function is\n * equivalent to calling {@link (getFirestore:1)}.\n *\n * @param app - The {@link @firebase/app#FirebaseApp} with which the {@link Firestore} instance will\n * be associated.\n * @param settings - A settings object to configure the {@link Firestore} instance.\n * @param databaseId - The name of the database.\n * @returns A newly initialized {@link Firestore} instance.\n */\nfunction initializeFirestore(app, settings, databaseId) {\n    if (!databaseId) {\n        databaseId = DEFAULT_DATABASE_NAME;\n    }\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'firestore');\n    if (provider.isInitialized(databaseId)) {\n        const existingInstance = provider.getImmediate({\n            identifier: databaseId\n        });\n        const initialSettings = provider.getOptions(databaseId);\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(initialSettings, settings)) {\n            return existingInstance;\n        }\n        else {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'initializeFirestore() has already been called with ' +\n                'different options. To avoid this error, call initializeFirestore() with the ' +\n                'same options as when it was originally called, or call getFirestore() to return the' +\n                ' already initialized instance.');\n        }\n    }\n    if (settings.cacheSizeBytes !== undefined &&\n        settings.localCache !== undefined) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `cache and cacheSizeBytes cannot be specified at the same time as cacheSizeBytes will` +\n            `be deprecated. Instead, specify the cache size in the cache object`);\n    }\n    if (settings.cacheSizeBytes !== undefined &&\n        settings.cacheSizeBytes !== CACHE_SIZE_UNLIMITED &&\n        settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);\n    }\n    // Workaround to get cookies in Firebase Studio\n    if (settings.host && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isCloudWorkstation)(settings.host)) {\n        void (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.pingServer)(settings.host);\n    }\n    return provider.initialize({\n        options: settings,\n        instanceIdentifier: databaseId\n    });\n}\nfunction getFirestore(appOrDatabaseId, optionalDatabaseId) {\n    const app = typeof appOrDatabaseId === 'object' ? appOrDatabaseId : (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)();\n    const databaseId = typeof appOrDatabaseId === 'string'\n        ? appOrDatabaseId\n        : optionalDatabaseId || DEFAULT_DATABASE_NAME;\n    const db = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'firestore').getImmediate({\n        identifier: databaseId\n    });\n    if (!db._initialized) {\n        const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getDefaultEmulatorHostnameAndPort)('firestore');\n        if (emulator) {\n            connectFirestoreEmulator(db, ...emulator);\n        }\n    }\n    return db;\n}\n/**\n * @internal\n */\nfunction ensureFirestoreConfigured(firestore) {\n    if (firestore._terminated) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');\n    }\n    if (!firestore._firestoreClient) {\n        configureFirestore(firestore);\n    }\n    return firestore._firestoreClient;\n}\nfunction configureFirestore(firestore) {\n    const settings = firestore._freezeSettings();\n    const databaseInfo = makeDatabaseInfo(firestore._databaseId, firestore._app?.options.appId || '', firestore._persistenceKey, firestore._app?.options.apiKey, settings);\n    if (!firestore._componentsProvider) {\n        if (settings.localCache?._offlineComponentProvider &&\n            settings.localCache?._onlineComponentProvider) {\n            firestore._componentsProvider = {\n                _offline: settings.localCache._offlineComponentProvider,\n                _online: settings.localCache._onlineComponentProvider\n            };\n        }\n    }\n    firestore._firestoreClient = new FirestoreClient(firestore._authCredentials, firestore._appCheckCredentials, firestore._queue, databaseInfo, firestore._componentsProvider &&\n        buildComponentProvider(firestore._componentsProvider));\n}\nfunction buildComponentProvider(componentsProvider) {\n    const online = componentsProvider?._online.build();\n    return {\n        _offline: componentsProvider?._offline.build(online),\n        _online: online\n    };\n}\n/**\n * Attempts to enable persistent storage, if possible.\n *\n * On failure, `enableIndexedDbPersistence()` will reject the promise or\n * throw an exception. There are several reasons why this can fail, which can be\n * identified by the `code` on the error.\n *\n *   * failed-precondition: The app is already open in another browser tab.\n *   * unimplemented: The browser is incompatible with the offline persistence\n *     implementation.\n *\n * Note that even after a failure, the {@link Firestore} instance will remain\n * usable, however offline persistence will be disabled.\n *\n * Note: `enableIndexedDbPersistence()` must be called before any other functions\n * (other than {@link initializeFirestore}, {@link (getFirestore:1)} or\n * {@link clearIndexedDbPersistence}.\n *\n * Persistence cannot be used in a Node.js environment.\n *\n * @param firestore - The {@link Firestore} instance to enable persistence for.\n * @param persistenceSettings - Optional settings object to configure\n * persistence.\n * @returns A `Promise` that represents successfully enabling persistent storage.\n * @deprecated This function will be removed in a future major release. Instead, set\n * `FirestoreSettings.localCache` to an instance of `PersistentLocalCache` to\n * turn on IndexedDb cache. Calling this function when `FirestoreSettings.localCache`\n * is already specified will throw an exception.\n */\nfunction enableIndexedDbPersistence(firestore, persistenceSettings) {\n    logWarn('enableIndexedDbPersistence() will be deprecated in the future, ' +\n        'you can use `FirestoreSettings.cache` instead.');\n    const settings = firestore._freezeSettings();\n    setPersistenceProviders(firestore, OnlineComponentProvider.provider, {\n        build: (onlineComponents) => new IndexedDbOfflineComponentProvider(onlineComponents, settings.cacheSizeBytes, persistenceSettings?.forceOwnership)\n    });\n    return Promise.resolve();\n}\n/**\n * Attempts to enable multi-tab persistent storage, if possible. If enabled\n * across all tabs, all operations share access to local persistence, including\n * shared execution of queries and latency-compensated local document updates\n * across all connected instances.\n *\n * On failure, `enableMultiTabIndexedDbPersistence()` will reject the promise or\n * throw an exception. There are several reasons why this can fail, which can be\n * identified by the `code` on the error.\n *\n *   * failed-precondition: The app is already open in another browser tab and\n *     multi-tab is not enabled.\n *   * unimplemented: The browser is incompatible with the offline persistence\n *     implementation.\n *\n * Note that even after a failure, the {@link Firestore} instance will remain\n * usable, however offline persistence will be disabled.\n *\n * @param firestore - The {@link Firestore} instance to enable persistence for.\n * @returns A `Promise` that represents successfully enabling persistent\n * storage.\n * @deprecated This function will be removed in a future major release. Instead, set\n * `FirestoreSettings.localCache` to an instance of `PersistentLocalCache` to\n * turn on indexeddb cache. Calling this function when `FirestoreSettings.localCache`\n * is already specified will throw an exception.\n */\nasync function enableMultiTabIndexedDbPersistence(firestore) {\n    logWarn('enableMultiTabIndexedDbPersistence() will be deprecated in the future, ' +\n        'you can use `FirestoreSettings.cache` instead.');\n    const settings = firestore._freezeSettings();\n    setPersistenceProviders(firestore, OnlineComponentProvider.provider, {\n        build: (onlineComponents) => new MultiTabOfflineComponentProvider(onlineComponents, settings.cacheSizeBytes)\n    });\n}\n/**\n * Registers both the `OfflineComponentProvider` and `OnlineComponentProvider`.\n * If the operation fails with a recoverable error (see\n * `canRecoverFromIndexedDbError()` below), the returned Promise is rejected\n * but the client remains usable.\n */\nfunction setPersistenceProviders(firestore, onlineComponentProvider, offlineComponentProvider) {\n    firestore = cast(firestore, Firestore);\n    if (firestore._firestoreClient || firestore._terminated) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and persistence can no longer be ' +\n            'enabled. You can only enable persistence before calling any other ' +\n            'methods on a Firestore object.');\n    }\n    if (firestore._componentsProvider || firestore._getSettings().localCache) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'SDK cache is already specified.');\n    }\n    firestore._componentsProvider = {\n        _online: onlineComponentProvider,\n        _offline: offlineComponentProvider\n    };\n    configureFirestore(firestore);\n}\n/**\n * Clears the persistent storage. This includes pending writes and cached\n * documents.\n *\n * Must be called while the {@link Firestore} instance is not started (after the app is\n * terminated or when the app is first initialized). On startup, this function\n * must be called before other functions (other than {@link\n * initializeFirestore} or {@link (getFirestore:1)})). If the {@link Firestore}\n * instance is still running, the promise will be rejected with the error code\n * of `failed-precondition`.\n *\n * Note: `clearIndexedDbPersistence()` is primarily intended to help write\n * reliable tests that use Cloud Firestore. It uses an efficient mechanism for\n * dropping existing data but does not attempt to securely overwrite or\n * otherwise make cached data unrecoverable. For applications that are sensitive\n * to the disclosure of cached data in between user sessions, we strongly\n * recommend not enabling persistence at all.\n *\n * @param firestore - The {@link Firestore} instance to clear persistence for.\n * @returns A `Promise` that is resolved when the persistent storage is\n * cleared. Otherwise, the promise is rejected with an error.\n */\nfunction clearIndexedDbPersistence(firestore) {\n    if (firestore._initialized && !firestore._terminated) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'Persistence can only be cleared before a Firestore instance is ' +\n            'initialized or after it is terminated.');\n    }\n    const deferred = new Deferred();\n    firestore._queue.enqueueAndForgetEvenWhileRestricted(async () => {\n        try {\n            await indexedDbClearPersistence(indexedDbStoragePrefix(firestore._databaseId, firestore._persistenceKey));\n            deferred.resolve();\n        }\n        catch (e) {\n            deferred.reject(e);\n        }\n    });\n    return deferred.promise;\n}\n/**\n * Waits until all currently pending writes for the active user have been\n * acknowledged by the backend.\n *\n * The returned promise resolves immediately if there are no outstanding writes.\n * Otherwise, the promise waits for all previously issued writes (including\n * those written in a previous app session), but it does not wait for writes\n * that were added after the function is called. If you want to wait for\n * additional writes, call `waitForPendingWrites()` again.\n *\n * Any outstanding `waitForPendingWrites()` promises are rejected during user\n * changes.\n *\n * @returns A `Promise` which resolves when all currently pending writes have been\n * acknowledged by the backend.\n */\nfunction waitForPendingWrites(firestore) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientWaitForPendingWrites(client);\n}\n/**\n * Re-enables use of the network for this {@link Firestore} instance after a prior\n * call to {@link disableNetwork}.\n *\n * @returns A `Promise` that is resolved once the network has been enabled.\n */\nfunction enableNetwork(firestore) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientEnableNetwork(client);\n}\n/**\n * Disables network usage for this instance. It can be re-enabled via {@link\n * enableNetwork}. While the network is disabled, any snapshot listeners,\n * `getDoc()` or `getDocs()` calls will return results from cache, and any write\n * operations will be queued until the network is restored.\n *\n * @returns A `Promise` that is resolved once the network has been disabled.\n */\nfunction disableNetwork(firestore) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientDisableNetwork(client);\n}\n/**\n * Terminates the provided {@link Firestore} instance.\n *\n * After calling `terminate()` only the `clearIndexedDbPersistence()` function\n * may be used. Any other function will throw a `FirestoreError`.\n *\n * To restart after termination, create a new instance of FirebaseFirestore with\n * {@link (getFirestore:1)}.\n *\n * Termination does not cancel any pending writes, and any promises that are\n * awaiting a response from the server will not be resolved. If you have\n * persistence enabled, the next time you start this instance, it will resume\n * sending these writes to the server.\n *\n * Note: Under normal circumstances, calling `terminate()` is not required. This\n * function is useful only when you want to force this instance to release all\n * of its resources or in combination with `clearIndexedDbPersistence()` to\n * ensure that all local state is destroyed between test runs.\n *\n * @returns A `Promise` that is resolved when the instance has been successfully\n * terminated.\n */\nfunction terminate(firestore) {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._removeServiceInstance)(firestore.app, 'firestore', firestore._databaseId.database);\n    return firestore._delete();\n}\n/**\n * Loads a Firestore bundle into the local cache.\n *\n * @param firestore - The {@link Firestore} instance to load bundles for.\n * @param bundleData - An object representing the bundle to be loaded. Valid\n * objects are `ArrayBuffer`, `ReadableStream<Uint8Array>` or `string`.\n *\n * @returns A `LoadBundleTask` object, which notifies callers with progress\n * updates, and completion or error events. It can be used as a\n * `Promise<LoadBundleTaskProgress>`.\n */\nfunction loadBundle(firestore, bundleData) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const resultTask = new LoadBundleTask();\n    firestoreClientLoadBundle(client, firestore._databaseId, bundleData, resultTask);\n    return resultTask;\n}\n/**\n * Reads a Firestore {@link Query} from local cache, identified by the given\n * name.\n *\n * The named queries are packaged  into bundles on the server side (along\n * with resulting documents), and loaded to local cache using `loadBundle`. Once\n * in local cache, use this method to extract a {@link Query} by name.\n *\n * @param firestore - The {@link Firestore} instance to read the query from.\n * @param name - The name of the query.\n * @returns A `Promise` that is resolved with the Query or `null`.\n */\nfunction namedQuery(firestore, name) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientGetNamedQuery(client, name).then(namedQuery => {\n        if (!namedQuery) {\n            return null;\n        }\n        return new Query(firestore, null, namedQuery.query);\n    });\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Concrete implementation of the Aggregate type.\n */\nclass AggregateImpl {\n    constructor(alias, aggregateType, fieldPath) {\n        this.alias = alias;\n        this.aggregateType = aggregateType;\n        this.fieldPath = fieldPath;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An immutable object representing an array of bytes.\n */\nclass Bytes {\n    /** @hideconstructor */\n    constructor(byteString) {\n        this._byteString = byteString;\n    }\n    /**\n     * Creates a new `Bytes` object from the given Base64 string, converting it to\n     * bytes.\n     *\n     * @param base64 - The Base64 string used to create the `Bytes` object.\n     */\n    static fromBase64String(base64) {\n        try {\n            return new Bytes(ByteString.fromBase64String(base64));\n        }\n        catch (e) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to construct data from Base64 string: ' + e);\n        }\n    }\n    /**\n     * Creates a new `Bytes` object from the given Uint8Array.\n     *\n     * @param array - The Uint8Array used to create the `Bytes` object.\n     */\n    static fromUint8Array(array) {\n        return new Bytes(ByteString.fromUint8Array(array));\n    }\n    /**\n     * Returns the underlying bytes as a Base64-encoded string.\n     *\n     * @returns The Base64-encoded string created from the `Bytes` object.\n     */\n    toBase64() {\n        return this._byteString.toBase64();\n    }\n    /**\n     * Returns the underlying bytes in a new `Uint8Array`.\n     *\n     * @returns The Uint8Array created from the `Bytes` object.\n     */\n    toUint8Array() {\n        return this._byteString.toUint8Array();\n    }\n    /**\n     * Returns a string representation of the `Bytes` object.\n     *\n     * @returns A string representation of the `Bytes` object.\n     */\n    toString() {\n        return 'Bytes(base64: ' + this.toBase64() + ')';\n    }\n    /**\n     * Returns true if this `Bytes` object is equal to the provided one.\n     *\n     * @param other - The `Bytes` object to compare against.\n     * @returns true if this `Bytes` object is equal to the provided one.\n     */\n    isEqual(other) {\n        return this._byteString.isEqual(other._byteString);\n    }\n    /**\n     * Returns a JSON-serializable representation of this `Bytes` instance.\n     *\n     * @returns a JSON representation of this object.\n     */\n    toJSON() {\n        return {\n            type: Bytes._jsonSchemaVersion,\n            bytes: this.toBase64()\n        };\n    }\n    /**\n     * Builds a `Bytes` instance from a JSON object created by {@link Bytes.toJSON}.\n     *\n     * @param json - a JSON object represention of a `Bytes` instance\n     * @returns an instance of {@link Bytes} if the JSON object could be parsed. Throws a\n     * {@link FirestoreError} if an error occurs.\n     */\n    static fromJSON(json) {\n        if (validateJSON(json, Bytes._jsonSchema)) {\n            return Bytes.fromBase64String(json.bytes);\n        }\n    }\n}\nBytes._jsonSchemaVersion = 'firestore/bytes/1.0';\nBytes._jsonSchema = {\n    type: property('string', Bytes._jsonSchemaVersion),\n    bytes: property('string')\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `FieldPath` refers to a field in a document. The path may consist of a\n * single field name (referring to a top-level field in the document), or a\n * list of field names (referring to a nested field in the document).\n *\n * Create a `FieldPath` by providing field names. If more than one field\n * name is provided, the path will point to a nested field in a document.\n */\nclass FieldPath {\n    /**\n     * Creates a `FieldPath` from the provided field names. If more than one field\n     * name is provided, the path will point to a nested field in a document.\n     *\n     * @param fieldNames - A list of field names.\n     */\n    constructor(...fieldNames) {\n        for (let i = 0; i < fieldNames.length; ++i) {\n            if (fieldNames[i].length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field name at argument $(i + 1). ` +\n                    'Field names must not be empty.');\n            }\n        }\n        this._internalPath = new FieldPath$1(fieldNames);\n    }\n    /**\n     * Returns true if this `FieldPath` is equal to the provided one.\n     *\n     * @param other - The `FieldPath` to compare against.\n     * @returns true if this `FieldPath` is equal to the provided one.\n     */\n    isEqual(other) {\n        return this._internalPath.isEqual(other._internalPath);\n    }\n}\n/**\n * Returns a special sentinel `FieldPath` to refer to the ID of a document.\n * It can be used in queries to sort or filter by the document ID.\n */\nfunction documentId() {\n    return new FieldPath(DOCUMENT_KEY_NAME);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Sentinel values that can be used when writing document fields with `set()`\n * or `update()`.\n */\nclass FieldValue {\n    /**\n     * @param _methodName - The public API endpoint that returns this class.\n     * @hideconstructor\n     */\n    constructor(_methodName) {\n        this._methodName = _methodName;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An immutable object representing a geographic location in Firestore. The\n * location is represented as latitude/longitude pair.\n *\n * Latitude values are in the range of [-90, 90].\n * Longitude values are in the range of [-180, 180].\n */\nclass GeoPoint {\n    /**\n     * Creates a new immutable `GeoPoint` object with the provided latitude and\n     * longitude values.\n     * @param latitude - The latitude as number between -90 and 90.\n     * @param longitude - The longitude as number between -180 and 180.\n     */\n    constructor(latitude, longitude) {\n        if (!isFinite(latitude) || latitude < -90 || latitude > 90) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Latitude must be a number between -90 and 90, but was: ' + latitude);\n        }\n        if (!isFinite(longitude) || longitude < -180 || longitude > 180) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Longitude must be a number between -180 and 180, but was: ' + longitude);\n        }\n        this._lat = latitude;\n        this._long = longitude;\n    }\n    /**\n     * The latitude of this `GeoPoint` instance.\n     */\n    get latitude() {\n        return this._lat;\n    }\n    /**\n     * The longitude of this `GeoPoint` instance.\n     */\n    get longitude() {\n        return this._long;\n    }\n    /**\n     * Returns true if this `GeoPoint` is equal to the provided one.\n     *\n     * @param other - The `GeoPoint` to compare against.\n     * @returns true if this `GeoPoint` is equal to the provided one.\n     */\n    isEqual(other) {\n        return this._lat === other._lat && this._long === other._long;\n    }\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n    _compareTo(other) {\n        return (primitiveComparator(this._lat, other._lat) ||\n            primitiveComparator(this._long, other._long));\n    }\n    /**\n     * Returns a JSON-serializable representation of this `GeoPoint` instance.\n     *\n     * @returns a JSON representation of this object.\n     */\n    toJSON() {\n        return {\n            latitude: this._lat,\n            longitude: this._long,\n            type: GeoPoint._jsonSchemaVersion\n        };\n    }\n    /**\n     * Builds a `GeoPoint` instance from a JSON object created by {@link GeoPoint.toJSON}.\n     *\n     * @param json - a JSON object represention of a `GeoPoint` instance\n     * @returns an instance of {@link GeoPoint} if the JSON object could be parsed. Throws a\n     * {@link FirestoreError} if an error occurs.\n     */\n    static fromJSON(json) {\n        if (validateJSON(json, GeoPoint._jsonSchema)) {\n            return new GeoPoint(json.latitude, json.longitude);\n        }\n    }\n}\nGeoPoint._jsonSchemaVersion = 'firestore/geoPoint/1.0';\nGeoPoint._jsonSchema = {\n    type: property('string', GeoPoint._jsonSchemaVersion),\n    latitude: property('number'),\n    longitude: property('number')\n};\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a vector type in Firestore documents.\n * Create an instance with <code>{@link vector}</code>.\n */\nclass VectorValue {\n    /**\n     * @private\n     * @internal\n     */\n    constructor(values) {\n        // Making a copy of the parameter.\n        this._values = (values || []).map(n => n);\n    }\n    /**\n     * Returns a copy of the raw number array form of the vector.\n     */\n    toArray() {\n        return this._values.map(n => n);\n    }\n    /**\n     * Returns `true` if the two `VectorValue` values have the same raw number arrays, returns `false` otherwise.\n     */\n    isEqual(other) {\n        return isPrimitiveArrayEqual(this._values, other._values);\n    }\n    /**\n     * Returns a JSON-serializable representation of this `VectorValue` instance.\n     *\n     * @returns a JSON representation of this object.\n     */\n    toJSON() {\n        return {\n            type: VectorValue._jsonSchemaVersion,\n            vectorValues: this._values\n        };\n    }\n    /**\n     * Builds a `VectorValue` instance from a JSON object created by {@link VectorValue.toJSON}.\n     *\n     * @param json - a JSON object represention of a `VectorValue` instance.\n     * @returns an instance of {@link VectorValue} if the JSON object could be parsed. Throws a\n     * {@link FirestoreError} if an error occurs.\n     */\n    static fromJSON(json) {\n        if (validateJSON(json, VectorValue._jsonSchema)) {\n            if (Array.isArray(json.vectorValues) &&\n                json.vectorValues.every(element => typeof element === 'number')) {\n                return new VectorValue(json.vectorValues);\n            }\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Expected 'vectorValues' field to be a number array\");\n        }\n    }\n}\nVectorValue._jsonSchemaVersion = 'firestore/vectorValue/1.0';\nVectorValue._jsonSchema = {\n    type: property('string', VectorValue._jsonSchemaVersion),\n    vectorValues: property('object')\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst RESERVED_FIELD_REGEX = /^__.*__$/;\n/** The result of parsing document data (e.g. for a setData call). */\nclass ParsedSetData {\n    constructor(data, fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    toMutation(key, precondition) {\n        if (this.fieldMask !== null) {\n            return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);\n        }\n        else {\n            return new SetMutation(key, this.data, precondition, this.fieldTransforms);\n        }\n    }\n}\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\nclass ParsedUpdateData {\n    constructor(data, \n    // The fieldMask does not include document transforms.\n    fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    toMutation(key, precondition) {\n        return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);\n    }\n}\nfunction isWrite(dataSource) {\n    switch (dataSource) {\n        case 0 /* UserDataSource.Set */: // fall through\n        case 2 /* UserDataSource.MergeSet */: // fall through\n        case 1 /* UserDataSource.Update */:\n            return true;\n        case 3 /* UserDataSource.Argument */:\n        case 4 /* UserDataSource.ArrayArgument */:\n            return false;\n        default:\n            throw fail(0x9c4b, {\n                dataSource\n            });\n    }\n}\n/** A \"context\" object passed around while parsing user data. */\nclass ParseContextImpl {\n    /**\n     * Initializes a ParseContext with the given source and path.\n     *\n     * @param settings - The settings for the parser.\n     * @param databaseId - The database ID of the Firestore instance.\n     * @param serializer - The serializer to use to generate the Value proto.\n     * @param ignoreUndefinedProperties - Whether to ignore undefined properties\n     * rather than throw.\n     * @param fieldTransforms - A mutable list of field transforms encountered\n     * while parsing the data.\n     * @param fieldMask - A mutable list of field paths encountered while parsing\n     * the data.\n     *\n     * TODO(b/34871131): We don't support array paths right now, so path can be\n     * null to indicate the context represents any location within an array (in\n     * which case certain features will not work and errors will be somewhat\n     * compromised).\n     */\n    constructor(settings, databaseId, serializer, ignoreUndefinedProperties, fieldTransforms, fieldMask) {\n        this.settings = settings;\n        this.databaseId = databaseId;\n        this.serializer = serializer;\n        this.ignoreUndefinedProperties = ignoreUndefinedProperties;\n        // Minor hack: If fieldTransforms is undefined, we assume this is an\n        // external call and we need to validate the entire path.\n        if (fieldTransforms === undefined) {\n            this.validatePath();\n        }\n        this.fieldTransforms = fieldTransforms || [];\n        this.fieldMask = fieldMask || [];\n    }\n    get path() {\n        return this.settings.path;\n    }\n    get dataSource() {\n        return this.settings.dataSource;\n    }\n    /** Returns a new context with the specified settings overwritten. */\n    contextWith(configuration) {\n        return new ParseContextImpl({ ...this.settings, ...configuration }, this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);\n    }\n    childContextForField(field) {\n        const childPath = this.path?.child(field);\n        const context = this.contextWith({ path: childPath, arrayElement: false });\n        context.validatePathSegment(field);\n        return context;\n    }\n    childContextForFieldPath(field) {\n        const childPath = this.path?.child(field);\n        const context = this.contextWith({ path: childPath, arrayElement: false });\n        context.validatePath();\n        return context;\n    }\n    childContextForArray(index) {\n        // TODO(b/34871131): We don't support array paths right now; so make path\n        // undefined.\n        return this.contextWith({ path: undefined, arrayElement: true });\n    }\n    createError(reason) {\n        return createError(reason, this.settings.methodName, this.settings.hasConverter || false, this.path, this.settings.targetDoc);\n    }\n    /** Returns 'true' if 'fieldPath' was traversed when creating this context. */\n    contains(fieldPath) {\n        return (this.fieldMask.find(field => fieldPath.isPrefixOf(field)) !== undefined ||\n            this.fieldTransforms.find(transform => fieldPath.isPrefixOf(transform.field)) !== undefined);\n    }\n    validatePath() {\n        // TODO(b/34871131): Remove null check once we have proper paths for fields\n        // within arrays.\n        if (!this.path) {\n            return;\n        }\n        for (let i = 0; i < this.path.length; i++) {\n            this.validatePathSegment(this.path.get(i));\n        }\n    }\n    validatePathSegment(segment) {\n        if (segment.length === 0) {\n            throw this.createError('Document fields must not be empty');\n        }\n        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {\n            throw this.createError('Document fields cannot begin and end with \"__\"');\n        }\n    }\n}\n/**\n * Helper for parsing raw user input (provided via the API) into internal model\n * classes.\n */\nclass UserDataReader {\n    constructor(databaseId, ignoreUndefinedProperties, serializer) {\n        this.databaseId = databaseId;\n        this.ignoreUndefinedProperties = ignoreUndefinedProperties;\n        this.serializer = serializer || newSerializer(databaseId);\n    }\n    /** Creates a new top-level parse context. */\n    createContext(dataSource, methodName, targetDoc, hasConverter = false) {\n        return new ParseContextImpl({\n            dataSource,\n            methodName,\n            targetDoc,\n            path: FieldPath$1.emptyPath(),\n            arrayElement: false,\n            hasConverter\n        }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);\n    }\n}\nfunction newUserDataReader(firestore) {\n    const settings = firestore._freezeSettings();\n    const serializer = newSerializer(firestore._databaseId);\n    return new UserDataReader(firestore._databaseId, !!settings.ignoreUndefinedProperties, serializer);\n}\n/** Parse document data from a set() call. */\nfunction parseSetData(userDataReader, methodName, targetDoc, input, hasConverter, options = {}) {\n    const context = userDataReader.createContext(options.merge || options.mergeFields\n        ? 2 /* UserDataSource.MergeSet */\n        : 0 /* UserDataSource.Set */, methodName, targetDoc, hasConverter);\n    validatePlainObject('Data must be an object, but it was:', context, input);\n    const updateData = parseObject(input, context);\n    let fieldMask;\n    let fieldTransforms;\n    if (options.merge) {\n        fieldMask = new FieldMask(context.fieldMask);\n        fieldTransforms = context.fieldTransforms;\n    }\n    else if (options.mergeFields) {\n        const validatedFieldPaths = [];\n        for (const stringOrFieldPath of options.mergeFields) {\n            const fieldPath = fieldPathFromArgument(methodName, stringOrFieldPath, targetDoc);\n            if (!context.contains(fieldPath)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Field '${fieldPath}' is specified in your field mask but missing from your input data.`);\n            }\n            if (!fieldMaskContains(validatedFieldPaths, fieldPath)) {\n                validatedFieldPaths.push(fieldPath);\n            }\n        }\n        fieldMask = new FieldMask(validatedFieldPaths);\n        fieldTransforms = context.fieldTransforms.filter(transform => fieldMask.covers(transform.field));\n    }\n    else {\n        fieldMask = null;\n        fieldTransforms = context.fieldTransforms;\n    }\n    return new ParsedSetData(new ObjectValue(updateData), fieldMask, fieldTransforms);\n}\nclass DeleteFieldValueImpl extends FieldValue {\n    _toFieldTransform(context) {\n        if (context.dataSource === 2 /* UserDataSource.MergeSet */) {\n            // No transform to add for a delete, but we need to add it to our\n            // fieldMask so it gets deleted.\n            context.fieldMask.push(context.path);\n        }\n        else if (context.dataSource === 1 /* UserDataSource.Update */) {\n            throw context.createError(`${this._methodName}() can only appear at the top level ` +\n                'of your update data');\n        }\n        else {\n            // We shouldn't encounter delete sentinels for queries or non-merge set() calls.\n            throw context.createError(`${this._methodName}() cannot be used with set() unless you pass ` +\n                '{merge:true}');\n        }\n        return null;\n    }\n    isEqual(other) {\n        return other instanceof DeleteFieldValueImpl;\n    }\n}\n/**\n * Creates a child context for parsing SerializableFieldValues.\n *\n * This is different than calling `ParseContext.contextWith` because it keeps\n * the fieldTransforms and fieldMask separate.\n *\n * The created context has its `dataSource` set to `UserDataSource.Argument`.\n * Although these values are used with writes, any elements in these FieldValues\n * are not considered writes since they cannot contain any FieldValue sentinels,\n * etc.\n *\n * @param fieldValue - The sentinel FieldValue for which to create a child\n *     context.\n * @param context - The parent context.\n * @param arrayElement - Whether or not the FieldValue has an array.\n */\nfunction createSentinelChildContext(fieldValue, context, arrayElement) {\n    return new ParseContextImpl({\n        dataSource: 3 /* UserDataSource.Argument */,\n        targetDoc: context.settings.targetDoc,\n        methodName: fieldValue._methodName,\n        arrayElement\n    }, context.databaseId, context.serializer, context.ignoreUndefinedProperties);\n}\nclass ServerTimestampFieldValueImpl extends FieldValue {\n    _toFieldTransform(context) {\n        return new FieldTransform(context.path, new ServerTimestampTransform());\n    }\n    isEqual(other) {\n        return other instanceof ServerTimestampFieldValueImpl;\n    }\n}\nclass ArrayUnionFieldValueImpl extends FieldValue {\n    constructor(methodName, _elements) {\n        super(methodName);\n        this._elements = _elements;\n    }\n    _toFieldTransform(context) {\n        const parseContext = createSentinelChildContext(this, context, \n        /*array=*/ true);\n        const parsedElements = this._elements.map(element => parseData(element, parseContext));\n        const arrayUnion = new ArrayUnionTransformOperation(parsedElements);\n        return new FieldTransform(context.path, arrayUnion);\n    }\n    isEqual(other) {\n        return (other instanceof ArrayUnionFieldValueImpl &&\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(this._elements, other._elements));\n    }\n}\nclass ArrayRemoveFieldValueImpl extends FieldValue {\n    constructor(methodName, _elements) {\n        super(methodName);\n        this._elements = _elements;\n    }\n    _toFieldTransform(context) {\n        const parseContext = createSentinelChildContext(this, context, \n        /*array=*/ true);\n        const parsedElements = this._elements.map(element => parseData(element, parseContext));\n        const arrayUnion = new ArrayRemoveTransformOperation(parsedElements);\n        return new FieldTransform(context.path, arrayUnion);\n    }\n    isEqual(other) {\n        return (other instanceof ArrayRemoveFieldValueImpl &&\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(this._elements, other._elements));\n    }\n}\nclass NumericIncrementFieldValueImpl extends FieldValue {\n    constructor(methodName, _operand) {\n        super(methodName);\n        this._operand = _operand;\n    }\n    _toFieldTransform(context) {\n        const numericIncrement = new NumericIncrementTransformOperation(context.serializer, toNumber(context.serializer, this._operand));\n        return new FieldTransform(context.path, numericIncrement);\n    }\n    isEqual(other) {\n        return (other instanceof NumericIncrementFieldValueImpl &&\n            this._operand === other._operand);\n    }\n}\n/** Parse update data from an update() call. */\nfunction parseUpdateData(userDataReader, methodName, targetDoc, input) {\n    const context = userDataReader.createContext(1 /* UserDataSource.Update */, methodName, targetDoc);\n    validatePlainObject('Data must be an object, but it was:', context, input);\n    const fieldMaskPaths = [];\n    const updateData = ObjectValue.empty();\n    forEach(input, (key, value) => {\n        const path = fieldPathFromDotSeparatedString(methodName, key, targetDoc);\n        // For Compat types, we have to \"extract\" the underlying types before\n        // performing validation.\n        value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(value);\n        const childContext = context.childContextForFieldPath(path);\n        if (value instanceof DeleteFieldValueImpl) {\n            // Add it to the field mask, but don't add anything to updateData.\n            fieldMaskPaths.push(path);\n        }\n        else {\n            const parsedValue = parseData(value, childContext);\n            if (parsedValue != null) {\n                fieldMaskPaths.push(path);\n                updateData.set(path, parsedValue);\n            }\n        }\n    });\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n}\n/** Parse update data from a list of field/value arguments. */\nfunction parseUpdateVarargs(userDataReader, methodName, targetDoc, field, value, moreFieldsAndValues) {\n    const context = userDataReader.createContext(1 /* UserDataSource.Update */, methodName, targetDoc);\n    const keys = [fieldPathFromArgument(methodName, field, targetDoc)];\n    const values = [value];\n    if (moreFieldsAndValues.length % 2 !== 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${methodName}() needs to be called with an even number ` +\n            'of arguments that alternate between field names and values.');\n    }\n    for (let i = 0; i < moreFieldsAndValues.length; i += 2) {\n        keys.push(fieldPathFromArgument(methodName, moreFieldsAndValues[i]));\n        values.push(moreFieldsAndValues[i + 1]);\n    }\n    const fieldMaskPaths = [];\n    const updateData = ObjectValue.empty();\n    // We iterate in reverse order to pick the last value for a field if the\n    // user specified the field multiple times.\n    for (let i = keys.length - 1; i >= 0; --i) {\n        if (!fieldMaskContains(fieldMaskPaths, keys[i])) {\n            const path = keys[i];\n            let value = values[i];\n            // For Compat types, we have to \"extract\" the underlying types before\n            // performing validation.\n            value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(value);\n            const childContext = context.childContextForFieldPath(path);\n            if (value instanceof DeleteFieldValueImpl) {\n                // Add it to the field mask, but don't add anything to updateData.\n                fieldMaskPaths.push(path);\n            }\n            else {\n                const parsedValue = parseData(value, childContext);\n                if (parsedValue != null) {\n                    fieldMaskPaths.push(path);\n                    updateData.set(path, parsedValue);\n                }\n            }\n        }\n    }\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n}\n/**\n * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\n * bound).\n *\n * @param allowArrays - Whether the query value is an array that may directly\n * contain additional arrays (e.g. the operand of an `in` query).\n */\nfunction parseQueryValue(userDataReader, methodName, input, allowArrays = false) {\n    const context = userDataReader.createContext(allowArrays ? 4 /* UserDataSource.ArrayArgument */ : 3 /* UserDataSource.Argument */, methodName);\n    const parsed = parseData(input, context);\n    return parsed;\n}\n/**\n * Parses user data to Protobuf Values.\n *\n * @param input - Data to be parsed.\n * @param context - A context object representing the current path being parsed,\n * the source of the data being parsed, etc.\n * @returns The parsed value, or null if the value was a FieldValue sentinel\n * that should not be included in the resulting parsed data.\n */\nfunction parseData(input, context) {\n    // Unwrap the API type from the Compat SDK. This will return the API type\n    // from firestore-exp.\n    input = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(input);\n    if (looksLikeJsonObject(input)) {\n        validatePlainObject('Unsupported field value:', context, input);\n        return parseObject(input, context);\n    }\n    else if (input instanceof FieldValue) {\n        // FieldValues usually parse into transforms (except deleteField())\n        // in which case we do not want to include this field in our parsed data\n        // (as doing so will overwrite the field directly prior to the transform\n        // trying to transform it). So we don't add this location to\n        // context.fieldMask and we return null as our parsing result.\n        parseSentinelFieldValue(input, context);\n        return null;\n    }\n    else if (input === undefined && context.ignoreUndefinedProperties) {\n        // If the input is undefined it can never participate in the fieldMask, so\n        // don't handle this below. If `ignoreUndefinedProperties` is false,\n        // `parseScalarValue` will reject an undefined value.\n        return null;\n    }\n    else {\n        // If context.path is null we are inside an array and we don't support\n        // field mask paths more granular than the top-level array.\n        if (context.path) {\n            context.fieldMask.push(context.path);\n        }\n        if (input instanceof Array) {\n            // TODO(b/34871131): Include the path containing the array in the error\n            // message.\n            // In the case of IN queries, the parsed data is an array (representing\n            // the set of values to be included for the IN query) that may directly\n            // contain additional arrays (each representing an individual field\n            // value), so we disable this validation.\n            if (context.settings.arrayElement &&\n                context.dataSource !== 4 /* UserDataSource.ArrayArgument */) {\n                throw context.createError('Nested arrays are not supported');\n            }\n            return parseArray(input, context);\n        }\n        else {\n            return parseScalarValue(input, context);\n        }\n    }\n}\nfunction parseObject(obj, context) {\n    const fields = {};\n    if (isEmpty(obj)) {\n        // If we encounter an empty object, we explicitly add it to the update\n        // mask to ensure that the server creates a map entry.\n        if (context.path && context.path.length > 0) {\n            context.fieldMask.push(context.path);\n        }\n    }\n    else {\n        forEach(obj, (key, val) => {\n            const parsedValue = parseData(val, context.childContextForField(key));\n            if (parsedValue != null) {\n                fields[key] = parsedValue;\n            }\n        });\n    }\n    return { mapValue: { fields } };\n}\nfunction parseArray(array, context) {\n    const values = [];\n    let entryIndex = 0;\n    for (const entry of array) {\n        let parsedEntry = parseData(entry, context.childContextForArray(entryIndex));\n        if (parsedEntry == null) {\n            // Just include nulls in the array for fields being replaced with a\n            // sentinel.\n            parsedEntry = { nullValue: 'NULL_VALUE' };\n        }\n        values.push(parsedEntry);\n        entryIndex++;\n    }\n    return { arrayValue: { values } };\n}\n/**\n * \"Parses\" the provided FieldValueImpl, adding any necessary transforms to\n * context.fieldTransforms.\n */\nfunction parseSentinelFieldValue(value, context) {\n    // Sentinels are only supported with writes, and not within arrays.\n    if (!isWrite(context.dataSource)) {\n        throw context.createError(`${value._methodName}() can only be used with update() and set()`);\n    }\n    if (!context.path) {\n        throw context.createError(`${value._methodName}() is not currently supported inside arrays`);\n    }\n    const fieldTransform = value._toFieldTransform(context);\n    if (fieldTransform) {\n        context.fieldTransforms.push(fieldTransform);\n    }\n}\n/**\n * Helper to parse a scalar value (i.e. not an Object, Array, or FieldValue)\n *\n * @returns The parsed value\n */\nfunction parseScalarValue(value, context) {\n    value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(value);\n    if (value === null) {\n        return { nullValue: 'NULL_VALUE' };\n    }\n    else if (typeof value === 'number') {\n        return toNumber(context.serializer, value);\n    }\n    else if (typeof value === 'boolean') {\n        return { booleanValue: value };\n    }\n    else if (typeof value === 'string') {\n        return { stringValue: value };\n    }\n    else if (value instanceof Date) {\n        const timestamp = Timestamp.fromDate(value);\n        return {\n            timestampValue: toTimestamp(context.serializer, timestamp)\n        };\n    }\n    else if (value instanceof Timestamp) {\n        // Firestore backend truncates precision down to microseconds. To ensure\n        // offline mode works the same with regards to truncation, perform the\n        // truncation immediately without waiting for the backend to do that.\n        const timestamp = new Timestamp(value.seconds, Math.floor(value.nanoseconds / 1000) * 1000);\n        return {\n            timestampValue: toTimestamp(context.serializer, timestamp)\n        };\n    }\n    else if (value instanceof GeoPoint) {\n        return {\n            geoPointValue: {\n                latitude: value.latitude,\n                longitude: value.longitude\n            }\n        };\n    }\n    else if (value instanceof Bytes) {\n        return { bytesValue: toBytes(context.serializer, value._byteString) };\n    }\n    else if (value instanceof DocumentReference) {\n        const thisDb = context.databaseId;\n        const otherDb = value.firestore._databaseId;\n        if (!otherDb.isEqual(thisDb)) {\n            throw context.createError('Document reference is for database ' +\n                `${otherDb.projectId}/${otherDb.database} but should be ` +\n                `for database ${thisDb.projectId}/${thisDb.database}`);\n        }\n        return {\n            referenceValue: toResourceName(value.firestore._databaseId || context.databaseId, value._key.path)\n        };\n    }\n    else if (value instanceof VectorValue) {\n        return parseVectorValue(value, context);\n    }\n    else if (isProtoValueSerializable(value)) {\n        return value._toProto(context.serializer);\n    }\n    else {\n        throw context.createError(`Unsupported field value: ${valueDescription(value)}`);\n    }\n}\n/**\n * Creates a new VectorValue proto value (using the internal format).\n */\nfunction parseVectorValue(value, context) {\n    const values = value instanceof VectorValue ? value.toArray() : value;\n    const mapValue = {\n        fields: {\n            [TYPE_KEY]: {\n                stringValue: VECTOR_VALUE_SENTINEL\n            },\n            [VECTOR_MAP_VECTORS_KEY]: {\n                arrayValue: {\n                    values: values.map(value => {\n                        if (typeof value !== 'number') {\n                            throw context.createError('VectorValues must only contain numeric values.');\n                        }\n                        return toDouble(context.serializer, value);\n                    })\n                }\n            }\n        }\n    };\n    return { mapValue };\n}\n/**\n * Checks whether an object looks like a JSON object that should be converted\n * into a struct. Normal class/prototype instances are considered to look like\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\n * GeoPoints, etc. are not considered to look like JSON objects since they map\n * to specific FieldValue types other than ObjectValue.\n */\nfunction looksLikeJsonObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        !(input instanceof Array) &&\n        !(input instanceof Date) &&\n        !(input instanceof Timestamp) &&\n        !(input instanceof GeoPoint) &&\n        !(input instanceof Bytes) &&\n        !(input instanceof DocumentReference) &&\n        !(input instanceof FieldValue) &&\n        !(input instanceof VectorValue) &&\n        !isProtoValueSerializable(input));\n}\nfunction validatePlainObject(message, context, input) {\n    if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\n        const description = valueDescription(input);\n        if (description === 'an object') {\n            // Massage the error if it was an object.\n            throw context.createError(message + ' a custom object');\n        }\n        else {\n            throw context.createError(message + ' ' + description);\n        }\n    }\n}\n/**\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\n */\nfunction fieldPathFromArgument(methodName, path, targetDoc) {\n    // If required, replace the FieldPath Compat class with the firestore-exp\n    // FieldPath.\n    path = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(path);\n    if (path instanceof FieldPath) {\n        return path._internalPath;\n    }\n    else if (typeof path === 'string') {\n        return fieldPathFromDotSeparatedString(methodName, path);\n    }\n    else {\n        const message = 'Field path arguments must be of type string or ';\n        throw createError(message, methodName, \n        /* hasConverter= */ false, \n        /* path= */ undefined, targetDoc);\n    }\n}\n/**\n * Matches any characters in a field path string that are reserved.\n */\nconst FIELD_PATH_RESERVED = new RegExp('[~\\\\*/\\\\[\\\\]]');\n/**\n * Wraps fromDotSeparatedString with an error message about the method that\n * was thrown.\n * @param methodName - The publicly visible method name\n * @param path - The dot-separated string form of a field path which will be\n * split on dots.\n * @param targetDoc - The document against which the field path will be\n * evaluated.\n */\nfunction fieldPathFromDotSeparatedString(methodName, path, targetDoc) {\n    const found = path.search(FIELD_PATH_RESERVED);\n    if (found >= 0) {\n        throw createError(`Invalid field path (${path}). Paths must not contain ` +\n            `'~', '*', '/', '[', or ']'`, methodName, \n        /* hasConverter= */ false, \n        /* path= */ undefined, targetDoc);\n    }\n    try {\n        return new FieldPath(...path.split('.'))._internalPath;\n    }\n    catch (e) {\n        throw createError(`Invalid field path (${path}). Paths must not be empty, ` +\n            `begin with '.', end with '.', or contain '..'`, methodName, \n        /* hasConverter= */ false, \n        /* path= */ undefined, targetDoc);\n    }\n}\nfunction createError(reason, methodName, hasConverter, path, targetDoc) {\n    const hasPath = path && !path.isEmpty();\n    const hasDocument = targetDoc !== undefined;\n    let message = `Function ${methodName}() called with invalid data`;\n    if (hasConverter) {\n        message += ' (via `toFirestore()`)';\n    }\n    message += '. ';\n    let description = '';\n    if (hasPath || hasDocument) {\n        description += ' (found';\n        if (hasPath) {\n            description += ` in field ${path}`;\n        }\n        if (hasDocument) {\n            description += ` in document ${targetDoc}`;\n        }\n        description += ')';\n    }\n    return new FirestoreError(Code.INVALID_ARGUMENT, message + reason + description);\n}\n/** Checks `haystack` if FieldPath `needle` is present. Runs in O(n). */\nfunction fieldMaskContains(haystack, needle) {\n    return haystack.some(v => v.isEqual(needle));\n}\nfunction isUserData(value) {\n    return typeof value._readUserData === 'function';\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Converts Firestore's internal types to the JavaScript types that we expose\n * to the user.\n *\n * @internal\n */\nclass AbstractUserDataWriter {\n    convertValue(value, serverTimestampBehavior = 'none') {\n        switch (typeOrder(value)) {\n            case 0 /* TypeOrder.NullValue */:\n                return null;\n            case 1 /* TypeOrder.BooleanValue */:\n                return value.booleanValue;\n            case 2 /* TypeOrder.NumberValue */:\n                return normalizeNumber(value.integerValue || value.doubleValue);\n            case 3 /* TypeOrder.TimestampValue */:\n                return this.convertTimestamp(value.timestampValue);\n            case 4 /* TypeOrder.ServerTimestampValue */:\n                return this.convertServerTimestamp(value, serverTimestampBehavior);\n            case 5 /* TypeOrder.StringValue */:\n                return value.stringValue;\n            case 6 /* TypeOrder.BlobValue */:\n                return this.convertBytes(normalizeByteString(value.bytesValue));\n            case 7 /* TypeOrder.RefValue */:\n                return this.convertReference(value.referenceValue);\n            case 8 /* TypeOrder.GeoPointValue */:\n                return this.convertGeoPoint(value.geoPointValue);\n            case 9 /* TypeOrder.ArrayValue */:\n                return this.convertArray(value.arrayValue, serverTimestampBehavior);\n            case 11 /* TypeOrder.ObjectValue */:\n                return this.convertObject(value.mapValue, serverTimestampBehavior);\n            case 10 /* TypeOrder.VectorValue */:\n                return this.convertVectorValue(value.mapValue);\n            default:\n                throw fail(0xf2a2, {\n                    value\n                });\n        }\n    }\n    convertObject(mapValue, serverTimestampBehavior) {\n        return this.convertObjectMap(mapValue.fields, serverTimestampBehavior);\n    }\n    /**\n     * @internal\n     */\n    convertObjectMap(fields, serverTimestampBehavior = 'none') {\n        const result = {};\n        forEach(fields, (key, value) => {\n            result[key] = this.convertValue(value, serverTimestampBehavior);\n        });\n        return result;\n    }\n    /**\n     * @internal\n     */\n    convertVectorValue(mapValue) {\n        const values = mapValue.fields?.[VECTOR_MAP_VECTORS_KEY].arrayValue?.values?.map(value => {\n            return normalizeNumber(value.doubleValue);\n        });\n        return new VectorValue(values);\n    }\n    convertGeoPoint(value) {\n        return new GeoPoint(normalizeNumber(value.latitude), normalizeNumber(value.longitude));\n    }\n    convertArray(arrayValue, serverTimestampBehavior) {\n        return (arrayValue.values || []).map(value => this.convertValue(value, serverTimestampBehavior));\n    }\n    convertServerTimestamp(value, serverTimestampBehavior) {\n        switch (serverTimestampBehavior) {\n            case 'previous':\n                const previousValue = getPreviousValue(value);\n                if (previousValue == null) {\n                    return null;\n                }\n                return this.convertValue(previousValue, serverTimestampBehavior);\n            case 'estimate':\n                return this.convertTimestamp(getLocalWriteTime(value));\n            default:\n                return null;\n        }\n    }\n    convertTimestamp(value) {\n        const normalizedValue = normalizeTimestamp(value);\n        return new Timestamp(normalizedValue.seconds, normalizedValue.nanos);\n    }\n    convertDocumentKey(name, expectedDatabaseId) {\n        const resourcePath = ResourcePath.fromString(name);\n        hardAssert(isValidResourceName(resourcePath), 0x25d8, { name });\n        const databaseId = new DatabaseId(resourcePath.get(1), resourcePath.get(3));\n        const key = new DocumentKey(resourcePath.popFirst(5));\n        if (!databaseId.isEqual(expectedDatabaseId)) {\n            // TODO(b/64130202): Somehow support foreign references.\n            logError(`Document ${key} contains a document ` +\n                `reference within a different database (` +\n                `${databaseId.projectId}/${databaseId.database}) which is not ` +\n                `supported. It will be treated as a reference in the current ` +\n                `database (${expectedDatabaseId.projectId}/${expectedDatabaseId.database}) ` +\n                `instead.`);\n        }\n        return key;\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass ExpUserDataWriter extends AbstractUserDataWriter {\n    constructor(firestore) {\n        super();\n        this.firestore = firestore;\n    }\n    convertBytes(bytes) {\n        return new Bytes(bytes);\n    }\n    convertReference(name) {\n        const key = this.convertDocumentKey(name, this.firestore._databaseId);\n        return new DocumentReference(this.firestore, /* converter= */ null, key);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a sentinel for use with {@link @firebase/firestore/lite#(updateDoc:1)} or\n * {@link @firebase/firestore/lite#(setDoc:1)} with `{merge: true}` to mark a field for deletion.\n */\nfunction deleteField() {\n    return new DeleteFieldValueImpl('deleteField');\n}\n/**\n * Returns a sentinel used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link @firebase/firestore/lite#(updateDoc:1)} to\n * include a server-generated timestamp in the written data.\n */\nfunction serverTimestamp() {\n    return new ServerTimestampFieldValueImpl('serverTimestamp');\n}\n/**\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to union the given elements with any array\n * value that already exists on the server. Each specified element that doesn't\n * already exist in the array will be added to the end. If the field being\n * modified is not already an array it will be overwritten with an array\n * containing exactly the specified elements.\n *\n * @param elements - The elements to union into the array.\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\n * `updateDoc()`.\n */\nfunction arrayUnion(...elements) {\n    // NOTE: We don't actually parse the data until it's used in set() or\n    // update() since we'd need the Firestore instance to do this.\n    return new ArrayUnionFieldValueImpl('arrayUnion', elements);\n}\n/**\n * Returns a special value that can be used with {@link (setDoc:1)} or {@link\n * updateDoc:1} that tells the server to remove the given elements from any\n * array value that already exists on the server. All instances of each element\n * specified will be removed from the array. If the field being modified is not\n * already an array it will be overwritten with an empty array.\n *\n * @param elements - The elements to remove from the array.\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\n * `updateDoc()`\n */\nfunction arrayRemove(...elements) {\n    // NOTE: We don't actually parse the data until it's used in set() or\n    // update() since we'd need the Firestore instance to do this.\n    return new ArrayRemoveFieldValueImpl('arrayRemove', elements);\n}\n/**\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to increment the field's current value by\n * the given value.\n *\n * If either the operand or the current field value uses floating point\n * precision, all arithmetic follows IEEE 754 semantics. If both values are\n * integers, values outside of JavaScript's safe number range\n * (`Number.MIN_SAFE_INTEGER` to `Number.MAX_SAFE_INTEGER`) are also subject to\n * precision loss. Furthermore, once processed by the Firestore backend, all\n * integer operations are capped between -2^63 and 2^63-1.\n *\n * If the current field value is not of type `number`, or if the field does not\n * yet exist, the transformation sets the field to the given value.\n *\n * @param n - The value to increment by.\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\n * `updateDoc()`\n */\nfunction increment(n) {\n    return new NumericIncrementFieldValueImpl('increment', n);\n}\n/**\n * Creates a new `VectorValue` constructed with a copy of the given array of numbers.\n *\n * @param values - Create a `VectorValue` instance with a copy of this array of numbers.\n *\n * @returns A new `VectorValue` constructed with a copy of the given array of numbers.\n */\nfunction vector(values) {\n    return new VectorValue(values);\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass OptionsUtil {\n    constructor(optionDefinitions) {\n        this.optionDefinitions = optionDefinitions;\n    }\n    _getKnownOptions(options, context) {\n        const knownOptions = ObjectValue.empty();\n        // SERIALIZE KNOWN OPTIONS\n        for (const knownOptionKey in this.optionDefinitions) {\n            if (this.optionDefinitions.hasOwnProperty(knownOptionKey)) {\n                const optionDefinition = this.optionDefinitions[knownOptionKey];\n                if (knownOptionKey in options) {\n                    const optionValue = options[knownOptionKey];\n                    let protoValue = undefined;\n                    if (optionDefinition.nestedOptions && isPlainObject(optionValue)) {\n                        const nestedUtil = new OptionsUtil(optionDefinition.nestedOptions);\n                        protoValue = {\n                            mapValue: {\n                                fields: nestedUtil.getOptionsProto(context, optionValue)\n                            }\n                        };\n                    }\n                    else if (optionValue) {\n                        protoValue = parseData(optionValue, context) ?? undefined;\n                    }\n                    if (protoValue) {\n                        knownOptions.set(FieldPath$1.fromServerFormat(optionDefinition.serverName), protoValue);\n                    }\n                }\n            }\n        }\n        return knownOptions;\n    }\n    getOptionsProto(context, knownOptions, optionsOverride) {\n        const result = this._getKnownOptions(knownOptions, context);\n        // APPLY OPTIONS OVERRIDES\n        if (optionsOverride) {\n            const optionsMap = new Map(mapToArray(optionsOverride, (value, key) => [\n                FieldPath$1.fromServerFormat(key),\n                value !== undefined ? parseData(value, context) : null\n            ]));\n            result.setAll(optionsMap);\n        }\n        // Return MapValue from `result` or empty map value\n        return result.value.mapValue.fields ?? {};\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass StructuredPipelineOptions {\n    constructor(_userOptions = {}, _optionsOverride = {}) {\n        this._userOptions = _userOptions;\n        this._optionsOverride = _optionsOverride;\n        this.optionsUtil = new OptionsUtil({\n            indexMode: {\n                serverName: 'index_mode'\n            }\n        });\n    }\n    _readUserData(context) {\n        this.proto = this.optionsUtil.getOptionsProto(context, this._userOptions, this._optionsOverride);\n    }\n}\nclass StructuredPipeline {\n    constructor(pipeline, options) {\n        this.pipeline = pipeline;\n        this.options = options;\n    }\n    _toProto(serializer) {\n        return {\n            pipeline: this.pipeline._toProto(serializer),\n            options: this.options.proto\n        };\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @internal\n * @private\n *\n * This function is for internal use only.\n *\n * Returns the `QueryTarget` representation of the given query. Returns `null`\n * if the Firestore client associated with the given query has not been\n * initialized or has been terminated.\n *\n * @param query - The Query to convert to proto representation.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _internalQueryToProtoQueryTarget(query) {\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const serializer = client._onlineComponents?.datastore.serializer;\n    if (serializer === undefined) {\n        return null;\n    }\n    return toQueryTarget(serializer, queryToTarget(query._query)).queryTarget;\n}\n/**\n * @internal\n * @private\n *\n * This function is for internal use only.\n *\n * Returns `RunAggregationQueryRequest` which contains the proto representation\n * of the given aggregation query request. Returns null if the Firestore client\n * associated with the given query has not been initialized or has been\n * terminated.\n *\n * @param query - The Query to convert to proto representation.\n * @param aggregateSpec - The set of aggregations and their aliases.\n */\nfunction _internalAggregationQueryToProtoRunAggregationQueryRequest(query, aggregateSpec) {\n    const aggregates = mapToArray(aggregateSpec, (aggregate, alias) => {\n        return new AggregateImpl(alias, aggregate.aggregateType, aggregate._internalFieldPath);\n    });\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const serializer = client._onlineComponents?.datastore.serializer;\n    if (serializer === undefined) {\n        return null;\n    }\n    return toRunAggregationQueryRequest(serializer, queryToAggregateTarget(query._query), aggregates, \n    /* skipAliasing= */ true).request;\n}\n/**\n * @internal\n * @private\n *\n * This function is for internal use only.\n *\n * Returns the `ExecutePipelineRequest` representation of the given query.\n * Returns `null` if the Firestore client associated with the given query has\n * not been initialized or has been terminated.\n *\n * @param pipeline - The Pipeline to convert to proto representation.\n */\nfunction _internalPipelineToExecutePipelineRequestProto(pipeline\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    const firestore = cast(pipeline._db, Firestore);\n    const datastore = getDatastore(firestore);\n    const serializer = datastore.serializer;\n    if (serializer === undefined) {\n        return null;\n    }\n    const structuredPipeline = new StructuredPipeline(pipeline, new StructuredPipelineOptions());\n    const executePipelineRequest = {\n        database: getEncodedDatabaseId(serializer),\n        structuredPipeline: structuredPipeline._toProto(serializer)\n    };\n    return executePipelineRequest;\n}\n\n\n//# sourceMappingURL=common-270e6a50.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BmaXJlYmFzZStmaXJlc3RvcmVANC4xMS4wX0BmaXJlYmFzZSthcHBAMC4xNC44L25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZmlyZXN0b3JlL2Rpc3QvY29tbW9uLTI3MGU2YTUwLm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1HO0FBQzZKO0FBQ3pMO0FBQ25CO0FBQ0s7QUFDSDtBQUNoQjtBQUNZOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZDQUFPLFVBQVUsWUFBWTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQVE7QUFDdEM7QUFDQSxzQ0FBc0MsWUFBWSxLQUFLLElBQUk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNEQUFRO0FBQ3RDO0FBQ0Esc0NBQXNDLFlBQVksS0FBSyxJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzREFBUTtBQUN0QztBQUNBLHFDQUFxQyxZQUFZLEtBQUssSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVksK0JBQStCLFNBQVMsT0FBTyxnQkFBZ0I7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlEQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVUsVUFBVSxVQUFVLEtBQUssYUFBYTtBQUNqRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsV0FBVztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsWUFBWTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUVBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDBDQUEwQywwQkFBMEI7QUFDOUo7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG1DQUFtQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxnQkFBZ0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsYUFBYTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1EQUFhO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0RUFBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLEtBQUs7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLEtBQUs7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxhQUFhLG9DQUFvQyxhQUFhO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYSxNQUFNLGFBQWE7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFKQUFxSixNQUFNLE1BQU0sWUFBWTtBQUM3SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0pBQXdKLE1BQU0sTUFBTSxZQUFZO0FBQ2hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsaUJBQWlCLGlCQUFpQixZQUFZO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxhQUFhLDZDQUE2QyxFQUFFO0FBQ2hJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxlQUFlO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCwyQkFBMkI7QUFDaEY7QUFDQSx5REFBeUQsSUFBSTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLElBQUksY0FBYyxXQUFXO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxJQUFJLG9CQUFvQixZQUFZO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnSEFBZ0g7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsdUJBQXVCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQXVEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUIsTUFBTSwyQkFBMkIsS0FBSyw4QkFBOEIsWUFBWSxHQUFHLE9BQU8sYUFBYTtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseURBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9FQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscURBQUs7QUFDeEI7QUFDQSwwQ0FBMEMsV0FBVyxnQkFBZ0I7QUFDckU7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFEQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxXQUFXLFlBQVksTUFBTTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFEQUFLO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLFVBQVU7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsbUJBQW1CO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxnQkFBZ0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxVQUFVO0FBQ2xFO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE1BQU07QUFDNUM7QUFDQSx1R0FBdUcsTUFBTTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsRUFBRSxHQUFHLEVBQUU7QUFDeEM7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCLEVBQUUseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0RBQXNELFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFxRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQ0FBK0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZDQUE2QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCLEdBQUcsMEJBQTBCO0FBQzVFO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCLEdBQUcsbUJBQW1CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUksR0FBRyxvQ0FBb0M7QUFDaEU7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCLGFBQWEsb0JBQW9CLGFBQWEsMkJBQTJCO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2Qyx3QkFBd0IsNkNBQTZDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHdEQUF3RCxrQkFBa0I7QUFDMUU7QUFDQSxtQ0FBbUMsY0FBYyxtQkFBbUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQ0FBb0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pELGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVMsSUFBSSxhQUFhLElBQUksZ0NBQWdDO0FBQzFGLGNBQWMsY0FBYyxpQkFBaUI7QUFDN0MsY0FBYyxnQkFBZ0IsbUJBQW1CO0FBQ2pELGNBQWMsaUJBQWlCLG9CQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQ0FBaUMsR0FBRyxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVSxHQUFHLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjLGdDQUFnQyxFQUFFLFdBQVcsRUFBRSwwQkFBMEI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QseUJBQXlCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0IsSUFBSSxnREFBZ0Q7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0IsSUFBSSxnREFBZ0Q7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQixJQUFJLGdEQUFnRDtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtCQUFrQixJQUFJLGdEQUFnRDtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFDQUFxQyxNQUFNLGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0EsMkJBQTJCLHdDQUF3QyxZQUFZLGdCQUFnQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEtBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDLGtCQUFrQjtBQUNsQixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2Q0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2Q0FBVztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw0RUFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0VBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0RUFBTztBQUNoQyx5QkFBeUIsNEVBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxRQUFRO0FBQ25FO0FBQ0E7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsUUFBUTtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNEVBQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0RUFBTztBQUN0RDtBQUNBO0FBQ0EsNEJBQTRCLDRFQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx5Q0FBeUM7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxlQUFlO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSwwQkFBMEIsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHFCQUFxQjtBQUNsRSw4QkFBOEIsb0JBQW9CO0FBQ2xELDhCQUE4QiwyQkFBMkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQixHQUFHLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsMEJBQTBCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsOEJBQThCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZLDJCQUEyQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWSwyQkFBMkI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVksNEJBQTRCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxPQUFPO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQ0FBa0M7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esc0VBQXNFLElBQUk7QUFDMUU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQSx1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFDQUFxQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdFQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDJCQUEyQixhQUFhLHVCQUF1QjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0NBQStDLHdCQUF3QjtBQUN2RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBaUQ7QUFDeEU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBaUQ7QUFDeEU7QUFDQSxxRUFBcUUsYUFBYTtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdFQUFnRTtBQUN2RjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLE9BQU87QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSw0R0FBNEcsa0NBQWtDO0FBQzlJO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkNBQTZDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsTUFBTTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGFBQWEsV0FBVztBQUNyRywrQ0FBK0MseUNBQXlDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDZDQUE2QztBQUN0Riw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQyxzREFBUTtBQUN6QztBQUNBLDRDQUE0QywyQkFBMkI7QUFDdkUsd0RBQXdELDBCQUEwQjtBQUNsRix1QkFBdUIscUNBQXFDO0FBQzVELGlDQUFpQyxnQkFBZ0I7QUFDakQsdUJBQXVCLHFDQUFxQztBQUM1RCxpQ0FBaUMsa0JBQWtCO0FBQ25ELHVCQUF1QixzQ0FBc0M7QUFDN0QsdUNBQXVDLDZCQUE2QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5QkFBeUIsc0JBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdEQUFnRDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZDQUE2QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsWUFBWTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWMsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0VBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySCwwQkFBMEI7QUFDcko7QUFDQSwyRkFBMkY7QUFDM0YscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsK0dBQStHLGNBQWM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkdBQTZHLGNBQWM7QUFDM0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxSEFBcUgsY0FBYztBQUNuSTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEZBQTBGLGNBQWM7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0lBQWtJLGVBQWU7QUFDako7QUFDQTtBQUNBLEtBQUs7QUFDTCx3R0FBd0csZUFBZTtBQUN2SDtBQUNBO0FBQ0EsS0FBSztBQUNMLGtHQUFrRyxlQUFlO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFJQUFxSSxlQUFlO0FBQ3BKLHVJQUF1SSxlQUFlO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhDQUE4QyxtQ0FBbUM7QUFDakY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwrRUFBK0UsT0FBTztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGNBQWMsSUFBSSxjQUFjO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsSUFBSSw2QkFBNkI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCLEdBQUcsb0JBQW9CLEdBQUcsU0FBUztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdDQUF3QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixTQUFTLElBQUksRUFBRTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLFdBQVc7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQVE7QUFDaEI7QUFDQTtBQUNBLCtCQUErQixxREFBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNEQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QixHQUFHLGVBQWUsR0FBRyxTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMEJBQTBCLEdBQUcsZUFBZSxHQUFHLFFBQVE7QUFDaEY7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0IsR0FBRyxlQUFlLEdBQUcsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCLEdBQUcsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUIsR0FBRyxlQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkJBQTJCLEdBQUcsZUFBZTtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFFBQVEsS0FBSyxNQUFNO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFNBQVMsS0FBSyxNQUFNO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQXFEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFNBQVMsS0FBSyxNQUFNO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLE1BQU07QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx3QkFBd0IsR0FBRyxzQkFBc0I7QUFDaEcsaURBQWlELDBCQUEwQixHQUFHLHNCQUFzQjtBQUNwRywrQ0FBK0Msd0JBQXdCLEdBQUcsc0JBQXNCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsdUJBQXVCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsV0FBVztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QixPQUFPLGFBQWEsT0FBTyxZQUFZO0FBQ3pHO0FBQ0E7QUFDQSx5QkFBeUIsbURBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0NBQWtDLGFBQWEsaUNBQWlDO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBZ0I7QUFDbEMsa0JBQWtCLHNEQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0Esd0NBQXdDLFFBQVEsSUFBSSxVQUFVO0FBQzlEO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUSxJQUFJLFVBQVU7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVEsSUFBSSxVQUFVO0FBQ3RFO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUSxJQUFJLFVBQVU7QUFDMUQ7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUyxFQUFFLFVBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0NBQXdDLFFBQVEsSUFBSSxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0NBQXdDLFFBQVEsSUFBSSxVQUFVO0FBQzlEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUSxXQUFXLFVBQVU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVEsV0FBVyxVQUFVO0FBQzdFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0Q0FBNEMsUUFBUSxXQUFXLFVBQVU7QUFDekU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSxXQUFXLFVBQVU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3Q0FBd0MsUUFBUSxXQUFXLFVBQVU7QUFDckU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJDQUEyQyxRQUFRLFdBQVcsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNENBQTRDLFFBQVEsV0FBVyxVQUFVO0FBQ3pFLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJDQUEyQztBQUNyRixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNkNBQTZDLEVBQUUsY0FBYztBQUN2RyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZDQUE2QyxFQUFFLGNBQWM7QUFDckY7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9EQUFvRDtBQUNoRztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvREFBb0Q7QUFDOUU7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyQ0FBMkM7QUFDeEY7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJDQUEyQztBQUN4RTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0NBQXdDO0FBQ25GO0FBQ0EsK0RBQStELDZDQUE2QztBQUM1RztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQXdDO0FBQ2pFO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQTZDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHdDQUF3QztBQUNuRjtBQUNBLCtEQUErRCw2Q0FBNkM7QUFDNUc7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUE2QztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHdDQUF3QztBQUNuRjtBQUNBLCtEQUErRCw2Q0FBNkM7QUFDNUc7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUE2QztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0NBQXdDO0FBQ25GO0FBQ0EsK0RBQStELDZDQUE2QztBQUM1RztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3Q0FBd0M7QUFDakU7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBNkM7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDJDQUEyQyxFQUFFLGNBQWM7QUFDdEc7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJDQUEyQyxFQUFFLGNBQWM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3REFBb0I7QUFDbEQsV0FBVyxnRUFBMEI7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtCQUFrQjtBQUNyRSxnQ0FBZ0Msb0JBQW9CO0FBQ3BELHNDQUFzQywwQkFBMEI7QUFDaEUsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE1BQU07QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsZ0NBQWdDO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSwyQkFBMkI7QUFDeEcsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxRQUFRO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usc0NBQXNDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSSxJQUFJLEVBQUU7QUFDckM7QUFDQSx1REFBdUQsSUFBSSxJQUFJLEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUNBQXFDO0FBQ2hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLCtCQUErQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw0Q0FBNEM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnREFBZ0Q7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkNBQTZDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywrQ0FBK0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtDQUErQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsRUFBRTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1QsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSUFBZ0kseUJBQXlCO0FBQ3pKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUNBQWlDO0FBQ2hEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixRQUFRO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixPQUFPO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLDZCQUE2QjtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1IO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBLDZGQUE2Rix3QkFBd0I7QUFDckgsNkNBQTZDLGlDQUFpQztBQUM5RTtBQUNBO0FBQ0EsNkZBQTZGLHdCQUF3QjtBQUNySCw2Q0FBNkMsaUNBQWlDO0FBQzlFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1QkFBdUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBLG1CQUFtQixrRUFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixLQUFLLEdBQUcsS0FBSztBQUMzQztBQUNBLGFBQWEsMERBQVUsWUFBWSxlQUFlO0FBQ2xELFFBQVEsb0VBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtRUFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrRUFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixhQUFhO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0VBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QixZQUFZLGtFQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWtCO0FBQzdCLFlBQVksa0VBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlCQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHVCQUF1QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQSxJQUFJLHVCQUF1QjtBQUMzQiwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0EscUJBQXFCLGlDQUFpQyxnQkFBZ0IsaUJBQWlCO0FBQ3ZGO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyREFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxZQUFZLHlEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsNkJBQTZCO0FBQ3hIO0FBQ0E7QUFDQSx5QkFBeUIsa0VBQWtCO0FBQzNDLGFBQWEsMERBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdFQUF3RSxxREFBTTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJEQUFZO0FBQzNCO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCLGlGQUFpQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEIsR0FBRyx3QkFBd0I7QUFDckUsSUFBSSxnQ0FBZ0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQSxzREFBc0Q7QUFDdEQsd0JBQXdCLElBQUksdUJBQXVCLFlBQVk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlCQUFpQjtBQUM1RCxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVCQUF1QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsbUJBQW1CO0FBQ25GO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxRQUFRLHNCQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsc0JBQXNCO0FBQ3pGO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hELFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHlCQUF5QjtBQUMvRjtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRCxRQUFRLHNCQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxvQ0FBb0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNDQUFzQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNDQUFzQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBLGtDQUFrQyxxQ0FBcUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFVBQVU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUJBQWlCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlCQUFpQjtBQUMxRCxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFdBQVc7QUFDL0U7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtFQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0VBQWtCO0FBQzlCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQzFELGdDQUFnQyxpQkFBaUIsR0FBRyxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHdCQUF3QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3QztBQUNBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLE1BQU07QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBLG1CQUFtQixxQkFBcUIsR0FBRyxvQkFBb0I7QUFDL0Q7QUFDQSw2QkFBNkIsNkJBQTZCLEdBQUcsNEJBQTRCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDhDQUE4QztBQUNsRixJQUFJLDJDQUEyQyxPQUFPLFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQ0FBMkMsSUFBSSw4Q0FBOEM7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDJDQUEyQyxJQUFJO0FBQ2pHLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCLElBQUk7QUFDeEUsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMkNBQTJDLElBQUk7QUFDakcsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdW9IO0FBQ3ZvSCIsInNvdXJjZXMiOlsiL1VzZXJzL3Rob21hc2h1bGloYW4vUHJvamVjdHMvVFJSL1RSUi1BUFAvbm9kZV9tb2R1bGVzLy5wbnBtL0BmaXJlYmFzZStmaXJlc3RvcmVANC4xMS4wX0BmaXJlYmFzZSthcHBAMC4xNC44L25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZmlyZXN0b3JlL2Rpc3QvY29tbW9uLTI3MGU2YTUwLm5vZGUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9nZXRQcm92aWRlciwgZ2V0QXBwLCBfcmVtb3ZlU2VydmljZUluc3RhbmNlLCBfaXNGaXJlYmFzZVNlcnZlckFwcCB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciwgaXNDbG91ZFdvcmtzdGF0aW9uLCBwaW5nU2VydmVyLCB1cGRhdGVFbXVsYXRvckJhbm5lciwgZGVlcEVxdWFsLCBjcmVhdGVNb2NrVXNlclRva2VuLCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCwgZ2V0R2xvYmFsLCBpc0luZGV4ZWREQkF2YWlsYWJsZSwgZ2V0VUEsIGlzU2FmYXJpLCBpc1NhZmFyaU9yV2Via2l0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgSW50ZWdlciwgTWQ1IH0gZnJvbSAnQGZpcmViYXNlL3dlYmNoYW5uZWwtd3JhcHBlci9ibG9vbS1ibG9iJztcbmltcG9ydCB7IExvZ2dlciwgTG9nTGV2ZWwgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcbmltcG9ydCB7IFRleHRFbmNvZGVyLCBpbnNwZWN0LCBUZXh0RGVjb2RlciB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgYXMgcmFuZG9tQnl0ZXMkMSB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgKiBhcyBncnBjIGZyb20gJ0BncnBjL2dycGMtanMnO1xuaW1wb3J0ICogYXMgcHJvdG9Mb2FkZXIgZnJvbSAnQGdycGMvcHJvdG8tbG9hZGVyJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogU2ltcGxlIHdyYXBwZXIgYXJvdW5kIGEgbnVsbGFibGUgVUlELiBNb3N0bHkgZXhpc3RzIHRvIG1ha2UgY29kZSBtb3JlXG4gKiByZWFkYWJsZS5cbiAqL1xuY2xhc3MgVXNlciB7XG4gICAgY29uc3RydWN0b3IodWlkKSB7XG4gICAgICAgIHRoaXMudWlkID0gdWlkO1xuICAgIH1cbiAgICBpc0F1dGhlbnRpY2F0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpZCAhPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEga2V5IHJlcHJlc2VudGluZyB0aGlzIHVzZXIsIHN1aXRhYmxlIGZvciBpbmNsdXNpb24gaW4gYVxuICAgICAqIGRpY3Rpb25hcnkuXG4gICAgICovXG4gICAgdG9LZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3VpZDonICsgdGhpcy51aWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Fub255bW91cy11c2VyJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyVXNlcikge1xuICAgICAgICByZXR1cm4gb3RoZXJVc2VyLnVpZCA9PT0gdGhpcy51aWQ7XG4gICAgfVxufVxuLyoqIEEgdXNlciB3aXRoIGEgbnVsbCBVSUQuICovXG5Vc2VyLlVOQVVUSEVOVElDQVRFRCA9IG5ldyBVc2VyKG51bGwpO1xuLy8gVE9ETyhtaWtlbGVoZW4pOiBMb29rIGludG8gZ2V0dGluZyBhIHByb3BlciB1aWQtZXF1aXZhbGVudCBmb3Jcbi8vIG5vbi1GaXJlYmFzZUF1dGggcHJvdmlkZXJzLlxuVXNlci5HT09HTEVfQ1JFREVOVElBTFMgPSBuZXcgVXNlcignZ29vZ2xlLWNyZWRlbnRpYWxzLXVpZCcpO1xuVXNlci5GSVJTVF9QQVJUWSA9IG5ldyBVc2VyKCdmaXJzdC1wYXJ0eS11aWQnKTtcblVzZXIuTU9DS19VU0VSID0gbmV3IFVzZXIoJ21vY2stdXNlcicpO1xuXG5jb25zdCB2ZXJzaW9uID0gXCIxMi45LjBcIjtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmxldCBTREtfVkVSU0lPTiA9IHZlcnNpb247XG5mdW5jdGlvbiBzZXRTREtWZXJzaW9uKHZlcnNpb24pIHtcbiAgICBTREtfVkVSU0lPTiA9IHZlcnNpb247XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogRm9ybWF0cyBhbiBvYmplY3QgYXMgYSBKU09OIHN0cmluZywgc3VpdGFibGUgZm9yIGxvZ2dpbmcuICovXG5mdW5jdGlvbiBmb3JtYXRKU09OKHZhbHVlKSB7XG4gICAgLy8gdXRpbC5pbnNwZWN0KCkgcmVzdWx0cyBpbiBtdWNoIG1vcmUgcmVhZGFibGUgb3V0cHV0IHRoYW4gSlNPTi5zdHJpbmdpZnkoKVxuICAgIHJldHVybiBpbnNwZWN0KHZhbHVlLCB7IGRlcHRoOiAxMDAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBsb2dDbGllbnQgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvZmlyZXN0b3JlJyk7XG4vLyBIZWxwZXIgbWV0aG9kcyBhcmUgbmVlZGVkIGJlY2F1c2UgdmFyaWFibGVzIGNhbid0IGJlIGV4cG9ydGVkIGFzIHJlYWQvd3JpdGVcbmZ1bmN0aW9uIGdldExvZ0xldmVsKCkge1xuICAgIHJldHVybiBsb2dDbGllbnQubG9nTGV2ZWw7XG59XG4vKipcbiAqIFNldHMgdGhlIHZlcmJvc2l0eSBvZiBDbG91ZCBGaXJlc3RvcmUgbG9ncyAoZGVidWcsIGVycm9yLCBvciBzaWxlbnQpLlxuICpcbiAqIEBwYXJhbSBsb2dMZXZlbCAtIFRoZSB2ZXJib3NpdHkgeW91IHNldCBmb3IgYWN0aXZpdHkgYW5kIGVycm9yIGxvZ2dpbmcuIENhblxuICogICBiZSBhbnkgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gKlxuICogICA8dWw+XG4gKiAgICAgPGxpPmBkZWJ1Z2AgZm9yIHRoZSBtb3N0IHZlcmJvc2UgbG9nZ2luZyBsZXZlbCwgcHJpbWFyaWx5IGZvclxuICogICAgIGRlYnVnZ2luZy48L2xpPlxuICogICAgIDxsaT5gZXJyb3JgIHRvIGxvZyBlcnJvcnMgb25seS48L2xpPlxuICogICAgIDxsaT48Y29kZT5gc2lsZW50YCB0byB0dXJuIG9mZiBsb2dnaW5nLjwvbGk+XG4gKiAgIDwvdWw+XG4gKi9cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XG4gICAgbG9nQ2xpZW50LnNldExvZ0xldmVsKGxvZ0xldmVsKTtcbn1cbmZ1bmN0aW9uIGxvZ0RlYnVnKG1zZywgLi4ub2JqKSB7XG4gICAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5ERUJVRykge1xuICAgICAgICBjb25zdCBhcmdzID0gb2JqLm1hcChhcmdUb1N0cmluZyk7XG4gICAgICAgIGxvZ0NsaWVudC5kZWJ1ZyhgRmlyZXN0b3JlICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxvZ0Vycm9yKG1zZywgLi4ub2JqKSB7XG4gICAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5FUlJPUikge1xuICAgICAgICBjb25zdCBhcmdzID0gb2JqLm1hcChhcmdUb1N0cmluZyk7XG4gICAgICAgIGxvZ0NsaWVudC5lcnJvcihgRmlyZXN0b3JlICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGxvZ1dhcm4obXNnLCAuLi5vYmopIHtcbiAgICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLldBUk4pIHtcbiAgICAgICAgY29uc3QgYXJncyA9IG9iai5tYXAoYXJnVG9TdHJpbmcpO1xuICAgICAgICBsb2dDbGllbnQud2FybihgRmlyZXN0b3JlICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgYW4gYWRkaXRpb25hbCBsb2cgcGFyYW1ldGVyIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICovXG5mdW5jdGlvbiBhcmdUb1N0cmluZyhvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0SlNPTihvYmopO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0aW5nIHRvIEpTT04gZmFpbGVkLCBqdXN0IGxvZyB0aGUgb2JqZWN0IGRpcmVjdGx5XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZmFpbChpZCwgbWVzc2FnZU9yQ29udGV4dCwgY29udGV4dCkge1xuICAgIGxldCBtZXNzYWdlID0gJ1VuZXhwZWN0ZWQgc3RhdGUnO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZU9yQ29udGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VPckNvbnRleHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb250ZXh0ID0gbWVzc2FnZU9yQ29udGV4dDtcbiAgICB9XG4gICAgX2ZhaWwoaWQsIG1lc3NhZ2UsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gX2ZhaWwoaWQsIGZhaWx1cmUsIGNvbnRleHQpIHtcbiAgICAvLyBMb2cgdGhlIGZhaWx1cmUgaW4gYWRkaXRpb24gdG8gdGhyb3cgYW4gZXhjZXB0aW9uLCBqdXN0IGluIGNhc2UgdGhlXG4gICAgLy8gZXhjZXB0aW9uIGlzIHN3YWxsb3dlZC5cbiAgICBsZXQgbWVzc2FnZSA9IGBGSVJFU1RPUkUgKCR7U0RLX1ZFUlNJT059KSBJTlRFUk5BTCBBU1NFUlRJT04gRkFJTEVEOiAke2ZhaWx1cmV9IChJRDogJHtpZC50b1N0cmluZygxNil9KWA7XG4gICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nQ29udGV4dCA9IEpTT04uc3RyaW5naWZ5KGNvbnRleHQpO1xuICAgICAgICAgICAgbWVzc2FnZSArPSAnIENPTlRFWFQ6ICcgKyBzdHJpbmdDb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9ICcgQ09OVEVYVDogJyArIGNvbnRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9nRXJyb3IobWVzc2FnZSk7XG4gICAgLy8gTk9URTogV2UgZG9uJ3QgdXNlIEZpcmVzdG9yZUVycm9yIGhlcmUgYmVjYXVzZSB0aGVzZSBhcmUgaW50ZXJuYWwgZmFpbHVyZXNcbiAgICAvLyB0aGF0IGNhbm5vdCBiZSBoYW5kbGVkIGJ5IHRoZSB1c2VyLiAoQWxzbyBpdCB3b3VsZCBjcmVhdGUgYSBjaXJjdWxhclxuICAgIC8vIGRlcGVuZGVuY3kgYmV0d2VlbiB0aGUgZXJyb3IgYW5kIGFzc2VydCBtb2R1bGVzIHdoaWNoIGRvZXNuJ3Qgd29yay4pXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gaGFyZEFzc2VydChhc3NlcnRpb24sIGlkLCBtZXNzYWdlT3JDb250ZXh0LCBjb250ZXh0KSB7XG4gICAgbGV0IG1lc3NhZ2UgPSAnVW5leHBlY3RlZCBzdGF0ZSc7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlT3JDb250ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBtZXNzYWdlID0gbWVzc2FnZU9yQ29udGV4dDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnRleHQgPSBtZXNzYWdlT3JDb250ZXh0O1xuICAgIH1cbiAgICBpZiAoIWFzc2VydGlvbikge1xuICAgICAgICBfZmFpbChpZCwgbWVzc2FnZSwgY29udGV4dCk7XG4gICAgfVxufVxuLyoqXG4gKiBGYWlscyBpZiB0aGUgZ2l2ZW4gYXNzZXJ0aW9uIGNvbmRpdGlvbiBpcyBmYWxzZSwgdGhyb3dpbmcgYW4gRXJyb3Igd2l0aCB0aGVcbiAqIGdpdmVuIG1lc3NhZ2UgaWYgaXQgZGlkLlxuICpcbiAqIFRoZSBjb2RlIG9mIGNhbGxzaXRlcyBpbnZva2luZyB0aGlzIGZ1bmN0aW9uIGFyZSBzdHJpcHBlZCBvdXQgaW4gcHJvZHVjdGlvblxuICogYnVpbGRzLiBBbnkgc2lkZS1lZmZlY3RzIG9mIGNvZGUgd2l0aGluIHRoZSBkZWJ1Z0Fzc2VydCgpIGludm9jYXRpb24gd2lsbCBub3RcbiAqIGhhcHBlbiBpbiB0aGlzIGNhc2UuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGRlYnVnQXNzZXJ0KGFzc2VydGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghYXNzZXJ0aW9uKSB7XG4gICAgICAgIGZhaWwoMHhkZWI2LCBtZXNzYWdlKTtcbiAgICB9XG59XG4vKipcbiAqIENhc3RzIGBvYmpgIHRvIGBUYC4gSW4gbm9uLXByb2R1Y3Rpb24gYnVpbGRzLCB2ZXJpZmllcyB0aGF0IGBvYmpgIGlzIGFuXG4gKiBpbnN0YW5jZSBvZiBgVGAgYmVmb3JlIGNhc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIGRlYnVnQ2FzdChvYmosIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IENvZGUgPSB7XG4gICAgLy8gQ2F1c2VzIGFyZSBjb3BpZWQgZnJvbTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvYmNlZWM5NGVhNGZjNWYwMDg1ZDgxMjM1ZDhlMWMwNjc5OGRjMzQxYS9pbmNsdWRlL2dycGMlMkIlMkIvaW1wbC9jb2RlZ2VuL3N0YXR1c19jb2RlX2VudW0uaFxuICAgIC8qKiBOb3QgYW4gZXJyb3I7IHJldHVybmVkIG9uIHN1Y2Nlc3MuICovXG4gICAgT0s6ICdvaycsXG4gICAgLyoqIFRoZSBvcGVyYXRpb24gd2FzIGNhbmNlbGxlZCAodHlwaWNhbGx5IGJ5IHRoZSBjYWxsZXIpLiAqL1xuICAgIENBTkNFTExFRDogJ2NhbmNlbGxlZCcsXG4gICAgLyoqIFVua25vd24gZXJyb3Igb3IgYW4gZXJyb3IgZnJvbSBhIGRpZmZlcmVudCBlcnJvciBkb21haW4uICovXG4gICAgVU5LTk9XTjogJ3Vua25vd24nLFxuICAgIC8qKlxuICAgICAqIENsaWVudCBzcGVjaWZpZWQgYW4gaW52YWxpZCBhcmd1bWVudC4gTm90ZSB0aGF0IHRoaXMgZGlmZmVycyBmcm9tXG4gICAgICogRkFJTEVEX1BSRUNPTkRJVElPTi4gSU5WQUxJRF9BUkdVTUVOVCBpbmRpY2F0ZXMgYXJndW1lbnRzIHRoYXQgYXJlXG4gICAgICogcHJvYmxlbWF0aWMgcmVnYXJkbGVzcyBvZiB0aGUgc3RhdGUgb2YgdGhlIHN5c3RlbSAoZS5nLiwgYSBtYWxmb3JtZWQgZmlsZVxuICAgICAqIG5hbWUpLlxuICAgICAqL1xuICAgIElOVkFMSURfQVJHVU1FTlQ6ICdpbnZhbGlkLWFyZ3VtZW50JyxcbiAgICAvKipcbiAgICAgKiBEZWFkbGluZSBleHBpcmVkIGJlZm9yZSBvcGVyYXRpb24gY291bGQgY29tcGxldGUuIEZvciBvcGVyYXRpb25zIHRoYXRcbiAgICAgKiBjaGFuZ2UgdGhlIHN0YXRlIG9mIHRoZSBzeXN0ZW0sIHRoaXMgZXJyb3IgbWF5IGJlIHJldHVybmVkIGV2ZW4gaWYgdGhlXG4gICAgICogb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBGb3IgZXhhbXBsZSwgYSBzdWNjZXNzZnVsIHJlc3BvbnNlXG4gICAgICogZnJvbSBhIHNlcnZlciBjb3VsZCBoYXZlIGJlZW4gZGVsYXllZCBsb25nIGVub3VnaCBmb3IgdGhlIGRlYWRsaW5lIHRvXG4gICAgICogZXhwaXJlLlxuICAgICAqL1xuICAgIERFQURMSU5FX0VYQ0VFREVEOiAnZGVhZGxpbmUtZXhjZWVkZWQnLFxuICAgIC8qKiBTb21lIHJlcXVlc3RlZCBlbnRpdHkgKGUuZy4sIGZpbGUgb3IgZGlyZWN0b3J5KSB3YXMgbm90IGZvdW5kLiAqL1xuICAgIE5PVF9GT1VORDogJ25vdC1mb3VuZCcsXG4gICAgLyoqXG4gICAgICogU29tZSBlbnRpdHkgdGhhdCB3ZSBhdHRlbXB0ZWQgdG8gY3JlYXRlIChlLmcuLCBmaWxlIG9yIGRpcmVjdG9yeSkgYWxyZWFkeVxuICAgICAqIGV4aXN0cy5cbiAgICAgKi9cbiAgICBBTFJFQURZX0VYSVNUUzogJ2FscmVhZHktZXhpc3RzJyxcbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbGVyIGRvZXMgbm90IGhhdmUgcGVybWlzc2lvbiB0byBleGVjdXRlIHRoZSBzcGVjaWZpZWQgb3BlcmF0aW9uLlxuICAgICAqIFBFUk1JU1NJT05fREVOSUVEIG11c3Qgbm90IGJlIHVzZWQgZm9yIHJlamVjdGlvbnMgY2F1c2VkIGJ5IGV4aGF1c3RpbmdcbiAgICAgKiBzb21lIHJlc291cmNlICh1c2UgUkVTT1VSQ0VfRVhIQVVTVEVEIGluc3RlYWQgZm9yIHRob3NlIGVycm9ycykuXG4gICAgICogUEVSTUlTU0lPTl9ERU5JRUQgbXVzdCBub3QgYmUgdXNlZCBpZiB0aGUgY2FsbGVyIGNhbm5vdCBiZSBpZGVudGlmaWVkXG4gICAgICogKHVzZSBVTkFVVEhFTlRJQ0FURUQgaW5zdGVhZCBmb3IgdGhvc2UgZXJyb3JzKS5cbiAgICAgKi9cbiAgICBQRVJNSVNTSU9OX0RFTklFRDogJ3Blcm1pc3Npb24tZGVuaWVkJyxcbiAgICAvKipcbiAgICAgKiBUaGUgcmVxdWVzdCBkb2VzIG5vdCBoYXZlIHZhbGlkIGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGZvciB0aGVcbiAgICAgKiBvcGVyYXRpb24uXG4gICAgICovXG4gICAgVU5BVVRIRU5USUNBVEVEOiAndW5hdXRoZW50aWNhdGVkJyxcbiAgICAvKipcbiAgICAgKiBTb21lIHJlc291cmNlIGhhcyBiZWVuIGV4aGF1c3RlZCwgcGVyaGFwcyBhIHBlci11c2VyIHF1b3RhLCBvciBwZXJoYXBzIHRoZVxuICAgICAqIGVudGlyZSBmaWxlIHN5c3RlbSBpcyBvdXQgb2Ygc3BhY2UuXG4gICAgICovXG4gICAgUkVTT1VSQ0VfRVhIQVVTVEVEOiAncmVzb3VyY2UtZXhoYXVzdGVkJyxcbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb24gd2FzIHJlamVjdGVkIGJlY2F1c2UgdGhlIHN5c3RlbSBpcyBub3QgaW4gYSBzdGF0ZSByZXF1aXJlZCBmb3JcbiAgICAgKiB0aGUgb3BlcmF0aW9uJ3MgZXhlY3V0aW9uLiBGb3IgZXhhbXBsZSwgZGlyZWN0b3J5IHRvIGJlIGRlbGV0ZWQgbWF5IGJlXG4gICAgICogbm9uLWVtcHR5LCBhbiBybWRpciBvcGVyYXRpb24gaXMgYXBwbGllZCB0byBhIG5vbi1kaXJlY3RvcnksIGV0Yy5cbiAgICAgKlxuICAgICAqIEEgbGl0bXVzIHRlc3QgdGhhdCBtYXkgaGVscCBhIHNlcnZpY2UgaW1wbGVtZW50b3IgaW4gZGVjaWRpbmdcbiAgICAgKiBiZXR3ZWVuIEZBSUxFRF9QUkVDT05ESVRJT04sIEFCT1JURUQsIGFuZCBVTkFWQUlMQUJMRTpcbiAgICAgKiAgKGEpIFVzZSBVTkFWQUlMQUJMRSBpZiB0aGUgY2xpZW50IGNhbiByZXRyeSBqdXN0IHRoZSBmYWlsaW5nIGNhbGwuXG4gICAgICogIChiKSBVc2UgQUJPUlRFRCBpZiB0aGUgY2xpZW50IHNob3VsZCByZXRyeSBhdCBhIGhpZ2hlci1sZXZlbFxuICAgICAqICAgICAgKGUuZy4sIHJlc3RhcnRpbmcgYSByZWFkLW1vZGlmeS13cml0ZSBzZXF1ZW5jZSkuXG4gICAgICogIChjKSBVc2UgRkFJTEVEX1BSRUNPTkRJVElPTiBpZiB0aGUgY2xpZW50IHNob3VsZCBub3QgcmV0cnkgdW50aWxcbiAgICAgKiAgICAgIHRoZSBzeXN0ZW0gc3RhdGUgaGFzIGJlZW4gZXhwbGljaXRseSBmaXhlZC4gRS5nLiwgaWYgYW4gXCJybWRpclwiXG4gICAgICogICAgICBmYWlscyBiZWNhdXNlIHRoZSBkaXJlY3RvcnkgaXMgbm9uLWVtcHR5LCBGQUlMRURfUFJFQ09ORElUSU9OXG4gICAgICogICAgICBzaG91bGQgYmUgcmV0dXJuZWQgc2luY2UgdGhlIGNsaWVudCBzaG91bGQgbm90IHJldHJ5IHVubGVzc1xuICAgICAqICAgICAgdGhleSBoYXZlIGZpcnN0IGZpeGVkIHVwIHRoZSBkaXJlY3RvcnkgYnkgZGVsZXRpbmcgZmlsZXMgZnJvbSBpdC5cbiAgICAgKiAgKGQpIFVzZSBGQUlMRURfUFJFQ09ORElUSU9OIGlmIHRoZSBjbGllbnQgcGVyZm9ybXMgY29uZGl0aW9uYWxcbiAgICAgKiAgICAgIFJFU1QgR2V0L1VwZGF0ZS9EZWxldGUgb24gYSByZXNvdXJjZSBhbmQgdGhlIHJlc291cmNlIG9uIHRoZVxuICAgICAqICAgICAgc2VydmVyIGRvZXMgbm90IG1hdGNoIHRoZSBjb25kaXRpb24uIEUuZy4sIGNvbmZsaWN0aW5nXG4gICAgICogICAgICByZWFkLW1vZGlmeS13cml0ZSBvbiB0aGUgc2FtZSByZXNvdXJjZS5cbiAgICAgKi9cbiAgICBGQUlMRURfUFJFQ09ORElUSU9OOiAnZmFpbGVkLXByZWNvbmRpdGlvbicsXG4gICAgLyoqXG4gICAgICogVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZCwgdHlwaWNhbGx5IGR1ZSB0byBhIGNvbmN1cnJlbmN5IGlzc3VlIGxpa2VcbiAgICAgKiBzZXF1ZW5jZXIgY2hlY2sgZmFpbHVyZXMsIHRyYW5zYWN0aW9uIGFib3J0cywgZXRjLlxuICAgICAqXG4gICAgICogU2VlIGxpdG11cyB0ZXN0IGFib3ZlIGZvciBkZWNpZGluZyBiZXR3ZWVuIEZBSUxFRF9QUkVDT05ESVRJT04sIEFCT1JURUQsXG4gICAgICogYW5kIFVOQVZBSUxBQkxFLlxuICAgICAqL1xuICAgIEFCT1JURUQ6ICdhYm9ydGVkJyxcbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb24gd2FzIGF0dGVtcHRlZCBwYXN0IHRoZSB2YWxpZCByYW5nZS4gRS5nLiwgc2Vla2luZyBvciByZWFkaW5nXG4gICAgICogcGFzdCBlbmQgb2YgZmlsZS5cbiAgICAgKlxuICAgICAqIFVubGlrZSBJTlZBTElEX0FSR1VNRU5ULCB0aGlzIGVycm9yIGluZGljYXRlcyBhIHByb2JsZW0gdGhhdCBtYXkgYmUgZml4ZWRcbiAgICAgKiBpZiB0aGUgc3lzdGVtIHN0YXRlIGNoYW5nZXMuIEZvciBleGFtcGxlLCBhIDMyLWJpdCBmaWxlIHN5c3RlbSB3aWxsXG4gICAgICogZ2VuZXJhdGUgSU5WQUxJRF9BUkdVTUVOVCBpZiBhc2tlZCB0byByZWFkIGF0IGFuIG9mZnNldCB0aGF0IGlzIG5vdCBpbiB0aGVcbiAgICAgKiByYW5nZSBbMCwyXjMyLTFdLCBidXQgaXQgd2lsbCBnZW5lcmF0ZSBPVVRfT0ZfUkFOR0UgaWYgYXNrZWQgdG8gcmVhZCBmcm9tXG4gICAgICogYW4gb2Zmc2V0IHBhc3QgdGhlIGN1cnJlbnQgZmlsZSBzaXplLlxuICAgICAqXG4gICAgICogVGhlcmUgaXMgYSBmYWlyIGJpdCBvZiBvdmVybGFwIGJldHdlZW4gRkFJTEVEX1BSRUNPTkRJVElPTiBhbmRcbiAgICAgKiBPVVRfT0ZfUkFOR0UuIFdlIHJlY29tbWVuZCB1c2luZyBPVVRfT0ZfUkFOR0UgKHRoZSBtb3JlIHNwZWNpZmljIGVycm9yKVxuICAgICAqIHdoZW4gaXQgYXBwbGllcyBzbyB0aGF0IGNhbGxlcnMgd2hvIGFyZSBpdGVyYXRpbmcgdGhyb3VnaCBhIHNwYWNlIGNhblxuICAgICAqIGVhc2lseSBsb29rIGZvciBhbiBPVVRfT0ZfUkFOR0UgZXJyb3IgdG8gZGV0ZWN0IHdoZW4gdGhleSBhcmUgZG9uZS5cbiAgICAgKi9cbiAgICBPVVRfT0ZfUkFOR0U6ICdvdXQtb2YtcmFuZ2UnLFxuICAgIC8qKiBPcGVyYXRpb24gaXMgbm90IGltcGxlbWVudGVkIG9yIG5vdCBzdXBwb3J0ZWQvZW5hYmxlZCBpbiB0aGlzIHNlcnZpY2UuICovXG4gICAgVU5JTVBMRU1FTlRFRDogJ3VuaW1wbGVtZW50ZWQnLFxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGVycm9ycy4gTWVhbnMgc29tZSBpbnZhcmlhbnRzIGV4cGVjdGVkIGJ5IHVuZGVybHlpbmcgU3lzdGVtIGhhc1xuICAgICAqIGJlZW4gYnJva2VuLiBJZiB5b3Ugc2VlIG9uZSBvZiB0aGVzZSBlcnJvcnMsIFNvbWV0aGluZyBpcyB2ZXJ5IGJyb2tlbi5cbiAgICAgKi9cbiAgICBJTlRFUk5BTDogJ2ludGVybmFsJyxcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmljZSBpcyBjdXJyZW50bHkgdW5hdmFpbGFibGUuIFRoaXMgaXMgYSBtb3N0IGxpa2VseSBhIHRyYW5zaWVudFxuICAgICAqIGNvbmRpdGlvbiBhbmQgbWF5IGJlIGNvcnJlY3RlZCBieSByZXRyeWluZyB3aXRoIGEgYmFja29mZi5cbiAgICAgKlxuICAgICAqIFNlZSBsaXRtdXMgdGVzdCBhYm92ZSBmb3IgZGVjaWRpbmcgYmV0d2VlbiBGQUlMRURfUFJFQ09ORElUSU9OLCBBQk9SVEVELFxuICAgICAqIGFuZCBVTkFWQUlMQUJMRS5cbiAgICAgKi9cbiAgICBVTkFWQUlMQUJMRTogJ3VuYXZhaWxhYmxlJyxcbiAgICAvKiogVW5yZWNvdmVyYWJsZSBkYXRhIGxvc3Mgb3IgY29ycnVwdGlvbi4gKi9cbiAgICBEQVRBX0xPU1M6ICdkYXRhLWxvc3MnXG59O1xuLyoqIEFuIGVycm9yIHJldHVybmVkIGJ5IGEgRmlyZXN0b3JlIG9wZXJhdGlvbi4gKi9cbmNsYXNzIEZpcmVzdG9yZUVycm9yIGV4dGVuZHMgRmlyZWJhc2VFcnJvciB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgYmFja2VuZCBlcnJvciBjb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGVycm9yLlxuICAgICAqL1xuICAgIGNvZGUsIFxuICAgIC8qKlxuICAgICAqIEEgY3VzdG9tIGVycm9yIGRlc2NyaXB0aW9uLlxuICAgICAqL1xuICAgIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoY29kZSwgbWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIC8vIEhBQ0s6IFdlIHdyaXRlIGEgdG9TdHJpbmcgcHJvcGVydHkgZGlyZWN0bHkgYmVjYXVzZSBFcnJvciBpcyBub3QgYSByZWFsXG4gICAgICAgIC8vIGNsYXNzIGFuZCBzbyBpbmhlcml0YW5jZSBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseS4gV2UgY291bGQgYWx0ZXJuYXRpdmVseVxuICAgICAgICAvLyBkbyB0aGUgc2FtZSBcImJhY2stZG9vciBpbmhlcml0YW5jZVwiIHRyaWNrIHRoYXQgRmlyZWJhc2VFcnJvciBkb2VzLlxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4gYCR7dGhpcy5uYW1lfTogW2NvZGU9JHt0aGlzLmNvZGV9XTogJHt0aGlzLm1lc3NhZ2V9YDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBEZWZlcnJlZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgT0F1dGhUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHVzZXIpIHtcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcbiAgICAgICAgdGhpcy50eXBlID0gJ09BdXRoJztcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgYEJlYXJlciAke3ZhbHVlfWApO1xuICAgIH1cbn1cbi8qKlxuICogQSBDcmVkZW50aWFsc1Byb3ZpZGVyIHRoYXQgYWx3YXlzIHlpZWxkcyBhbiBlbXB0eSB0b2tlbi5cbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBFbXB0eUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIHtcbiAgICBnZXRUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZVRva2VuKCkgeyB9XG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgLy8gRmlyZSB3aXRoIGluaXRpYWwgdXNlci5cbiAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IGNoYW5nZUxpc3RlbmVyKFVzZXIuVU5BVVRIRU5USUNBVEVEKSk7XG4gICAgfVxuICAgIHNodXRkb3duKCkgeyB9XG59XG4vKipcbiAqIEEgQ3JlZGVudGlhbHNQcm92aWRlciB0aGF0IGFsd2F5cyByZXR1cm5zIGEgY29uc3RhbnQgdG9rZW4uIFVzZWQgZm9yXG4gKiBlbXVsYXRvciB0b2tlbiBtb2NraW5nLlxuICovXG5jbGFzcyBFbXVsYXRvckF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbikge1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIGxpc3RlbmVyIHJlZ2lzdGVyZWQgd2l0aCBzZXRDaGFuZ2VMaXN0ZW5lcigpXG4gICAgICAgICAqIFRoaXMgaXNuJ3QgYWN0dWFsbHkgbmVjZXNzYXJ5IHNpbmNlIHRoZSBVSUQgbmV2ZXIgY2hhbmdlcywgYnV0IHdlIHVzZSB0aGlzXG4gICAgICAgICAqIHRvIHZlcmlmeSB0aGUgbGlzdGVuIGNvbnRyYWN0IGlzIGFkaGVyZWQgdG8gaW4gdGVzdHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5nZUxpc3RlbmVyID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0VG9rZW4oKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy50b2tlbik7XG4gICAgfVxuICAgIGludmFsaWRhdGVUb2tlbigpIHsgfVxuICAgIHN0YXJ0KGFzeW5jUXVldWUsIGNoYW5nZUxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIgPSBjaGFuZ2VMaXN0ZW5lcjtcbiAgICAgICAgLy8gRmlyZSB3aXRoIGluaXRpYWwgdXNlci5cbiAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IGNoYW5nZUxpc3RlbmVyKHRoaXMudG9rZW4udXNlcikpO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IG51bGw7XG4gICAgfVxufVxuY2xhc3MgRmlyZWJhc2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoYXV0aFByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyID0gYXV0aFByb3ZpZGVyO1xuICAgICAgICAvKiogVHJhY2tzIHRoZSBjdXJyZW50IFVzZXIuICovXG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSBVc2VyLlVOQVVUSEVOVElDQVRFRDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50ZXIgdXNlZCB0byBkZXRlY3QgaWYgdGhlIHRva2VuIGNoYW5nZWQgd2hpbGUgYSBnZXRUb2tlbiByZXF1ZXN0IHdhc1xuICAgICAgICAgKiBvdXRzdGFuZGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG9rZW5Db3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdXRoID0gbnVsbDtcbiAgICB9XG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgaGFyZEFzc2VydCh0aGlzLnRva2VuTGlzdGVuZXIgPT09IHVuZGVmaW5lZCwgMHhhNTQwKTtcbiAgICAgICAgbGV0IGxhc3RUb2tlbklkID0gdGhpcy50b2tlbkNvdW50ZXI7XG4gICAgICAgIC8vIEEgY2hhbmdlIGxpc3RlbmVyIHRoYXQgcHJldmVudHMgZG91YmxlLWZpcmluZyBmb3IgdGhlIHNhbWUgdG9rZW4gY2hhbmdlLlxuICAgICAgICBjb25zdCBndWFyZGVkQ2hhbmdlTGlzdGVuZXIgPSB1c2VyID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuQ291bnRlciAhPT0gbGFzdFRva2VuSWQpIHtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW5JZCA9IHRoaXMudG9rZW5Db3VudGVyO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2VMaXN0ZW5lcih1c2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQSBwcm9taXNlIHRoYXQgY2FuIGJlIHdhaXRlZCBvbiB0byBibG9jayBvbiB0aGUgbmV4dCB0b2tlbiBjaGFuZ2UuXG4gICAgICAgIC8vIFRoaXMgcHJvbWlzZSBpcyByZS1jcmVhdGVkIGFmdGVyIGVhY2ggY2hhbmdlLlxuICAgICAgICBsZXQgbmV4dFRva2VuID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMudG9rZW5MaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5Db3VudGVyKys7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gdGhpcy5nZXRVc2VyKCk7XG4gICAgICAgICAgICBuZXh0VG9rZW4ucmVzb2x2ZSgpO1xuICAgICAgICAgICAgbmV4dFRva2VuID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gZ3VhcmRlZENoYW5nZUxpc3RlbmVyKHRoaXMuY3VycmVudFVzZXIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXdhaXROZXh0VG9rZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VG9rZW5BdHRlbXB0ID0gbmV4dFRva2VuO1xuICAgICAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjdXJyZW50VG9rZW5BdHRlbXB0LnByb21pc2U7XG4gICAgICAgICAgICAgICAgYXdhaXQgZ3VhcmRlZENoYW5nZUxpc3RlbmVyKHRoaXMuY3VycmVudFVzZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyQXV0aCA9IChhdXRoKSA9PiB7XG4gICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlcicsICdBdXRoIGRldGVjdGVkJyk7XG4gICAgICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5MaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0aC5hZGRBdXRoVG9rZW5MaXN0ZW5lcih0aGlzLnRva2VuTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIGF3YWl0TmV4dFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyLm9uSW5pdChhdXRoID0+IHJlZ2lzdGVyQXV0aChhdXRoKSk7XG4gICAgICAgIC8vIE91ciB1c2VycyBjYW4gaW5pdGlhbGl6ZSBBdXRoIHJpZ2h0IGFmdGVyIEZpcmVzdG9yZSwgc28gd2UgZ2l2ZSBpdFxuICAgICAgICAvLyBhIGNoYW5jZSB0byByZWdpc3RlciBpdHNlbGYgd2l0aCB0aGUgY29tcG9uZW50IGZyYW1ld29yayBiZWZvcmUgd2VcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gc3RhcnQgdXAgaW4gdW5hdXRoZW50aWNhdGVkIG1vZGUuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmF1dGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdXRoID0gdGhpcy5hdXRoUHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGF1dGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJBdXRoKGF1dGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYXV0aCBpcyBzdGlsbCBub3QgYXZhaWxhYmxlLCBwcm9jZWVkIHdpdGggYG51bGxgIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoJ0ZpcmViYXNlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXInLCAnQXV0aCBub3QgeWV0IGRldGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbi5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbiA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGF3YWl0TmV4dFRva2VuKCk7XG4gICAgfVxuICAgIGdldFRva2VuKCkge1xuICAgICAgICAvLyBUYWtlIG5vdGUgb2YgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHRva2VuQ291bnRlciBzbyB0aGF0IHRoaXMgbWV0aG9kXG4gICAgICAgIC8vIGNhbiBmYWlsICh3aXRoIGFuIEFCT1JURUQgZXJyb3IpIGlmIHRoZXJlIGlzIGEgdG9rZW4gY2hhbmdlIHdoaWxlIHRoZVxuICAgICAgICAvLyByZXF1ZXN0IGlzIG91dHN0YW5kaW5nLlxuICAgICAgICBjb25zdCBpbml0aWFsVG9rZW5Db3VudGVyID0gdGhpcy50b2tlbkNvdW50ZXI7XG4gICAgICAgIGNvbnN0IGZvcmNlUmVmcmVzaCA9IHRoaXMuZm9yY2VSZWZyZXNoO1xuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuYXV0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hdXRoLmdldFRva2VuKGZvcmNlUmVmcmVzaCkudGhlbih0b2tlbkRhdGEgPT4ge1xuICAgICAgICAgICAgLy8gQ2FuY2VsIHRoZSByZXF1ZXN0IHNpbmNlIHRoZSB0b2tlbiBjaGFuZ2VkIHdoaWxlIHRoZSByZXF1ZXN0IHdhc1xuICAgICAgICAgICAgLy8gb3V0c3RhbmRpbmcgc28gdGhlIHJlc3BvbnNlIGlzIHBvdGVudGlhbGx5IGZvciBhIHByZXZpb3VzIHVzZXIgKHdoaWNoXG4gICAgICAgICAgICAvLyB1c2VyLCB3ZSBjYW4ndCBiZSBzdXJlKS5cbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuQ291bnRlciAhPT0gaW5pdGlhbFRva2VuQ291bnRlcikge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdGaXJlYmFzZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyJywgJ2dldFRva2VuIGFib3J0ZWQgZHVlIHRvIHRva2VuIGNoYW5nZS4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KHR5cGVvZiB0b2tlbkRhdGEuYWNjZXNzVG9rZW4gPT09ICdzdHJpbmcnLCAweDdjNWQsIHsgdG9rZW5EYXRhIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9BdXRoVG9rZW4odG9rZW5EYXRhLmFjY2Vzc1Rva2VuLCB0aGlzLmN1cnJlbnRVc2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGludmFsaWRhdGVUb2tlbigpIHtcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2ggPSB0cnVlO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0aCAmJiB0aGlzLnRva2VuTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aC5yZW1vdmVBdXRoVG9rZW5MaXN0ZW5lcih0aGlzLnRva2VuTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9rZW5MaXN0ZW5lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gQXV0aC5nZXRVaWQoKSBjYW4gcmV0dXJuIG51bGwgZXZlbiB3aXRoIGEgdXNlciBsb2dnZWQgaW4uIEl0IGlzIGJlY2F1c2VcbiAgICAvLyBnZXRVaWQoKSBpcyBzeW5jaHJvbm91cywgYnV0IHRoZSBhdXRoIGNvZGUgcG9wdWxhdGluZyBVaWQgaXMgYXN5bmNocm9ub3VzLlxuICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpbiB0aGUgQXV0aFRva2VuTGlzdGVuZXIgY2FsbGJhY2tcbiAgICAvLyB0byBndWFyYW50ZWUgdG8gZ2V0IHRoZSBhY3R1YWwgdXNlci5cbiAgICBnZXRVc2VyKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VWlkID0gdGhpcy5hdXRoICYmIHRoaXMuYXV0aC5nZXRVaWQoKTtcbiAgICAgICAgaGFyZEFzc2VydChjdXJyZW50VWlkID09PSBudWxsIHx8IHR5cGVvZiBjdXJyZW50VWlkID09PSAnc3RyaW5nJywgMHgwODA3LCB7IGN1cnJlbnRVaWQgfSk7XG4gICAgICAgIHJldHVybiBuZXcgVXNlcihjdXJyZW50VWlkKTtcbiAgICB9XG59XG4vKlxuICogRmlyc3RQYXJ0eVRva2VuIHByb3ZpZGVzIGEgZnJlc2ggdG9rZW4gZWFjaCB0aW1lIGl0cyB2YWx1ZVxuICogaXMgcmVxdWVzdGVkLCBiZWNhdXNlIGlmIHRoZSB0b2tlbiBpcyB0b28gb2xkLCByZXF1ZXN0cyB3aWxsIGJlIHJlamVjdGVkLlxuICogVGVjaG5pY2FsbHkgdGhpcyBtYXkgbm8gbG9uZ2VyIGJlIG5lY2Vzc2FyeSBzaW5jZSB0aGUgU0RLIHNob3VsZCBncmFjZWZ1bGx5XG4gKiByZWNvdmVyIGZyb20gdW5hdXRoZW50aWNhdGVkIGVycm9ycyAoc2VlIGIvMzMxNDc4MTggZm9yIGNvbnRleHQpLCBidXQgaXQnc1xuICogc2FmZXIgdG8ga2VlcCB0aGUgaW1wbGVtZW50YXRpb24gYXMtaXMuXG4gKi9cbmNsYXNzIEZpcnN0UGFydHlUb2tlbiB7XG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbkluZGV4LCBpYW1Ub2tlbiwgYXV0aFRva2VuRmFjdG9yeSkge1xuICAgICAgICB0aGlzLnNlc3Npb25JbmRleCA9IHNlc3Npb25JbmRleDtcbiAgICAgICAgdGhpcy5pYW1Ub2tlbiA9IGlhbVRva2VuO1xuICAgICAgICB0aGlzLmF1dGhUb2tlbkZhY3RvcnkgPSBhdXRoVG9rZW5GYWN0b3J5O1xuICAgICAgICB0aGlzLnR5cGUgPSAnRmlyc3RQYXJ0eSc7XG4gICAgICAgIHRoaXMudXNlciA9IFVzZXIuRklSU1RfUEFSVFk7XG4gICAgICAgIHRoaXMuX2hlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYW4gYXV0aG9yaXphdGlvbiB0b2tlbiwgdXNpbmcgYSBwcm92aWRlZCBmYWN0b3J5IGZ1bmN0aW9uLCBvciByZXR1cm5cbiAgICAgKiBudWxsLlxuICAgICAqL1xuICAgIGdldEF1dGhUb2tlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuRmFjdG9yeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXV0aFRva2VuRmFjdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdYLUdvb2ctQXV0aFVzZXInLCB0aGlzLnNlc3Npb25JbmRleCk7XG4gICAgICAgIC8vIFVzZSBhcnJheSBub3RhdGlvbiB0byBwcmV2ZW50IG1pbmlmaWNhdGlvblxuICAgICAgICBjb25zdCBhdXRoSGVhZGVyVG9rZW5WYWx1ZSA9IHRoaXMuZ2V0QXV0aFRva2VuKCk7XG4gICAgICAgIGlmIChhdXRoSGVhZGVyVG9rZW5WYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBhdXRoSGVhZGVyVG9rZW5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWFtVG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcnMuc2V0KCdYLUdvb2ctSWFtLUF1dGhvcml6YXRpb24tVG9rZW4nLCB0aGlzLmlhbVRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVycztcbiAgICB9XG59XG4vKlxuICogUHJvdmlkZXMgdXNlciBjcmVkZW50aWFscyByZXF1aXJlZCBmb3IgdGhlIEZpcmVzdG9yZSBKYXZhU2NyaXB0IFNES1xuICogdG8gYXV0aGVudGljYXRlIHRoZSB1c2VyLCB1c2luZyB0ZWNobmlxdWUgdGhhdCBpcyBvbmx5IGF2YWlsYWJsZVxuICogdG8gYXBwbGljYXRpb25zIGhvc3RlZCBieSBHb29nbGUuXG4gKi9cbmNsYXNzIEZpcnN0UGFydHlBdXRoQ3JlZGVudGlhbHNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbkluZGV4LCBpYW1Ub2tlbiwgYXV0aFRva2VuRmFjdG9yeSkge1xuICAgICAgICB0aGlzLnNlc3Npb25JbmRleCA9IHNlc3Npb25JbmRleDtcbiAgICAgICAgdGhpcy5pYW1Ub2tlbiA9IGlhbVRva2VuO1xuICAgICAgICB0aGlzLmF1dGhUb2tlbkZhY3RvcnkgPSBhdXRoVG9rZW5GYWN0b3J5O1xuICAgIH1cbiAgICBnZXRUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgRmlyc3RQYXJ0eVRva2VuKHRoaXMuc2Vzc2lvbkluZGV4LCB0aGlzLmlhbVRva2VuLCB0aGlzLmF1dGhUb2tlbkZhY3RvcnkpKTtcbiAgICB9XG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgLy8gRmlyZSB3aXRoIGluaXRpYWwgdWlkLlxuICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gY2hhbmdlTGlzdGVuZXIoVXNlci5GSVJTVF9QQVJUWSkpO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHsgfVxuICAgIGludmFsaWRhdGVUb2tlbigpIHsgfVxufVxuY2xhc3MgQXBwQ2hlY2tUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnR5cGUgPSAnQXBwQ2hlY2snO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCd4LWZpcmViYXNlLWFwcGNoZWNrJywgdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBGaXJlYmFzZUFwcENoZWNrVG9rZW5Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoYXBwLCBhcHBDaGVja1Byb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwQ2hlY2tQcm92aWRlciA9IGFwcENoZWNrUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXBwQ2hlY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdEFwcENoZWNrVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLnNlcnZlckFwcEFwcENoZWNrVG9rZW4gPSBudWxsO1xuICAgICAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAoYXBwKSAmJiBhcHAuc2V0dGluZ3MuYXBwQ2hlY2tUb2tlbikge1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJBcHBBcHBDaGVja1Rva2VuID0gYXBwLnNldHRpbmdzLmFwcENoZWNrVG9rZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgaGFyZEFzc2VydCh0aGlzLnRva2VuTGlzdGVuZXIgPT09IHVuZGVmaW5lZCwgMHgwZGI4KTtcbiAgICAgICAgY29uc3Qgb25Ub2tlbkNoYW5nZWQgPSB0b2tlblJlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAodG9rZW5SZXN1bHQuZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdGaXJlYmFzZUFwcENoZWNrVG9rZW5Qcm92aWRlcicsIGBFcnJvciBnZXR0aW5nIEFwcCBDaGVjayB0b2tlbjsgdXNpbmcgcGxhY2Vob2xkZXIgdG9rZW4gaW5zdGVhZC4gRXJyb3I6ICR7dG9rZW5SZXN1bHQuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRva2VuVXBkYXRlZCA9IHRva2VuUmVzdWx0LnRva2VuICE9PSB0aGlzLmxhdGVzdEFwcENoZWNrVG9rZW47XG4gICAgICAgICAgICB0aGlzLmxhdGVzdEFwcENoZWNrVG9rZW4gPSB0b2tlblJlc3VsdC50b2tlbjtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdGaXJlYmFzZUFwcENoZWNrVG9rZW5Qcm92aWRlcicsIGBSZWNlaXZlZCAke3Rva2VuVXBkYXRlZCA/ICduZXcnIDogJ2V4aXN0aW5nJ30gdG9rZW4uYCk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5VcGRhdGVkXG4gICAgICAgICAgICAgICAgPyBjaGFuZ2VMaXN0ZW5lcih0b2tlblJlc3VsdC50b2tlbilcbiAgICAgICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRva2VuTGlzdGVuZXIgPSAodG9rZW5SZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiBvblRva2VuQ2hhbmdlZCh0b2tlblJlc3VsdCkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWdpc3RlckFwcENoZWNrID0gKGFwcENoZWNrKSA9PiB7XG4gICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBcHBDaGVja1Rva2VuUHJvdmlkZXInLCAnQXBwQ2hlY2sgZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2sgPSBhcHBDaGVjaztcbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcENoZWNrLmFkZFRva2VuTGlzdGVuZXIodGhpcy50b2tlbkxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcHBDaGVja1Byb3ZpZGVyLm9uSW5pdChhcHBDaGVjayA9PiByZWdpc3RlckFwcENoZWNrKGFwcENoZWNrKSk7XG4gICAgICAgIC8vIE91ciB1c2VycyBjYW4gaW5pdGlhbGl6ZSBBcHBDaGVjayBhZnRlciBGaXJlc3RvcmUsIHNvIHdlIGdpdmUgaXRcbiAgICAgICAgLy8gYSBjaGFuY2UgdG8gcmVnaXN0ZXIgaXRzZWxmIHdpdGggdGhlIGNvbXBvbmVudCBmcmFtZXdvcmsuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFwcENoZWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwQ2hlY2sgPSB0aGlzLmFwcENoZWNrUHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGFwcENoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyQXBwQ2hlY2soYXBwQ2hlY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgQXBwQ2hlY2sgaXMgc3RpbGwgbm90IGF2YWlsYWJsZSwgcHJvY2VlZCB3aXRob3V0IGl0LlxuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBcHBDaGVja1Rva2VuUHJvdmlkZXInLCAnQXBwQ2hlY2sgbm90IHlldCBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIGdldFRva2VuKCkge1xuICAgICAgICBpZiAodGhpcy5zZXJ2ZXJBcHBBcHBDaGVja1Rva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBBcHBDaGVja1Rva2VuKHRoaXMuc2VydmVyQXBwQXBwQ2hlY2tUb2tlbikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcmNlUmVmcmVzaCA9IHRoaXMuZm9yY2VSZWZyZXNoO1xuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuYXBwQ2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwQ2hlY2suZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKS50aGVuKHRva2VuUmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmICh0b2tlblJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIHRva2VuUmVzdWx0LnRva2VuID09PSAnc3RyaW5nJywgMHhhZTBlLCB7IHRva2VuUmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0QXBwQ2hlY2tUb2tlbiA9IHRva2VuUmVzdWx0LnRva2VuO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXBwQ2hlY2tUb2tlbih0b2tlblJlc3VsdC50b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGludmFsaWRhdGVUb2tlbigpIHtcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2ggPSB0cnVlO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2sgJiYgdGhpcy50b2tlbkxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrLnJlbW92ZVRva2VuTGlzdGVuZXIodGhpcy50b2tlbkxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRva2VuTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBBcHBDaGVjayB0b2tlbiBwcm92aWRlciB0aGF0IGFsd2F5cyB5aWVsZHMgYW4gZW1wdHkgdG9rZW4uXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgRW1wdHlBcHBDaGVja1Rva2VuUHJvdmlkZXIge1xuICAgIGdldFRva2VuKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBBcHBDaGVja1Rva2VuKCcnKSk7XG4gICAgfVxuICAgIGludmFsaWRhdGVUb2tlbigpIHsgfVxuICAgIHN0YXJ0KGFzeW5jUXVldWUsIGNoYW5nZUxpc3RlbmVyKSB7IH1cbiAgICBzaHV0ZG93bigpIHsgfVxufVxuLyoqXG4gKiBCdWlsZHMgYSBDcmVkZW50aWFsc1Byb3ZpZGVyIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZlxuICogdGhlIGNyZWRlbnRpYWxzIHBhc3NlZCBpbi5cbiAqL1xuZnVuY3Rpb24gbWFrZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKGNyZWRlbnRpYWxzKSB7XG4gICAgaWYgKCFjcmVkZW50aWFscykge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIoKTtcbiAgICB9XG4gICAgc3dpdGNoIChjcmVkZW50aWFsc1sndHlwZSddKSB7XG4gICAgICAgIGNhc2UgJ2ZpcnN0UGFydHknOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaXJzdFBhcnR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIoY3JlZGVudGlhbHNbJ3Nlc3Npb25JbmRleCddIHx8ICcwJywgY3JlZGVudGlhbHNbJ2lhbVRva2VuJ10gfHwgbnVsbCwgY3JlZGVudGlhbHNbJ2F1dGhUb2tlbkZhY3RvcnknXSB8fCBudWxsKTtcbiAgICAgICAgY2FzZSAncHJvdmlkZXInOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWRlbnRpYWxzWydjbGllbnQnXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdtYWtlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXIgZmFpbGVkIGR1ZSB0byBpbnZhbGlkIGNyZWRlbnRpYWwgdHlwZScpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogR2VuZXJhdGVzIGBuQnl0ZXNgIG9mIHJhbmRvbSBieXRlcy5cbiAqXG4gKiBJZiBgbkJ5dGVzIDwgMGAgLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMobkJ5dGVzKSB7XG4gICAgcmV0dXJuIHJhbmRvbUJ5dGVzJDEobkJ5dGVzKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSB1dGlsaXR5IGNsYXNzIGZvciBnZW5lcmF0aW5nIHVuaXF1ZSBhbHBoYW51bWVyaWMgSURzIG9mIGEgc3BlY2lmaWVkIGxlbmd0aC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEV4cG9ydGVkIGludGVybmFsbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gKi9cbmNsYXNzIEF1dG9JZCB7XG4gICAgc3RhdGljIG5ld0lkKCkge1xuICAgICAgICAvLyBBbHBoYW51bWVyaWMgY2hhcmFjdGVyc1xuICAgICAgICBjb25zdCBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSc7XG4gICAgICAgIC8vIFRoZSBsYXJnZXN0IGJ5dGUgdmFsdWUgdGhhdCBpcyBhIG11bHRpcGxlIG9mIGBjaGFyLmxlbmd0aGAuXG4gICAgICAgIGNvbnN0IG1heE11bHRpcGxlID0gTWF0aC5mbG9vcigyNTYgLyBjaGFycy5sZW5ndGgpICogY2hhcnMubGVuZ3RoO1xuICAgICAgICBsZXQgYXV0b0lkID0gJyc7XG4gICAgICAgIGNvbnN0IHRhcmdldExlbmd0aCA9IDIwO1xuICAgICAgICB3aGlsZSAoYXV0b0lkLmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSByYW5kb21CeXRlcyg0MCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBhY2NlcHQgdmFsdWVzIHRoYXQgYXJlIFswLCBtYXhNdWx0aXBsZSksIHRoaXMgZW5zdXJlcyB0aGV5IGNhblxuICAgICAgICAgICAgICAgIC8vIGJlIGV2ZW5seSBtYXBwZWQgdG8gaW5kaWNlcyBvZiBgY2hhcnNgIHZpYSBhIG1vZHVsbyBvcGVyYXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKGF1dG9JZC5sZW5ndGggPCB0YXJnZXRMZW5ndGggJiYgYnl0ZXNbaV0gPCBtYXhNdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICBhdXRvSWQgKz0gY2hhcnMuY2hhckF0KGJ5dGVzW2ldICUgY2hhcnMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1dG9JZDtcbiAgICB9XG59XG5mdW5jdGlvbiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPCByaWdodCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuLyoqIENvbXBhcmUgc3RyaW5ncyBpbiBVVEYtOCBlbmNvZGVkIGJ5dGUgb3JkZXIgKi9cbmZ1bmN0aW9uIGNvbXBhcmVVdGY4U3RyaW5ncyhsZWZ0LCByaWdodCkge1xuICAgIC8vIEZpbmQgdGhlIGZpcnN0IGRpZmZlcmluZyBjaGFyYWN0ZXIgKGEuay5hLiBcIlVURi0xNiBjb2RlIHVuaXRcIikgaW4gdGhlIHR3byBzdHJpbmdzIGFuZCxcbiAgICAvLyBpZiBmb3VuZCwgdXNlIHRoYXQgY2hhcmFjdGVyIHRvIGRldGVybWluZSB0aGUgcmVsYXRpdmUgb3JkZXJpbmcgb2YgdGhlIHR3byBzdHJpbmdzIGFzIGFcbiAgICAvLyB3aG9sZS4gQ29tcGFyaW5nIFVURi0xNiBzdHJpbmdzIGluIFVURi04IGJ5dGUgb3JkZXIgY2FuIGJlIGRvbmUgc2ltcGx5IGFuZCBlZmZpY2llbnRseSBieVxuICAgIC8vIGNvbXBhcmluZyB0aGUgVVRGLTE2IGNvZGUgdW5pdHMgKGNoYXJzKS4gVGhpcyBzZXJlbmRpcGl0b3VzbHkgd29ya3MgYmVjYXVzZSBvZiB0aGUgd2F5IFVURi04XG4gICAgLy8gYW5kIFVURi0xNiBoYXBwZW4gdG8gcmVwcmVzZW50IFVuaWNvZGUgY29kZSBwb2ludHMuXG4gICAgLy9cbiAgICAvLyBBZnRlciBmaW5kaW5nIHRoZSBmaXJzdCBwYWlyIG9mIGRpZmZlcmluZyBjaGFyYWN0ZXJzLCB0aGVyZSBhcmUgdHdvIGNhc2VzOlxuICAgIC8vXG4gICAgLy8gQ2FzZSAxOiBCb3RoIGNoYXJhY3RlcnMgYXJlIG5vbi1zdXJyb2dhdGVzIChjb2RlIHBvaW50cyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMHhGRkZGKSBvclxuICAgIC8vIGJvdGggYXJlIHN1cnJvZ2F0ZXMgZnJvbSBhIHN1cnJvZ2F0ZSBwYWlyICh0aGF0IGNvbGxlY3RpdmVseSByZXByZXNlbnQgY29kZSBwb2ludHMgZ3JlYXRlclxuICAgIC8vIHRoYW4gMHhGRkZGKS4gSW4gdGhpcyBjYXNlIHRoZWlyIG51bWVyaWMgb3JkZXIgYXMgVVRGLTE2IGNvZGUgdW5pdHMgaXMgdGhlIHNhbWUgYXMgdGhlXG4gICAgLy8gbGV4aWNvZ3JhcGhpY2FsIG9yZGVyIG9mIHRoZWlyIGNvcnJlc3BvbmRpbmcgVVRGLTggYnl0ZSBzZXF1ZW5jZXMuIEEgZGlyZWN0IGNvbXBhcmlzb24gaXNcbiAgICAvLyBzdWZmaWNpZW50LlxuICAgIC8vXG4gICAgLy8gQ2FzZSAyOiBPbmUgY2hhcmFjdGVyIGlzIGEgc3Vycm9nYXRlIGFuZCB0aGUgb3RoZXIgaXMgbm90LiBJbiB0aGlzIGNhc2UgdGhlIHN1cnJvZ2F0ZS1cbiAgICAvLyBjb250YWluaW5nIHN0cmluZyBpcyBhbHdheXMgb3JkZXJlZCBhZnRlciB0aGUgbm9uLXN1cnJvZ2F0ZS4gVGhpcyBpcyBiZWNhdXNlIHN1cnJvZ2F0ZXMgYXJlXG4gICAgLy8gdXNlZCB0byByZXByZXNlbnQgY29kZSBwb2ludHMgZ3JlYXRlciB0aGFuIDB4RkZGRiB3aGljaCBoYXZlIDQtYnl0ZSBVVEYtOCByZXByZXNlbnRhdGlvbnNcbiAgICAvLyBhbmQgYXJlIGxleGljb2dyYXBoaWNhbGx5IGdyZWF0ZXIgdGhhbiB0aGUgMSwgMiwgb3IgMy1ieXRlIHJlcHJlc2VudGF0aW9ucyBvZiBjb2RlIHBvaW50c1xuICAgIC8vIGxlc3MgdGhhbiBvciBlcXVhbCB0byAweEZGRkYuXG4gICAgLy9cbiAgICAvLyBBbiBleGFtcGxlIG9mIHdoeSBDYXNlIDIgaXMgcmVxdWlyZWQgaXMgY29tcGFyaW5nIHRoZSBmb2xsb3dpbmcgdHdvIFVuaWNvZGUgY29kZSBwb2ludHM6XG4gICAgLy9cbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8IE5hbWUgICAgICAgICAgICAgICAgICB8IENvZGUgUG9pbnQgfCBVVEYtOCBFbmNvZGluZyAgICAgIHwgVVRGLTE2IEVuY29kaW5nIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8IFJlcGxhY2VtZW50IENoYXJhY3RlciB8IFUrRkZGRCAgICAgfCAweEVGIDB4QkYgMHhCRCAgICAgIHwgMHhGRkZEICAgICAgICAgIHxcbiAgICAvLyB8IEdyaW5uaW5nIEZhY2UgICAgICAgICB8IFUrMUY2MDAgICAgfCAweEYwIDB4OUYgMHg5OCAweDgwIHwgMHhEODNEIDB4REUwMCAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvL1xuICAgIC8vIEEgbGV4aWNvZ3JhcGhpY2FsIGNvbXBhcmlzb24gb2YgdGhlIFVURi04IGVuY29kaW5ncyBvZiB0aGVzZSBjb2RlIHBvaW50cyB3b3VsZCBvcmRlclxuICAgIC8vIFwiUmVwbGFjZW1lbnQgQ2hhcmFjdGVyXCIgX2JlZm9yZV8gXCJHcmlubmluZyBGYWNlXCIgYmVjYXVzZSAweEVGIGlzIGxlc3MgdGhhbiAweEYwLiBIb3dldmVyLCBhXG4gICAgLy8gZGlyZWN0IGNvbXBhcmlzb24gb2YgdGhlIFVURi0xNiBjb2RlIHVuaXRzLCBhcyB3b3VsZCBiZSBkb25lIGluIGNhc2UgMSwgd291bGQgZXJyb25lb3VzbHlcbiAgICAvLyBwcm9kdWNlIHRoZSBfb3Bwb3NpdGVfIG9yZGVyaW5nLCBiZWNhdXNlIDB4RkZGRCBpcyBfZ3JlYXRlciB0aGFuXyAweEQ4M0QuIEFzIGl0IHR1cm5zIG91dCxcbiAgICAvLyB0aGlzIHJlbGF0aXZlIG9yZGVyaW5nIGhvbGRzIGZvciBhbGwgY29tcGFyaXNvbnMgb2YgVVRGLTE2IGNvZGUgcG9pbnRzIHJlcXVpcmluZyBhIHN1cnJvZ2F0ZVxuICAgIC8vIHBhaXIgd2l0aCB0aG9zZSB0aGF0IGRvIG5vdC5cbiAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbihsZWZ0Lmxlbmd0aCwgcmlnaHQubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxlZnRDaGFyID0gbGVmdC5jaGFyQXQoaSk7XG4gICAgICAgIGNvbnN0IHJpZ2h0Q2hhciA9IHJpZ2h0LmNoYXJBdChpKTtcbiAgICAgICAgaWYgKGxlZnRDaGFyICE9PSByaWdodENoYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1N1cnJvZ2F0ZShsZWZ0Q2hhcikgPT09IGlzU3Vycm9nYXRlKHJpZ2h0Q2hhcilcbiAgICAgICAgICAgICAgICA/IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdENoYXIsIHJpZ2h0Q2hhcilcbiAgICAgICAgICAgICAgICA6IGlzU3Vycm9nYXRlKGxlZnRDaGFyKVxuICAgICAgICAgICAgICAgICAgICA/IDFcbiAgICAgICAgICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2UgdGhlIGxlbmd0aHMgb2YgdGhlIHN0cmluZ3MgdG8gZGV0ZXJtaW5lIHRoZSBvdmVyYWxsIGNvbXBhcmlzb24gcmVzdWx0IHNpbmNlIGVpdGhlciB0aGVcbiAgICAvLyBzdHJpbmdzIHdlcmUgZXF1YWwgb3Igb25lIGlzIGEgcHJlZml4IG9mIHRoZSBvdGhlci5cbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0Lmxlbmd0aCwgcmlnaHQubGVuZ3RoKTtcbn1cbmNvbnN0IE1JTl9TVVJST0dBVEUkMSA9IDB4ZDgwMDtcbmNvbnN0IE1BWF9TVVJST0dBVEUkMSA9IDB4ZGZmZjtcbmZ1bmN0aW9uIGlzU3Vycm9nYXRlKHMpIHtcbiAgICBjb25zdCBjID0gcy5jaGFyQ29kZUF0KDApO1xuICAgIHJldHVybiBjID49IE1JTl9TVVJST0dBVEUkMSAmJiBjIDw9IE1BWF9TVVJST0dBVEUkMTtcbn1cbi8qKiBIZWxwZXIgdG8gY29tcGFyZSBhcnJheXMgdXNpbmcgaXNFcXVhbCgpLiAqL1xuZnVuY3Rpb24gYXJyYXlFcXVhbHMobGVmdCwgcmlnaHQsIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAobGVmdC5sZW5ndGggIT09IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0LmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IGNvbXBhcmF0b3IodmFsdWUsIHJpZ2h0W2luZGV4XSkpO1xufVxuLyoqXG4gKiBWZXJpZmllcyBlcXVhbGl0eSBmb3IgYW4gb3B0aW9uYWwgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGlzT3B0aW9uYWxFcXVhbChsZWZ0LCByaWdodCwgZXF1YWxpdHlUZXN0KSB7XG4gICAgaWYgKGxlZnQgPT09IHVuZGVmaW5lZCAmJiByaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobGVmdCA9PT0gdW5kZWZpbmVkIHx8IHJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZXF1YWxpdHlUZXN0KGxlZnQsIHJpZ2h0KTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW1tZWRpYXRlIGxleGljb2dyYXBoaWNhbGx5LWZvbGxvd2luZyBzdHJpbmcuIFRoaXMgaXMgdXNlZnVsIHRvXG4gKiBjb25zdHJ1Y3QgYW4gaW5jbHVzaXZlIHJhbmdlIGZvciBpbmRleGVkZGIgaXRlcmF0b3JzLlxuICovXG5mdW5jdGlvbiBpbW1lZGlhdGVTdWNjZXNzb3Iocykge1xuICAgIC8vIFJldHVybiB0aGUgaW5wdXQgc3RyaW5nLCB3aXRoIGFuIGFkZGl0aW9uYWwgTlVMIGJ5dGUgYXBwZW5kZWQuXG4gICAgcmV0dXJuIHMgKyAnXFwwJztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERPQ1VNRU5UX0tFWV9OQU1FID0gJ19fbmFtZV9fJztcbi8qKlxuICogUGF0aCByZXByZXNlbnRzIGFuIG9yZGVyZWQgc2VxdWVuY2Ugb2Ygc3RyaW5nIHNlZ21lbnRzLlxuICovXG5jbGFzcyBCYXNlUGF0aCB7XG4gICAgY29uc3RydWN0b3Ioc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvZmZzZXQgPiBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZhaWwoMHgwMjdkLCB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBzZWdtZW50cy5sZW5ndGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoIC0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA+IHNlZ21lbnRzLmxlbmd0aCAtIG9mZnNldCkge1xuICAgICAgICAgICAgZmFpbCgweDA2ZDIsIHtcbiAgICAgICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHNlZ21lbnRzLmxlbmd0aCAtIG9mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWdtZW50cyA9IHNlZ21lbnRzO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW5ndGg7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbjtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gQmFzZVBhdGguY29tcGFyYXRvcih0aGlzLCBvdGhlcikgPT09IDA7XG4gICAgfVxuICAgIGNoaWxkKG5hbWVPclBhdGgpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzLnNsaWNlKHRoaXMub2Zmc2V0LCB0aGlzLmxpbWl0KCkpO1xuICAgICAgICBpZiAobmFtZU9yUGF0aCBpbnN0YW5jZW9mIEJhc2VQYXRoKSB7XG4gICAgICAgICAgICBuYW1lT3JQYXRoLmZvckVhY2goc2VnbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VnbWVudHMucHVzaChuYW1lT3JQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Qoc2VnbWVudHMpO1xuICAgIH1cbiAgICAvKiogVGhlIGluZGV4IG9mIG9uZSBwYXN0IHRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIHBhdGguICovXG4gICAgbGltaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldCArIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBwb3BGaXJzdChzaXplKSB7XG4gICAgICAgIHNpemUgPSBzaXplID09PSB1bmRlZmluZWQgPyAxIDogc2l6ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0KHRoaXMuc2VnbWVudHMsIHRoaXMub2Zmc2V0ICsgc2l6ZSwgdGhpcy5sZW5ndGggLSBzaXplKTtcbiAgICB9XG4gICAgcG9wTGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0KHRoaXMuc2VnbWVudHMsIHRoaXMub2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBmaXJzdFNlZ21lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRzW3RoaXMub2Zmc2V0XTtcbiAgICB9XG4gICAgbGFzdFNlZ21lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudHNbdGhpcy5vZmZzZXQgKyBpbmRleF07XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgaXNQcmVmaXhPZihvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIubGVuZ3RoIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChpKSAhPT0gb3RoZXIuZ2V0KGkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpc0ltbWVkaWF0ZVBhcmVudE9mKHBvdGVudGlhbENoaWxkKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCArIDEgIT09IHBvdGVudGlhbENoaWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KGkpICE9PSBwb3RlbnRpYWxDaGlsZC5nZXQoaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvckVhY2goZm4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMub2Zmc2V0LCBlbmQgPSB0aGlzLmxpbWl0KCk7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgZm4odGhpcy5zZWdtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudHMuc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMubGltaXQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgMiBwYXRocyBzZWdtZW50IGJ5IHNlZ21lbnQsIHByaW9yaXRpemluZyBudW1lcmljIElEc1xuICAgICAqIChlLmcuLCBcIl9faWQxMjNfX1wiKSBpbiBudW1lcmljIGFzY2VuZGluZyBvcmRlciwgZm9sbG93ZWQgYnkgc3RyaW5nXG4gICAgICogc2VnbWVudHMgaW4gbGV4aWNvZ3JhcGhpY2FsIG9yZGVyLlxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJhdG9yKHAxLCBwMikge1xuICAgICAgICBjb25zdCBsZW4gPSBNYXRoLm1pbihwMS5sZW5ndGgsIHAyLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmlzb24gPSBCYXNlUGF0aC5jb21wYXJlU2VnbWVudHMocDEuZ2V0KGkpLCBwMi5nZXQoaSkpO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihwMS5sZW5ndGgsIHAyLmxlbmd0aCk7XG4gICAgfVxuICAgIHN0YXRpYyBjb21wYXJlU2VnbWVudHMobGhzLCByaHMpIHtcbiAgICAgICAgY29uc3QgaXNMaHNOdW1lcmljID0gQmFzZVBhdGguaXNOdW1lcmljSWQobGhzKTtcbiAgICAgICAgY29uc3QgaXNSaHNOdW1lcmljID0gQmFzZVBhdGguaXNOdW1lcmljSWQocmhzKTtcbiAgICAgICAgaWYgKGlzTGhzTnVtZXJpYyAmJiAhaXNSaHNOdW1lcmljKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGxocyBpcyBudW1lcmljXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzTGhzTnVtZXJpYyAmJiBpc1Joc051bWVyaWMpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgcmhzIGlzIG51bWVyaWNcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTGhzTnVtZXJpYyAmJiBpc1Joc051bWVyaWMpIHtcbiAgICAgICAgICAgIC8vIGJvdGggbnVtZXJpY1xuICAgICAgICAgICAgcmV0dXJuIEJhc2VQYXRoLmV4dHJhY3ROdW1lcmljSWQobGhzKS5jb21wYXJlKEJhc2VQYXRoLmV4dHJhY3ROdW1lcmljSWQocmhzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBib3RoIG5vbi1udW1lcmljXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVV0ZjhTdHJpbmdzKGxocywgcmhzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGVja3MgaWYgYSBzZWdtZW50IGlzIGEgbnVtZXJpYyBJRCAoc3RhcnRzIHdpdGggXCJfX2lkXCIgYW5kIGVuZHMgd2l0aCBcIl9fXCIpLlxuICAgIHN0YXRpYyBpc051bWVyaWNJZChzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBzZWdtZW50LnN0YXJ0c1dpdGgoJ19faWQnKSAmJiBzZWdtZW50LmVuZHNXaXRoKCdfXycpO1xuICAgIH1cbiAgICBzdGF0aWMgZXh0cmFjdE51bWVyaWNJZChzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21TdHJpbmcoc2VnbWVudC5zdWJzdHJpbmcoNCwgc2VnbWVudC5sZW5ndGggLSAyKSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHNsYXNoLXNlcGFyYXRlZCBwYXRoIGZvciBuYXZpZ2F0aW5nIHJlc291cmNlcyAoZG9jdW1lbnRzIGFuZCBjb2xsZWN0aW9ucylcbiAqIHdpdGhpbiBGaXJlc3RvcmUuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFJlc291cmNlUGF0aCBleHRlbmRzIEJhc2VQYXRoIHtcbiAgICBjb25zdHJ1Y3Qoc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2VQYXRoKHNlZ21lbnRzLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgfVxuICAgIGNhbm9uaWNhbFN0cmluZygpIHtcbiAgICAgICAgLy8gTk9URTogVGhlIGNsaWVudCBpcyBpZ25vcmFudCBvZiBhbnkgcGF0aCBzZWdtZW50cyBjb250YWluaW5nIGVzY2FwZVxuICAgICAgICAvLyBzZXF1ZW5jZXMgKGUuZy4gX19pZDEyM19fKSBhbmQganVzdCBwYXNzZXMgdGhlbSB0aHJvdWdoIHJhdyAodGhleSBleGlzdFxuICAgICAgICAvLyBmb3IgbGVnYWN5IHJlYXNvbnMgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBmcmVxdWVudGx5KS5cbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmpvaW4oJy8nKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbm9uaWNhbFN0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGF0aFxuICAgICAqIHdoZXJlIGVhY2ggcGF0aCBzZWdtZW50IGhhcyBiZWVuIGVuY29kZWQgd2l0aFxuICAgICAqIGBlbmNvZGVVUklDb21wb25lbnRgLlxuICAgICAqL1xuICAgIHRvVXJpRW5jb2RlZFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLm1hcChlbmNvZGVVUklDb21wb25lbnQpLmpvaW4oJy8nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlc291cmNlIHBhdGggZnJvbSB0aGUgZ2l2ZW4gc2xhc2gtZGVsaW1pdGVkIHN0cmluZy4gSWYgbXVsdGlwbGVcbiAgICAgKiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCBhbGwgY29tcG9uZW50cyBhcmUgY29tYmluZWQuIExlYWRpbmcgYW5kIHRyYWlsaW5nXG4gICAgICogc2xhc2hlcyBmcm9tIGFsbCBjb21wb25lbnRzIGFyZSBpZ25vcmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU3RyaW5nKC4uLnBhdGhDb21wb25lbnRzKSB7XG4gICAgICAgIC8vIE5PVEU6IFRoZSBjbGllbnQgaXMgaWdub3JhbnQgb2YgYW55IHBhdGggc2VnbWVudHMgY29udGFpbmluZyBlc2NhcGVcbiAgICAgICAgLy8gc2VxdWVuY2VzIChlLmcuIF9faWQxMjNfXykgYW5kIGp1c3QgcGFzc2VzIHRoZW0gdGhyb3VnaCByYXcgKHRoZXkgZXhpc3RcbiAgICAgICAgLy8gZm9yIGxlZ2FjeSByZWFzb25zIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgZnJlcXVlbnRseSkuXG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRoQ29tcG9uZW50cykge1xuICAgICAgICAgICAgaWYgKHBhdGguaW5kZXhPZignLy8nKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgc2VnbWVudCAoJHtwYXRofSkuIFBhdGhzIG11c3Qgbm90IGNvbnRhaW4gLy8gaW4gdGhlbS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZWQuXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKC4uLnBhdGguc3BsaXQoJy8nKS5maWx0ZXIoc2VnbWVudCA9PiBzZWdtZW50Lmxlbmd0aCA+IDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlUGF0aChzZWdtZW50cyk7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eVBhdGgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2VQYXRoKFtdKTtcbiAgICB9XG59XG5jb25zdCBpZGVudGlmaWVyUmVnRXhwID0gL15bX2EtekEtWl1bX2EtekEtWjAtOV0qJC87XG4vKipcbiAqIEEgZG90LXNlcGFyYXRlZCBwYXRoIGZvciBuYXZpZ2F0aW5nIHN1Yi1vYmplY3RzIHdpdGhpbiBhIGRvY3VtZW50LlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIEZpZWxkUGF0aCQxIGV4dGVuZHMgQmFzZVBhdGgge1xuICAgIGNvbnN0cnVjdChzZWdtZW50cywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgkMShzZWdtZW50cywgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBjb3VsZCBiZSB1c2VkIGFzIGEgc2VnbWVudCBpbiBhIGZpZWxkIHBhdGhcbiAgICAgKiB3aXRob3V0IGVzY2FwaW5nLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1ZhbGlkSWRlbnRpZmllcihzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyUmVnRXhwLnRlc3Qoc2VnbWVudCk7XG4gICAgfVxuICAgIGNhbm9uaWNhbFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpXG4gICAgICAgICAgICAubWFwKHN0ciA9PiB7XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9gL2csICdcXFxcYCcpO1xuICAgICAgICAgICAgaWYgKCFGaWVsZFBhdGgkMS5pc1ZhbGlkSWRlbnRpZmllcihzdHIpKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJ2AnICsgc3RyICsgJ2AnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcuJyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZmllbGQgcmVmZXJlbmNlcyB0aGUga2V5IG9mIGEgZG9jdW1lbnQuXG4gICAgICovXG4gICAgaXNLZXlGaWVsZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMuZ2V0KDApID09PSBET0NVTUVOVF9LRVlfTkFNRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpZWxkIGRlc2lnbmF0aW5nIHRoZSBrZXkgb2YgYSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMga2V5RmllbGQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRQYXRoJDEoW0RPQ1VNRU5UX0tFWV9OQU1FXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGZpZWxkIHN0cmluZyBmcm9tIHRoZSBnaXZlbiBzZXJ2ZXItZm9ybWF0dGVkIHN0cmluZy5cbiAgICAgKlxuICAgICAqIC0gU3BsaXR0aW5nIHRoZSBlbXB0eSBzdHJpbmcgaXMgbm90IGFsbG93ZWQgKGZvciBub3cgYXQgbGVhc3QpLlxuICAgICAqIC0gRW1wdHkgc2VnbWVudHMgd2l0aGluIHRoZSBzdHJpbmcgKGUuZy4gaWYgdGhlcmUgYXJlIHR3byBjb25zZWN1dGl2ZVxuICAgICAqICAgc2VwYXJhdG9ycykgYXJlIG5vdCBhbGxvd2VkLlxuICAgICAqXG4gICAgICogVE9ETyhiLzM3MjQ0MTU3KTogd2Ugc2hvdWxkIG1ha2UgdGhpcyBtb3JlIHN0cmljdC4gUmlnaHQgbm93LCBpdCBhbGxvd3NcbiAgICAgKiBub24taWRlbnRpZmllciBwYXRoIGNvbXBvbmVudHMsIGV2ZW4gaWYgdGhleSBhcmVuJ3QgZXNjYXBlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVNlcnZlckZvcm1hdChwYXRoKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gW107XG4gICAgICAgIGxldCBjdXJyZW50ID0gJyc7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgYWRkQ3VycmVudFNlZ21lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBmaWVsZCBwYXRoICgke3BhdGh9KS4gUGF0aHMgbXVzdCBub3QgYmUgZW1wdHksIGJlZ2luIGAgK1xuICAgICAgICAgICAgICAgICAgICBgd2l0aCAnLicsIGVuZCB3aXRoICcuJywgb3IgY29udGFpbiAnLi4nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgaW5CYWNrdGlja3MgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKGkgPCBwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgYyA9IHBhdGhbaV07XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxID09PSBwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnUGF0aCBoYXMgdHJhaWxpbmcgZXNjYXBlIGNoYXJhY3RlcjogJyArIHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gcGF0aFtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKCEobmV4dCA9PT0gJ1xcXFwnIHx8IG5leHQgPT09ICcuJyB8fCBuZXh0ID09PSAnYCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdQYXRoIGhhcyBpbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZTogJyArIHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ICs9IG5leHQ7XG4gICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ2AnKSB7XG4gICAgICAgICAgICAgICAgaW5CYWNrdGlja3MgPSAhaW5CYWNrdGlja3M7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJy4nICYmICFpbkJhY2t0aWNrcykge1xuICAgICAgICAgICAgICAgIGFkZEN1cnJlbnRTZWdtZW50KCk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGRDdXJyZW50U2VnbWVudCgpO1xuICAgICAgICBpZiAoaW5CYWNrdGlja3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdVbnRlcm1pbmF0ZWQgYCBpbiBwYXRoOiAnICsgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgkMShzZWdtZW50cyk7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eVBhdGgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRQYXRoJDEoW10pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIERvY3VtZW50S2V5IHtcbiAgICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRLZXkoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKG5hbWUpLnBvcEZpcnN0KDUpKTtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KFJlc291cmNlUGF0aC5lbXB0eVBhdGgoKSk7XG4gICAgfVxuICAgIGdldCBjb2xsZWN0aW9uR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgucG9wTGFzdCgpLmxhc3RTZWdtZW50KCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRvY3VtZW50IGlzIGluIHRoZSBzcGVjaWZpZWQgY29sbGVjdGlvbklkLiAqL1xuICAgIGhhc0NvbGxlY3Rpb25JZChjb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnBhdGgubGVuZ3RoID49IDIgJiZcbiAgICAgICAgICAgIHRoaXMucGF0aC5nZXQodGhpcy5wYXRoLmxlbmd0aCAtIDIpID09PSBjb2xsZWN0aW9uSWQpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgY29sbGVjdGlvbiBncm91cCAoaS5lLiB0aGUgbmFtZSBvZiB0aGUgcGFyZW50IGNvbGxlY3Rpb24pIGZvciB0aGlzIGtleS4gKi9cbiAgICBnZXRDb2xsZWN0aW9uR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGguZ2V0KHRoaXMucGF0aC5sZW5ndGggLSAyKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIGZ1bGx5IHF1YWxpZmllZCBwYXRoIHRvIHRoZSBwYXJlbnQgY29sbGVjdGlvbi4gKi9cbiAgICBnZXRDb2xsZWN0aW9uUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC5wb3BMYXN0KCk7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIChvdGhlciAhPT0gbnVsbCAmJiBSZXNvdXJjZVBhdGguY29tcGFyYXRvcih0aGlzLnBhdGgsIG90aGVyLnBhdGgpID09PSAwKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgc3RhdGljIGNvbXBhcmF0b3IoazEsIGsyKSB7XG4gICAgICAgIHJldHVybiBSZXNvdXJjZVBhdGguY29tcGFyYXRvcihrMS5wYXRoLCBrMi5wYXRoKTtcbiAgICB9XG4gICAgc3RhdGljIGlzRG9jdW1lbnRLZXkocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggJSAyID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IGRvY3VtZW50IGtleSB3aXRoIHRoZSBnaXZlbiBzZWdtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWdtZW50cyAtIFRoZSBzZWdtZW50cyBvZiB0aGUgcGF0aCB0byB0aGUgZG9jdW1lbnRcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbnN0YW5jZSBvZiBEb2N1bWVudEtleVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2VnbWVudHMoc2VnbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShuZXcgUmVzb3VyY2VQYXRoKHNlZ21lbnRzLnNsaWNlKCkpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU5vbkVtcHR5QXJndW1lbnQoZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUsIGFyZ3VtZW50KSB7XG4gICAgaWYgKCFhcmd1bWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9KCkgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5ICR7YXJndW1lbnROYW1lfS5gKTtcbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IHR3byBib29sZWFuIG9wdGlvbnMgYXJlIG5vdCBzZXQgYXQgdGhlIHNhbWUgdGltZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUlzTm90VXNlZFRvZ2V0aGVyKG9wdGlvbk5hbWUxLCBhcmd1bWVudDEsIG9wdGlvbk5hbWUyLCBhcmd1bWVudDIpIHtcbiAgICBpZiAoYXJndW1lbnQxID09PSB0cnVlICYmIGFyZ3VtZW50MiA9PT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgJHtvcHRpb25OYW1lMX0gYW5kICR7b3B0aW9uTmFtZTJ9IGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyLmApO1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYHBhdGhgIHJlZmVycyB0byBhIGRvY3VtZW50IChpbmRpY2F0ZWQgYnkgdGhlIGZhY3QgaXQgY29udGFpbnNcbiAqIGFuIGV2ZW4gbnVtYmVycyBvZiBzZWdtZW50cykuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRG9jdW1lbnRQYXRoKHBhdGgpIHtcbiAgICBpZiAoIURvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkocGF0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgZG9jdW1lbnQgcmVmZXJlbmNlLiBEb2N1bWVudCByZWZlcmVuY2VzIG11c3QgaGF2ZSBhbiBldmVuIG51bWJlciBvZiBzZWdtZW50cywgYnV0ICR7cGF0aH0gaGFzICR7cGF0aC5sZW5ndGh9LmApO1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYHBhdGhgIHJlZmVycyB0byBhIGNvbGxlY3Rpb24gKGluZGljYXRlZCBieSB0aGUgZmFjdCBpdFxuICogY29udGFpbnMgYW4gb2RkIG51bWJlcnMgb2Ygc2VnbWVudHMpLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbGxlY3Rpb25QYXRoKHBhdGgpIHtcbiAgICBpZiAoRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShwYXRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBjb2xsZWN0aW9uIHJlZmVyZW5jZS4gQ29sbGVjdGlvbiByZWZlcmVuY2VzIG11c3QgaGF2ZSBhbiBvZGQgbnVtYmVyIG9mIHNlZ21lbnRzLCBidXQgJHtwYXRofSBoYXMgJHtwYXRoLmxlbmd0aH0uYCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgaXQncyBhIG5vbi1udWxsIG9iamVjdCB3aXRob3V0IGEgY3VzdG9tIHByb3RvdHlwZVxuICogKGkuZS4gZXhjbHVkZXMgQXJyYXksIERhdGUsIGV0Yy4pLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KGlucHV0KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGlucHV0ICE9PSBudWxsICYmXG4gICAgICAgIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpID09PSBPYmplY3QucHJvdG90eXBlIHx8XG4gICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpID09PSBudWxsKSk7XG59XG4vKiogUmV0dXJucyBhIHN0cmluZyBkZXNjcmliaW5nIHRoZSB0eXBlIC8gdmFsdWUgb2YgdGhlIHByb3ZpZGVkIGlucHV0LiAqL1xuZnVuY3Rpb24gdmFsdWVEZXNjcmlwdGlvbihpbnB1dCkge1xuICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMjApIHtcbiAgICAgICAgICAgIGlucHV0ID0gYCR7aW5wdXQuc3Vic3RyaW5nKDAsIDIwKX0uLi5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGlucHV0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaW5wdXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiAnYW4gYXJyYXknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tT2JqZWN0TmFtZSA9IHRyeUdldEN1c3RvbU9iamVjdFR5cGUoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKGN1c3RvbU9iamVjdE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYGEgY3VzdG9tICR7Y3VzdG9tT2JqZWN0TmFtZX0gb2JqZWN0YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnYW4gb2JqZWN0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuICdhIGZ1bmN0aW9uJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKDB4MzAyOSwgeyB0eXBlOiB0eXBlb2YgaW5wdXQgfSk7XG4gICAgfVxufVxuLyoqIHRyeSB0byBnZXQgdGhlIGNvbnN0cnVjdG9yIG5hbWUgZm9yIGFuIG9iamVjdC4gKi9cbmZ1bmN0aW9uIHRyeUdldEN1c3RvbU9iamVjdFR5cGUoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBDYXN0cyBgb2JqYCB0byBgVGAsIG9wdGlvbmFsbHkgdW53cmFwcGluZyBDb21wYXQgdHlwZXMgdG8gZXhwb3NlIHRoZVxuICogdW5kZXJseWluZyBpbnN0YW5jZS4gVGhyb3dzIGlmICBgb2JqYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYFRgLlxuICpcbiAqIFRoaXMgY2FzdCBpcyB1c2VkIGluIHRoZSBMaXRlIGFuZCBGdWxsIFNESyB0byB2ZXJpZnkgaW5zdGFuY2UgdHlwZXMgZm9yXG4gKiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBwdWJsaWMgQVBJLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNhc3Qob2JqLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdHJ1Y3Rvcikge1xuICAgIGlmICgnX2RlbGVnYXRlJyBpbiBvYmopIHtcbiAgICAgICAgLy8gVW53cmFwIENvbXBhdCB0eXBlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBvYmogPSBvYmouX2RlbGVnYXRlO1xuICAgIH1cbiAgICBpZiAoIShvYmogaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yLm5hbWUgPT09IG9iai5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVHlwZSBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgaW5zdGFuY2UuIERpZCB5b3UgcGFzcyBhICcgK1xuICAgICAgICAgICAgICAgIGByZWZlcmVuY2UgZnJvbSBhIGRpZmZlcmVudCBGaXJlc3RvcmUgU0RLP2ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB2YWx1ZURlc2NyaXB0aW9uKG9iaik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRXhwZWN0ZWQgdHlwZSAnJHtjb25zdHJ1Y3Rvci5uYW1lfScsIGJ1dCBpdCB3YXM6ICR7ZGVzY3JpcHRpb259YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUG9zaXRpdmVOdW1iZXIoZnVuY3Rpb25OYW1lLCBuKSB7XG4gICAgaWYgKG4gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9KCkgcmVxdWlyZXMgYSBwb3NpdGl2ZSBudW1iZXIsIGJ1dCBpdCB3YXM6ICR7bn0uYCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGVmaW5lIGEgSlNPTiBzY2hlbWEge0BsaW5rIFByb3BlcnR5fS5cbiAqIEBwcml2YXRlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkodHlwZVN0cmluZywgb3B0aW9uYWxWYWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZVN0cmluZ1xuICAgIH07XG4gICAgaWYgKG9wdGlvbmFsVmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gb3B0aW9uYWxWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBKU09OIG9iamVjdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgc2NoZW1hLCBhbmQgbmFycm93cyB0aGUgdHlwZSB0byB0aGUgcHJvdmlkZWRcbiAqIEpTT04gc2NoZW1hLlxuICogQHByaXZhdGVcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEBwYXJhbSBqc29uIC0gQSBKU09OIG9iamVjdCB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBzY2hlbWUgLSBhIHtAbGluayBKc29uU2NoZW1hfSB0aGF0IGRlZmluZXMgdGhlIHByb3BlcnRpZXMgdG8gdmFsaWRhdGUuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBKU09OIHNjaGVtYSBleGlzdHMgd2l0aGluIHRoZSBvYmplY3QuIFRocm93cyBhIEZpcmVzdG9yZUVycm9yIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVKU09OKGpzb24sIHNjaGVtYSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChqc29uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSlNPTiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICBsZXQgZXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChzY2hlbWFba2V5XSkge1xuICAgICAgICAgICAgY29uc3QgdHlwZVN0cmluZyA9IHNjaGVtYVtrZXldLnR5cGVTdHJpbmc7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9ICd2YWx1ZScgaW4gc2NoZW1hW2tleV0gPyB7IHZhbHVlOiBzY2hlbWFba2V5XS52YWx1ZSB9IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIGpzb24pKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBgSlNPTiBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkOiAnJHtrZXl9J2A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IGpzb25ba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlU3RyaW5nICYmIHR5cGVvZiBmaWVsZFZhbHVlICE9PSB0eXBlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBgSlNPTiBmaWVsZCAnJHtrZXl9JyBtdXN0IGJlIGEgJHt0eXBlU3RyaW5nfS5gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBmaWVsZFZhbHVlICE9PSB2YWx1ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gYEV4cGVjdGVkICcke2tleX0nIGZpZWxkIHRvIGVxdWFsICcke3ZhbHVlLnZhbHVlfSdgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gVGhlIGVhcmxpZXN0IGRhdGUgc3VwcG9ydGVkIGJ5IEZpcmVzdG9yZSB0aW1lc3RhbXBzICgwMDAxLTAxLTAxVDAwOjAwOjAwWikuXG5jb25zdCBNSU5fU0VDT05EUyA9IC02MjEzNTU5NjgwMDtcbi8vIE51bWJlciBvZiBuYW5vc2Vjb25kcyBpbiBhIG1pbGxpc2Vjb25kLlxuY29uc3QgTVNfVE9fTkFOT1MgPSAxZTY7XG4vKipcbiAqIEEgYFRpbWVzdGFtcGAgcmVwcmVzZW50cyBhIHBvaW50IGluIHRpbWUgaW5kZXBlbmRlbnQgb2YgYW55IHRpbWUgem9uZSBvclxuICogY2FsZW5kYXIsIHJlcHJlc2VudGVkIGFzIHNlY29uZHMgYW5kIGZyYWN0aW9ucyBvZiBzZWNvbmRzIGF0IG5hbm9zZWNvbmRcbiAqIHJlc29sdXRpb24gaW4gVVRDIEVwb2NoIHRpbWUuXG4gKlxuICogSXQgaXMgZW5jb2RlZCB1c2luZyB0aGUgUHJvbGVwdGljIEdyZWdvcmlhbiBDYWxlbmRhciB3aGljaCBleHRlbmRzIHRoZVxuICogR3JlZ29yaWFuIGNhbGVuZGFyIGJhY2t3YXJkcyB0byB5ZWFyIG9uZS4gSXQgaXMgZW5jb2RlZCBhc3N1bWluZyBhbGwgbWludXRlc1xuICogYXJlIDYwIHNlY29uZHMgbG9uZywgaS5lLiBsZWFwIHNlY29uZHMgYXJlIFwic21lYXJlZFwiIHNvIHRoYXQgbm8gbGVhcCBzZWNvbmRcbiAqIHRhYmxlIGlzIG5lZWRlZCBmb3IgaW50ZXJwcmV0YXRpb24uIFJhbmdlIGlzIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG9cbiAqIDk5OTktMTItMzFUMjM6NTk6NTkuOTk5OTk5OTk5Wi5cbiAqXG4gKiBGb3IgZXhhbXBsZXMgYW5kIGZ1cnRoZXIgc3BlY2lmaWNhdGlvbnMsIHJlZmVyIHRvIHRoZVxuICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvcHJvdG9idWYvYmxvYi9tYXN0ZXIvc3JjL2dvb2dsZS9wcm90b2J1Zi90aW1lc3RhbXAucHJvdG8gfCBUaW1lc3RhbXAgZGVmaW5pdGlvbn0uXG4gKi9cbmNsYXNzIFRpbWVzdGFtcCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0aW1lc3RhbXAgd2l0aCB0aGUgY3VycmVudCBkYXRlLCB3aXRoIG1pbGxpc2Vjb25kIHByZWNpc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgbmV3IHRpbWVzdGFtcCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgZGF0ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgbm93KCkge1xuICAgICAgICByZXR1cm4gVGltZXN0YW1wLmZyb21NaWxsaXMoRGF0ZS5ub3coKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGltZXN0YW1wIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGluaXRpYWxpemUgdGhlIGBUaW1lc3RhbXBgIGZyb20uXG4gICAgICogQHJldHVybnMgQSBuZXcgYFRpbWVzdGFtcGAgcmVwcmVzZW50aW5nIHRoZSBzYW1lIHBvaW50IGluIHRpbWUgYXMgdGhlIGdpdmVuXG4gICAgICogICAgIGRhdGUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21EYXRlKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIFRpbWVzdGFtcC5mcm9tTWlsbGlzKGRhdGUuZ2V0VGltZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0aW1lc3RhbXAgZnJvbSB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtaWxsaXNlY29uZHMgLSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIFVuaXggZXBvY2hcbiAgICAgKiAgICAgMTk3MC0wMS0wMVQwMDowMDowMFouXG4gICAgICogQHJldHVybnMgQSBuZXcgYFRpbWVzdGFtcGAgcmVwcmVzZW50aW5nIHRoZSBzYW1lIHBvaW50IGluIHRpbWUgYXMgdGhlIGdpdmVuXG4gICAgICogICAgIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21NaWxsaXMobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBjb25zdCBuYW5vcyA9IE1hdGguZmxvb3IoKG1pbGxpc2Vjb25kcyAtIHNlY29uZHMgKiAxMDAwKSAqIE1TX1RPX05BTk9TKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoc2Vjb25kcywgbmFub3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRpbWVzdGFtcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWNvbmRzIC0gVGhlIG51bWJlciBvZiBzZWNvbmRzIG9mIFVUQyB0aW1lIHNpbmNlIFVuaXggZXBvY2hcbiAgICAgKiAgICAgMTk3MC0wMS0wMVQwMDowMDowMFouIE11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0b1xuICAgICAqICAgICA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmUuXG4gICAgICogQHBhcmFtIG5hbm9zZWNvbmRzIC0gVGhlIG5vbi1uZWdhdGl2ZSBmcmFjdGlvbnMgb2YgYSBzZWNvbmQgYXQgbmFub3NlY29uZFxuICAgICAqICAgICByZXNvbHV0aW9uLiBOZWdhdGl2ZSBzZWNvbmQgdmFsdWVzIHdpdGggZnJhY3Rpb25zIG11c3Qgc3RpbGwgaGF2ZVxuICAgICAqICAgICBub24tbmVnYXRpdmUgbmFub3NlY29uZHMgdmFsdWVzIHRoYXQgY291bnQgZm9yd2FyZCBpbiB0aW1lLiBNdXN0IGJlXG4gICAgICogICAgIGZyb20gMCB0byA5OTksOTk5LDk5OSBpbmNsdXNpdmUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBzZWNvbmRzIG9mIFVUQyB0aW1lIHNpbmNlIFVuaXggZXBvY2ggMTk3MC0wMS0wMVQwMDowMDowMFouXG4gICAgICovXG4gICAgc2Vjb25kcywgXG4gICAgLyoqXG4gICAgICogVGhlIGZyYWN0aW9ucyBvZiBhIHNlY29uZCBhdCBuYW5vc2Vjb25kIHJlc29sdXRpb24uKlxuICAgICAqL1xuICAgIG5hbm9zZWNvbmRzKSB7XG4gICAgICAgIHRoaXMuc2Vjb25kcyA9IHNlY29uZHM7XG4gICAgICAgIHRoaXMubmFub3NlY29uZHMgPSBuYW5vc2Vjb25kcztcbiAgICAgICAgaWYgKG5hbm9zZWNvbmRzIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RpbWVzdGFtcCBuYW5vc2Vjb25kcyBvdXQgb2YgcmFuZ2U6ICcgKyBuYW5vc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbm9zZWNvbmRzID49IDFlOSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RpbWVzdGFtcCBuYW5vc2Vjb25kcyBvdXQgb2YgcmFuZ2U6ICcgKyBuYW5vc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY29uZHMgPCBNSU5fU0VDT05EUykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RpbWVzdGFtcCBzZWNvbmRzIG91dCBvZiByYW5nZTogJyArIHNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgd2lsbCBicmVhayBpbiB0aGUgeWVhciAxMCwwMDAuXG4gICAgICAgIGlmIChzZWNvbmRzID49IDI1MzQwMjMwMDgwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RpbWVzdGFtcCBzZWNvbmRzIG91dCBvZiByYW5nZTogJyArIHNlY29uZHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYFRpbWVzdGFtcGAgdG8gYSBKYXZhU2NyaXB0IGBEYXRlYCBvYmplY3QuIFRoaXMgY29udmVyc2lvblxuICAgICAqIGNhdXNlcyBhIGxvc3Mgb2YgcHJlY2lzaW9uIHNpbmNlIGBEYXRlYCBvYmplY3RzIG9ubHkgc3VwcG9ydCBtaWxsaXNlY29uZFxuICAgICAqIHByZWNpc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEphdmFTY3JpcHQgYERhdGVgIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNhbWUgcG9pbnQgaW4gdGltZSBhc1xuICAgICAqICAgICB0aGlzIGBUaW1lc3RhbXBgLCB3aXRoIG1pbGxpc2Vjb25kIHByZWNpc2lvbi5cbiAgICAgKi9cbiAgICB0b0RhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnRvTWlsbGlzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGBUaW1lc3RhbXBgIHRvIGEgbnVtZXJpYyB0aW1lc3RhbXAgKGluIG1pbGxpc2Vjb25kcyBzaW5jZVxuICAgICAqIGVwb2NoKS4gVGhpcyBvcGVyYXRpb24gY2F1c2VzIGEgbG9zcyBvZiBwcmVjaXNpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcG9pbnQgaW4gdGltZSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgdGltZXN0YW1wLCByZXByZXNlbnRlZCBhc1xuICAgICAqICAgICB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSBVbml4IGVwb2NoIDE5NzAtMDEtMDFUMDA6MDA6MDBaLlxuICAgICAqL1xuICAgIHRvTWlsbGlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWNvbmRzICogMTAwMCArIHRoaXMubmFub3NlY29uZHMgLyBNU19UT19OQU5PUztcbiAgICB9XG4gICAgX2NvbXBhcmVUbyhvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zZWNvbmRzID09PSBvdGhlci5zZWNvbmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcih0aGlzLm5hbm9zZWNvbmRzLCBvdGhlci5uYW5vc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IodGhpcy5zZWNvbmRzLCBvdGhlci5zZWNvbmRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYFRpbWVzdGFtcGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBgVGltZXN0YW1wYCB0byBjb21wYXJlIGFnYWluc3QuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGBUaW1lc3RhbXBgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICovXG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKG90aGVyLnNlY29uZHMgPT09IHRoaXMuc2Vjb25kcyAmJiBvdGhlci5uYW5vc2Vjb25kcyA9PT0gdGhpcy5uYW5vc2Vjb25kcyk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGBUaW1lc3RhbXBgLiAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKCdUaW1lc3RhbXAoc2Vjb25kcz0nICtcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kcyArXG4gICAgICAgICAgICAnLCBuYW5vc2Vjb25kcz0nICtcbiAgICAgICAgICAgIHRoaXMubmFub3NlY29uZHMgK1xuICAgICAgICAgICAgJyknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgYFRpbWVzdGFtcGAuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVGltZXN0YW1wLl9qc29uU2NoZW1hVmVyc2lvbixcbiAgICAgICAgICAgIHNlY29uZHM6IHRoaXMuc2Vjb25kcyxcbiAgICAgICAgICAgIG5hbm9zZWNvbmRzOiB0aGlzLm5hbm9zZWNvbmRzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIGBUaW1lc3RhbXBgIGluc3RhbmNlIGZyb20gYSBKU09OIG9iamVjdCBjcmVhdGVkIGJ5IHtAbGluayBUaW1lc3RhbXAudG9KU09OfS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAodmFsaWRhdGVKU09OKGpzb24sIFRpbWVzdGFtcC5fanNvblNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKGpzb24uc2Vjb25kcywganNvbi5uYW5vc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBvYmplY3QgdG8gYSBwcmltaXRpdmUgc3RyaW5nLCB3aGljaCBhbGxvd3MgYFRpbWVzdGFtcGAgb2JqZWN0c1xuICAgICAqIHRvIGJlIGNvbXBhcmVkIHVzaW5nIHRoZSBgPmAsIGA8PWAsIGA+PWAgYW5kIGA+YCBvcGVyYXRvcnMuXG4gICAgICovXG4gICAgdmFsdWVPZigpIHtcbiAgICAgICAgLy8gVGhpcyBtZXRob2QgcmV0dXJucyBhIHN0cmluZyBvZiB0aGUgZm9ybSA8c2Vjb25kcz4uPG5hbm9zZWNvbmRzPiB3aGVyZVxuICAgICAgICAvLyA8c2Vjb25kcz4gaXMgdHJhbnNsYXRlZCB0byBoYXZlIGEgbm9uLW5lZ2F0aXZlIHZhbHVlIGFuZCBib3RoIDxzZWNvbmRzPlxuICAgICAgICAvLyBhbmQgPG5hbm9zZWNvbmRzPiBhcmUgbGVmdC1wYWRkZWQgd2l0aCB6ZXJvZXMgdG8gYmUgYSBjb25zaXN0ZW50IGxlbmd0aC5cbiAgICAgICAgLy8gU3RyaW5ncyB3aXRoIHRoaXMgZm9ybWF0IHRoZW4gaGF2ZSBhIGxleGljb2dyYXBoaWNhbCBvcmRlcmluZyB0aGF0IG1hdGNoZXNcbiAgICAgICAgLy8gdGhlIGV4cGVjdGVkIG9yZGVyaW5nLiBUaGUgPHNlY29uZHM+IHRyYW5zbGF0aW9uIGlzIGRvbmUgdG8gYXZvaWQgaGF2aW5nXG4gICAgICAgIC8vIGEgbGVhZGluZyBuZWdhdGl2ZSBzaWduIChpLmUuIGEgbGVhZGluZyAnLScgY2hhcmFjdGVyKSBpbiBpdHMgc3RyaW5nXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uLCB3aGljaCB3b3VsZCBhZmZlY3QgaXRzIGxleGljb2dyYXBoaWNhbCBvcmRlcmluZy5cbiAgICAgICAgY29uc3QgYWRqdXN0ZWRTZWNvbmRzID0gdGhpcy5zZWNvbmRzIC0gTUlOX1NFQ09ORFM7XG4gICAgICAgIC8vIE5vdGU6IFVwIHRvIDEyIGRlY2ltYWwgZGlnaXRzIGFyZSByZXF1aXJlZCB0byByZXByZXNlbnQgYWxsIHZhbGlkXG4gICAgICAgIC8vICdzZWNvbmRzJyB2YWx1ZXMuXG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZFNlY29uZHMgPSBTdHJpbmcoYWRqdXN0ZWRTZWNvbmRzKS5wYWRTdGFydCgxMiwgJzAnKTtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkTmFub3NlY29uZHMgPSBTdHJpbmcodGhpcy5uYW5vc2Vjb25kcykucGFkU3RhcnQoOSwgJzAnKTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFNlY29uZHMgKyAnLicgKyBmb3JtYXR0ZWROYW5vc2Vjb25kcztcbiAgICB9XG59XG5UaW1lc3RhbXAuX2pzb25TY2hlbWFWZXJzaW9uID0gJ2ZpcmVzdG9yZS90aW1lc3RhbXAvMS4wJztcblRpbWVzdGFtcC5fanNvblNjaGVtYSA9IHtcbiAgICB0eXBlOiBwcm9wZXJ0eSgnc3RyaW5nJywgVGltZXN0YW1wLl9qc29uU2NoZW1hVmVyc2lvbiksXG4gICAgc2Vjb25kczogcHJvcGVydHkoJ251bWJlcicpLFxuICAgIG5hbm9zZWNvbmRzOiBwcm9wZXJ0eSgnbnVtYmVyJylcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgdmVyc2lvbiBvZiBhIGRvY3VtZW50IGluIEZpcmVzdG9yZS4gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgdmVyc2lvblxuICogdGltZXN0YW1wLCBzdWNoIGFzIHVwZGF0ZV90aW1lIG9yIHJlYWRfdGltZS5cbiAqL1xuY2xhc3MgU25hcHNob3RWZXJzaW9uIHtcbiAgICBzdGF0aWMgZnJvbVRpbWVzdGFtcCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNuYXBzaG90VmVyc2lvbih2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBtaW4oKSB7XG4gICAgICAgIHJldHVybiBuZXcgU25hcHNob3RWZXJzaW9uKG5ldyBUaW1lc3RhbXAoMCwgMCkpO1xuICAgIH1cbiAgICBzdGF0aWMgbWF4KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNuYXBzaG90VmVyc2lvbihuZXcgVGltZXN0YW1wKDI1MzQwMjMwMDc5OSwgMWU5IC0gMSkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih0aW1lc3RhbXApIHtcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgfVxuICAgIGNvbXBhcmVUbyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXAuX2NvbXBhcmVUbyhvdGhlci50aW1lc3RhbXApO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcC5pc0VxdWFsKG90aGVyLnRpbWVzdGFtcCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgbnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZXJzaW9uIGZvciB1c2UgaW4gc3BlYyB0ZXN0cy4gKi9cbiAgICB0b01pY3Jvc2Vjb25kcygpIHtcbiAgICAgICAgLy8gQ29udmVydCB0byBtaWNyb3NlY29uZHMuXG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcC5zZWNvbmRzICogMWU2ICsgdGhpcy50aW1lc3RhbXAubmFub3NlY29uZHMgLyAxMDAwO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICdTbmFwc2hvdFZlcnNpb24oJyArIHRoaXMudGltZXN0YW1wLnRvU3RyaW5nKCkgKyAnKSc7XG4gICAgfVxuICAgIHRvVGltZXN0YW1wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXA7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgaW5pdGlhbCBtdXRhdGlvbiBiYXRjaCBpZCBmb3IgZWFjaCBpbmRleC4gR2V0cyB1cGRhdGVkIGR1cmluZyBpbmRleFxuICogYmFja2ZpbGwuXG4gKi9cbmNvbnN0IElOSVRJQUxfTEFSR0VTVF9CQVRDSF9JRCA9IC0xO1xuLyoqXG4gKiBUaGUgaW5pdGlhbCBzZXF1ZW5jZSBudW1iZXIgZm9yIGVhY2ggaW5kZXguIEdldHMgdXBkYXRlZCBkdXJpbmcgaW5kZXhcbiAqIGJhY2tmaWxsLlxuICovXG5jb25zdCBJTklUSUFMX1NFUVVFTkNFX05VTUJFUiA9IDA7XG4vKipcbiAqIEFuIGluZGV4IGRlZmluaXRpb24gZm9yIGZpZWxkIGluZGV4ZXMgaW4gRmlyZXN0b3JlLlxuICpcbiAqIEV2ZXJ5IGluZGV4IGlzIGFzc29jaWF0ZWQgd2l0aCBhIGNvbGxlY3Rpb24uIFRoZSBkZWZpbml0aW9uIGNvbnRhaW5zIGEgbGlzdFxuICogb2YgZmllbGRzIGFuZCB0aGVpciBpbmRleCBraW5kICh3aGljaCBjYW4gYmUgYEFTQ0VORElOR2AsIGBERVNDRU5ESU5HYCBvclxuICogYENPTlRBSU5TYCBmb3IgQXJyYXlDb250YWlucy9BcnJheUNvbnRhaW5zQW55IHF1ZXJpZXMpLlxuICpcbiAqIFVubGlrZSB0aGUgYmFja2VuZCwgdGhlIFNESyBkb2VzIG5vdCBkaWZmZXJlbnRpYXRlIGJldHdlZW4gY29sbGVjdGlvbiBvclxuICogY29sbGVjdGlvbiBncm91cC1zY29wZWQgaW5kaWNlcy4gRXZlcnkgaW5kZXggY2FuIGJlIHVzZWQgZm9yIGJvdGggc2luZ2xlXG4gKiBjb2xsZWN0aW9uIGFuZCBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJpZXMuXG4gKi9cbmNsYXNzIEZpZWxkSW5kZXgge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBJRC4gUmV0dXJucyAtMSBpZiB0aGUgaW5kZXggSUQgaXMgbm90IGF2YWlsYWJsZSAoZS5nLiB0aGUgaW5kZXhcbiAgICAgKiBoYXMgbm90IHlldCBiZWVuIHBlcnNpc3RlZCkuXG4gICAgICovXG4gICAgaW5kZXhJZCwgXG4gICAgLyoqIFRoZSBjb2xsZWN0aW9uIElEIHRoaXMgaW5kZXggYXBwbGllcyB0by4gKi9cbiAgICBjb2xsZWN0aW9uR3JvdXAsIFxuICAgIC8qKiBUaGUgZmllbGQgc2VnbWVudHMgZm9yIHRoaXMgaW5kZXguICovXG4gICAgZmllbGRzLCBcbiAgICAvKiogU2hvd3MgaG93IHVwLXRvLWRhdGUgdGhlIGluZGV4IGlzIGZvciB0aGUgY3VycmVudCB1c2VyLiAqL1xuICAgIGluZGV4U3RhdGUpIHtcbiAgICAgICAgdGhpcy5pbmRleElkID0gaW5kZXhJZDtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXAgPSBjb2xsZWN0aW9uR3JvdXA7XG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgICAgICB0aGlzLmluZGV4U3RhdGUgPSBpbmRleFN0YXRlO1xuICAgIH1cbn1cbi8qKiBBbiBJRCBmb3IgYW4gaW5kZXggdGhhdCBoYXMgbm90IHlldCBiZWVuIGFkZGVkIHRvIHBlcnNpc3RlbmNlLiAgKi9cbkZpZWxkSW5kZXguVU5LTk9XTl9JRCA9IC0xO1xuLyoqIFJldHVybnMgdGhlIEFycmF5Q29udGFpbnMvQXJyYXlDb250YWluc0FueSBzZWdtZW50IGZvciB0aGlzIGluZGV4LiAqL1xuZnVuY3Rpb24gZmllbGRJbmRleEdldEFycmF5U2VnbWVudChmaWVsZEluZGV4KSB7XG4gICAgcmV0dXJuIGZpZWxkSW5kZXguZmllbGRzLmZpbmQocyA9PiBzLmtpbmQgPT09IDIgLyogSW5kZXhLaW5kLkNPTlRBSU5TICovKTtcbn1cbi8qKiBSZXR1cm5zIGFsbCBkaXJlY3Rpb25hbCAoYXNjZW5kaW5nL2Rlc2NlbmRpbmcpIHNlZ21lbnRzIGZvciB0aGlzIGluZGV4LiAqL1xuZnVuY3Rpb24gZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoZmllbGRJbmRleCkge1xuICAgIHJldHVybiBmaWVsZEluZGV4LmZpZWxkcy5maWx0ZXIocyA9PiBzLmtpbmQgIT09IDIgLyogSW5kZXhLaW5kLkNPTlRBSU5TICovKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgb3JkZXIgb2YgdGhlIGRvY3VtZW50IGtleSBjb21wb25lbnQgZm9yIHRoZSBnaXZlbiBpbmRleC5cbiAqXG4gKiBQT1JUSU5HIE5PVEU6IFRoaXMgaXMgb25seSB1c2VkIGluIHRoZSBXZWIgSW5kZXhlZERiIGltcGxlbWVudGF0aW9uLlxuICovXG5mdW5jdGlvbiBmaWVsZEluZGV4R2V0S2V5T3JkZXIoZmllbGRJbmRleCkge1xuICAgIGNvbnN0IGRpcmVjdGlvbmFsU2VnbWVudHMgPSBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KTtcbiAgICByZXR1cm4gZGlyZWN0aW9uYWxTZWdtZW50cy5sZW5ndGggPT09IDBcbiAgICAgICAgPyAwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi9cbiAgICAgICAgOiBkaXJlY3Rpb25hbFNlZ21lbnRzW2RpcmVjdGlvbmFsU2VnbWVudHMubGVuZ3RoIC0gMV0ua2luZDtcbn1cbi8qKlxuICogQ29tcGFyZXMgaW5kZXhlcyBieSBjb2xsZWN0aW9uIGdyb3VwIGFuZCBzZWdtZW50cy4gSWdub3JlcyB1cGRhdGUgdGltZSBhbmRcbiAqIGluZGV4IElELlxuICovXG5mdW5jdGlvbiBmaWVsZEluZGV4U2VtYW50aWNDb21wYXJhdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgbGV0IGNtcCA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC5jb2xsZWN0aW9uR3JvdXAsIHJpZ2h0LmNvbGxlY3Rpb25Hcm91cCk7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKGxlZnQuZmllbGRzLmxlbmd0aCwgcmlnaHQuZmllbGRzLmxlbmd0aCk7ICsraSkge1xuICAgICAgICBjbXAgPSBpbmRleFNlZ21lbnRDb21wYXJhdG9yKGxlZnQuZmllbGRzW2ldLCByaWdodC5maWVsZHNbaV0pO1xuICAgICAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQuZmllbGRzLmxlbmd0aCwgcmlnaHQuZmllbGRzLmxlbmd0aCk7XG59XG4vKiogUmV0dXJucyBhIGRlYnVnIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmaWVsZCBpbmRleCAqL1xuZnVuY3Rpb24gZmllbGRJbmRleFRvU3RyaW5nKGZpZWxkSW5kZXgpIHtcbiAgICByZXR1cm4gYGlkPSR7ZmllbGRJbmRleC5pbmRleElkfXxjZz0ke2ZpZWxkSW5kZXguY29sbGVjdGlvbkdyb3VwfXxmPSR7ZmllbGRJbmRleC5maWVsZHMubWFwKGYgPT4gYCR7Zi5maWVsZFBhdGh9OiR7Zi5raW5kfWApLmpvaW4oJywnKX1gO1xufVxuLyoqIEFuIGluZGV4IGNvbXBvbmVudCBjb25zaXN0aW5nIG9mIGZpZWxkIHBhdGggYW5kIGluZGV4IHR5cGUuICAqL1xuY2xhc3MgSW5kZXhTZWdtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVGhlIGZpZWxkIHBhdGggb2YgdGhlIGNvbXBvbmVudC4gKi9cbiAgICBmaWVsZFBhdGgsIFxuICAgIC8qKiBUaGUgZmllbGRzIHNvcnRpbmcgb3JkZXIuICovXG4gICAga2luZCkge1xuICAgICAgICB0aGlzLmZpZWxkUGF0aCA9IGZpZWxkUGF0aDtcbiAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB9XG59XG5mdW5jdGlvbiBpbmRleFNlZ21lbnRDb21wYXJhdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgY21wID0gRmllbGRQYXRoJDEuY29tcGFyYXRvcihsZWZ0LmZpZWxkUGF0aCwgcmlnaHQuZmllbGRQYXRoKTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQua2luZCwgcmlnaHQua2luZCk7XG59XG4vKipcbiAqIFN0b3JlcyB0aGUgXCJoaWdoIHdhdGVyIG1hcmtcIiB0aGF0IGluZGljYXRlcyBob3cgdXBkYXRlZCB0aGUgSW5kZXggaXMgZm9yIHRoZVxuICogY3VycmVudCB1c2VyLlxuICovXG5jbGFzcyBJbmRleFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hlbiB0aGUgaW5kZXggd2FzIGxhc3QgdXBkYXRlZCAocmVsYXRpdmUgdG8gb3RoZXIgaW5kZXhlcykuXG4gICAgICovXG4gICAgc2VxdWVuY2VOdW1iZXIsIFxuICAgIC8qKiBUaGUgdGhlIGxhdGVzdCBpbmRleGVkIHJlYWQgdGltZSwgZG9jdW1lbnQgYW5kIGJhdGNoIGlkLiAqL1xuICAgIG9mZnNldCkge1xuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgICAvKiogVGhlIHN0YXRlIG9mIGFuIGluZGV4IHRoYXQgaGFzIG5vdCB5ZXQgYmVlbiBiYWNrZmlsbGVkLiAqL1xuICAgIHN0YXRpYyBlbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleFN0YXRlKElOSVRJQUxfU0VRVUVOQ0VfTlVNQkVSLCBJbmRleE9mZnNldC5taW4oKSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGFuIG9mZnNldCB0aGF0IG1hdGNoZXMgYWxsIGRvY3VtZW50cyB3aXRoIGEgcmVhZCB0aW1lIGhpZ2hlciB0aGFuXG4gKiBgcmVhZFRpbWVgLlxuICovXG5mdW5jdGlvbiBuZXdJbmRleE9mZnNldFN1Y2Nlc3NvckZyb21SZWFkVGltZShyZWFkVGltZSwgbGFyZ2VzdEJhdGNoSWQpIHtcbiAgICAvLyBXZSB3YW50IHRvIGNyZWF0ZSBhbiBvZmZzZXQgdGhhdCBtYXRjaGVzIGFsbCBkb2N1bWVudHMgd2l0aCBhIHJlYWQgdGltZVxuICAgIC8vIGdyZWF0ZXIgdGhhbiB0aGUgcHJvdmlkZWQgcmVhZCB0aW1lLiBUbyBkbyBzbywgd2UgdGVjaG5pY2FsbHkgbmVlZCB0b1xuICAgIC8vIGNyZWF0ZSBhbiBvZmZzZXQgZm9yIGAocmVhZFRpbWUsIE1BWF9ET0NVTUVOVF9LRVkpYC4gV2hpbGUgd2UgY291bGQgdXNlXG4gICAgLy8gVW5pY29kZSBjb2RlcG9pbnRzIHRvIGdlbmVyYXRlIE1BWF9ET0NVTUVOVF9LRVksIGl0IGlzIG11Y2ggZWFzaWVyIHRvIHVzZVxuICAgIC8vIGAocmVhZFRpbWUgKyAxLCBEb2N1bWVudEtleS5lbXB0eSgpKWAgc2luY2UgYD4gRG9jdW1lbnRLZXkuZW1wdHkoKWAgbWF0Y2hlc1xuICAgIC8vIGFsbCB2YWxpZCBkb2N1bWVudCBJRHMuXG4gICAgY29uc3Qgc3VjY2Vzc29yU2Vjb25kcyA9IHJlYWRUaW1lLnRvVGltZXN0YW1wKCkuc2Vjb25kcztcbiAgICBjb25zdCBzdWNjZXNzb3JOYW5vcyA9IHJlYWRUaW1lLnRvVGltZXN0YW1wKCkubmFub3NlY29uZHMgKyAxO1xuICAgIGNvbnN0IHN1Y2Nlc3NvciA9IFNuYXBzaG90VmVyc2lvbi5mcm9tVGltZXN0YW1wKHN1Y2Nlc3Nvck5hbm9zID09PSAxZTlcbiAgICAgICAgPyBuZXcgVGltZXN0YW1wKHN1Y2Nlc3NvclNlY29uZHMgKyAxLCAwKVxuICAgICAgICA6IG5ldyBUaW1lc3RhbXAoc3VjY2Vzc29yU2Vjb25kcywgc3VjY2Vzc29yTmFub3MpKTtcbiAgICByZXR1cm4gbmV3IEluZGV4T2Zmc2V0KHN1Y2Nlc3NvciwgRG9jdW1lbnRLZXkuZW1wdHkoKSwgbGFyZ2VzdEJhdGNoSWQpO1xufVxuLyoqIENyZWF0ZXMgYSBuZXcgb2Zmc2V0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBkb2N1bWVudC4gKi9cbmZ1bmN0aW9uIG5ld0luZGV4T2Zmc2V0RnJvbURvY3VtZW50KGRvY3VtZW50KSB7XG4gICAgcmV0dXJuIG5ldyBJbmRleE9mZnNldChkb2N1bWVudC5yZWFkVGltZSwgZG9jdW1lbnQua2V5LCBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQpO1xufVxuLyoqXG4gKiBTdG9yZXMgdGhlIGxhdGVzdCByZWFkIHRpbWUsIGRvY3VtZW50IGFuZCBiYXRjaCBJRCB0aGF0IHdlcmUgcHJvY2Vzc2VkIGZvciBhblxuICogaW5kZXguXG4gKi9cbmNsYXNzIEluZGV4T2Zmc2V0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgbGF0ZXN0IHJlYWQgdGltZSB2ZXJzaW9uIHRoYXQgaGFzIGJlZW4gaW5kZXhlZCBieSBGaXJlc3RvcmUgZm9yIHRoaXNcbiAgICAgKiBmaWVsZCBpbmRleC5cbiAgICAgKi9cbiAgICByZWFkVGltZSwgXG4gICAgLyoqXG4gICAgICogVGhlIGtleSBvZiB0aGUgbGFzdCBkb2N1bWVudCB0aGF0IHdhcyBpbmRleGVkIGZvciB0aGlzIHF1ZXJ5LiBVc2VcbiAgICAgKiBgRG9jdW1lbnRLZXkuZW1wdHkoKWAgaWYgbm8gZG9jdW1lbnQgaGFzIGJlZW4gaW5kZXhlZC5cbiAgICAgKi9cbiAgICBkb2N1bWVudEtleSwgXG4gICAgLypcbiAgICAgKiBUaGUgbGFyZ2VzdCBtdXRhdGlvbiBiYXRjaCBpZCB0aGF0J3MgYmVlbiBwcm9jZXNzZWQgYnkgRmlyZXN0b3JlLlxuICAgICAqL1xuICAgIGxhcmdlc3RCYXRjaElkKSB7XG4gICAgICAgIHRoaXMucmVhZFRpbWUgPSByZWFkVGltZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudEtleSA9IGRvY3VtZW50S2V5O1xuICAgICAgICB0aGlzLmxhcmdlc3RCYXRjaElkID0gbGFyZ2VzdEJhdGNoSWQ7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGFuIG9mZnNldCB0aGF0IHNvcnRzIGJlZm9yZSBhbGwgcmVndWxhciBvZmZzZXRzLiAqL1xuICAgIHN0YXRpYyBtaW4oKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhPZmZzZXQoU25hcHNob3RWZXJzaW9uLm1pbigpLCBEb2N1bWVudEtleS5lbXB0eSgpLCBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhbiBvZmZzZXQgdGhhdCBzb3J0cyBhZnRlciBhbGwgcmVndWxhciBvZmZzZXRzLiAqL1xuICAgIHN0YXRpYyBtYXgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhPZmZzZXQoU25hcHNob3RWZXJzaW9uLm1heCgpLCBEb2N1bWVudEtleS5lbXB0eSgpLCBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluZGV4T2Zmc2V0Q29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xuICAgIGxldCBjbXAgPSBsZWZ0LnJlYWRUaW1lLmNvbXBhcmVUbyhyaWdodC5yZWFkVGltZSk7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICBjbXAgPSBEb2N1bWVudEtleS5jb21wYXJhdG9yKGxlZnQuZG9jdW1lbnRLZXksIHJpZ2h0LmRvY3VtZW50S2V5KTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQubGFyZ2VzdEJhdGNoSWQsIHJpZ2h0Lmxhcmdlc3RCYXRjaElkKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IFBSSU1BUllfTEVBU0VfTE9TVF9FUlJPUl9NU0cgPSAnVGhlIGN1cnJlbnQgdGFiIGlzIG5vdCBpbiB0aGUgcmVxdWlyZWQgc3RhdGUgdG8gcGVyZm9ybSB0aGlzIG9wZXJhdGlvbi4gJyArXG4gICAgJ0l0IG1pZ2h0IGJlIG5lY2Vzc2FyeSB0byByZWZyZXNoIHRoZSBicm93c2VyIHRhYi4nO1xuLyoqXG4gKiBBIGJhc2UgY2xhc3MgcmVwcmVzZW50aW5nIGEgcGVyc2lzdGVuY2UgdHJhbnNhY3Rpb24sIGVuY2Fwc3VsYXRpbmcgYm90aCB0aGVcbiAqIHRyYW5zYWN0aW9uJ3Mgc2VxdWVuY2UgbnVtYmVycyBhcyB3ZWxsIGFzIGEgbGlzdCBvZiBvbkNvbW1pdHRlZCBsaXN0ZW5lcnMuXG4gKlxuICogV2hlbiB5b3UgY2FsbCBQZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbigpLCBpdCB3aWxsIGNyZWF0ZSBhIHRyYW5zYWN0aW9uIGFuZFxuICogcGFzcyBpdCB0byB5b3VyIGNhbGxiYWNrLiBZb3UgdGhlbiBwYXNzIGl0IHRvIGFueSBtZXRob2QgdGhhdCBvcGVyYXRlc1xuICogb24gcGVyc2lzdGVuY2UuXG4gKi9cbmNsYXNzIFBlcnNpc3RlbmNlVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm9uQ29tbWl0dGVkTGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIGFkZE9uQ29tbWl0dGVkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5vbkNvbW1pdHRlZExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmFpc2VPbkNvbW1pdHRlZEV2ZW50KCkge1xuICAgICAgICB0aGlzLm9uQ29tbWl0dGVkTGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBWZXJpZmllcyB0aGUgZXJyb3IgdGhyb3duIGJ5IGEgTG9jYWxTdG9yZSBvcGVyYXRpb24uIElmIGEgTG9jYWxTdG9yZVxuICogb3BlcmF0aW9uIGZhaWxzIGJlY2F1c2UgdGhlIHByaW1hcnkgbGVhc2UgaGFzIGJlZW4gdGFrZW4gYnkgYW5vdGhlciBjbGllbnQsXG4gKiB3ZSBpZ25vcmUgdGhlIGVycm9yICh0aGUgcGVyc2lzdGVuY2UgbGF5ZXIgd2lsbCBpbW1lZGlhdGVseSBjYWxsXG4gKiBgYXBwbHlQcmltYXJ5TGVhc2VgIHRvIHByb3BhZ2F0ZSB0aGUgcHJpbWFyeSBzdGF0ZSBjaGFuZ2UpLiBBbGwgb3RoZXIgZXJyb3JzXG4gKiBhcmUgcmUtdGhyb3duLlxuICpcbiAqIEBwYXJhbSBlcnIgLSBBbiBlcnJvciByZXR1cm5lZCBieSBhIExvY2FsU3RvcmUgb3BlcmF0aW9uLlxuICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgd2UgcmVjb3ZlcmVkLCBvciB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgPT09IENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiAmJlxuICAgICAgICBlcnIubWVzc2FnZSA9PT0gUFJJTUFSWV9MRUFTRV9MT1NUX0VSUk9SX01TRykge1xuICAgICAgICBsb2dEZWJ1ZygnTG9jYWxTdG9yZScsICdVbmV4cGVjdGVkbHkgbG9zdCBwcmltYXJ5IGxlYXNlJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQZXJzaXN0ZW5jZVByb21pc2UgaXMgZXNzZW50aWFsbHkgYSByZS1pbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlIGV4Y2VwdFxuICogaXQgaGFzIGEgLm5leHQoKSBtZXRob2QgaW5zdGVhZCBvZiAudGhlbigpIGFuZCAubmV4dCgpIGFuZCAuY2F0Y2goKSBjYWxsYmFja3NcbiAqIGFyZSBleGVjdXRlZCBzeW5jaHJvbm91c2x5IHdoZW4gYSBQZXJzaXN0ZW5jZVByb21pc2UgcmVzb2x2ZXMgcmF0aGVyIHRoYW5cbiAqIGFzeW5jaHJvbm91c2x5IChQcm9taXNlIGltcGxlbWVudGF0aW9ucyB1c2Ugc2V0SW1tZWRpYXRlKCkgb3Igc2ltaWxhcikuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgdG8gaW50ZXJvcGVyYXRlIHdpdGggSW5kZXhlZERCIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseVxuICogY29tbWl0IHRyYW5zYWN0aW9ucyBpZiBjb250cm9sIGlzIHJldHVybmVkIHRvIHRoZSBldmVudCBsb29wIHdpdGhvdXRcbiAqIHN5bmNocm9ub3VzbHkgaW5pdGlhdGluZyBhbm90aGVyIG9wZXJhdGlvbiBvbiB0aGUgdHJhbnNhY3Rpb24uXG4gKlxuICogTk9URTogLnRoZW4oKSBhbmQgLmNhdGNoKCkgb25seSBhbGxvdyBhIHNpbmdsZSBjb25zdW1lciwgdW5saWtlIG5vcm1hbFxuICogUHJvbWlzZXMuXG4gKi9cbmNsYXNzIFBlcnNpc3RlbmNlUHJvbWlzZSB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2spIHtcbiAgICAgICAgLy8gTk9URTogbmV4dC9jYXRjaENhbGxiYWNrIHdpbGwgYWx3YXlzIHBvaW50IHRvIG91ciBvd24gd3JhcHBlciBmdW5jdGlvbnMsXG4gICAgICAgIC8vIG5vdCB0aGUgdXNlcidzIHJhdyBuZXh0KCkgb3IgY2F0Y2goKSBjYWxsYmFja3MuXG4gICAgICAgIHRoaXMubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYXRjaENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgLy8gV2hlbiB0aGUgb3BlcmF0aW9uIHJlc29sdmVzLCB3ZSdsbCBzZXQgcmVzdWx0IG9yIGVycm9yIGFuZCBtYXJrIGlzRG9uZS5cbiAgICAgICAgdGhpcy5yZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaXNEb25lID0gZmFsc2U7XG4gICAgICAgIC8vIFNldCB0byB0cnVlIHdoZW4gLnRoZW4oKSBvciAuY2F0Y2goKSBhcmUgY2FsbGVkIGFuZCBwcmV2ZW50cyBhZGRpdGlvbmFsXG4gICAgICAgIC8vIGNoYWluaW5nLlxuICAgICAgICB0aGlzLmNhbGxiYWNrQXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgY2FsbGJhY2sodmFsdWUgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlIHNob3VsZCBiZSBkZWZpbmVkIHVubGVzcyBUIGlzIFZvaWQsIGJ1dCB3ZSBjYW4ndCBleHByZXNzXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBpbiB0aGUgdHlwZSBzeXN0ZW0uXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbGJhY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICBpZiAodGhpcy5jYXRjaENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXRjaENhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoKGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQodW5kZWZpbmVkLCBmbik7XG4gICAgfVxuICAgIG5leHQobmV4dEZuLCBjYXRjaEZuKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbGxiYWNrQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIGZhaWwoMHhlODMwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxiYWNrQXR0YWNoZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pc0RvbmUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5lcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBTdWNjZXNzKG5leHRGbiwgdGhpcy5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcEZhaWx1cmUoY2F0Y2hGbiwgdGhpcy5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbGJhY2sgPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cmFwU3VjY2VzcyhuZXh0Rm4sIHZhbHVlKS5uZXh0KHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhdGNoQ2FsbGJhY2sgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cmFwRmFpbHVyZShjYXRjaEZuLCBlcnJvcikubmV4dChyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1Byb21pc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5leHQocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdyYXBVc2VyRnVuY3Rpb24oZm4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUGVyc2lzdGVuY2VQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cmFwU3VjY2VzcyhuZXh0Rm4sIHZhbHVlKSB7XG4gICAgICAgIGlmIChuZXh0Rm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBVc2VyRnVuY3Rpb24oKCkgPT4gbmV4dEZuKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIG5leHRGbiwgdGhlbiBSIG11c3QgYmUgdGhlIHNhbWUgYXMgVFxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cmFwRmFpbHVyZShjYXRjaEZuLCBlcnJvcikge1xuICAgICAgICBpZiAoY2F0Y2hGbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcFVzZXJGdW5jdGlvbigoKSA9PiBjYXRjaEZuKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHJlc29sdmUocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyByZWplY3QoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyB3YWl0Rm9yKFxuICAgIC8vIEFjY2VwdCBhbGwgUHJvbWlzZSB0eXBlcyBpbiB3YWl0Rm9yKCkuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhbGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IGV4cGVjdGVkQ291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkQ291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGFsbC5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICsrZXhwZWN0ZWRDb3VudDtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICArK3Jlc29sdmVkQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lICYmIHJlc29sdmVkQ291bnQgPT09IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGVyciA9PiByZWplY3QoZXJyKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkQ291bnQgPT09IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiBwcmVkaWNhdGUgZnVuY3Rpb25zIHRoYXQgYXN5bmNocm9ub3VzbHkgZXZhbHVhdGUgdG8gYVxuICAgICAqIGJvb2xlYW4sIGltcGxlbWVudHMgYSBzaG9ydC1jaXJjdWl0aW5nIGBvcmAgYmV0d2VlbiB0aGUgcmVzdWx0cy4gUHJlZGljYXRlc1xuICAgICAqIHdpbGwgYmUgZXZhbHVhdGVkIHVudGlsIG9uZSBvZiB0aGVtIHJldHVybnMgYHRydWVgLCB0aGVuIHN0b3AuIFRoZSBmaW5hbFxuICAgICAqIHJlc3VsdCB3aWxsIGJlIHdoZXRoZXIgYW55IG9mIHRoZW0gcmV0dXJuZWQgYHRydWVgLlxuICAgICAqL1xuICAgIHN0YXRpYyBvcihwcmVkaWNhdGVzKSB7XG4gICAgICAgIGxldCBwID0gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICBmb3IgKGNvbnN0IHByZWRpY2F0ZSBvZiBwcmVkaWNhdGVzKSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KGlzVHJ1ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoaXNUcnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgc3RhdGljIGZvckVhY2goY29sbGVjdGlvbiwgZikge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBjb2xsZWN0aW9uLmZvckVhY2goKHIsIHMpID0+IHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goZi5jYWxsKHRoaXMsIHIsIHMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLndhaXRGb3IocHJvbWlzZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25jdXJyZW50bHkgbWFwIGFsbCBhcnJheSBlbGVtZW50cyB0aHJvdWdoIGFzeW5jaHJvbm91cyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgbWFwQXJyYXkoYXJyYXksIGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRDb3VudCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoZXhwZWN0ZWRDb3VudCk7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cGVjdGVkQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBpO1xuICAgICAgICAgICAgICAgIGYoYXJyYXlbY3VycmVudF0pLm5leHQocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tjdXJyZW50XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgKytyZXNvbHZlZENvdW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRDb3VudCA9PT0gZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGVyciA9PiByZWplY3QoZXJyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byByZWN1cnNpdmUgUGVyc2lzdGVuY2VQcm9taXNlIGNhbGxzLCB0aGF0IGF2b2lkc1xuICAgICAqIHBvdGVudGlhbCBtZW1vcnkgcHJvYmxlbXMgZnJvbSB1bmJvdW5kZWQgY2hhaW5zIG9mIHByb21pc2VzLlxuICAgICAqXG4gICAgICogVGhlIGBhY3Rpb25gIHdpbGwgYmUgY2FsbGVkIHJlcGVhdGVkbHkgd2hpbGUgYGNvbmRpdGlvbmAgaXMgdHJ1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZG9XaGlsZShjb25kaXRpb24sIGFjdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb24oKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24oKS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBSZWZlcmVuY2VzIHRvIGBpbmRleGVkREJgIGFyZSBndWFyZGVkIGJ5IFNpbXBsZURiLmlzQXZhaWxhYmxlKCkgYW5kIGdldEdsb2JhbCgpXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cbmNvbnN0IExPR19UQUckaSA9ICdTaW1wbGVEYic7XG4vKipcbiAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZXRyeSBhdHRlbXB0cyBmb3IgYW4gSW5kZXhlZERiIHRyYW5zYWN0aW9uIHRoYXQgZmFpbHNcbiAqIHdpdGggYSBET01FeGNlcHRpb24uXG4gKi9cbmNvbnN0IFRSQU5TQUNUSU9OX1JFVFJZX0NPVU5UID0gMztcbi8qKlxuICogV3JhcHMgYW4gSURCVHJhbnNhY3Rpb24gYW5kIGV4cG9zZXMgYSBzdG9yZSgpIG1ldGhvZCB0byBnZXQgYSBoYW5kbGUgdG8gYVxuICogc3BlY2lmaWMgb2JqZWN0IHN0b3JlLlxuICovXG5jbGFzcyBTaW1wbGVEYlRyYW5zYWN0aW9uIHtcbiAgICBzdGF0aWMgb3BlbihkYiwgYWN0aW9uLCBtb2RlLCBvYmplY3RTdG9yZU5hbWVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpbXBsZURiVHJhbnNhY3Rpb24oYWN0aW9uLCBkYi50cmFuc2FjdGlvbihvYmplY3RTdG9yZU5hbWVzLCBtb2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGFjdGlvbiwgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3IoYWN0aW9uLCB0cmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBJbmRleGVkRGIgdHJhbnNhY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24ub25hYm9ydCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5lcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbkRlZmVycmVkLnJlamVjdChuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihhY3Rpb24sIHRyYW5zYWN0aW9uLmVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24ub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBjaGVja0ZvckFuZFJlcG9ydGlPU0Vycm9yKGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5yZWplY3QobmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoYWN0aW9uLCBlcnJvcikpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgY29tcGxldGlvblByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbiAgICBhYm9ydChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbkRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ0Fib3J0aW5nIHRyYW5zYWN0aW9uOicsIGVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdDbGllbnQtaW5pdGlhdGVkIGFib3J0Jyk7XG4gICAgICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1heWJlQ29tbWl0KCkge1xuICAgICAgICAvLyBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBWMyBJbmRleGVkREIsIHdlIGludm9rZSBjb21taXQoKSBleHBsaWNpdGx5IHRvXG4gICAgICAgIC8vIHNwZWVkIHVwIGluZGV4IERCIHByb2Nlc3NpbmcgaWYgdGhlIGV2ZW50IGxvb3AgcmVtYWlucyBibG9ja3MuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IG1heWJlVjNJbmRleGVkRGIgPSB0aGlzLnRyYW5zYWN0aW9uO1xuICAgICAgICBpZiAoIXRoaXMuYWJvcnRlZCAmJiB0eXBlb2YgbWF5YmVWM0luZGV4ZWREYi5jb21taXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlVjNJbmRleGVkRGIuY29tbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFNpbXBsZURiU3RvcmU8S2V5VHlwZSwgVmFsdWVUeXBlPiBmb3IgdGhlIHNwZWNpZmllZCBzdG9yZS4gQWxsXG4gICAgICogb3BlcmF0aW9ucyBwZXJmb3JtZWQgb24gdGhlIFNpbXBsZURiU3RvcmUgaGFwcGVuIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGlzXG4gICAgICogdHJhbnNhY3Rpb24gYW5kIGl0IGNhbm5vdCBiZSB1c2VkIGFueW1vcmUgb25jZSB0aGUgdHJhbnNhY3Rpb24gaXNcbiAgICAgKiBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2UgY2FuJ3QgYWN0dWFsbHkgZW5mb3JjZSB0aGF0IHRoZSBLZXlUeXBlIGFuZCBWYWx1ZVR5cGUgYXJlXG4gICAgICogY29ycmVjdCwgYnV0IHRoZXkgYWxsb3cgdHlwZSBzYWZldHkgdGhyb3VnaCB0aGUgcmVzdCBvZiB0aGUgY29uc3VtaW5nIGNvZGUuXG4gICAgICovXG4gICAgc3RvcmUoc3RvcmVOYW1lKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy50cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZURiU3RvcmUoc3RvcmUpO1xuICAgIH1cbn1cbi8qKlxuICogUHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBJbmRleGVkRGIgd2l0aCBhIHNpbXBsaWZpZWQgaW50ZXJmYWNlIHRoYXQgdXNlc1xuICogUHJvbWlzZS1saWtlIHJldHVybiB2YWx1ZXMgdG8gY2hhaW4gb3BlcmF0aW9ucy4gUmVhbCBwcm9taXNlcyBjYW5ub3QgYmUgdXNlZFxuICogc2luY2UgLnRoZW4oKSBjb250aW51YXRpb25zIGFyZSBleGVjdXRlZCBhc3luY2hyb25vdXNseSAoZS5nLiB2aWFcbiAqIC5zZXRJbW1lZGlhdGUpLCB3aGljaCB3b3VsZCBjYXVzZSBJbmRleGVkREIgdG8gZW5kIHRoZSB0cmFuc2FjdGlvbi5cbiAqIFNlZSBQZXJzaXN0ZW5jZVByb21pc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xuY2xhc3MgU2ltcGxlRGIge1xuICAgIC8qKiBEZWxldGVzIHRoZSBzcGVjaWZpZWQgZGF0YWJhc2UuICovXG4gICAgc3RhdGljIGRlbGV0ZShuYW1lKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ1JlbW92aW5nIGRhdGFiYXNlOicsIG5hbWUpO1xuICAgICAgICBjb25zdCBnbG9iYWxzID0gZ2V0R2xvYmFsKCk7XG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdChnbG9iYWxzLmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShuYW1lKSkudG9Qcm9taXNlKCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgSW5kZXhlZERCIGlzIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gKi9cbiAgICBzdGF0aWMgaXNBdmFpbGFibGUoKSB7XG4gICAgICAgIGlmICghaXNJbmRleGVkREJBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChTaW1wbGVEYi5pc01vY2tQZXJzaXN0ZW5jZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBleHRlbnNpdmVseSB1c2UgaW5kZXhlZCBhcnJheSB2YWx1ZXMgYW5kIGNvbXBvdW5kIGtleXMsXG4gICAgICAgIC8vIHdoaWNoIElFIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0LiBIb3dldmVyLCB0aGV5IHN0aWxsIGhhdmUgaW5kZXhlZERCXG4gICAgICAgIC8vIGRlZmluZWQgb24gdGhlIHdpbmRvdywgc28gd2UgbmVlZCB0byBjaGVjayBmb3IgdGhlbSBoZXJlIGFuZCBtYWtlIHN1cmVcbiAgICAgICAgLy8gdG8gcmV0dXJuIHRoYXQgcGVyc2lzdGVuY2UgaXMgbm90IGVuYWJsZWQgZm9yIHRob3NlIGJyb3dzZXJzLlxuICAgICAgICAvLyBGb3IgdHJhY2tpbmcgc3VwcG9ydCBvZiB0aGlzIGZlYXR1cmUsIHNlZSBoZXJlOlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL3N0YXR1cy9pbmRleGVkZGJhcnJheXNhbmRtdWx0aWVudHJ5c3VwcG9ydC9cbiAgICAgICAgLy8gQ2hlY2sgdGhlIFVBIHN0cmluZyB0byBmaW5kIG91dCB0aGUgYnJvd3Nlci5cbiAgICAgICAgY29uc3QgdWEgPSBnZXRVQSgpO1xuICAgICAgICAvLyBJRSAxMFxuICAgICAgICAvLyB1YSA9ICdNb3ppbGxhLzUuMCAoY29tcGF0aWJsZTsgTVNJRSAxMC4wOyBXaW5kb3dzIE5UIDYuMjsgVHJpZGVudC82LjApJztcbiAgICAgICAgLy8gSUUgMTFcbiAgICAgICAgLy8gdWEgPSAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgNi4zOyBUcmlkZW50LzcuMDsgcnY6MTEuMCkgbGlrZSBHZWNrbyc7XG4gICAgICAgIC8vIEVkZ2VcbiAgICAgICAgLy8gdWEgPSAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV09XNjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsXG4gICAgICAgIC8vIGxpa2UgR2Vja28pIENocm9tZS8zOS4wLjIxNzEuNzEgU2FmYXJpLzUzNy4zNiBFZGdlLzEyLjAnO1xuICAgICAgICAvLyBpT1MgU2FmYXJpOiBEaXNhYmxlIGZvciB1c2VycyBydW5uaW5nIGlPUyB2ZXJzaW9uIDwgMTAuXG4gICAgICAgIGNvbnN0IGlPU1ZlcnNpb24gPSBTaW1wbGVEYi5nZXRJT1NWZXJzaW9uKHVhKTtcbiAgICAgICAgY29uc3QgaXNVbnN1cHBvcnRlZElPUyA9IDAgPCBpT1NWZXJzaW9uICYmIGlPU1ZlcnNpb24gPCAxMDtcbiAgICAgICAgLy8gQW5kcm9pZCBicm93c2VyOiBEaXNhYmxlIGZvciB1c2VycyBydW5uaW5nIHZlcnNpb24gPCA0LjUuXG4gICAgICAgIGNvbnN0IGFuZHJvaWRWZXJzaW9uID0gZ2V0QW5kcm9pZFZlcnNpb24odWEpO1xuICAgICAgICBjb25zdCBpc1Vuc3VwcG9ydGVkQW5kcm9pZCA9IDAgPCBhbmRyb2lkVmVyc2lvbiAmJiBhbmRyb2lkVmVyc2lvbiA8IDQuNTtcbiAgICAgICAgaWYgKHVhLmluZGV4T2YoJ01TSUUgJykgPiAwIHx8XG4gICAgICAgICAgICB1YS5pbmRleE9mKCdUcmlkZW50LycpID4gMCB8fFxuICAgICAgICAgICAgdWEuaW5kZXhPZignRWRnZS8nKSA+IDAgfHxcbiAgICAgICAgICAgIGlzVW5zdXBwb3J0ZWRJT1MgfHxcbiAgICAgICAgICAgIGlzVW5zdXBwb3J0ZWRBbmRyb2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGJhY2tpbmcgSW5kZXhlZERCIHN0b3JlIGlzIHRoZSBOb2RlIEluZGV4ZWREQlNoaW1cbiAgICAgKiAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9heGVtY2xpb24vSW5kZXhlZERCU2hpbSkuXG4gICAgICovXG4gICAgc3RhdGljIGlzTW9ja1BlcnNpc3RlbmNlKCkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgcHJvY2Vzcy5lbnY/LlVTRV9NT0NLX1BFUlNJU1RFTkNFID09PSAnWUVTJyk7XG4gICAgfVxuICAgIC8qKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmcm9tIGEgdHJhbnNhY3Rpb24uICovXG4gICAgc3RhdGljIGdldFN0b3JlKHR4biwgc3RvcmUpIHtcbiAgICAgICAgcmV0dXJuIHR4bi5zdG9yZShzdG9yZSk7XG4gICAgfVxuICAgIC8vIHZpc2libGUgZm9yIHRlc3RpbmdcbiAgICAvKiogUGFyc2UgVXNlciBBZ2VudCB0byBkZXRlcm1pbmUgaU9TIHZlcnNpb24uIFJldHVybnMgLTEgaWYgbm90IGZvdW5kLiAqL1xuICAgIHN0YXRpYyBnZXRJT1NWZXJzaW9uKHVhKSB7XG4gICAgICAgIGNvbnN0IGlPU1ZlcnNpb25SZWdleCA9IHVhLm1hdGNoKC9pKD86cGhvbmV8cGFkfHBvZCkgb3MgKFtcXGRfXSspL2kpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gaU9TVmVyc2lvblJlZ2V4XG4gICAgICAgICAgICA/IGlPU1ZlcnNpb25SZWdleFsxXS5zcGxpdCgnXycpLnNsaWNlKDAsIDIpLmpvaW4oJy4nKVxuICAgICAgICAgICAgOiAnLTEnO1xuICAgICAgICByZXR1cm4gTnVtYmVyKHZlcnNpb24pO1xuICAgIH1cbiAgICAvKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2ltcGxlRGIgd3JhcHBlciBmb3IgSW5kZXhlZERiIGRhdGFiYXNlIGBuYW1lYC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBgdmVyc2lvbmAgbXVzdCBub3QgYmUgYSBkb3duZ3JhZGUuIEluZGV4ZWREQiBkb2VzIG5vdCBzdXBwb3J0XG4gICAgICogZG93bmdyYWRpbmcgdGhlIHNjaGVtYSB2ZXJzaW9uLiBXZSBjdXJyZW50bHkgZG8gbm90IHN1cHBvcnQgYW55IHdheSB0byBkb1xuICAgICAqIHZlcnNpb25pbmcgb3V0c2lkZSBvZiBJbmRleGVkREIncyB2ZXJzaW9uaW5nIG1lY2hhbmlzbSwgYXMgb25seVxuICAgICAqIHZlcnNpb24tdXBncmFkZSB0cmFuc2FjdGlvbnMgYXJlIGFsbG93ZWQgdG8gZG8gdGhpbmdzIGxpa2UgY3JlYXRlXG4gICAgICogb2JqZWN0c3RvcmVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZlcnNpb24sIHNjaGVtYUNvbnZlcnRlcikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLnNjaGVtYUNvbnZlcnRlciA9IHNjaGVtYUNvbnZlcnRlcjtcbiAgICAgICAgdGhpcy5sYXN0Q2xvc2VkRGJWZXJzaW9uID0gbnVsbDtcbiAgICAgICAgY29uc3QgaU9TVmVyc2lvbiA9IFNpbXBsZURiLmdldElPU1ZlcnNpb24oZ2V0VUEoKSk7XG4gICAgICAgIC8vIE5PVEU6IEFjY29yZGluZyB0byBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTk3MDUwLCB0aGVcbiAgICAgICAgLy8gYnVnIHdlJ3JlIGNoZWNraW5nIGZvciBzaG91bGQgZXhpc3QgaW4gaU9TID49IDEyLjIgYW5kIDwgMTMsIGJ1dCBmb3JcbiAgICAgICAgLy8gd2hhdGV2ZXIgcmVhc29uIGl0J3MgbXVjaCBoYXJkZXIgdG8gaGl0IGFmdGVyIDEyLjIgc28gd2Ugb25seSBwcm9hY3RpdmVseVxuICAgICAgICAvLyBsb2cgb24gMTIuMi5cbiAgICAgICAgaWYgKGlPU1ZlcnNpb24gPT09IDEyLjIpIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKCdGaXJlc3RvcmUgcGVyc2lzdGVuY2Ugc3VmZmVycyBmcm9tIGEgYnVnIGluIGlPUyAxMi4yICcgK1xuICAgICAgICAgICAgICAgICdTYWZhcmkgdGhhdCBtYXkgY2F1c2UgeW91ciBhcHAgdG8gc3RvcCB3b3JraW5nLiBTZWUgJyArXG4gICAgICAgICAgICAgICAgJ2h0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS81NjQ5NjI5Ni8xMTA5MTUgZm9yIGRldGFpbHMgJyArXG4gICAgICAgICAgICAgICAgJ2FuZCBhIHBvdGVudGlhbCB3b3JrYXJvdW5kLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBzcGVjaWZpZWQgZGF0YWJhc2UsIGNyZWF0aW5nIG9yIHVwZ3JhZGluZyBpdCBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgYXN5bmMgZW5zdXJlRGIoYWN0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5kYikge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnT3BlbmluZyBkYXRhYmFzZTonLCB0aGlzLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5kYiA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKG1pa2VsZWhlbik6IEludmVzdGlnYXRlIGJyb3dzZXIgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW5kZXhlZERCX0FQSS9Vc2luZ19JbmRleGVkREJcbiAgICAgICAgICAgICAgICAvLyBzdWdnZXN0cyBJRTkgYW5kIG9sZGVyIFdlYktpdCBicm93c2VycyBoYW5kbGUgdXBncmFkZVxuICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVudGx5LiBUaGV5IGV4cGVjdCBzZXRWZXJzaW9uLCBhcyBkZXNjcmliZWQgaGVyZTpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSURCVmVyc2lvbkNoYW5nZVJlcXVlc3Qvc2V0VmVyc2lvblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLm5hbWUsIHRoaXMudmVyc2lvbik7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGIgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRiKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25ibG9ja2VkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoYWN0aW9uLCAnQ2Fubm90IHVwZ3JhZGUgSW5kZXhlZERCIHNjaGVtYSB3aGlsZSBhbm90aGVyIHRhYiBpcyBvcGVuLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdDbG9zZSBhbGwgdGFicyB0aGF0IGFjY2VzcyBGaXJlc3RvcmUgYW5kIHJlbG9hZCB0aGlzIHBhZ2UgdG8gcHJvY2VlZC4nKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBldmVudC50YXJnZXQuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnVmVyc2lvbkVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdBIG5ld2VyIHZlcnNpb24gb2YgdGhlIEZpcmVzdG9yZSBTREsgd2FzIHByZXZpb3VzbHkgdXNlZCBhbmQgc28gdGhlIHBlcnNpc3RlZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSB2ZXJzaW9uIG9mIHRoZSBTREsgeW91IGFyZSBub3cgdXNpbmcuIFRoZSBTREsgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpbGwgb3BlcmF0ZSB3aXRoIHBlcnNpc3RlbmNlIGRpc2FibGVkLiBJZiB5b3UgbmVlZCBwZXJzaXN0ZW5jZSwgcGxlYXNlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZS11cGdyYWRlIHRvIGEgbmV3ZXIgdmVyc2lvbiBvZiB0aGUgU0RLIG9yIGVsc2UgY2xlYXIgdGhlIHBlcnNpc3RlZCBJbmRleGVkREIgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEgZm9yIHlvdXIgYXBwIHRvIHN0YXJ0IGZyZXNoLicpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnSW52YWxpZFN0YXRlRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ1VuYWJsZSB0byBvcGVuIGFuIEluZGV4ZWREQiBjb25uZWN0aW9uLiBUaGlzIGNvdWxkIGJlIGR1ZSB0byBydW5uaW5nIGluIGEgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUgYnJvd3Npbmcgc2Vzc2lvbiBvbiBhIGJyb3dzZXIgd2hvc2UgcHJpdmF0ZSBicm93c2luZyBzZXNzaW9ucyBkbyBub3QgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N1cHBvcnQgSW5kZXhlZERCOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGFjdGlvbiwgZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnRGF0YWJhc2UgXCInICsgdGhpcy5uYW1lICsgJ1wiIHJlcXVpcmVzIHVwZ3JhZGUgZnJvbSB2ZXJzaW9uOicsIGV2ZW50Lm9sZFZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZW1hQ29udmVydGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY3JlYXRlT3JVcGdyYWRlKGRiLCByZXF1ZXN0LnRyYW5zYWN0aW9uLCBldmVudC5vbGRWZXJzaW9uLCB0aGlzLnZlcnNpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdEYXRhYmFzZSB1cGdyYWRlIHRvIHZlcnNpb24gJyArIHRoaXMudmVyc2lvbiArICcgY29tcGxldGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb25jaGFuZ2VsaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5kYi5vbnZlcnNpb25jaGFuZ2UgPSBldmVudCA9PiB0aGlzLnZlcnNpb25jaGFuZ2VsaXN0ZW5lcihldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGI7XG4gICAgfVxuICAgIHNldFZlcnNpb25DaGFuZ2VMaXN0ZW5lcih2ZXJzaW9uQ2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uY2hhbmdlbGlzdGVuZXIgPSB2ZXJzaW9uQ2hhbmdlTGlzdGVuZXI7XG4gICAgICAgIGlmICh0aGlzLmRiKSB7XG4gICAgICAgICAgICB0aGlzLmRiLm9udmVyc2lvbmNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uQ2hhbmdlTGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBydW5UcmFuc2FjdGlvbihhY3Rpb24sIG1vZGUsIG9iamVjdFN0b3JlcywgdHJhbnNhY3Rpb25Gbikge1xuICAgICAgICBjb25zdCByZWFkb25seSA9IG1vZGUgPT09ICdyZWFkb25seSc7XG4gICAgICAgIGxldCBhdHRlbXB0TnVtYmVyID0gMDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICsrYXR0ZW1wdE51bWJlcjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYiA9IGF3YWl0IHRoaXMuZW5zdXJlRGIoYWN0aW9uKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IFNpbXBsZURiVHJhbnNhY3Rpb24ub3Blbih0aGlzLmRiLCBhY3Rpb24sIHJlYWRvbmx5ID8gJ3JlYWRvbmx5JyA6ICdyZWFkd3JpdGUnLCBvYmplY3RTdG9yZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRm5SZXN1bHQgPSB0cmFuc2FjdGlvbkZuKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5tYXliZUNvbW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFib3J0IHRoZSB0cmFuc2FjdGlvbiBpZiB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFib3J0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2Fubm90IGFjdHVhbGx5IHJlY292ZXIsIGFuZCBjYWxsaW5nIGBhYm9ydCgpYCB3aWxsIGNhdXNlIHRoZSB0cmFuc2FjdGlvbidzXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRpb24gcHJvbWlzZSB0byBiZSByZWplY3RlZC4gVGhpcyBpbiB0dXJuIG1lYW5zIHRoYXQgd2Ugd29uJ3QgdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGB0cmFuc2FjdGlvbkZuUmVzdWx0YCBiZWxvdy4gV2UgcmV0dXJuIGEgcmVqZWN0aW9uIGhlcmUgc28gdGhhdCB3ZSBkb24ndCBhZGQgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvc3NpYmlsaXR5IG9mIHJldHVybmluZyBgdm9pZGAgdG8gdGhlIHR5cGUgb2YgYHRyYW5zYWN0aW9uRm5SZXN1bHRgLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRvUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIC8vIEFzIG5vdGVkIGFib3ZlLCBlcnJvcnMgYXJlIHByb3BhZ2F0ZWQgYnkgYWJvcnRpbmcgdGhlIHRyYW5zYWN0aW9uLiBTb1xuICAgICAgICAgICAgICAgIC8vIHdlIHN3YWxsb3cgYW55IGVycm9yIGhlcmUgdG8gYXZvaWQgdGhlIGJyb3dzZXIgbG9nZ2luZyBpdCBhcyB1bmhhbmRsZWQuXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25GblJlc3VsdC5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBjb21wbGV0ZSAoaS5lLiBJbmRleGVkRGIncyBvbnN1Y2Nlc3MgZXZlbnQgdG9cbiAgICAgICAgICAgICAgICAvLyBmaXJlKSwgYnV0IHN0aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgdHJhbnNhY3Rpb25GblJlc3VsdCBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNhbGxlci5cbiAgICAgICAgICAgICAgICBhd2FpdCB0cmFuc2FjdGlvbi5jb21wbGV0aW9uUHJvbWlzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25GblJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oc2NobWlkdC1zZWJhc3RpYW4pOiBXZSBjb3VsZCBwcm9iYWJseSBiZSBzbWFydGVyIGFib3V0IHRoaXMgYW5kXG4gICAgICAgICAgICAgICAgLy8gbm90IHJldHJ5IGV4Y2VwdGlvbnMgdGhhdCBhcmUgbGlrZWx5IHVucmVjb3ZlcmFibGUgKHN1Y2ggYXMgcXVvdGFcbiAgICAgICAgICAgICAgICAvLyBleGNlZWRlZCBlcnJvcnMpLlxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdlIGNhbm5vdCB1c2UgYW4gaW5zdGFuY2VvZiBjaGVjayBmb3IgRmlyZXN0b3JlRXhjZXB0aW9uLCBzaW5jZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gaXMgd3JhcHBlZCBpbiBhIGdlbmVyaWMgZXJyb3IgYnkgb3VyIGFzeW5jL2F3YWl0IGhhbmRsaW5nLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5YWJsZSA9IGVycm9yLm5hbWUgIT09ICdGaXJlYmFzZUVycm9yJyAmJlxuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0TnVtYmVyIDwgVFJBTlNBQ1RJT05fUkVUUllfQ09VTlQ7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnVHJhbnNhY3Rpb24gZmFpbGVkIHdpdGggZXJyb3I6JywgZXJyb3IubWVzc2FnZSwgJ1JldHJ5aW5nOicsIHJldHJ5YWJsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGlmICghcmV0cnlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5kYikge1xuICAgICAgICAgICAgdGhpcy5kYi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGIgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqIFBhcnNlIFVzZXIgQWdlbnQgdG8gZGV0ZXJtaW5lIEFuZHJvaWQgdmVyc2lvbi4gUmV0dXJucyAtMSBpZiBub3QgZm91bmQuICovXG5mdW5jdGlvbiBnZXRBbmRyb2lkVmVyc2lvbih1YSkge1xuICAgIGNvbnN0IGFuZHJvaWRWZXJzaW9uUmVnZXggPSB1YS5tYXRjaCgvQW5kcm9pZCAoW1xcZC5dKykvaSk7XG4gICAgY29uc3QgdmVyc2lvbiA9IGFuZHJvaWRWZXJzaW9uUmVnZXhcbiAgICAgICAgPyBhbmRyb2lkVmVyc2lvblJlZ2V4WzFdLnNwbGl0KCcuJykuc2xpY2UoMCwgMikuam9pbignLicpXG4gICAgICAgIDogJy0xJztcbiAgICByZXR1cm4gTnVtYmVyKHZlcnNpb24pO1xufVxuLyoqXG4gKiBBIGNvbnRyb2xsZXIgZm9yIGl0ZXJhdGluZyBvdmVyIGEga2V5IHJhbmdlIG9yIGluZGV4LiBJdCBhbGxvd3MgYW4gaXRlcmF0ZVxuICogY2FsbGJhY2sgdG8gZGVsZXRlIHRoZSBjdXJyZW50bHktcmVmZXJlbmNlZCBvYmplY3QsIG9yIGp1bXAgdG8gYSBuZXcga2V5XG4gKiB3aXRoaW4gdGhlIGtleSByYW5nZSBvciBpbmRleC5cbiAqL1xuY2xhc3MgSXRlcmF0aW9uQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoZGJDdXJzb3IpIHtcbiAgICAgICAgdGhpcy5kYkN1cnNvciA9IGRiQ3Vyc29yO1xuICAgICAgICB0aGlzLnNob3VsZFN0b3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZXh0S2V5ID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGlzRG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvdWxkU3RvcDtcbiAgICB9XG4gICAgZ2V0IHNraXBUb0tleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dEtleTtcbiAgICB9XG4gICAgc2V0IGN1cnNvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLmRiQ3Vyc29yID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCB0byBzdG9wIGl0ZXJhdGlvbiBhdCBhbnkgcG9pbnQuXG4gICAgICovXG4gICAgZG9uZSgpIHtcbiAgICAgICAgdGhpcy5zaG91bGRTdG9wID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIHRvIHNraXAgdG8gdGhhdCBuZXh0IGtleSwgd2hpY2ggY291bGQgYmVcbiAgICAgKiBhbiBpbmRleCBvciBhIHByaW1hcnkga2V5LlxuICAgICAqL1xuICAgIHNraXAoa2V5KSB7XG4gICAgICAgIHRoaXMubmV4dEtleSA9IGtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRoZSBjdXJyZW50IGN1cnNvciB2YWx1ZSBmcm9tIHRoZSBvYmplY3Qgc3RvcmUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBZb3UgQ0FOTk9UIGRvIHRoaXMgd2l0aCBhIGtleXNPbmx5IHF1ZXJ5LlxuICAgICAqL1xuICAgIGRlbGV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBSZXF1ZXN0KHRoaXMuZGJDdXJzb3IuZGVsZXRlKCkpO1xuICAgIH1cbn1cbi8qKiBBbiBlcnJvciB0aGF0IHdyYXBzIGV4Y2VwdGlvbnMgdGhhdCB0aHJvd24gZHVyaW5nIEluZGV4ZWREQiBleGVjdXRpb24uICovXG5jbGFzcyBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yIGV4dGVuZHMgRmlyZXN0b3JlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGFjdGlvbk5hbWUsIGNhdXNlKSB7XG4gICAgICAgIHN1cGVyKENvZGUuVU5BVkFJTEFCTEUsIGBJbmRleGVkREIgdHJhbnNhY3Rpb24gJyR7YWN0aW9uTmFtZX0nIGZhaWxlZDogJHtjYXVzZX1gKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3InO1xuICAgIH1cbn1cbi8qKiBWZXJpZmllcyB3aGV0aGVyIGBlYCBpcyBhbiBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yLiAqL1xuZnVuY3Rpb24gaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpIHtcbiAgICAvLyBVc2UgbmFtZSBlcXVhbGl0eSwgYXMgaW5zdGFuY2VvZiBjaGVja3Mgb24gZXJyb3JzIGRvbid0IHdvcmsgd2l0aCBlcnJvcnNcbiAgICAvLyB0aGF0IHdyYXAgb3RoZXIgZXJyb3JzLlxuICAgIHJldHVybiBlLm5hbWUgPT09ICdJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yJztcbn1cbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCBhbiBJREJPYmplY3RTdG9yZSBwcm92aWRpbmcgYW4gQVBJIHRoYXQ6XG4gKlxuICogMSkgSGFzIGdlbmVyaWMgS2V5VHlwZSAvIFZhbHVlVHlwZSBwYXJhbWV0ZXJzIHRvIHByb3ZpZGUgc3Ryb25nbHktdHlwZWRcbiAqIG1ldGhvZHMgZm9yIGFjdGluZyBhZ2FpbnN0IHRoZSBvYmplY3Qgc3RvcmUuXG4gKiAyKSBEZWFscyB3aXRoIEluZGV4ZWREQidzIG9uc3VjY2VzcyAvIG9uZXJyb3IgZXZlbnQgY2FsbGJhY2tzLCBtYWtpbmcgZXZlcnlcbiAqIG1ldGhvZCByZXR1cm4gYSBQZXJzaXN0ZW5jZVByb21pc2UgaW5zdGVhZC5cbiAqIDMpIFByb3ZpZGVzIGEgaGlnaGVyLWxldmVsIEFQSSB0byBhdm9pZCBuZWVkaW5nIHRvIGRvIGV4Y2Vzc2l2ZSB3cmFwcGluZyBvZlxuICogaW50ZXJtZWRpYXRlIEluZGV4ZWREQiB0eXBlcyAoSURCQ3Vyc29yV2l0aFZhbHVlLCBldGMuKVxuICovXG5jbGFzcyBTaW1wbGVEYlN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihzdG9yZSkge1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgfVxuICAgIHB1dChrZXlPclZhbHVlLCB2YWx1ZSkge1xuICAgICAgICBsZXQgcmVxdWVzdDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ1BVVCcsIHRoaXMuc3RvcmUubmFtZSwga2V5T3JWYWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgcmVxdWVzdCA9IHRoaXMuc3RvcmUucHV0KHZhbHVlLCBrZXlPclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ1BVVCcsIHRoaXMuc3RvcmUubmFtZSwgJzxhdXRvLWtleT4nLCBrZXlPclZhbHVlKTtcbiAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLnN0b3JlLnB1dChrZXlPclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JhcFJlcXVlc3QocmVxdWVzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgdmFsdWUgaW50byBhbiBPYmplY3QgU3RvcmUgYW5kIHJldHVybnMgdGhlIG5ldyBrZXkuIFNpbWlsYXIgdG9cbiAgICAgKiBJbmRleGVkRGIncyBgYWRkKClgLCB0aGlzIG1ldGhvZCB3aWxsIGZhaWwgb24gcHJpbWFyeSBrZXkgY29sbGlzaW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBvYmplY3QgdG8gd3JpdGUuXG4gICAgICogQHJldHVybnMgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gYWRkLlxuICAgICAqL1xuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdBREQnLCB0aGlzLnN0b3JlLm5hbWUsIHZhbHVlLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnN0b3JlLmFkZCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdChyZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgZnJvbSB0aGUgc3BlY2lmaWVkIHN0b3JlLCBvciBudWxsXG4gICAgICogaWYgbm8gb2JqZWN0IGV4aXN0cyB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LlxuICAgICAqXG4gICAgICogQGtleSBUaGUga2V5IG9mIHRoZSBvYmplY3QgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBvciBudWxsIGlmIG5vIG9iamVjdCBleGlzdHMuXG4gICAgICovXG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5zdG9yZS5nZXQoa2V5KTtcbiAgICAgICAgLy8gV2UncmUgZG9pbmcgYW4gdW5zYWZlIGNhc3QgdG8gVmFsdWVUeXBlLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gd3JhcFJlcXVlc3QocmVxdWVzdCkubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIG5vbmV4aXN0ZW5jZSB0byBudWxsLlxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ0dFVCcsIHRoaXMuc3RvcmUubmFtZSwga2V5LCByZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnREVMRVRFJywgdGhpcy5zdG9yZS5uYW1lLCBrZXkpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5zdG9yZS5kZWxldGUoa2V5KTtcbiAgICAgICAgcmV0dXJuIHdyYXBSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB3ZSBldmVyIG5lZWQgbW9yZSBvZiB0aGUgY291bnQgdmFyaWFudHMsIHdlIGNhbiBhZGQgb3ZlcmxvYWRzLiBGb3Igbm93LFxuICAgICAqIGFsbCB3ZSBuZWVkIGlzIHRvIGNvdW50IGV2ZXJ5dGhpbmcgaW4gYSBzdG9yZS5cbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBzdG9yZS5cbiAgICAgKi9cbiAgICBjb3VudCgpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnQ09VTlQnLCB0aGlzLnN0b3JlLm5hbWUpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5zdG9yZS5jb3VudCgpO1xuICAgICAgICByZXR1cm4gd3JhcFJlcXVlc3QocmVxdWVzdCk7XG4gICAgfVxuICAgIGxvYWRBbGwoaW5kZXhPclJhbmdlLCByYW5nZSkge1xuICAgICAgICBjb25zdCBpdGVyYXRlT3B0aW9ucyA9IHRoaXMub3B0aW9ucyhpbmRleE9yUmFuZ2UsIHJhbmdlKTtcbiAgICAgICAgLy8gVXNlIGBnZXRBbGwoKWAgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgSW5kZXhlZERCIHYzLCBhcyBpdCBpcyByb3VnaGx5XG4gICAgICAgIC8vIDIwJSBmYXN0ZXIuXG4gICAgICAgIGNvbnN0IHN0b3JlID0gaXRlcmF0ZU9wdGlvbnMuaW5kZXhcbiAgICAgICAgICAgID8gdGhpcy5zdG9yZS5pbmRleChpdGVyYXRlT3B0aW9ucy5pbmRleClcbiAgICAgICAgICAgIDogdGhpcy5zdG9yZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdG9yZS5nZXRBbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5nZXRBbGwoaXRlcmF0ZU9wdGlvbnMucmFuZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5jdXJzb3IoaXRlcmF0ZU9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0ZUN1cnNvcihjdXJzb3IsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH0pLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIGZpcnN0IGBjb3VudGAgZWxlbWVudHMgZnJvbSB0aGUgcHJvdmlkZWQgaW5kZXggcmFuZ2UuIExvYWRzIGFsbFxuICAgICAqIGVsZW1lbnRzIGlmIG5vIGxpbWl0IGlzIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIGxvYWRGaXJzdChyYW5nZSwgY291bnQpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuc3RvcmUuZ2V0QWxsKHJhbmdlLCBjb3VudCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGNvdW50KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlbGV0ZUFsbChpbmRleE9yUmFuZ2UsIHJhbmdlKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ0RFTEVURSBBTEwnLCB0aGlzLnN0b3JlLm5hbWUpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zKGluZGV4T3JSYW5nZSwgcmFuZ2UpO1xuICAgICAgICBvcHRpb25zLmtleXNPbmx5ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuY3Vyc29yKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlQ3Vyc29yKGN1cnNvciwgKGtleSwgdmFsdWUsIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIC8vIE5PVEU6IENhbGxpbmcgZGVsZXRlKCkgb24gYSBjdXJzb3IgaXMgZG9jdW1lbnRlZCBhcyBtb3JlIGVmZmljaWVudCB0aGFuXG4gICAgICAgICAgICAvLyBjYWxsaW5nIGRlbGV0ZSgpIG9uIGFuIG9iamVjdCBzdG9yZSB3aXRoIGEgc2luZ2xlIGtleVxuICAgICAgICAgICAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JREJPYmplY3RTdG9yZS9kZWxldGUpLFxuICAgICAgICAgICAgLy8gaG93ZXZlciwgdGhpcyByZXF1aXJlcyB1cyAqbm90KiB0byB1c2UgYSBrZXlzT25seSBjdXJzb3JcbiAgICAgICAgICAgIC8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSURCQ3Vyc29yL2RlbGV0ZSkuIFdlXG4gICAgICAgICAgICAvLyBtYXkgd2FudCB0byBjb21wYXJlIHRoZSBwZXJmb3JtYW5jZSBvZiBlYWNoIG1ldGhvZC5cbiAgICAgICAgICAgIHJldHVybiBjb250cm9sLmRlbGV0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXRlcmF0ZShvcHRpb25zT3JDYWxsYmFjaywgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc09yQ2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQ2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5jdXJzb3Iob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGVDdXJzb3IoY3Vyc29yLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgYSBzdG9yZSwgYnV0IHdhaXRzIGZvciB0aGUgZ2l2ZW4gY2FsbGJhY2sgdG8gY29tcGxldGUgZm9yXG4gICAgICogZWFjaCBlbnRyeSBiZWZvcmUgaXRlcmF0aW5nIHRoZSBuZXh0IGVudHJ5LiBUaGlzIGFsbG93cyB0aGUgY2FsbGJhY2sgdG8gZG9cbiAgICAgKiBhc3luY2hyb25vdXMgd29yayB0byBkZXRlcm1pbmUgaWYgdGhpcyBpdGVyYXRpb24gc2hvdWxkIGNvbnRpbnVlLlxuICAgICAqXG4gICAgICogVGhlIHByb3ZpZGVkIGNhbGxiYWNrIHNob3VsZCByZXR1cm4gYHRydWVgIHRvIGNvbnRpbnVlIGl0ZXJhdGlvbiwgYW5kXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXRlcmF0ZVNlcmlhbChjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBjdXJzb3JSZXF1ZXN0ID0gdGhpcy5jdXJzb3Ioe30pO1xuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGNoZWNrRm9yQW5kUmVwb3J0aU9TRXJyb3IoZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGN1cnNvclJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY3Vyc29yLnByaW1hcnlLZXksIGN1cnNvci52YWx1ZSkubmV4dChzaG91bGRDb250aW51ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRDb250aW51ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpdGVyYXRlQ3Vyc29yKGN1cnNvclJlcXVlc3QsIGZuKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEl0ZXJhdGlvbkNvbnRyb2xsZXIoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyUmVzdWx0ID0gZm4oY3Vyc29yLnByaW1hcnlLZXksIGN1cnNvci52YWx1ZSwgY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJSZXN1bHQgaW5zdGFuY2VvZiBQZXJzaXN0ZW5jZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlclByb21pc2UgPSB1c2VyUmVzdWx0LmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godXNlclByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5pc0RvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250cm9sbGVyLnNraXBUb0tleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShjb250cm9sbGVyLnNraXBUb0tleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihyZXN1bHRzKSk7XG4gICAgfVxuICAgIG9wdGlvbnMoaW5kZXhPclJhbmdlLCByYW5nZSkge1xuICAgICAgICBsZXQgaW5kZXhOYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaW5kZXhPclJhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXhPclJhbmdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGluZGV4TmFtZSA9IGluZGV4T3JSYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gaW5kZXhPclJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGluZGV4OiBpbmRleE5hbWUsIHJhbmdlIH07XG4gICAgfVxuICAgIGN1cnNvcihvcHRpb25zKSB7XG4gICAgICAgIGxldCBkaXJlY3Rpb24gPSAnbmV4dCc7XG4gICAgICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdwcmV2JztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbmRleCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnN0b3JlLmluZGV4KG9wdGlvbnMuaW5kZXgpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMua2V5c09ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXgub3BlbktleUN1cnNvcihvcHRpb25zLnJhbmdlLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4Lm9wZW5DdXJzb3Iob3B0aW9ucy5yYW5nZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JlLm9wZW5DdXJzb3Iob3B0aW9ucy5yYW5nZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogV3JhcHMgYW4gSURCUmVxdWVzdCBpbiBhIFBlcnNpc3RlbmNlUHJvbWlzZSwgdXNpbmcgdGhlIG9uc3VjY2VzcyAvIG9uZXJyb3JcbiAqIGhhbmRsZXJzIHRvIHJlc29sdmUgLyByZWplY3QgdGhlIFBlcnNpc3RlbmNlUHJvbWlzZSBhcyBhcHByb3ByaWF0ZS5cbiAqL1xuZnVuY3Rpb24gd3JhcFJlcXVlc3QocmVxdWVzdCkge1xuICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBjaGVja0ZvckFuZFJlcG9ydGlPU0Vycm9yKGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuLy8gR3VhcmQgc28gd2Ugb25seSByZXBvcnQgdGhlIGVycm9yIG9uY2UuXG5sZXQgcmVwb3J0ZWRJT1NFcnJvciA9IGZhbHNlO1xuZnVuY3Rpb24gY2hlY2tGb3JBbmRSZXBvcnRpT1NFcnJvcihlcnJvcikge1xuICAgIGNvbnN0IGlPU1ZlcnNpb24gPSBTaW1wbGVEYi5nZXRJT1NWZXJzaW9uKGdldFVBKCkpO1xuICAgIGlmIChpT1NWZXJzaW9uID49IDEyLjIgJiYgaU9TVmVyc2lvbiA8IDEzKSB7XG4gICAgICAgIGNvbnN0IElPU19FUlJPUiA9ICdBbiBpbnRlcm5hbCBlcnJvciB3YXMgZW5jb3VudGVyZWQgaW4gdGhlIEluZGV4ZWQgRGF0YWJhc2Ugc2VydmVyJztcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5kZXhPZihJT1NfRVJST1IpID49IDApIHtcbiAgICAgICAgICAgIC8vIFdyYXAgZXJyb3IgaW4gYSBtb3JlIGRlc2NyaXB0aXZlIG9uZS5cbiAgICAgICAgICAgIGNvbnN0IG5ld0Vycm9yID0gbmV3IEZpcmVzdG9yZUVycm9yKCdpbnRlcm5hbCcsIGBJT1NfSU5ERVhFRERCX0JVRzE6IEluZGV4ZWREYiBoYXMgdGhyb3duICcke0lPU19FUlJPUn0nLiBUaGlzIGlzIGxpa2VseSBgICtcbiAgICAgICAgICAgICAgICBgZHVlIHRvIGFuIHVuYXZvaWRhYmxlIGJ1ZyBpbiBpT1MuIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvNTY0OTYyOTYvMTEwOTE1IGAgK1xuICAgICAgICAgICAgICAgIGBmb3IgZGV0YWlscyBhbmQgYSBwb3RlbnRpYWwgd29ya2Fyb3VuZC5gKTtcbiAgICAgICAgICAgIGlmICghcmVwb3J0ZWRJT1NFcnJvcikge1xuICAgICAgICAgICAgICAgIHJlcG9ydGVkSU9TRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIFRocm93IGEgZ2xvYmFsIGV4Y2VwdGlvbiBvdXRzaWRlIG9mIHRoaXMgcHJvbWlzZSBjaGFpbiwgZm9yIHRoZSB1c2VyIHRvXG4gICAgICAgICAgICAgICAgLy8gcG90ZW50aWFsbHkgY2F0Y2guXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ld0Vycm9yO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld0Vycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbn1cblxuY29uc3QgTE9HX1RBRyRoID0gJ0luZGV4QmFja2ZpbGxlcic7XG4vKiogSG93IGxvbmcgd2Ugd2FpdCB0byB0cnkgcnVubmluZyBpbmRleCBiYWNrZmlsbCBhZnRlciBTREsgaW5pdGlhbGl6YXRpb24uICovXG5jb25zdCBJTklUSUFMX0JBQ0tGSUxMX0RFTEFZX01TID0gMTUgKiAxMDAwO1xuLyoqIE1pbmltdW0gYW1vdW50IG9mIHRpbWUgYmV0d2VlbiBiYWNrZmlsbCBjaGVja3MsIGFmdGVyIHRoZSBmaXJzdCBvbmUuICovXG5jb25zdCBSRUdVTEFSX0JBQ0tGSUxMX0RFTEFZX01TID0gNjAgKiAxMDAwO1xuLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkb2N1bWVudHMgdG8gcHJvY2VzcyBlYWNoIHRpbWUgYmFja2ZpbGwoKSBpcyBjYWxsZWQuICovXG5jb25zdCBNQVhfRE9DVU1FTlRTX1RPX1BST0NFU1MgPSA1MDtcbi8qKiBUaGlzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgc2NoZWR1bGluZyBvZiBJbmRleCBCYWNrZmlsbGVyLiAqL1xuY2xhc3MgSW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihhc3luY1F1ZXVlLCBiYWNrZmlsbGVyKSB7XG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZSA9IGFzeW5jUXVldWU7XG4gICAgICAgIHRoaXMuYmFja2ZpbGxlciA9IGJhY2tmaWxsZXI7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlKElOSVRJQUxfQkFDS0ZJTExfREVMQVlfTVMpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy50YXNrKSB7XG4gICAgICAgICAgICB0aGlzLnRhc2suY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzdGFydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YXNrICE9PSBudWxsO1xuICAgIH1cbiAgICBzY2hlZHVsZShkZWxheSkge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGgsIGBTY2hlZHVsZWQgaW4gJHtkZWxheX1tc2ApO1xuICAgICAgICB0aGlzLnRhc2sgPSB0aGlzLmFzeW5jUXVldWUuZW5xdWV1ZUFmdGVyRGVsYXkoXCJpbmRleF9iYWNrZmlsbFwiIC8qIFRpbWVySWQuSW5kZXhCYWNrZmlsbCAqLywgZGVsYXksIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50c1Byb2Nlc3NlZCA9IGF3YWl0IHRoaXMuYmFja2ZpbGxlci5iYWNrZmlsbCgpO1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgYERvY3VtZW50cyB3cml0dGVuOiAke2RvY3VtZW50c1Byb2Nlc3NlZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGgsICdJZ25vcmluZyBJbmRleGVkREIgZXJyb3IgZHVyaW5nIGluZGV4IGJhY2tmaWxsOiAnLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNjaGVkdWxlKFJFR1VMQVJfQkFDS0ZJTExfREVMQVlfTVMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogSW1wbGVtZW50cyB0aGUgc3RlcHMgZm9yIGJhY2tmaWxsaW5nIGluZGV4ZXMuICovXG5jbGFzcyBJbmRleEJhY2tmaWxsZXIge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIExvY2FsU3RvcmUgcHJvdmlkZXMgYWNjZXNzIHRvIEluZGV4TWFuYWdlciBhbmQgTG9jYWxEb2N1bWVudFZpZXcuXG4gICAgICogVGhlc2UgcHJvcGVydGllcyB3aWxsIHVwZGF0ZSB3aGVuIHRoZSB1c2VyIGNoYW5nZXMuIENvbnNlcXVlbnRseSxcbiAgICAgKiBtYWtpbmcgYSBsb2NhbCBjb3B5IG9mIEluZGV4TWFuYWdlciBhbmQgTG9jYWxEb2N1bWVudFZpZXcgd2lsbCByZXF1aXJlXG4gICAgICogdXBkYXRlcyBvdmVyIHRpbWUuIFRoZSBzaW1wbGVyIHNvbHV0aW9uIGlzIHRvIHJlbHkgb24gTG9jYWxTdG9yZSB0byBoYXZlXG4gICAgICogYW4gdXAtdG8tZGF0ZSByZWZlcmVuY2VzIHRvIEluZGV4TWFuYWdlciBhbmQgTG9jYWxEb2N1bWVudFN0b3JlLlxuICAgICAqL1xuICAgIGxvY2FsU3RvcmUsIHBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdG9yZSA9IGxvY2FsU3RvcmU7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICB9XG4gICAgYXN5bmMgYmFja2ZpbGwobWF4RG9jdW1lbnRzVG9Qcm9jZXNzID0gTUFYX0RPQ1VNRU5UU19UT19QUk9DRVNTKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdCYWNrZmlsbCBJbmRleGVzJywgJ3JlYWR3cml0ZS1wcmltYXJ5JywgdHhuID0+IHRoaXMud3JpdGVJbmRleEVudHJpZXModHhuLCBtYXhEb2N1bWVudHNUb1Byb2Nlc3MpKTtcbiAgICB9XG4gICAgLyoqIFdyaXRlcyBpbmRleCBlbnRyaWVzIHVudGlsIHRoZSBjYXAgaXMgcmVhY2hlZC4gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBwcm9jZXNzZWQuICovXG4gICAgd3JpdGVJbmRleEVudHJpZXModHJhbnNhY3Rpb24sIG1heERvY3VtZW50c1RvUHJvY2Vzcykge1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRDb2xsZWN0aW9uR3JvdXBzID0gbmV3IFNldCgpO1xuICAgICAgICBsZXQgZG9jdW1lbnRzUmVtYWluaW5nID0gbWF4RG9jdW1lbnRzVG9Qcm9jZXNzO1xuICAgICAgICBsZXQgY29udGludWVMb29wID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5kb1doaWxlKCgpID0+IGNvbnRpbnVlTG9vcCA9PT0gdHJ1ZSAmJiBkb2N1bWVudHNSZW1haW5pbmcgPiAwLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JlLmluZGV4TWFuYWdlclxuICAgICAgICAgICAgICAgIC5nZXROZXh0Q29sbGVjdGlvbkdyb3VwVG9VcGRhdGUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgLm5leHQoKGNvbGxlY3Rpb25Hcm91cCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uR3JvdXAgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkQ29sbGVjdGlvbkdyb3Vwcy5oYXMoY29sbGVjdGlvbkdyb3VwKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZUxvb3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgYFByb2Nlc3NpbmcgY29sbGVjdGlvbjogJHtjb2xsZWN0aW9uR3JvdXB9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlRW50cmllc0ZvckNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBkb2N1bWVudHNSZW1haW5pbmcpLm5leHQoZG9jdW1lbnRzUHJvY2Vzc2VkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50c1JlbWFpbmluZyAtPSBkb2N1bWVudHNQcm9jZXNzZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRDb2xsZWN0aW9uR3JvdXBzLmFkZChjb2xsZWN0aW9uR3JvdXApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkubmV4dCgoKSA9PiBtYXhEb2N1bWVudHNUb1Byb2Nlc3MgLSBkb2N1bWVudHNSZW1haW5pbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgZW50cmllcyBmb3IgdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb24gZ3JvdXAuIFJldHVybnMgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgcHJvY2Vzc2VkLlxuICAgICAqL1xuICAgIHdyaXRlRW50cmllc0ZvckNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBkb2N1bWVudHNSZW1haW5pbmdVbmRlckNhcCkge1xuICAgICAgICAvLyBVc2UgdGhlIGVhcmxpZXN0IG9mZnNldCBvZiBhbGwgZmllbGQgaW5kZXhlcyB0byBxdWVyeSB0aGUgbG9jYWwgY2FjaGUuXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RvcmUuaW5kZXhNYW5hZ2VyXG4gICAgICAgICAgICAuZ2V0TWluT2Zmc2V0RnJvbUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwKVxuICAgICAgICAgICAgLm5leHQoZXhpc3RpbmdPZmZzZXQgPT4gdGhpcy5sb2NhbFN0b3JlLmxvY2FsRG9jdW1lbnRzXG4gICAgICAgICAgICAuZ2V0TmV4dERvY3VtZW50cyh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBleGlzdGluZ09mZnNldCwgZG9jdW1lbnRzUmVtYWluaW5nVW5kZXJDYXApXG4gICAgICAgICAgICAubmV4dChuZXh0QmF0Y2ggPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9jcyA9IG5leHRCYXRjaC5jaGFuZ2VzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yZS5pbmRleE1hbmFnZXJcbiAgICAgICAgICAgICAgICAudXBkYXRlSW5kZXhFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2NzKVxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMuZ2V0TmV3T2Zmc2V0KGV4aXN0aW5nT2Zmc2V0LCBuZXh0QmF0Y2gpKVxuICAgICAgICAgICAgICAgIC5uZXh0KG5ld09mZnNldCA9PiB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRoLCBgVXBkYXRpbmcgb2Zmc2V0OiAke25ld09mZnNldH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JlLmluZGV4TWFuYWdlci51cGRhdGVDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgbmV3T2Zmc2V0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jcy5zaXplKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgbmV4dCBvZmZzZXQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGRvY3VtZW50cy4gKi9cbiAgICBnZXROZXdPZmZzZXQoZXhpc3RpbmdPZmZzZXQsIGxvb2t1cFJlc3VsdCkge1xuICAgICAgICBsZXQgbWF4T2Zmc2V0ID0gZXhpc3RpbmdPZmZzZXQ7XG4gICAgICAgIGxvb2t1cFJlc3VsdC5jaGFuZ2VzLmZvckVhY2goKGtleSwgZG9jdW1lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld09mZnNldCA9IG5ld0luZGV4T2Zmc2V0RnJvbURvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgIGlmIChpbmRleE9mZnNldENvbXBhcmF0b3IobmV3T2Zmc2V0LCBtYXhPZmZzZXQpID4gMCkge1xuICAgICAgICAgICAgICAgIG1heE9mZnNldCA9IG5ld09mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhPZmZzZXQobWF4T2Zmc2V0LnJlYWRUaW1lLCBtYXhPZmZzZXQuZG9jdW1lbnRLZXksIE1hdGgubWF4KGxvb2t1cFJlc3VsdC5iYXRjaElkLCBleGlzdGluZ09mZnNldC5sYXJnZXN0QmF0Y2hJZCkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogYExpc3RlblNlcXVlbmNlYCBpcyBhIG1vbm90b25pYyBzZXF1ZW5jZS4gSXQgaXMgaW5pdGlhbGl6ZWQgd2l0aCBhIG1pbmltdW0gdmFsdWUgdG9cbiAqIGV4Y2VlZC4gQWxsIHN1YnNlcXVlbnQgY2FsbHMgdG8gbmV4dCB3aWxsIHJldHVybiBpbmNyZWFzaW5nIHZhbHVlcy4gSWYgcHJvdmlkZWQgd2l0aCBhXG4gKiBgU2VxdWVuY2VOdW1iZXJTeW5jZXJgLCBpdCB3aWxsIGFkZGl0aW9uYWxseSBidW1wIGl0cyBuZXh0IHZhbHVlIHdoZW4gdG9sZCBvZiBhIG5ldyB2YWx1ZSwgYXNcbiAqIHdlbGwgYXMgd3JpdGUgb3V0IHNlcXVlbmNlIG51bWJlcnMgdGhhdCBpdCBwcm9kdWNlcyB2aWEgYG5leHQoKWAuXG4gKi9cbmNsYXNzIExpc3RlblNlcXVlbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihwcmV2aW91c1ZhbHVlLCBzZXF1ZW5jZU51bWJlclN5bmNlcikge1xuICAgICAgICB0aGlzLnByZXZpb3VzVmFsdWUgPSBwcmV2aW91c1ZhbHVlO1xuICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXJTeW5jZXIpIHtcbiAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyU3luY2VyLnNlcXVlbmNlTnVtYmVySGFuZGxlciA9IHNlcXVlbmNlTnVtYmVyID0+IHRoaXMuc2V0UHJldmlvdXNWYWx1ZShzZXF1ZW5jZU51bWJlcik7XG4gICAgICAgICAgICB0aGlzLndyaXRlTmV3U2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlciA9PiBzZXF1ZW5jZU51bWJlclN5bmNlci53cml0ZVNlcXVlbmNlTnVtYmVyKHNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQcmV2aW91c1ZhbHVlKGV4dGVybmFsUHJldmlvdXNWYWx1ZSkge1xuICAgICAgICB0aGlzLnByZXZpb3VzVmFsdWUgPSBNYXRoLm1heChleHRlcm5hbFByZXZpb3VzVmFsdWUsIHRoaXMucHJldmlvdXNWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzVmFsdWU7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9ICsrdGhpcy5wcmV2aW91c1ZhbHVlO1xuICAgICAgICBpZiAodGhpcy53cml0ZU5ld1NlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlTmV3U2VxdWVuY2VOdW1iZXIobmV4dFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgIH1cbn1cbkxpc3RlblNlcXVlbmNlLklOVkFMSUQgPSAtMTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGVzY2FwZUNoYXIgPSAnXFx1MDAwMSc7XG5jb25zdCBlbmNvZGVkU2VwYXJhdG9yQ2hhciA9ICdcXHUwMDAxJztcbmNvbnN0IGVuY29kZWROdWwgPSAnXFx1MDAxMCc7XG5jb25zdCBlbmNvZGVkRXNjYXBlID0gJ1xcdTAwMTEnO1xuLyoqXG4gKiBFbmNvZGVzIGEgcmVzb3VyY2UgcGF0aCBpbnRvIGEgSW5kZXhlZERiLWNvbXBhdGlibGUgc3RyaW5nIGZvcm0uXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVJlc291cmNlUGF0aChwYXRoKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGVuY29kZVNlcGFyYXRvcihyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGVuY29kZVNlZ21lbnQocGF0aC5nZXQoaSksIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVTZXBhcmF0b3IocmVzdWx0KTtcbn1cbi8qKiBFbmNvZGVzIGEgc2luZ2xlIHNlZ21lbnQgb2YgYSByZXNvdXJjZSBwYXRoIGludG8gdGhlIGdpdmVuIHJlc3VsdCAqL1xuZnVuY3Rpb24gZW5jb2RlU2VnbWVudChzZWdtZW50LCByZXN1bHRCdWYpIHtcbiAgICBsZXQgcmVzdWx0ID0gcmVzdWx0QnVmO1xuICAgIGNvbnN0IGxlbmd0aCA9IHNlZ21lbnQubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHNlZ21lbnQuY2hhckF0KGkpO1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgIGNhc2UgJ1xcMCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZUNoYXIgKyBlbmNvZGVkTnVsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBlc2NhcGVDaGFyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVDaGFyICsgZW5jb2RlZEVzY2FwZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBFbmNvZGVzIGEgcGF0aCBzZXBhcmF0b3IgaW50byB0aGUgZ2l2ZW4gcmVzdWx0ICovXG5mdW5jdGlvbiBlbmNvZGVTZXBhcmF0b3IocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZUNoYXIgKyBlbmNvZGVkU2VwYXJhdG9yQ2hhcjtcbn1cbi8qKlxuICogRGVjb2RlcyB0aGUgZ2l2ZW4gSW5kZXhlZERiLWNvbXBhdGlibGUgc3RyaW5nIGZvcm0gb2YgYSByZXNvdXJjZSBwYXRoIGludG9cbiAqIGEgUmVzb3VyY2VQYXRoIGluc3RhbmNlLiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgaXMgbm90IHN1aXRhYmxlIGZvciB1c2Ugd2l0aFxuICogZGVjb2RpbmcgcmVzb3VyY2UgbmFtZXMgZnJvbSB0aGUgc2VydmVyOyB0aG9zZSBhcmUgT25lIFBsYXRmb3JtIGZvcm1hdFxuICogc3RyaW5ncy5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlUmVzb3VyY2VQYXRoKHBhdGgpIHtcbiAgICAvLyBFdmVudCB0aGUgZW1wdHkgcGF0aCBtdXN0IGVuY29kZSBhcyBhIHBhdGggb2YgYXQgbGVhc3QgbGVuZ3RoIDIuIEEgcGF0aFxuICAgIC8vIHdpdGggZXhhY3RseSAyIG11c3QgYmUgdGhlIGVtcHR5IHBhdGguXG4gICAgY29uc3QgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgaGFyZEFzc2VydChsZW5ndGggPj0gMiwgMHhmYjk4LCB7IHBhdGggfSk7XG4gICAgaWYgKGxlbmd0aCA9PT0gMikge1xuICAgICAgICBoYXJkQXNzZXJ0KHBhdGguY2hhckF0KDApID09PSBlc2NhcGVDaGFyICYmIHBhdGguY2hhckF0KDEpID09PSBlbmNvZGVkU2VwYXJhdG9yQ2hhciwgMHhkYjUxLCB7IHBhdGggfSk7XG4gICAgICAgIHJldHVybiBSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCk7XG4gICAgfVxuICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIGNhbm5vdCBleGlzdCBwYXN0IHRoZSBzZWNvbmQtdG8tbGFzdCBwb3NpdGlvbiBpbiB0aGVcbiAgICAvLyBzb3VyY2UgdmFsdWUuXG4gICAgY29uc3QgbGFzdFJlYXNvbmFibGVFc2NhcGVJbmRleCA9IGxlbmd0aCAtIDI7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcbiAgICBsZXQgc2VnbWVudEJ1aWxkZXIgPSAnJztcbiAgICBmb3IgKGxldCBzdGFydCA9IDA7IHN0YXJ0IDwgbGVuZ3RoOykge1xuICAgICAgICAvLyBUaGUgbGFzdCB0d28gY2hhcmFjdGVycyBvZiBhIHZhbGlkIGVuY29kZWQgcGF0aCBtdXN0IGJlIGEgc2VwYXJhdG9yLCBzb1xuICAgICAgICAvLyB0aGVyZSBtdXN0IGJlIGFuIGVuZCB0byB0aGlzIHNlZ21lbnQuXG4gICAgICAgIGNvbnN0IGVuZCA9IHBhdGguaW5kZXhPZihlc2NhcGVDaGFyLCBzdGFydCk7XG4gICAgICAgIGlmIChlbmQgPCAwIHx8IGVuZCA+IGxhc3RSZWFzb25hYmxlRXNjYXBlSW5kZXgpIHtcbiAgICAgICAgICAgIGZhaWwoMHhjNTUzLCB7IHBhdGggfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dCA9IHBhdGguY2hhckF0KGVuZCArIDEpO1xuICAgICAgICBzd2l0Y2ggKG5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgZW5jb2RlZFNlcGFyYXRvckNoYXI6XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBpZWNlID0gcGF0aC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgbGV0IHNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRCdWlsZGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBjb3B5aW5nIGZvciB0aGUgY29tbW9uIGNhc2Ugb2YgYSBzZWdtZW50IHRoYXQgZXhjbHVkZXMgXFwwXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBcXDAwMVxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50ID0gY3VycmVudFBpZWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudEJ1aWxkZXIgKz0gY3VycmVudFBpZWNlO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudEJ1aWxkZXI7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRCdWlsZGVyID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGVuY29kZWROdWw6XG4gICAgICAgICAgICAgICAgc2VnbWVudEJ1aWxkZXIgKz0gcGF0aC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgc2VnbWVudEJ1aWxkZXIgKz0gJ1xcMCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGVuY29kZWRFc2NhcGU6XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVzY2FwZSBjaGFyYWN0ZXIgY2FuIGJlIHVzZWQgaW4gdGhlIG91dHB1dCB0byBlbmNvZGUgaXRzZWxmLlxuICAgICAgICAgICAgICAgIHNlZ21lbnRCdWlsZGVyICs9IHBhdGguc3Vic3RyaW5nKHN0YXJ0LCBlbmQgKyAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZmFpbCgweGVlZWYsIHsgcGF0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IGVuZCArIDI7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVzb3VyY2VQYXRoKHNlZ21lbnRzKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxID0gJ3JlbW90ZURvY3VtZW50cyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBuYW1lICdvd25lcicgaXMgY2hvc2VuIHRvIGVuc3VyZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoXG4gKiBvbGRlciBjbGllbnRzIHRoYXQgb25seSBzdXBwb3J0ZWQgc2luZ2xlIGxvY2tlZCBhY2Nlc3MgdG8gdGhlIHBlcnNpc3RlbmNlXG4gKiBsYXllci5cbiAqL1xuY29uc3QgRGJQcmltYXJ5Q2xpZW50U3RvcmUgPSAnb3duZXInO1xuLyoqXG4gKiBUaGUga2V5IHN0cmluZyB1c2VkIGZvciB0aGUgc2luZ2xlIG9iamVjdCB0aGF0IGV4aXN0cyBpbiB0aGVcbiAqIERiUHJpbWFyeUNsaWVudCBzdG9yZS5cbiAqL1xuY29uc3QgRGJQcmltYXJ5Q2xpZW50S2V5ID0gJ293bmVyJztcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAgKi9cbmNvbnN0IERiTXV0YXRpb25RdWV1ZVN0b3JlID0gJ211dGF0aW9uUXVldWVzJztcbi8qKiBLZXlzIGFyZSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHZpYSB0aGUgdXNlcklkIHByb3BlcnR5LiAqL1xuY29uc3QgRGJNdXRhdGlvblF1ZXVlS2V5UGF0aCA9ICd1c2VySWQnO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICAqL1xuY29uc3QgRGJNdXRhdGlvbkJhdGNoU3RvcmUgPSAnbXV0YXRpb25zJztcbi8qKiBLZXlzIGFyZSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHZpYSB0aGUgdXNlcklkLCBiYXRjaElkIHByb3BlcnRpZXMuICovXG5jb25zdCBEYk11dGF0aW9uQmF0Y2hLZXlQYXRoID0gJ2JhdGNoSWQnO1xuLyoqIFRoZSBpbmRleCBuYW1lIGZvciBsb29rdXAgb2YgbXV0YXRpb25zIGJ5IHVzZXIuICovXG5jb25zdCBEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zSW5kZXggPSAndXNlck11dGF0aW9uc0luZGV4Jztcbi8qKiBUaGUgdXNlciBtdXRhdGlvbnMgaW5kZXggaXMga2V5ZWQgYnkgW3VzZXJJZCwgYmF0Y2hJZF0gcGFpcnMuICovXG5jb25zdCBEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zS2V5UGF0aCA9IFsndXNlcklkJywgJ2JhdGNoSWQnXTtcbi8qKlxuICogQ3JlYXRlcyBhIFt1c2VySWRdIGtleSBmb3IgdXNlIGluIHRoZSBEYkRvY3VtZW50TXV0YXRpb25zIGluZGV4IHRvIGl0ZXJhdGVcbiAqIG92ZXIgYWxsIG9mIGEgdXNlcidzIGRvY3VtZW50IG11dGF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbmV3RGJEb2N1bWVudE11dGF0aW9uUHJlZml4Rm9yVXNlcih1c2VySWQpIHtcbiAgICByZXR1cm4gW3VzZXJJZF07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBbdXNlcklkLCBlbmNvZGVkUGF0aF0ga2V5IGZvciB1c2UgaW4gdGhlIERiRG9jdW1lbnRNdXRhdGlvbnNcbiAqIGluZGV4IHRvIGl0ZXJhdGUgb3ZlciBhbGwgYXQgZG9jdW1lbnQgbXV0YXRpb25zIGZvciBhIGdpdmVuIHBhdGggb3IgbG93ZXIuXG4gKi9cbmZ1bmN0aW9uIG5ld0RiRG9jdW1lbnRNdXRhdGlvblByZWZpeEZvclBhdGgodXNlcklkLCBwYXRoKSB7XG4gICAgcmV0dXJuIFt1c2VySWQsIGVuY29kZVJlc291cmNlUGF0aChwYXRoKV07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBmdWxsIGluZGV4IGtleSBvZiBbdXNlcklkLCBlbmNvZGVkUGF0aCwgYmF0Y2hJZF0gZm9yIGluc2VydGluZ1xuICogYW5kIGRlbGV0aW5nIGludG8gdGhlIERiRG9jdW1lbnRNdXRhdGlvbnMgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIG5ld0RiRG9jdW1lbnRNdXRhdGlvbktleSh1c2VySWQsIHBhdGgsIGJhdGNoSWQpIHtcbiAgICByZXR1cm4gW3VzZXJJZCwgZW5jb2RlUmVzb3VyY2VQYXRoKHBhdGgpLCBiYXRjaElkXTtcbn1cbi8qKlxuICogQmVjYXVzZSB3ZSBzdG9yZSBhbGwgdGhlIHVzZWZ1bCBpbmZvcm1hdGlvbiBmb3IgdGhpcyBzdG9yZSBpbiB0aGUga2V5LFxuICogdGhlcmUgaXMgbm8gdXNlZnVsIGluZm9ybWF0aW9uIHRvIHN0b3JlIGFzIHRoZSB2YWx1ZS4gVGhlIHJhdyAodW5lbmNvZGVkKVxuICogcGF0aCBjYW5ub3QgYmUgc3RvcmVkIGJlY2F1c2UgSW5kZXhlZERiIGRvZXNuJ3Qgc3RvcmUgcHJvdG90eXBlXG4gKiBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgRGJEb2N1bWVudE11dGF0aW9uUGxhY2Vob2xkZXIgPSB7fTtcbmNvbnN0IERiRG9jdW1lbnRNdXRhdGlvblN0b3JlID0gJ2RvY3VtZW50TXV0YXRpb25zJztcbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRTdG9yZSA9ICdyZW1vdGVEb2N1bWVudHNWMTQnO1xuLyoqXG4gKiBUaGUgcHJpbWFyeSBrZXkgb2YgdGhlIHJlbW90ZSBkb2N1bWVudHMgc3RvcmUsIHdoaWNoIGFsbG93cyBmb3IgZWZmaWNpZW50XG4gKiBhY2Nlc3MgYnkgY29sbGVjdGlvbiBwYXRoIGFuZCByZWFkIHRpbWUuXG4gKi9cbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRLZXlQYXRoID0gW1xuICAgICdwcmVmaXhQYXRoJyxcbiAgICAnY29sbGVjdGlvbkdyb3VwJyxcbiAgICAncmVhZFRpbWUnLFxuICAgICdkb2N1bWVudElkJ1xuXTtcbi8qKiBBbiBpbmRleCB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byBkb2N1bWVudHMgYnkga2V5LiAqL1xuY29uc3QgRGJSZW1vdGVEb2N1bWVudERvY3VtZW50S2V5SW5kZXggPSAnZG9jdW1lbnRLZXlJbmRleCc7XG5jb25zdCBEYlJlbW90ZURvY3VtZW50RG9jdW1lbnRLZXlJbmRleFBhdGggPSBbXG4gICAgJ3ByZWZpeFBhdGgnLFxuICAgICdjb2xsZWN0aW9uR3JvdXAnLFxuICAgICdkb2N1bWVudElkJ1xuXTtcbi8qKlxuICogQW4gaW5kZXggdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gZG9jdW1lbnRzIGJ5IGNvbGxlY3Rpb24gZ3JvdXAgYW5kIHJlYWRcbiAqIHRpbWUuXG4gKlxuICogVGhpcyBpbmRleCBpcyB1c2VkIGJ5IHRoZSBpbmRleCBiYWNrZmlsbGVyLlxuICovXG5jb25zdCBEYlJlbW90ZURvY3VtZW50Q29sbGVjdGlvbkdyb3VwSW5kZXggPSAnY29sbGVjdGlvbkdyb3VwSW5kZXgnO1xuY29uc3QgRGJSZW1vdGVEb2N1bWVudENvbGxlY3Rpb25Hcm91cEluZGV4UGF0aCA9IFtcbiAgICAnY29sbGVjdGlvbkdyb3VwJyxcbiAgICAncmVhZFRpbWUnLFxuICAgICdwcmVmaXhQYXRoJyxcbiAgICAnZG9jdW1lbnRJZCdcbl07XG5jb25zdCBEYlJlbW90ZURvY3VtZW50R2xvYmFsU3RvcmUgPSAncmVtb3RlRG9jdW1lbnRHbG9iYWwnO1xuY29uc3QgRGJSZW1vdGVEb2N1bWVudEdsb2JhbEtleSA9ICdyZW1vdGVEb2N1bWVudEdsb2JhbEtleSc7XG5jb25zdCBEYlRhcmdldFN0b3JlID0gJ3RhcmdldHMnO1xuLyoqIEtleXMgYXJlIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdmlhIHRoZSB0YXJnZXRJZCBwcm9wZXJ0eS4gKi9cbmNvbnN0IERiVGFyZ2V0S2V5UGF0aCA9ICd0YXJnZXRJZCc7XG4vKiogVGhlIG5hbWUgb2YgdGhlIHF1ZXJ5VGFyZ2V0cyBpbmRleC4gKi9cbmNvbnN0IERiVGFyZ2V0UXVlcnlUYXJnZXRzSW5kZXhOYW1lID0gJ3F1ZXJ5VGFyZ2V0c0luZGV4Jztcbi8qKlxuICogVGhlIGluZGV4IG9mIGFsbCBjYW5vbmljYWxJZHMgdG8gdGhlIHRhcmdldHMgdGhhdCB0aGV5IG1hdGNoLiBUaGlzIGlzIG5vdFxuICogYSB1bmlxdWUgbWFwcGluZyBiZWNhdXNlIGNhbm9uaWNhbElkIGRvZXMgbm90IHByb21pc2UgYSB1bmlxdWUgbmFtZSBmb3IgYWxsXG4gKiBwb3NzaWJsZSBxdWVyaWVzLCBzbyB3ZSBhcHBlbmQgdGhlIHRhcmdldElkIHRvIG1ha2UgdGhlIG1hcHBpbmcgdW5pcXVlLlxuICovXG5jb25zdCBEYlRhcmdldFF1ZXJ5VGFyZ2V0c0tleVBhdGggPSBbJ2Nhbm9uaWNhbElkJywgJ3RhcmdldElkJ107XG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gICovXG5jb25zdCBEYlRhcmdldERvY3VtZW50U3RvcmUgPSAndGFyZ2V0RG9jdW1lbnRzJztcbi8qKiBLZXlzIGFyZSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHZpYSB0aGUgdGFyZ2V0SWQsIHBhdGggcHJvcGVydGllcy4gKi9cbmNvbnN0IERiVGFyZ2V0RG9jdW1lbnRLZXlQYXRoID0gWyd0YXJnZXRJZCcsICdwYXRoJ107XG4vKiogVGhlIGluZGV4IG5hbWUgZm9yIHRoZSByZXZlcnNlIGluZGV4LiAqL1xuY29uc3QgRGJUYXJnZXREb2N1bWVudERvY3VtZW50VGFyZ2V0c0luZGV4ID0gJ2RvY3VtZW50VGFyZ2V0c0luZGV4Jztcbi8qKiBXZSBhbHNvIG5lZWQgdG8gY3JlYXRlIHRoZSByZXZlcnNlIGluZGV4IGZvciB0aGVzZSBwcm9wZXJ0aWVzLiAqL1xuY29uc3QgRGJUYXJnZXREb2N1bWVudERvY3VtZW50VGFyZ2V0c0tleVBhdGggPSBbJ3BhdGgnLCAndGFyZ2V0SWQnXTtcbi8qKlxuICogVGhlIGtleSBzdHJpbmcgdXNlZCBmb3IgdGhlIHNpbmdsZSBvYmplY3QgdGhhdCBleGlzdHMgaW4gdGhlXG4gKiBEYlRhcmdldEdsb2JhbCBzdG9yZS5cbiAqL1xuY29uc3QgRGJUYXJnZXRHbG9iYWxLZXkgPSAndGFyZ2V0R2xvYmFsS2V5JztcbmNvbnN0IERiVGFyZ2V0R2xvYmFsU3RvcmUgPSAndGFyZ2V0R2xvYmFsJztcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xuY29uc3QgRGJDb2xsZWN0aW9uUGFyZW50U3RvcmUgPSAnY29sbGVjdGlvblBhcmVudHMnO1xuLyoqIEtleXMgYXJlIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdmlhIHRoZSBjb2xsZWN0aW9uSWQsIHBhcmVudCBwcm9wZXJ0aWVzLiAqL1xuY29uc3QgRGJDb2xsZWN0aW9uUGFyZW50S2V5UGF0aCA9IFsnY29sbGVjdGlvbklkJywgJ3BhcmVudCddO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXG5jb25zdCBEYkNsaWVudE1ldGFkYXRhU3RvcmUgPSAnY2xpZW50TWV0YWRhdGEnO1xuLyoqIEtleXMgYXJlIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdmlhIHRoZSBjbGllbnRJZCBwcm9wZXJ0aWVzLiAqL1xuY29uc3QgRGJDbGllbnRNZXRhZGF0YUtleVBhdGggPSAnY2xpZW50SWQnO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXG5jb25zdCBEYkJ1bmRsZVN0b3JlID0gJ2J1bmRsZXMnO1xuY29uc3QgRGJCdW5kbGVLZXlQYXRoID0gJ2J1bmRsZUlkJztcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xuY29uc3QgRGJOYW1lZFF1ZXJ5U3RvcmUgPSAnbmFtZWRRdWVyaWVzJztcbmNvbnN0IERiTmFtZWRRdWVyeUtleVBhdGggPSAnbmFtZSc7XG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gKi9cbmNvbnN0IERiSW5kZXhDb25maWd1cmF0aW9uU3RvcmUgPSAnaW5kZXhDb25maWd1cmF0aW9uJztcbmNvbnN0IERiSW5kZXhDb25maWd1cmF0aW9uS2V5UGF0aCA9ICdpbmRleElkJztcbi8qKlxuICogQW4gaW5kZXggdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGluZGV4IGNvbmZpZ3VyYXRpb25zIGJ5IGNvbGxlY3Rpb25cbiAqIGdyb3VwLlxuICpcbiAqIFBPUlRJTkcgTk9URTogaU9TIGFuZCBBbmRyb2lkIG1haW50YWluIHRoaXMgaW5kZXggaW4tbWVtb3J5LCBidXQgdGhpcyBpc1xuICogbm90IHBvc3NpYmxlIGhlcmUgYXMgdGhlIFdlYiBjbGllbnQgc3VwcG9ydHMgY29uY3VycmVudCBhY2Nlc3MgdG9cbiAqIHBlcnNpc3RlbmNlIHZpYSBtdWx0aS10YWIuXG4gKi9cbmNvbnN0IERiSW5kZXhDb25maWd1cmF0aW9uQ29sbGVjdGlvbkdyb3VwSW5kZXggPSAnY29sbGVjdGlvbkdyb3VwSW5kZXgnO1xuY29uc3QgRGJJbmRleENvbmZpZ3VyYXRpb25Db2xsZWN0aW9uR3JvdXBJbmRleFBhdGggPSAnY29sbGVjdGlvbkdyb3VwJztcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xuY29uc3QgRGJJbmRleFN0YXRlU3RvcmUgPSAnaW5kZXhTdGF0ZSc7XG5jb25zdCBEYkluZGV4U3RhdGVLZXlQYXRoID0gWydpbmRleElkJywgJ3VpZCddO1xuLyoqXG4gKiBBbiBpbmRleCB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byBkb2N1bWVudHMgaW4gYSBjb2xsZWN0aW9uIHNvcnRlZCBieSBsYXN0XG4gKiB1cGRhdGUgdGltZS4gVXNlZCBieSB0aGUgYmFja2ZpbGxlci5cbiAqXG4gKiBQT1JUSU5HIE5PVEU6IGlPUyBhbmQgQW5kcm9pZCBtYWludGFpbiB0aGlzIGluZGV4IGluLW1lbW9yeSwgYnV0IHRoaXMgaXNcbiAqIG5vdCBwb3NzaWJsZSBoZXJlIGFzIHRoZSBXZWIgY2xpZW50IHN1cHBvcnRzIGNvbmN1cnJlbnQgYWNjZXNzIHRvXG4gKiBwZXJzaXN0ZW5jZSB2aWEgbXVsdGktdGFiLlxuICovXG5jb25zdCBEYkluZGV4U3RhdGVTZXF1ZW5jZU51bWJlckluZGV4ID0gJ3NlcXVlbmNlTnVtYmVySW5kZXgnO1xuY29uc3QgRGJJbmRleFN0YXRlU2VxdWVuY2VOdW1iZXJJbmRleFBhdGggPSBbJ3VpZCcsICdzZXF1ZW5jZU51bWJlciddO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXG5jb25zdCBEYkluZGV4RW50cnlTdG9yZSA9ICdpbmRleEVudHJpZXMnO1xuY29uc3QgRGJJbmRleEVudHJ5S2V5UGF0aCA9IFtcbiAgICAnaW5kZXhJZCcsXG4gICAgJ3VpZCcsXG4gICAgJ2FycmF5VmFsdWUnLFxuICAgICdkaXJlY3Rpb25hbFZhbHVlJyxcbiAgICAnb3JkZXJlZERvY3VtZW50S2V5JyxcbiAgICAnZG9jdW1lbnRLZXknXG5dO1xuY29uc3QgRGJJbmRleEVudHJ5RG9jdW1lbnRLZXlJbmRleCA9ICdkb2N1bWVudEtleUluZGV4JztcbmNvbnN0IERiSW5kZXhFbnRyeURvY3VtZW50S2V5SW5kZXhQYXRoID0gW1xuICAgICdpbmRleElkJyxcbiAgICAndWlkJyxcbiAgICAnb3JkZXJlZERvY3VtZW50S2V5J1xuXTtcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xuY29uc3QgRGJEb2N1bWVudE92ZXJsYXlTdG9yZSA9ICdkb2N1bWVudE92ZXJsYXlzJztcbmNvbnN0IERiRG9jdW1lbnRPdmVybGF5S2V5UGF0aCA9IFtcbiAgICAndXNlcklkJyxcbiAgICAnY29sbGVjdGlvblBhdGgnLFxuICAgICdkb2N1bWVudElkJ1xuXTtcbmNvbnN0IERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvblBhdGhPdmVybGF5SW5kZXggPSAnY29sbGVjdGlvblBhdGhPdmVybGF5SW5kZXgnO1xuY29uc3QgRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleFBhdGggPSBbXG4gICAgJ3VzZXJJZCcsXG4gICAgJ2NvbGxlY3Rpb25QYXRoJyxcbiAgICAnbGFyZ2VzdEJhdGNoSWQnXG5dO1xuY29uc3QgRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uR3JvdXBPdmVybGF5SW5kZXggPSAnY29sbGVjdGlvbkdyb3VwT3ZlcmxheUluZGV4JztcbmNvbnN0IERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvbkdyb3VwT3ZlcmxheUluZGV4UGF0aCA9IFtcbiAgICAndXNlcklkJyxcbiAgICAnY29sbGVjdGlvbkdyb3VwJyxcbiAgICAnbGFyZ2VzdEJhdGNoSWQnXG5dO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXG5jb25zdCBEYkdsb2JhbHNTdG9yZSA9ICdnbG9iYWxzJztcbmNvbnN0IERiR2xvYmFsc0tleVBhdGggPSAnbmFtZSc7XG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nXG5jb25zdCBWMV9TVE9SRVMgPSBbXG4gICAgRGJNdXRhdGlvblF1ZXVlU3RvcmUsXG4gICAgRGJNdXRhdGlvbkJhdGNoU3RvcmUsXG4gICAgRGJEb2N1bWVudE11dGF0aW9uU3RvcmUsXG4gICAgRGJSZW1vdGVEb2N1bWVudFN0b3JlJDEsXG4gICAgRGJUYXJnZXRTdG9yZSxcbiAgICBEYlByaW1hcnlDbGllbnRTdG9yZSxcbiAgICBEYlRhcmdldEdsb2JhbFN0b3JlLFxuICAgIERiVGFyZ2V0RG9jdW1lbnRTdG9yZVxuXTtcbi8vIFZpc2libGUgZm9yIHRlc3RpbmdcbmNvbnN0IFYzX1NUT1JFUyA9IFYxX1NUT1JFUztcbi8vIE5vdGU6IERiUmVtb3RlRG9jdW1lbnRDaGFuZ2VzIGlzIG5vIGxvbmdlciB1c2VkIGFuZCBkcm9wcGVkIHdpdGggdjkuXG5jb25zdCBWNF9TVE9SRVMgPSBbLi4uVjNfU1RPUkVTLCBEYkNsaWVudE1ldGFkYXRhU3RvcmVdO1xuY29uc3QgVjZfU1RPUkVTID0gWy4uLlY0X1NUT1JFUywgRGJSZW1vdGVEb2N1bWVudEdsb2JhbFN0b3JlXTtcbmNvbnN0IFY4X1NUT1JFUyA9IFsuLi5WNl9TVE9SRVMsIERiQ29sbGVjdGlvblBhcmVudFN0b3JlXTtcbmNvbnN0IFYxMV9TVE9SRVMgPSBbLi4uVjhfU1RPUkVTLCBEYkJ1bmRsZVN0b3JlLCBEYk5hbWVkUXVlcnlTdG9yZV07XG5jb25zdCBWMTJfU1RPUkVTID0gWy4uLlYxMV9TVE9SRVMsIERiRG9jdW1lbnRPdmVybGF5U3RvcmVdO1xuY29uc3QgVjEzX1NUT1JFUyA9IFtcbiAgICBEYk11dGF0aW9uUXVldWVTdG9yZSxcbiAgICBEYk11dGF0aW9uQmF0Y2hTdG9yZSxcbiAgICBEYkRvY3VtZW50TXV0YXRpb25TdG9yZSxcbiAgICBEYlJlbW90ZURvY3VtZW50U3RvcmUsXG4gICAgRGJUYXJnZXRTdG9yZSxcbiAgICBEYlByaW1hcnlDbGllbnRTdG9yZSxcbiAgICBEYlRhcmdldEdsb2JhbFN0b3JlLFxuICAgIERiVGFyZ2V0RG9jdW1lbnRTdG9yZSxcbiAgICBEYkNsaWVudE1ldGFkYXRhU3RvcmUsXG4gICAgRGJSZW1vdGVEb2N1bWVudEdsb2JhbFN0b3JlLFxuICAgIERiQ29sbGVjdGlvblBhcmVudFN0b3JlLFxuICAgIERiQnVuZGxlU3RvcmUsXG4gICAgRGJOYW1lZFF1ZXJ5U3RvcmUsXG4gICAgRGJEb2N1bWVudE92ZXJsYXlTdG9yZVxuXTtcbmNvbnN0IFYxNF9TVE9SRVMgPSBWMTNfU1RPUkVTO1xuY29uc3QgVjE1X1NUT1JFUyA9IFtcbiAgICAuLi5WMTRfU1RPUkVTLFxuICAgIERiSW5kZXhDb25maWd1cmF0aW9uU3RvcmUsXG4gICAgRGJJbmRleFN0YXRlU3RvcmUsXG4gICAgRGJJbmRleEVudHJ5U3RvcmVcbl07XG5jb25zdCBWMTZfU1RPUkVTID0gVjE1X1NUT1JFUztcbmNvbnN0IFYxN19TVE9SRVMgPSBbLi4uVjE1X1NUT1JFUywgRGJHbG9iYWxzU3RvcmVdO1xuY29uc3QgVjE4X1NUT1JFUyA9IFYxN19TVE9SRVM7XG4vKiogUmV0dXJucyB0aGUgb2JqZWN0IHN0b3JlcyBmb3IgdGhlIHByb3ZpZGVkIHNjaGVtYS4gKi9cbmZ1bmN0aW9uIGdldE9iamVjdFN0b3JlcyhzY2hlbWFWZXJzaW9uKSB7XG4gICAgaWYgKHNjaGVtYVZlcnNpb24gPT09IDE4KSB7XG4gICAgICAgIHJldHVybiBWMThfU1RPUkVTO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWFWZXJzaW9uID09PSAxNykge1xuICAgICAgICByZXR1cm4gVjE3X1NUT1JFUztcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hVmVyc2lvbiA9PT0gMTYpIHtcbiAgICAgICAgcmV0dXJuIFYxNl9TVE9SRVM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYVZlcnNpb24gPT09IDE1KSB7XG4gICAgICAgIHJldHVybiBWMTVfU1RPUkVTO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWFWZXJzaW9uID09PSAxNCkge1xuICAgICAgICByZXR1cm4gVjE0X1NUT1JFUztcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hVmVyc2lvbiA9PT0gMTMpIHtcbiAgICAgICAgcmV0dXJuIFYxM19TVE9SRVM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYVZlcnNpb24gPT09IDEyKSB7XG4gICAgICAgIHJldHVybiBWMTJfU1RPUkVTO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWFWZXJzaW9uID09PSAxMSkge1xuICAgICAgICByZXR1cm4gVjExX1NUT1JFUztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZhaWwoMHhlYjU1KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBJbmRleGVkRGJUcmFuc2FjdGlvbiBleHRlbmRzIFBlcnNpc3RlbmNlVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNpbXBsZURiVHJhbnNhY3Rpb24sIGN1cnJlbnRTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNpbXBsZURiVHJhbnNhY3Rpb24gPSBzaW1wbGVEYlRyYW5zYWN0aW9uO1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZU51bWJlciA9IGN1cnJlbnRTZXF1ZW5jZU51bWJlcjtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTdG9yZSh0eG4sIHN0b3JlKSB7XG4gICAgY29uc3QgaW5kZXhlZERiVHJhbnNhY3Rpb24gPSBkZWJ1Z0Nhc3QodHhuKTtcbiAgICByZXR1cm4gU2ltcGxlRGIuZ2V0U3RvcmUoaW5kZXhlZERiVHJhbnNhY3Rpb24uc2ltcGxlRGJUcmFuc2FjdGlvbiwgc3RvcmUpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0U2l6ZShvYmopIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG59XG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIGZuKGtleSwgb2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwVG9BcnJheShvYmosIGZuKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChmbihvYmpba2V5XSwga2V5LCBvYmopKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIEFuIGltbXV0YWJsZSBzb3J0ZWQgbWFwIGltcGxlbWVudGF0aW9uLCBiYXNlZCBvbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2tcbi8vIHRyZWUuXG5jbGFzcyBTb3J0ZWRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3IsIHJvb3QpIHtcbiAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdCA/IHJvb3QgOiBMTFJCTm9kZS5FTVBUWTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hcCwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS92YWx1ZSBhZGRlZCBvciByZXBsYWNlZC5cbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3IsIHRoaXMucm9vdFxuICAgICAgICAgICAgLmluc2VydChrZXksIHZhbHVlLCB0aGlzLmNvbXBhcmF0b3IpXG4gICAgICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCkpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgbWFwLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IHJlbW92ZWQuXG4gICAgcmVtb3ZlKGtleSkge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3IsIHRoaXMucm9vdFxuICAgICAgICAgICAgLnJlbW92ZShrZXksIHRoaXMuY29tcGFyYXRvcilcbiAgICAgICAgICAgIC5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLkJMQUNLLCBudWxsLCBudWxsKSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBub2RlIHdpdGggdGhlIGdpdmVuIGtleSwgb3IgbnVsbC5cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5yb290O1xuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBjb25zdCBjbXAgPSB0aGlzLmNvbXBhcmF0b3Ioa2V5LCBub2RlLmtleSk7XG4gICAgICAgICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhpcyBzb3J0ZWQgbWFwLCBvciAtMSBpZiBpdCBkb2Vzbid0XG4gICAgLy8gZXhpc3QuXG4gICAgaW5kZXhPZihrZXkpIHtcbiAgICAgICAgLy8gTnVtYmVyIG9mIG5vZGVzIHRoYXQgd2VyZSBwcnVuZWQgd2hlbiBkZXNjZW5kaW5nIHJpZ2h0XG4gICAgICAgIGxldCBwcnVuZWROb2RlcyA9IDA7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5yb290O1xuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBjb25zdCBjbXAgPSB0aGlzLmNvbXBhcmF0b3Ioa2V5LCBub2RlLmtleSk7XG4gICAgICAgICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBydW5lZE5vZGVzICsgbm9kZS5sZWZ0LnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENvdW50IGFsbCBub2RlcyBsZWZ0IG9mIHRoZSBub2RlIHBsdXMgdGhlIG5vZGUgaXRzZWxmXG4gICAgICAgICAgICAgICAgcHJ1bmVkTm9kZXMgKz0gbm9kZS5sZWZ0LnNpemUgKyAxO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vZGUgbm90IGZvdW5kXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5pc0VtcHR5KCk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgbWFwLlxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LnNpemU7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG1pbmltdW0ga2V5IGluIHRoZSBtYXAuXG4gICAgbWluS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Lm1pbktleSgpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIGtleSBpbiB0aGUgbWFwLlxuICAgIG1heEtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5tYXhLZXkoKTtcbiAgICB9XG4gICAgLy8gVHJhdmVyc2VzIHRoZSBtYXAgaW4ga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxuICAgIC8vIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cbiAgICAvLyBSZXR1cm5zIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLCBvciB0aGUgbGFzdCBmYWxzZXlcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXG4gICAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbik7XG4gICAgfVxuICAgIGZvckVhY2goZm4pIHtcbiAgICAgICAgdGhpcy5pbm9yZGVyVHJhdmVyc2FsKChrLCB2KSA9PiB7XG4gICAgICAgICAgICBmbihrLCB2KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbm9yZGVyVHJhdmVyc2FsKChrLCB2KSA9PiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbnMucHVzaChgJHtrfToke3Z9YCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYHske2Rlc2NyaXB0aW9ucy5qb2luKCcsICcpfX1gO1xuICAgIH1cbiAgICAvLyBUcmF2ZXJzZXMgdGhlIG1hcCBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb25cbiAgICAvLyBmdW5jdGlvbiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci4gSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzXG4gICAgLy8gYWJvcnRlZC5cbiAgICAvLyBSZXR1cm5zIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLCBvciB0aGUgbGFzdCBmYWxzZXlcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXG4gICAgcmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbik7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB0aGUgU29ydGVkTWFwLlxuICAgIGdldEl0ZXJhdG9yKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdCwgbnVsbCwgdGhpcy5jb21wYXJhdG9yLCBmYWxzZSk7XG4gICAgfVxuICAgIGdldEl0ZXJhdG9yRnJvbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3QsIGtleSwgdGhpcy5jb21wYXJhdG9yLCBmYWxzZSk7XG4gICAgfVxuICAgIGdldFJldmVyc2VJdGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3QsIG51bGwsIHRoaXMuY29tcGFyYXRvciwgdHJ1ZSk7XG4gICAgfVxuICAgIGdldFJldmVyc2VJdGVyYXRvckZyb20oa2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290LCBrZXksIHRoaXMuY29tcGFyYXRvciwgdHJ1ZSk7XG4gICAgfVxufSAvLyBlbmQgU29ydGVkTWFwXG4vLyBBbiBpdGVyYXRvciBvdmVyIGFuIExMUkJOb2RlLlxuY2xhc3MgU29ydGVkTWFwSXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIHN0YXJ0S2V5LCBjb21wYXJhdG9yLCBpc1JldmVyc2UpIHtcbiAgICAgICAgdGhpcy5pc1JldmVyc2UgPSBpc1JldmVyc2U7XG4gICAgICAgIHRoaXMubm9kZVN0YWNrID0gW107XG4gICAgICAgIGxldCBjbXAgPSAxO1xuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBjbXAgPSBzdGFydEtleSA/IGNvbXBhcmF0b3Iobm9kZS5rZXksIHN0YXJ0S2V5KSA6IDE7XG4gICAgICAgICAgICAvLyBmbGlwIHRoZSBjb21wYXJpc29uIGlmIHdlJ3JlIGdvaW5nIGluIHJldmVyc2VcbiAgICAgICAgICAgIGlmIChzdGFydEtleSAmJiBpc1JldmVyc2UpIHtcbiAgICAgICAgICAgICAgICBjbXAgKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBsZXNzIHRoYW4gb3VyIHN0YXJ0IGtleS4gaWdub3JlIGl0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG5vZGUgaXMgZXhhY3RseSBlcXVhbCB0byBvdXIgc3RhcnQga2V5LiBQdXNoIGl0IG9uIHRoZSBzdGFjayxcbiAgICAgICAgICAgICAgICAvLyBidXQgc3RvcCBpdGVyYXRpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBncmVhdGVyIHRoYW4gb3VyIHN0YXJ0IGtleSwgYWRkIGl0IHRvIHRoZSBzdGFjayBhbmQgbW92ZVxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBuZXh0IG9uZVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TmV4dCgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLm5vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBrZXk6IG5vZGUua2V5LCB2YWx1ZTogbm9kZS52YWx1ZSB9O1xuICAgICAgICBpZiAodGhpcy5pc1JldmVyc2UpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoYXNOZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlU3RhY2subGVuZ3RoID4gMDtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZVN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZVN0YWNrW3RoaXMubm9kZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4geyBrZXk6IG5vZGUua2V5LCB2YWx1ZTogbm9kZS52YWx1ZSB9O1xuICAgIH1cbn0gLy8gZW5kIFNvcnRlZE1hcEl0ZXJhdG9yXG4vLyBSZXByZXNlbnRzIGEgbm9kZSBpbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2sgdHJlZS5cbmNsYXNzIExMUkJOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yICE9IG51bGwgPyBjb2xvciA6IExMUkJOb2RlLlJFRDtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdCAhPSBudWxsID8gbGVmdCA6IExMUkJOb2RlLkVNUFRZO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogTExSQk5vZGUuRU1QVFk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMubGVmdC5zaXplICsgMSArIHRoaXMucmlnaHQuc2l6ZTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgbm9kZSwgb3B0aW9uYWxseSByZXBsYWNpbmcgcGllY2VzIG9mIGl0LlxuICAgIGNvcHkoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5ICE9IG51bGwgPyBrZXkgOiB0aGlzLmtleSwgdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogdGhpcy52YWx1ZSwgY29sb3IgIT0gbnVsbCA/IGNvbG9yIDogdGhpcy5jb2xvciwgbGVmdCAhPSBudWxsID8gbGVmdCA6IHRoaXMubGVmdCwgcmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogdGhpcy5yaWdodCk7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVHJhdmVyc2VzIHRoZSB0cmVlIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cbiAgICAvLyBmb3IgZWFjaCBub2RlLiBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cbiAgICAvLyBSZXR1cm5zIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLCBvciB0aGUgbGFzdCBmYWxzZXlcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXG4gICAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxlZnQuaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHx8XG4gICAgICAgICAgICBhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Lmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSk7XG4gICAgfVxuICAgIC8vIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb25cbiAgICAvLyBmdW5jdGlvbiBmb3IgZWFjaCBub2RlLiBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cbiAgICAvLyBSZXR1cm5zIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLCBvciB0aGUgbGFzdCBmYWxzZXlcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXG4gICAgcmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnJpZ2h0LnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB8fFxuICAgICAgICAgICAgYWN0aW9uKHRoaXMua2V5LCB0aGlzLnZhbHVlKSB8fFxuICAgICAgICAgICAgdGhpcy5sZWZ0LnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG1pbmltdW0gbm9kZSBpbiB0aGUgdHJlZS5cbiAgICBtaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmxlZnQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQubWluKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXG4gICAgbWluS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oKS5rZXk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG1heGltdW0ga2V5IGluIHRoZSB0cmVlLlxuICAgIG1heEtleSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5tYXhLZXkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm5zIG5ldyB0cmVlLCB3aXRoIHRoZSBrZXkvdmFsdWUgYWRkZWQuXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgbGV0IG4gPSB0aGlzO1xuICAgICAgICBjb25zdCBjbXAgPSBjb21wYXJhdG9yKGtleSwgbi5rZXkpO1xuICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBuLmxlZnQuaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgdmFsdWUsIG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0Lmluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4uZml4VXAoKTtcbiAgICB9XG4gICAgcmVtb3ZlTWluKCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIExMUkJOb2RlLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuID0gdGhpcztcbiAgICAgICAgaWYgKCFuLmxlZnQuaXNSZWQoKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWQoKSkge1xuICAgICAgICAgICAgbiA9IG4ubW92ZVJlZExlZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmVNaW4oKSwgbnVsbCk7XG4gICAgICAgIHJldHVybiBuLmZpeFVwKCk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgbmV3IHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBpdGVtIHJlbW92ZWQuXG4gICAgcmVtb3ZlKGtleSwgY29tcGFyYXRvcikge1xuICAgICAgICBsZXQgc21hbGxlc3Q7XG4gICAgICAgIGxldCBuID0gdGhpcztcbiAgICAgICAgaWYgKGNvbXBhcmF0b3Ioa2V5LCBuLmtleSkgPCAwKSB7XG4gICAgICAgICAgICBpZiAoIW4ubGVmdC5pc0VtcHR5KCkgJiYgIW4ubGVmdC5pc1JlZCgpICYmICFuLmxlZnQubGVmdC5pc1JlZCgpKSB7XG4gICAgICAgICAgICAgICAgbiA9IG4ubW92ZVJlZExlZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0LnJlbW92ZShrZXksIGNvbXBhcmF0b3IpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuLmxlZnQuaXNSZWQoKSkge1xuICAgICAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW4ucmlnaHQuaXNFbXB0eSgpICYmICFuLnJpZ2h0LmlzUmVkKCkgJiYgIW4ucmlnaHQubGVmdC5pc1JlZCgpKSB7XG4gICAgICAgICAgICAgICAgbiA9IG4ubW92ZVJlZFJpZ2h0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChuLnJpZ2h0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTExSQk5vZGUuRU1QVFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzbWFsbGVzdCA9IG4ucmlnaHQubWluKCk7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBuLmNvcHkoc21hbGxlc3Qua2V5LCBzbWFsbGVzdC52YWx1ZSwgbnVsbCwgbnVsbCwgbi5yaWdodC5yZW1vdmVNaW4oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0LnJlbW92ZShrZXksIGNvbXBhcmF0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbi5maXhVcCgpO1xuICAgIH1cbiAgICBpc1JlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3I7XG4gICAgfVxuICAgIC8vIFJldHVybnMgbmV3IHRyZWUgYWZ0ZXIgcGVyZm9ybWluZyBhbnkgbmVlZGVkIHJvdGF0aW9ucy5cbiAgICBmaXhVcCgpIHtcbiAgICAgICAgbGV0IG4gPSB0aGlzO1xuICAgICAgICBpZiAobi5yaWdodC5pc1JlZCgpICYmICFuLmxlZnQuaXNSZWQoKSkge1xuICAgICAgICAgICAgbiA9IG4ucm90YXRlTGVmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWQoKSAmJiBuLmxlZnQubGVmdC5pc1JlZCgpKSB7XG4gICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWQoKSAmJiBuLnJpZ2h0LmlzUmVkKCkpIHtcbiAgICAgICAgICAgIG4gPSBuLmNvbG9yRmxpcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBtb3ZlUmVkTGVmdCgpIHtcbiAgICAgICAgbGV0IG4gPSB0aGlzLmNvbG9yRmxpcCgpO1xuICAgICAgICBpZiAobi5yaWdodC5sZWZ0LmlzUmVkKCkpIHtcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5yb3RhdGVSaWdodCgpKTtcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZUxlZnQoKTtcbiAgICAgICAgICAgIG4gPSBuLmNvbG9yRmxpcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBtb3ZlUmVkUmlnaHQoKSB7XG4gICAgICAgIGxldCBuID0gdGhpcy5jb2xvckZsaXAoKTtcbiAgICAgICAgaWYgKG4ubGVmdC5sZWZ0LmlzUmVkKCkpIHtcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0KCk7XG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgcm90YXRlTGVmdCgpIHtcbiAgICAgICAgY29uc3QgbmwgPSB0aGlzLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuUkVELCBudWxsLCB0aGlzLnJpZ2h0LmxlZnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG5sLCBudWxsKTtcbiAgICB9XG4gICAgcm90YXRlUmlnaHQoKSB7XG4gICAgICAgIGNvbnN0IG5yID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLlJFRCwgdGhpcy5sZWZ0LnJpZ2h0LCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG51bGwsIG5yKTtcbiAgICB9XG4gICAgY29sb3JGbGlwKCkge1xuICAgICAgICBjb25zdCBsZWZ0ID0gdGhpcy5sZWZ0LmNvcHkobnVsbCwgbnVsbCwgIXRoaXMubGVmdC5jb2xvciwgbnVsbCwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsICF0aGlzLnJpZ2h0LmNvbG9yLCBudWxsLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weShudWxsLCBudWxsLCAhdGhpcy5jb2xvciwgbGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICAvLyBGb3IgdGVzdGluZy5cbiAgICBjaGVja01heERlcHRoKCkge1xuICAgICAgICBjb25zdCBibGFja0RlcHRoID0gdGhpcy5jaGVjaygpO1xuICAgICAgICBpZiAoTWF0aC5wb3coMi4wLCBibGFja0RlcHRoKSA8PSB0aGlzLnNpemUgKyAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJbiBhIGJhbGFuY2VkIFJCIHRyZWUsIHRoZSBibGFjay1kZXB0aCAobnVtYmVyIG9mIGJsYWNrIG5vZGVzKSBmcm9tIHJvb3QgdG9cbiAgICAvLyBsZWF2ZXMgaXMgZXF1YWwgb24gYm90aCBzaWRlcy4gIFRoaXMgZnVuY3Rpb24gdmVyaWZpZXMgdGhhdCBvciBhc3NlcnRzLlxuICAgIGNoZWNrKCkge1xuICAgICAgICBpZiAodGhpcy5pc1JlZCgpICYmIHRoaXMubGVmdC5pc1JlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBmYWlsKDB4YWFkMiwge1xuICAgICAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJpZ2h0LmlzUmVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IGZhaWwoMHgzNzIxLCB7XG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxhY2tEZXB0aCA9IHRoaXMubGVmdC5jaGVjaygpO1xuICAgICAgICBpZiAoYmxhY2tEZXB0aCAhPT0gdGhpcy5yaWdodC5jaGVjaygpKSB7XG4gICAgICAgICAgICB0aHJvdyBmYWlsKDB4NmQyZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYmxhY2tEZXB0aCArICh0aGlzLmlzUmVkKCkgPyAwIDogMSk7XG4gICAgICAgIH1cbiAgICB9XG59IC8vIGVuZCBMTFJCTm9kZVxuLy8gRW1wdHkgbm9kZSBpcyBzaGFyZWQgYmV0d2VlbiBhbGwgTExSQiB0cmVlcy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5MTFJCTm9kZS5FTVBUWSA9IG51bGw7XG5MTFJCTm9kZS5SRUQgPSB0cnVlO1xuTExSQk5vZGUuQkxBQ0sgPSBmYWxzZTtcbi8vIFJlcHJlc2VudHMgYW4gZW1wdHkgbm9kZSAoYSBsZWFmIG5vZGUgaW4gdGhlIFJlZC1CbGFjayBUcmVlKS5cbmNsYXNzIExMUkJFbXB0eU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cbiAgICBnZXQga2V5KCkge1xuICAgICAgICB0aHJvdyBmYWlsKDB4ZTFhNik7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgdGhyb3cgZmFpbCgweDNmMGQpO1xuICAgIH1cbiAgICBnZXQgY29sb3IoKSB7XG4gICAgICAgIHRocm93IGZhaWwoMHg0MTU3KTtcbiAgICB9XG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHRocm93IGZhaWwoMHg3NDFlKTtcbiAgICB9XG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICB0aHJvdyBmYWlsKDB4OTAxZSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgY29weShrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSB0cmVlLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5L3ZhbHVlIGFkZGVkLlxuICAgIGluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSB0cmVlLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IHJlbW92ZWQuXG4gICAgcmVtb3ZlKGtleSwgY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtaW5LZXkoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBtYXhLZXkoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpc1JlZCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBGb3IgdGVzdGluZy5cbiAgICBjaGVja01heERlcHRoKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2hlY2soKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn0gLy8gZW5kIExMUkJFbXB0eU5vZGVcbkxMUkJOb2RlLkVNUFRZID0gbmV3IExMUkJFbXB0eU5vZGUoKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogU29ydGVkU2V0IGlzIGFuIGltbXV0YWJsZSAoY29weS1vbi13cml0ZSkgY29sbGVjdGlvbiB0aGF0IGhvbGRzIGVsZW1lbnRzXG4gKiBpbiBvcmRlciBzcGVjaWZpZWQgYnkgdGhlIHByb3ZpZGVkIGNvbXBhcmF0b3IuXG4gKlxuICogTk9URTogaWYgcHJvdmlkZWQgY29tcGFyYXRvciByZXR1cm5zIDAgZm9yIHR3byBlbGVtZW50cywgd2UgY29uc2lkZXIgdGhlbSB0b1xuICogYmUgZXF1YWwhXG4gKi9cbmNsYXNzIFNvcnRlZFNldCB7XG4gICAgY29uc3RydWN0b3IoY29tcGFyYXRvcikge1xuICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgU29ydGVkTWFwKHRoaXMuY29tcGFyYXRvcik7XG4gICAgfVxuICAgIGhhcyhlbGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuZ2V0KGVsZW0pICE9PSBudWxsO1xuICAgIH1cbiAgICBmaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5taW5LZXkoKTtcbiAgICB9XG4gICAgbGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5tYXhLZXkoKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuc2l6ZTtcbiAgICB9XG4gICAgaW5kZXhPZihlbGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuaW5kZXhPZihlbGVtKTtcbiAgICB9XG4gICAgLyoqIEl0ZXJhdGVzIGVsZW1lbnRzIGluIG9yZGVyIGRlZmluZWQgYnkgXCJjb21wYXJhdG9yXCIgKi9cbiAgICBmb3JFYWNoKGNiKSB7XG4gICAgICAgIHRoaXMuZGF0YS5pbm9yZGVyVHJhdmVyc2FsKChrLCB2KSA9PiB7XG4gICAgICAgICAgICBjYihrKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBJdGVyYXRlcyBvdmVyIGBlbGVtYHMgc3VjaCB0aGF0OiByYW5nZVswXSAmbHQ7PSBlbGVtICZsdDsgcmFuZ2VbMV0uICovXG4gICAgZm9yRWFjaEluUmFuZ2UocmFuZ2UsIGNiKSB7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3JGcm9tKHJhbmdlWzBdKTtcbiAgICAgICAgd2hpbGUgKGl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtID0gaXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wYXJhdG9yKGVsZW0ua2V5LCByYW5nZVsxXSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiKGVsZW0ua2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGBlbGVtYHMgc3VjaCB0aGF0OiBzdGFydCAmbHQ7PSBlbGVtIHVudGlsIGZhbHNlIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGZvckVhY2hXaGlsZShjYiwgc3RhcnQpIHtcbiAgICAgICAgbGV0IGl0ZXI7XG4gICAgICAgIGlmIChzdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdGVyID0gdGhpcy5kYXRhLmdldEl0ZXJhdG9yRnJvbShzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVyID0gdGhpcy5kYXRhLmdldEl0ZXJhdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtID0gaXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYihlbGVtLmtleSk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogRmluZHMgdGhlIGxlYXN0IGVsZW1lbnQgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBlbGVtYC4gKi9cbiAgICBmaXJzdEFmdGVyT3JFcXVhbChlbGVtKSB7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3JGcm9tKGVsZW0pO1xuICAgICAgICByZXR1cm4gaXRlci5oYXNOZXh0KCkgPyBpdGVyLmdldE5leHQoKS5rZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRJdGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRTZXRJdGVyYXRvcih0aGlzLmRhdGEuZ2V0SXRlcmF0b3IoKSk7XG4gICAgfVxuICAgIGdldEl0ZXJhdG9yRnJvbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRTZXRJdGVyYXRvcih0aGlzLmRhdGEuZ2V0SXRlcmF0b3JGcm9tKGtleSkpO1xuICAgIH1cbiAgICAvKiogSW5zZXJ0cyBvciB1cGRhdGVzIGFuIGVsZW1lbnQgKi9cbiAgICBhZGQoZWxlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KHRoaXMuZGF0YS5yZW1vdmUoZWxlbSkuaW5zZXJ0KGVsZW0sIHRydWUpKTtcbiAgICB9XG4gICAgLyoqIERlbGV0ZXMgYW4gZWxlbWVudCAqL1xuICAgIGRlbGV0ZShlbGVtKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXMoZWxlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkodGhpcy5kYXRhLnJlbW92ZShlbGVtKSk7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuaXNFbXB0eSgpO1xuICAgIH1cbiAgICB1bmlvbldpdGgob3RoZXIpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXM7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBgcmVzdWx0YCBhbHdheXMgcmVmZXJzIHRvIHRoZSBsYXJnZXIgb25lIG9mIHRoZSB0d28gc2V0cy5cbiAgICAgICAgaWYgKHJlc3VsdC5zaXplIDwgb3RoZXIuc2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gb3RoZXI7XG4gICAgICAgICAgICBvdGhlciA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXIuZm9yRWFjaChlbGVtID0+IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZWxlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU29ydGVkU2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNpemUgIT09IG90aGVyLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aGlzSXQgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgY29uc3Qgb3RoZXJJdCA9IG90aGVyLmRhdGEuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgd2hpbGUgKHRoaXNJdC5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRoaXNFbGVtID0gdGhpc0l0LmdldE5leHQoKS5rZXk7XG4gICAgICAgICAgICBjb25zdCBvdGhlckVsZW0gPSBvdGhlckl0LmdldE5leHQoKS5rZXk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wYXJhdG9yKHRoaXNFbGVtLCBvdGhlckVsZW0pICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0b0FycmF5KCkge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKHRhcmdldElkID0+IHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHRhcmdldElkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGVsZW0gPT4gcmVzdWx0LnB1c2goZWxlbSkpO1xuICAgICAgICByZXR1cm4gJ1NvcnRlZFNldCgnICsgcmVzdWx0LnRvU3RyaW5nKCkgKyAnKSc7XG4gICAgfVxuICAgIGNvcHkoZGF0YSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU29ydGVkU2V0KHRoaXMuY29tcGFyYXRvcik7XG4gICAgICAgIHJlc3VsdC5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5jbGFzcyBTb3J0ZWRTZXRJdGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoaXRlcikge1xuICAgICAgICB0aGlzLml0ZXIgPSBpdGVyO1xuICAgIH1cbiAgICBnZXROZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyLmdldE5leHQoKS5rZXk7XG4gICAgfVxuICAgIGhhc05leHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXIuaGFzTmV4dCgpO1xuICAgIH1cbn1cbi8qKlxuICogQ29tcGFyZXMgdHdvIHNvcnRlZCBzZXRzIGZvciBlcXVhbGl0eSB1c2luZyB0aGVpciBuYXR1cmFsIG9yZGVyaW5nLiBUaGVcbiAqIG1ldGhvZCBjb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIGFuZCBpbnZva2VzIGBvbkFkZGAgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdFxuICogaXMgaW4gYGFmdGVyYCBidXQgbm90IGBiZWZvcmVgLiBgb25SZW1vdmVgIGlzIGludm9rZWQgZm9yIGV2ZXJ5IGVsZW1lbnQgaW5cbiAqIGBiZWZvcmVgIGJ1dCBtaXNzaW5nIGZyb20gYGFmdGVyYC5cbiAqXG4gKiBUaGUgbWV0aG9kIGNyZWF0ZXMgYSBjb3B5IG9mIGJvdGggYGJlZm9yZWAgYW5kIGBhZnRlcmAgYW5kIHJ1bnMgaW4gTyhuIGxvZ1xuICogbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIHR3byBsaXN0cy5cbiAqXG4gKiBAcGFyYW0gYmVmb3JlIC0gVGhlIGVsZW1lbnRzIHRoYXQgZXhpc3QgaW4gdGhlIG9yaWdpbmFsIHNldC5cbiAqIEBwYXJhbSBhZnRlciAtIFRoZSBlbGVtZW50cyB0byBkaWZmIGFnYWluc3QgdGhlIG9yaWdpbmFsIHNldC5cbiAqIEBwYXJhbSBjb21wYXJhdG9yIC0gVGhlIGNvbXBhcmF0b3IgZm9yIHRoZSBlbGVtZW50cyBpbiBiZWZvcmUgYW5kIGFmdGVyLlxuICogQHBhcmFtIG9uQWRkIC0gQSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdCBpcyBwYXJ0IG9mIGBcbiAqIGFmdGVyYCBidXQgbm90IGBiZWZvcmVgLlxuICogQHBhcmFtIG9uUmVtb3ZlIC0gQSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdCBpcyBwYXJ0IG9mXG4gKiBgYmVmb3JlYCBidXQgbm90IGBhZnRlcmAuXG4gKi9cbmZ1bmN0aW9uIGRpZmZTb3J0ZWRTZXRzKGJlZm9yZSwgYWZ0ZXIsIGNvbXBhcmF0b3IsIG9uQWRkLCBvblJlbW92ZSkge1xuICAgIGNvbnN0IGJlZm9yZUl0ID0gYmVmb3JlLmdldEl0ZXJhdG9yKCk7XG4gICAgY29uc3QgYWZ0ZXJJdCA9IGFmdGVyLmdldEl0ZXJhdG9yKCk7XG4gICAgbGV0IGJlZm9yZVZhbHVlID0gYWR2YW5jZUl0ZXJhdG9yKGJlZm9yZUl0KTtcbiAgICBsZXQgYWZ0ZXJWYWx1ZSA9IGFkdmFuY2VJdGVyYXRvcihhZnRlckl0KTtcbiAgICAvLyBXYWxrIHRocm91Z2ggdGhlIHR3byBzZXRzIGF0IHRoZSBzYW1lIHRpbWUsIHVzaW5nIHRoZSBvcmRlcmluZyBkZWZpbmVkIGJ5XG4gICAgLy8gYGNvbXBhcmF0b3JgLlxuICAgIHdoaWxlIChiZWZvcmVWYWx1ZSB8fCBhZnRlclZhbHVlKSB7XG4gICAgICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoYmVmb3JlVmFsdWUgJiYgYWZ0ZXJWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY21wID0gY29tcGFyYXRvcihiZWZvcmVWYWx1ZSwgYWZ0ZXJWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IHdhcyByZW1vdmVkIGlmIHRoZSBuZXh0IGVsZW1lbnQgaW4gb3VyIG9yZGVyZWRcbiAgICAgICAgICAgICAgICAvLyB3YWxrdGhyb3VnaCBpcyBvbmx5IGluIGBiZWZvcmVgLlxuICAgICAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IHdhcyBhZGRlZCBpZiB0aGUgbmV4dCBlbGVtZW50IGluIG91ciBvcmRlcmVkIHdhbGt0aHJvdWdoXG4gICAgICAgICAgICAgICAgLy8gaXMgb25seSBpbiBgYWZ0ZXJgLlxuICAgICAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiZWZvcmVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkZWQpIHtcbiAgICAgICAgICAgIG9uQWRkKGFmdGVyVmFsdWUpO1xuICAgICAgICAgICAgYWZ0ZXJWYWx1ZSA9IGFkdmFuY2VJdGVyYXRvcihhZnRlckl0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICBvblJlbW92ZShiZWZvcmVWYWx1ZSk7XG4gICAgICAgICAgICBiZWZvcmVWYWx1ZSA9IGFkdmFuY2VJdGVyYXRvcihiZWZvcmVJdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiZWZvcmVWYWx1ZSA9IGFkdmFuY2VJdGVyYXRvcihiZWZvcmVJdCk7XG4gICAgICAgICAgICBhZnRlclZhbHVlID0gYWR2YW5jZUl0ZXJhdG9yKGFmdGVySXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZXh0IGVsZW1lbnQgZnJvbSB0aGUgaXRlcmF0b3Igb3IgYHVuZGVmaW5lZGAgaWYgbm9uZSBhdmFpbGFibGUuXG4gKi9cbmZ1bmN0aW9uIGFkdmFuY2VJdGVyYXRvcihpdCkge1xuICAgIHJldHVybiBpdC5oYXNOZXh0KCkgPyBpdC5nZXROZXh0KCkgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVzIGEgc2V0IG9mIGZpZWxkcyB0aGF0IGNhbiBiZSB1c2VkIHRvIHBhcnRpYWxseSBwYXRjaCBhIGRvY3VtZW50LlxuICogRmllbGRNYXNrIGlzIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBPYmplY3RWYWx1ZS5cbiAqIEV4YW1wbGVzOlxuICogICBmb28gLSBPdmVyd3JpdGVzIGZvbyBlbnRpcmVseSB3aXRoIHRoZSBwcm92aWRlZCB2YWx1ZS4gSWYgZm9vIGlzIG5vdFxuICogICAgICAgICBwcmVzZW50IGluIHRoZSBjb21wYW5pb24gT2JqZWN0VmFsdWUsIHRoZSBmaWVsZCBpcyBkZWxldGVkLlxuICogICBmb28uYmFyIC0gT3ZlcndyaXRlcyBvbmx5IHRoZSBmaWVsZCBiYXIgb2YgdGhlIG9iamVjdCBmb28uXG4gKiAgICAgICAgICAgICBJZiBmb28gaXMgbm90IGFuIG9iamVjdCwgZm9vIGlzIHJlcGxhY2VkIHdpdGggYW4gb2JqZWN0XG4gKiAgICAgICAgICAgICBjb250YWluaW5nIGZvb1xuICovXG5jbGFzcyBGaWVsZE1hc2sge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiB2YWxpZGF0aW9uIG9mIEZpZWxkTWFza1xuICAgICAgICAvLyBTb3J0IHRoZSBmaWVsZCBtYXNrIHRvIHN1cHBvcnQgYEZpZWxkTWFzay5pc0VxdWFsKClgIGFuZCBhc3NlcnQgYmVsb3cuXG4gICAgICAgIGZpZWxkcy5zb3J0KEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IpO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRNYXNrKFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBGaWVsZE1hc2sgb2JqZWN0IHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBhZGRpbmcgYWxsIHRoZSBnaXZlblxuICAgICAqIGZpZWxkcyBwYXRocyB0byB0aGlzIGZpZWxkIG1hc2suXG4gICAgICovXG4gICAgdW5pb25XaXRoKGV4dHJhRmllbGRzKSB7XG4gICAgICAgIGxldCBtZXJnZWRNYXNrU2V0ID0gbmV3IFNvcnRlZFNldChGaWVsZFBhdGgkMS5jb21wYXJhdG9yKTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZFBhdGggb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIG1lcmdlZE1hc2tTZXQgPSBtZXJnZWRNYXNrU2V0LmFkZChmaWVsZFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRQYXRoIG9mIGV4dHJhRmllbGRzKSB7XG4gICAgICAgICAgICBtZXJnZWRNYXNrU2V0ID0gbWVyZ2VkTWFza1NldC5hZGQoZmllbGRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZpZWxkTWFzayhtZXJnZWRNYXNrU2V0LnRvQXJyYXkoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoYXQgYGZpZWxkUGF0aGAgaXMgaW5jbHVkZWQgYnkgYXQgbGVhc3Qgb25lIGZpZWxkIGluIHRoaXMgZmllbGRcbiAgICAgKiBtYXNrLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhbiBPKG4pIG9wZXJhdGlvbiwgd2hlcmUgYG5gIGlzIHRoZSBzaXplIG9mIHRoZSBmaWVsZCBtYXNrLlxuICAgICAqL1xuICAgIGNvdmVycyhmaWVsZFBhdGgpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE1hc2tQYXRoIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRNYXNrUGF0aC5pc1ByZWZpeE9mKGZpZWxkUGF0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKHRoaXMuZmllbGRzLCBvdGhlci5maWVsZHMsIChsLCByKSA9PiBsLmlzRXF1YWwocikpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBDb252ZXJ0cyBhIEJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byBhIGJpbmFyeSBzdHJpbmcuICovXG5mdW5jdGlvbiBkZWNvZGVCYXNlNjQoZW5jb2RlZCkge1xuICAgIC8vIE5vdGU6IFdlIHVzZWQgdG8gdmFsaWRhdGUgdGhlIGJhc2U2NCBzdHJpbmcgaGVyZSB2aWEgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgLy8gVGhpcyB3YXMgcmVtb3ZlZCB0byBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZSBvZiBpbmRleGluZy5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oZW5jb2RlZCwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiaW5hcnknKTtcbn1cbi8qKiBDb252ZXJ0cyBhIGJpbmFyeSBzdHJpbmcgdG8gYSBCYXNlNjQgZW5jb2RlZCBzdHJpbmcuICovXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjQocmF3KSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJhdywgJ2JpbmFyeScpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbn1cbi8qKiBUcnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBCYXNlNjQgY29udmVyc2lvbiBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZS4gKi9cbmZ1bmN0aW9uIGlzQmFzZTY0QXZhaWxhYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBJbW11dGFibGUgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgXCJwcm90b1wiIGJ5dGUgc3RyaW5nLlxuICpcbiAqIFByb3RvIGJ5dGUgc3RyaW5ncyBjYW4gZWl0aGVyIGJlIEJhc2U2NC1lbmNvZGVkIHN0cmluZ3Mgb3IgVWludDhBcnJheXMgd2hlblxuICogc2VudCBvbiB0aGUgd2lyZS4gVGhpcyBjbGFzcyBhYnN0cmFjdHMgYXdheSB0aGlzIGRpZmZlcmVudGlhdGlvbiBieSBob2xkaW5nXG4gKiB0aGUgcHJvdG8gYnl0ZSBzdHJpbmcgaW4gYSBjb21tb24gY2xhc3MgdGhhdCBtdXN0IGJlIGNvbnZlcnRlZCBpbnRvIGEgc3RyaW5nXG4gKiBiZWZvcmUgYmVpbmcgc2VudCBhcyBhIHByb3RvLlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIEJ5dGVTdHJpbmcge1xuICAgIGNvbnN0cnVjdG9yKGJpbmFyeVN0cmluZykge1xuICAgICAgICB0aGlzLmJpbmFyeVN0cmluZyA9IGJpbmFyeVN0cmluZztcbiAgICB9XG4gICAgc3RhdGljIGZyb21CYXNlNjRTdHJpbmcoYmFzZTY0KSB7XG4gICAgICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IGRlY29kZUJhc2U2NChiYXNlNjQpO1xuICAgICAgICByZXR1cm4gbmV3IEJ5dGVTdHJpbmcoYmluYXJ5U3RyaW5nKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21VaW50OEFycmF5KGFycmF5KSB7XG4gICAgICAgIC8vIFRPRE8oaW5kZXhpbmcpOyBSZW1vdmUgdGhlIGNvcHkgb2YgdGhlIGJ5dGUgc3RyaW5nIGhlcmUgYXMgdGhpcyBtZXRob2RcbiAgICAgICAgLy8gaXMgZnJlcXVlbnRseSBjYWxsZWQgZHVyaW5nIGluZGV4aW5nLlxuICAgICAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBiaW5hcnlTdHJpbmdGcm9tVWludDhBcnJheShhcnJheSk7XG4gICAgICAgIHJldHVybiBuZXcgQnl0ZVN0cmluZyhiaW5hcnlTdHJpbmcpO1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgdGhpcy5iaW5hcnlTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzLmJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkrKyksIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b0Jhc2U2NCgpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUJhc2U2NCh0aGlzLmJpbmFyeVN0cmluZyk7XG4gICAgfVxuICAgIHRvVWludDhBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlGcm9tQmluYXJ5U3RyaW5nKHRoaXMuYmluYXJ5U3RyaW5nKTtcbiAgICB9XG4gICAgYXBwcm94aW1hdGVCeXRlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5U3RyaW5nLmxlbmd0aCAqIDI7XG4gICAgfVxuICAgIGNvbXBhcmVUbyhvdGhlcikge1xuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcih0aGlzLmJpbmFyeVN0cmluZywgb3RoZXIuYmluYXJ5U3RyaW5nKTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlTdHJpbmcgPT09IG90aGVyLmJpbmFyeVN0cmluZztcbiAgICB9XG59XG5CeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HID0gbmV3IEJ5dGVTdHJpbmcoJycpO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhbiBVaW50OGFycmF5IHRvIGEgYmluYXJ5IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmluYXJ5U3RyaW5nRnJvbVVpbnQ4QXJyYXkoYXJyYXkpIHtcbiAgICBsZXQgYmluYXJ5U3RyaW5nID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICBiaW5hcnlTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG4gICAgfVxuICAgIHJldHVybiBiaW5hcnlTdHJpbmc7XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGEgYmluYXJ5IHN0cmluZyB0byBhbiBVaW50OEFycmF5LlxuICovXG5mdW5jdGlvbiB1aW50OEFycmF5RnJvbUJpbmFyeVN0cmluZyhiaW5hcnlTdHJpbmcpIHtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBidWZmZXJbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIEEgUmVnRXhwIG1hdGNoaW5nIElTTyA4NjAxIFVUQyB0aW1lc3RhbXBzIHdpdGggb3B0aW9uYWwgZnJhY3Rpb24uXG5jb25zdCBJU09fVElNRVNUQU1QX1JFR19FWFAgPSBuZXcgUmVnRXhwKC9eXFxkezR9LVxcZFxcZC1cXGRcXGRUXFxkXFxkOlxcZFxcZDpcXGRcXGQoPzpcXC4oXFxkKykpP1okLyk7XG4vKipcbiAqIENvbnZlcnRzIHRoZSBwb3NzaWJsZSBQcm90byB2YWx1ZXMgZm9yIGEgdGltZXN0YW1wIHZhbHVlIGludG8gYSBcInNlY29uZHMgYW5kXG4gKiBuYW5vc1wiIHJlcHJlc2VudGF0aW9uLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVUaW1lc3RhbXAoZGF0ZSkge1xuICAgIGhhcmRBc3NlcnQoISFkYXRlLCAweDk4NmEpO1xuICAgIC8vIFRoZSBqc29uIGludGVyZmFjZSAoZm9yIHRoZSBicm93c2VyKSB3aWxsIHJldHVybiBhbiBpc28gdGltZXN0YW1wIHN0cmluZyxcbiAgICAvLyB3aGlsZSB0aGUgcHJvdG8ganMgbGlicmFyeSAoZm9yIG5vZGUpIHdpbGwgcmV0dXJuIGFcbiAgICAvLyBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGluc3RhbmNlLlxuICAgIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gVGhlIGRhdGUgc3RyaW5nIGNhbiBoYXZlIGhpZ2hlciBwcmVjaXNpb24gKG5hbm9zKSB0aGFuIHRoZSBEYXRlIGNsYXNzXG4gICAgICAgIC8vIChtaWxsaXMpLCBzbyB3ZSBkbyBzb21lIGN1c3RvbSBwYXJzaW5nIGhlcmUuXG4gICAgICAgIC8vIFBhcnNlIHRoZSBuYW5vcyByaWdodCBvdXQgb2YgdGhlIHN0cmluZy5cbiAgICAgICAgbGV0IG5hbm9zID0gMDtcbiAgICAgICAgY29uc3QgZnJhY3Rpb24gPSBJU09fVElNRVNUQU1QX1JFR19FWFAuZXhlYyhkYXRlKTtcbiAgICAgICAgaGFyZEFzc2VydCghIWZyYWN0aW9uLCAweGI1ZGUsIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZGF0ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZyYWN0aW9uWzFdKSB7XG4gICAgICAgICAgICAvLyBQYWQgdGhlIGZyYWN0aW9uIG91dCB0byA5IGRpZ2l0cyAobmFub3MpLlxuICAgICAgICAgICAgbGV0IG5hbm9TdHIgPSBmcmFjdGlvblsxXTtcbiAgICAgICAgICAgIG5hbm9TdHIgPSAobmFub1N0ciArICcwMDAwMDAwMDAnKS5zdWJzdHIoMCwgOSk7XG4gICAgICAgICAgICBuYW5vcyA9IE51bWJlcihuYW5vU3RyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJzZSB0aGUgZGF0ZSB0byBnZXQgdGhlIHNlY29uZHMuXG4gICAgICAgIGNvbnN0IHBhcnNlZERhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kcyA9IE1hdGguZmxvb3IocGFyc2VkRGF0ZS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICAgICAgcmV0dXJuIHsgc2Vjb25kcywgbmFub3MgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRPRE8oYi8zNzI4MjIzNyk6IFVzZSBzdHJpbmdzIGZvciBQcm90bzMgdGltZXN0YW1wc1xuICAgICAgICAvLyBhc3NlcnQoIXRoaXMub3B0aW9ucy51c2VQcm90bzNKc29uLFxuICAgICAgICAvLyAgICdUaGUgdGltZXN0YW1wIGluc3RhbmNlIGZvcm1hdCByZXF1aXJlcyBQcm90byBKUy4nKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kcyA9IG5vcm1hbGl6ZU51bWJlcihkYXRlLnNlY29uZHMpO1xuICAgICAgICBjb25zdCBuYW5vcyA9IG5vcm1hbGl6ZU51bWJlcihkYXRlLm5hbm9zKTtcbiAgICAgICAgcmV0dXJuIHsgc2Vjb25kcywgbmFub3MgfTtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBwb3NzaWJsZSBQcm90byB0eXBlcyBmb3IgbnVtYmVycyBpbnRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gKiBSZXR1cm5zIDAgaWYgdGhlIHZhbHVlIGlzIG5vdCBudW1lcmljLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVOdW1iZXIodmFsdWUpIHtcbiAgICAvLyBUT0RPKGJqb3JuaWNrKTogSGFuZGxlIGludDY0IGdyZWF0ZXIgdGhhbiA1MyBiaXRzLlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbi8qKiBDb252ZXJ0cyB0aGUgcG9zc2libGUgUHJvdG8gdHlwZXMgZm9yIEJsb2JzIGludG8gYSBCeXRlU3RyaW5nLiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQnl0ZVN0cmluZyhibG9iKSB7XG4gICAgaWYgKHR5cGVvZiBibG9iID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gQnl0ZVN0cmluZy5mcm9tQmFzZTY0U3RyaW5nKGJsb2IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEJ5dGVTdHJpbmcuZnJvbVVpbnQ4QXJyYXkoYmxvYik7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgbG9jYWxseS1hcHBsaWVkIFNlcnZlclRpbWVzdGFtcC5cbiAqXG4gKiBTZXJ2ZXIgVGltZXN0YW1wcyBhcmUgYmFja2VkIGJ5IE1hcFZhbHVlcyB0aGF0IGNvbnRhaW4gYW4gaW50ZXJuYWwgZmllbGRcbiAqIGBfX3R5cGVfX2Agd2l0aCBhIHZhbHVlIG9mIGBzZXJ2ZXJfdGltZXN0YW1wYC4gVGhlIHByZXZpb3VzIHZhbHVlIGFuZCBsb2NhbFxuICogd3JpdGUgdGltZSBhcmUgc3RvcmVkIGluIGl0cyBgX19wcmV2aW91c192YWx1ZV9fYCBhbmQgYF9fbG9jYWxfd3JpdGVfdGltZV9fYFxuICogZmllbGRzIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBOb3RlczpcbiAqIC0gU2VydmVyVGltZXN0YW1wVmFsdWUgaW5zdGFuY2VzIGFyZSBjcmVhdGVkIGFzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYVxuICogICB0cmFuc2Zvcm0uIFRoZXkgY2FuIG9ubHkgZXhpc3QgaW4gdGhlIGxvY2FsIHZpZXcgb2YgYSBkb2N1bWVudC4gVGhlcmVmb3JlXG4gKiAgIHRoZXkgZG8gbm90IG5lZWQgdG8gYmUgcGFyc2VkIG9yIHNlcmlhbGl6ZWQuXG4gKiAtIFdoZW4gZXZhbHVhdGVkIGxvY2FsbHkgKGUuZy4gZm9yIHNuYXBzaG90LmRhdGEoKSksIHRoZXkgYnkgZGVmYXVsdFxuICogICBldmFsdWF0ZSB0byBgbnVsbGAuIFRoaXMgYmVoYXZpb3IgY2FuIGJlIGNvbmZpZ3VyZWQgYnkgcGFzc2luZyBjdXN0b21cbiAqICAgRmllbGRWYWx1ZU9wdGlvbnMgdG8gdmFsdWUoKS5cbiAqIC0gV2l0aCByZXNwZWN0IHRvIG90aGVyIFNlcnZlclRpbWVzdGFtcFZhbHVlcywgdGhleSBzb3J0IGJ5IHRoZWlyXG4gKiAgIGxvY2FsV3JpdGVUaW1lLlxuICovXG5jb25zdCBTRVJWRVJfVElNRVNUQU1QX1NFTlRJTkVMID0gJ3NlcnZlcl90aW1lc3RhbXAnO1xuY29uc3QgVFlQRV9LRVkkMSA9ICdfX3R5cGVfXyc7XG5jb25zdCBQUkVWSU9VU19WQUxVRV9LRVkgPSAnX19wcmV2aW91c192YWx1ZV9fJztcbmNvbnN0IExPQ0FMX1dSSVRFX1RJTUVfS0VZID0gJ19fbG9jYWxfd3JpdGVfdGltZV9fJztcbmZ1bmN0aW9uIGlzU2VydmVyVGltZXN0YW1wKHZhbHVlKSB7XG4gICAgY29uc3QgdHlwZSA9ICh2YWx1ZT8ubWFwVmFsdWU/LmZpZWxkcyB8fCB7fSlbVFlQRV9LRVkkMV0/LnN0cmluZ1ZhbHVlO1xuICAgIHJldHVybiB0eXBlID09PSBTRVJWRVJfVElNRVNUQU1QX1NFTlRJTkVMO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFNlcnZlclRpbWVzdGFtcCBwcm90byB2YWx1ZSAodXNpbmcgdGhlIGludGVybmFsIGZvcm1hdCkuXG4gKi9cbmZ1bmN0aW9uIHNlcnZlclRpbWVzdGFtcCQxKGxvY2FsV3JpdGVUaW1lLCBwcmV2aW91c1ZhbHVlKSB7XG4gICAgY29uc3QgbWFwVmFsdWUgPSB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgW1RZUEVfS0VZJDFdOiB7XG4gICAgICAgICAgICAgICAgc3RyaW5nVmFsdWU6IFNFUlZFUl9USU1FU1RBTVBfU0VOVElORUxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbTE9DQUxfV1JJVEVfVElNRV9LRVldOiB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wVmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kczogbG9jYWxXcml0ZVRpbWUuc2Vjb25kcyxcbiAgICAgICAgICAgICAgICAgICAgbmFub3M6IGxvY2FsV3JpdGVUaW1lLm5hbm9zZWNvbmRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBXZSBzaG91bGQgYXZvaWQgc3RvcmluZyBkZWVwbHkgbmVzdGVkIHNlcnZlciB0aW1lc3RhbXAgbWFwIHZhbHVlc1xuICAgIC8vIGJlY2F1c2Ugd2UgbmV2ZXIgdXNlIHRoZSBpbnRlcm1lZGlhdGUgXCJwcmV2aW91cyB2YWx1ZXNcIi5cbiAgICAvLyBGb3IgZXhhbXBsZTpcbiAgICAvLyBwcmV2aW91czogNDJMLCBhZGQ6IHQxLCByZXN1bHQ6IHQxIC0+IDQyTFxuICAgIC8vIHByZXZpb3VzOiB0MSwgIGFkZDogdDIsIHJlc3VsdDogdDIgLT4gNDJMIChOT1QgdDIgLT4gdDEgLT4gNDJMKVxuICAgIC8vIHByZXZpb3VzOiB0MiwgIGFkZDogdDMsIHJlc3VsdDogdDMgLT4gNDJMIChOT1QgdDMgLT4gdDIgLT4gdDEgLT4gNDJMKVxuICAgIC8vIGBnZXRQcmV2aW91c1ZhbHVlYCByZWN1cnNpdmVseSB0cmF2ZXJzZXMgc2VydmVyIHRpbWVzdGFtcHMgdG8gZmluZCB0aGVcbiAgICAvLyBsZWFzdCByZWNlbnQgVmFsdWUuXG4gICAgaWYgKHByZXZpb3VzVmFsdWUgJiYgaXNTZXJ2ZXJUaW1lc3RhbXAocHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgICAgcHJldmlvdXNWYWx1ZSA9IGdldFByZXZpb3VzVmFsdWUocHJldmlvdXNWYWx1ZSk7XG4gICAgfVxuICAgIGlmIChwcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgIG1hcFZhbHVlLmZpZWxkc1tQUkVWSU9VU19WQUxVRV9LRVldID0gcHJldmlvdXNWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWFwVmFsdWUgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkIGJlZm9yZSB0aGlzIFNlcnZlclRpbWVzdGFtcCB3YXMgc2V0LlxuICpcbiAqIFByZXNlcnZpbmcgdGhlIHByZXZpb3VzIHZhbHVlcyBhbGxvd3MgdGhlIHVzZXIgdG8gZGlzcGxheSB0aGUgbGFzdCByZXNvbGVkXG4gKiB2YWx1ZSB1bnRpbCB0aGUgYmFja2VuZCByZXNwb25kcyB3aXRoIHRoZSB0aW1lc3RhbXAuXG4gKi9cbmZ1bmN0aW9uIGdldFByZXZpb3VzVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdmFsdWUubWFwVmFsdWUuZmllbGRzW1BSRVZJT1VTX1ZBTFVFX0tFWV07XG4gICAgaWYgKGlzU2VydmVyVGltZXN0YW1wKHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBnZXRQcmV2aW91c1ZhbHVlKHByZXZpb3VzVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbG9jYWwgdGltZSBhdCB3aGljaCB0aGlzIHRpbWVzdGFtcCB3YXMgZmlyc3Qgc2V0LlxuICovXG5mdW5jdGlvbiBnZXRMb2NhbFdyaXRlVGltZSh2YWx1ZSkge1xuICAgIGNvbnN0IGxvY2FsV3JpdGVUaW1lID0gbm9ybWFsaXplVGltZXN0YW1wKHZhbHVlLm1hcFZhbHVlLmZpZWxkc1tMT0NBTF9XUklURV9USU1FX0tFWV0udGltZXN0YW1wVmFsdWUpO1xuICAgIHJldHVybiBuZXcgVGltZXN0YW1wKGxvY2FsV3JpdGVUaW1lLnNlY29uZHMsIGxvY2FsV3JpdGVUaW1lLm5hbm9zKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIERhdGFiYXNlSW5mbyB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIERhdGFiYXNlSW5mbyB1c2luZyB0aGUgcHJvdmlkZWQgaG9zdCwgZGF0YWJhc2VJZCBhbmRcbiAgICAgKiBwZXJzaXN0ZW5jZUtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhYmFzZUlkIC0gVGhlIGRhdGFiYXNlIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gYXBwSWQgLSBUaGUgRmlyZWJhc2UgQXBwIElkLlxuICAgICAqIEBwYXJhbSBwZXJzaXN0ZW5jZUtleSAtIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgRmlyZXN0b3JlJ3MgbG9jYWxcbiAgICAgKiBzdG9yYWdlICh1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGRhdGFiYXNlSWQpLlxuICAgICAqIEBwYXJhbSBob3N0IC0gVGhlIEZpcmVzdG9yZSBiYWNrZW5kIGhvc3QgdG8gY29ubmVjdCB0by5cbiAgICAgKiBAcGFyYW0gc3NsIC0gV2hldGhlciB0byB1c2UgU1NMIHdoZW4gY29ubmVjdGluZy5cbiAgICAgKiBAcGFyYW0gZm9yY2VMb25nUG9sbGluZyAtIFdoZXRoZXIgdG8gdXNlIHRoZSBmb3JjZUxvbmdQb2xsaW5nIG9wdGlvblxuICAgICAqIHdoZW4gdXNpbmcgV2ViQ2hhbm5lbCBhcyB0aGUgbmV0d29yayB0cmFuc3BvcnQuXG4gICAgICogQHBhcmFtIGF1dG9EZXRlY3RMb25nUG9sbGluZyAtIFdoZXRoZXIgdG8gdXNlIHRoZSBkZXRlY3RCdWZmZXJpbmdQcm94eVxuICAgICAqIG9wdGlvbiB3aGVuIHVzaW5nIFdlYkNoYW5uZWwgYXMgdGhlIG5ldHdvcmsgdHJhbnNwb3J0LlxuICAgICAqIEBwYXJhbSBsb25nUG9sbGluZ09wdGlvbnMgLSBPcHRpb25zIHRoYXQgY29uZmlndXJlIGxvbmctcG9sbGluZy5cbiAgICAgKiBAcGFyYW0gdXNlRmV0Y2hTdHJlYW1zIC0gV2hldGhlciB0byB1c2UgdGhlIEZldGNoIEFQSSBpbnN0ZWFkIG9mXG4gICAgICogWE1MSFRUUFJlcXVlc3RcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkYXRhYmFzZUlkLCBhcHBJZCwgcGVyc2lzdGVuY2VLZXksIGhvc3QsIHNzbCwgZm9yY2VMb25nUG9sbGluZywgYXV0b0RldGVjdExvbmdQb2xsaW5nLCBsb25nUG9sbGluZ09wdGlvbnMsIHVzZUZldGNoU3RyZWFtcywgaXNVc2luZ0VtdWxhdG9yLCBhcGlLZXkpIHtcbiAgICAgICAgdGhpcy5kYXRhYmFzZUlkID0gZGF0YWJhc2VJZDtcbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkO1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlS2V5ID0gcGVyc2lzdGVuY2VLZXk7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuc3NsID0gc3NsO1xuICAgICAgICB0aGlzLmZvcmNlTG9uZ1BvbGxpbmcgPSBmb3JjZUxvbmdQb2xsaW5nO1xuICAgICAgICB0aGlzLmF1dG9EZXRlY3RMb25nUG9sbGluZyA9IGF1dG9EZXRlY3RMb25nUG9sbGluZztcbiAgICAgICAgdGhpcy5sb25nUG9sbGluZ09wdGlvbnMgPSBsb25nUG9sbGluZ09wdGlvbnM7XG4gICAgICAgIHRoaXMudXNlRmV0Y2hTdHJlYW1zID0gdXNlRmV0Y2hTdHJlYW1zO1xuICAgICAgICB0aGlzLmlzVXNpbmdFbXVsYXRvciA9IGlzVXNpbmdFbXVsYXRvcjtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgfVxufVxuLyoqIFRoZSBkZWZhdWx0IGRhdGFiYXNlIG5hbWUgZm9yIGEgcHJvamVjdC4gKi9cbmNvbnN0IERFRkFVTFRfREFUQUJBU0VfTkFNRSA9ICcoZGVmYXVsdCknO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBkYXRhYmFzZSBJRCBhIEZpcmVzdG9yZSBjbGllbnQgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIERhdGFiYXNlSWQge1xuICAgIGNvbnN0cnVjdG9yKHByb2plY3RJZCwgZGF0YWJhc2UpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0SWQgPSBwcm9qZWN0SWQ7XG4gICAgICAgIHRoaXMuZGF0YWJhc2UgPSBkYXRhYmFzZSA/IGRhdGFiYXNlIDogREVGQVVMVF9EQVRBQkFTRV9OQU1FO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YWJhc2VJZCgnJywgJycpO1xuICAgIH1cbiAgICBnZXQgaXNEZWZhdWx0RGF0YWJhc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFiYXNlID09PSBERUZBVUxUX0RBVEFCQVNFX05BTUU7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIChvdGhlciBpbnN0YW5jZW9mIERhdGFiYXNlSWQgJiZcbiAgICAgICAgICAgIG90aGVyLnByb2plY3RJZCA9PT0gdGhpcy5wcm9qZWN0SWQgJiZcbiAgICAgICAgICAgIG90aGVyLmRhdGFiYXNlID09PSB0aGlzLmRhdGFiYXNlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkYXRhYmFzZUlkRnJvbUFwcChhcHAsIGRhdGFiYXNlKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmFwcGx5KGFwcC5vcHRpb25zLCBbJ3Byb2plY3RJZCddKSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnXCJwcm9qZWN0SWRcIiBub3QgcHJvdmlkZWQgaW4gZmlyZWJhc2UuaW5pdGlhbGl6ZUFwcC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRhYmFzZUlkKGFwcC5vcHRpb25zLnByb2plY3RJZCwgZGF0YWJhc2UpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIFNlbnRpbmVsIHZhbHVlIHRoYXQgc29ydHMgYmVmb3JlIGFueSBNdXRhdGlvbiBCYXRjaCBJRC4gKi9cbmNvbnN0IEJBVENISURfVU5LTk9XTiA9IC0xO1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSB2YXJpYWJsZSBpcyBlaXRoZXIgdW5kZWZpbmVkIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG4vKiogUmV0dXJucyB3aGV0aGVyIHRoZSB2YWx1ZSByZXByZXNlbnRzIC0wLiAqL1xuZnVuY3Rpb24gaXNOZWdhdGl2ZVplcm8odmFsdWUpIHtcbiAgICAvLyBEZXRlY3QgaWYgdGhlIHZhbHVlIGlzIC0wLjAuIEJhc2VkIG9uIHBvbHlmaWxsIGZyb21cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlID09PSAxIC8gLTA7XG59XG5mdW5jdGlvbiBpc051bWJlciQxKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBhIHZhbHVlIGlzIGFuIGludGVnZXIgYW5kIGluIHRoZSBzYWZlIGludGVnZXIgcmFuZ2VcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0IGZvciBiZWluZyBhbiBpbnRlZ2VyIGFuZCBpbiB0aGUgc2FmZSByYW5nZVxuICovXG5mdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgICAgIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmXG4gICAgICAgICFpc05lZ2F0aXZlWmVybyh2YWx1ZSkgJiZcbiAgICAgICAgdmFsdWUgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgJiZcbiAgICAgICAgdmFsdWUgPj0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IFRZUEVfS0VZID0gJ19fdHlwZV9fJztcbmNvbnN0IE1BWF9WQUxVRV9UWVBFID0gJ19fbWF4X18nO1xuY29uc3QgTUFYX1ZBTFVFID0ge1xuICAgIG1hcFZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgJ19fdHlwZV9fJzogeyBzdHJpbmdWYWx1ZTogTUFYX1ZBTFVFX1RZUEUgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IFZFQ1RPUl9WQUxVRV9TRU5USU5FTCA9ICdfX3ZlY3Rvcl9fJztcbmNvbnN0IFZFQ1RPUl9NQVBfVkVDVE9SU19LRVkgPSAndmFsdWUnO1xuY29uc3QgTUlOX1ZBTFVFID0ge1xuICAgIG51bGxWYWx1ZTogJ05VTExfVkFMVUUnXG59O1xuLyoqIEV4dHJhY3RzIHRoZSBiYWNrZW5kJ3MgdHlwZSBvcmRlciBmb3IgdGhlIHByb3ZpZGVkIHZhbHVlLiAqL1xuZnVuY3Rpb24gdHlwZU9yZGVyKHZhbHVlKSB7XG4gICAgaWYgKCdudWxsVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAwIC8qIFR5cGVPcmRlci5OdWxsVmFsdWUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCdib29sZWFuVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFR5cGVPcmRlci5Cb29sZWFuVmFsdWUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIHZhbHVlIHx8ICdkb3VibGVWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDIgLyogVHlwZU9yZGVyLk51bWJlclZhbHVlICovO1xuICAgIH1cbiAgICBlbHNlIGlmICgndGltZXN0YW1wVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAzIC8qIFR5cGVPcmRlci5UaW1lc3RhbXBWYWx1ZSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3N0cmluZ1ZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gNSAvKiBUeXBlT3JkZXIuU3RyaW5nVmFsdWUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCdieXRlc1ZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gNiAvKiBUeXBlT3JkZXIuQmxvYlZhbHVlICovO1xuICAgIH1cbiAgICBlbHNlIGlmICgncmVmZXJlbmNlVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiA3IC8qIFR5cGVPcmRlci5SZWZWYWx1ZSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2dlb1BvaW50VmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiA4IC8qIFR5cGVPcmRlci5HZW9Qb2ludFZhbHVlICovO1xuICAgIH1cbiAgICBlbHNlIGlmICgnYXJyYXlWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDkgLyogVHlwZU9yZGVyLkFycmF5VmFsdWUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCdtYXBWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzU2VydmVyVGltZXN0YW1wKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDQgLyogVHlwZU9yZGVyLlNlcnZlclRpbWVzdGFtcFZhbHVlICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTWF4VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gOTAwNzE5OTI1NDc0MDk5MSAvKiBUeXBlT3JkZXIuTWF4VmFsdWUgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNWZWN0b3JWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAxMCAvKiBUeXBlT3JkZXIuVmVjdG9yVmFsdWUgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDExIC8qIFR5cGVPcmRlci5PYmplY3RWYWx1ZSAqLztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKDB4NmU4NywgeyB2YWx1ZSB9KTtcbiAgICB9XG59XG4vKiogVGVzdHMgYGxlZnRgIGFuZCBgcmlnaHRgIGZvciBlcXVhbGl0eSBiYXNlZCBvbiB0aGUgYmFja2VuZCBzZW1hbnRpY3MuICovXG5mdW5jdGlvbiB2YWx1ZUVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0ID09PSByaWdodCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbGVmdFR5cGUgPSB0eXBlT3JkZXIobGVmdCk7XG4gICAgY29uc3QgcmlnaHRUeXBlID0gdHlwZU9yZGVyKHJpZ2h0KTtcbiAgICBpZiAobGVmdFR5cGUgIT09IHJpZ2h0VHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAobGVmdFR5cGUpIHtcbiAgICAgICAgY2FzZSAwIC8qIFR5cGVPcmRlci5OdWxsVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAxIC8qIFR5cGVPcmRlci5Cb29sZWFuVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gbGVmdC5ib29sZWFuVmFsdWUgPT09IHJpZ2h0LmJvb2xlYW5WYWx1ZTtcbiAgICAgICAgY2FzZSA0IC8qIFR5cGVPcmRlci5TZXJ2ZXJUaW1lc3RhbXBWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBnZXRMb2NhbFdyaXRlVGltZShsZWZ0KS5pc0VxdWFsKGdldExvY2FsV3JpdGVUaW1lKHJpZ2h0KSk7XG4gICAgICAgIGNhc2UgMyAvKiBUeXBlT3JkZXIuVGltZXN0YW1wVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wRXF1YWxzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgY2FzZSA1IC8qIFR5cGVPcmRlci5TdHJpbmdWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnN0cmluZ1ZhbHVlID09PSByaWdodC5zdHJpbmdWYWx1ZTtcbiAgICAgICAgY2FzZSA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gYmxvYkVxdWFscyhsZWZ0LCByaWdodCk7XG4gICAgICAgIGNhc2UgNyAvKiBUeXBlT3JkZXIuUmVmVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gbGVmdC5yZWZlcmVuY2VWYWx1ZSA9PT0gcmlnaHQucmVmZXJlbmNlVmFsdWU7XG4gICAgICAgIGNhc2UgOCAvKiBUeXBlT3JkZXIuR2VvUG9pbnRWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBnZW9Qb2ludEVxdWFscyhsZWZ0LCByaWdodCk7XG4gICAgICAgIGNhc2UgMiAvKiBUeXBlT3JkZXIuTnVtYmVyVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyRXF1YWxzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgY2FzZSA5IC8qIFR5cGVPcmRlci5BcnJheVZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKGxlZnQuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10sIHJpZ2h0LmFycmF5VmFsdWUudmFsdWVzIHx8IFtdLCB2YWx1ZUVxdWFscyk7XG4gICAgICAgIGNhc2UgMTAgLyogVHlwZU9yZGVyLlZlY3RvclZhbHVlICovOlxuICAgICAgICBjYXNlIDExIC8qIFR5cGVPcmRlci5PYmplY3RWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RFcXVhbHMobGVmdCwgcmlnaHQpO1xuICAgICAgICBjYXNlIDkwMDcxOTkyNTQ3NDA5OTEgLyogVHlwZU9yZGVyLk1heFZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgweGNiZjgsIHsgbGVmdCB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiB0aW1lc3RhbXBFcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAodHlwZW9mIGxlZnQudGltZXN0YW1wVmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIHR5cGVvZiByaWdodC50aW1lc3RhbXBWYWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgbGVmdC50aW1lc3RhbXBWYWx1ZS5sZW5ndGggPT09IHJpZ2h0LnRpbWVzdGFtcFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAvLyBVc2Ugc3RyaW5nIGVxdWFsaXR5IGZvciBJU08gODYwMSB0aW1lc3RhbXBzXG4gICAgICAgIHJldHVybiBsZWZ0LnRpbWVzdGFtcFZhbHVlID09PSByaWdodC50aW1lc3RhbXBWYWx1ZTtcbiAgICB9XG4gICAgY29uc3QgbGVmdFRpbWVzdGFtcCA9IG5vcm1hbGl6ZVRpbWVzdGFtcChsZWZ0LnRpbWVzdGFtcFZhbHVlKTtcbiAgICBjb25zdCByaWdodFRpbWVzdGFtcCA9IG5vcm1hbGl6ZVRpbWVzdGFtcChyaWdodC50aW1lc3RhbXBWYWx1ZSk7XG4gICAgcmV0dXJuIChsZWZ0VGltZXN0YW1wLnNlY29uZHMgPT09IHJpZ2h0VGltZXN0YW1wLnNlY29uZHMgJiZcbiAgICAgICAgbGVmdFRpbWVzdGFtcC5uYW5vcyA9PT0gcmlnaHRUaW1lc3RhbXAubmFub3MpO1xufVxuZnVuY3Rpb24gZ2VvUG9pbnRFcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gKG5vcm1hbGl6ZU51bWJlcihsZWZ0Lmdlb1BvaW50VmFsdWUubGF0aXR1ZGUpID09PVxuICAgICAgICBub3JtYWxpemVOdW1iZXIocmlnaHQuZ2VvUG9pbnRWYWx1ZS5sYXRpdHVkZSkgJiZcbiAgICAgICAgbm9ybWFsaXplTnVtYmVyKGxlZnQuZ2VvUG9pbnRWYWx1ZS5sb25naXR1ZGUpID09PVxuICAgICAgICAgICAgbm9ybWFsaXplTnVtYmVyKHJpZ2h0Lmdlb1BvaW50VmFsdWUubG9uZ2l0dWRlKSk7XG59XG5mdW5jdGlvbiBibG9iRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUJ5dGVTdHJpbmcobGVmdC5ieXRlc1ZhbHVlKS5pc0VxdWFsKG5vcm1hbGl6ZUJ5dGVTdHJpbmcocmlnaHQuYnl0ZXNWYWx1ZSkpO1xufVxuZnVuY3Rpb24gbnVtYmVyRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIGxlZnQgJiYgJ2ludGVnZXJWYWx1ZScgaW4gcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIChub3JtYWxpemVOdW1iZXIobGVmdC5pbnRlZ2VyVmFsdWUpID09PSBub3JtYWxpemVOdW1iZXIocmlnaHQuaW50ZWdlclZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdkb3VibGVWYWx1ZScgaW4gbGVmdCAmJiAnZG91YmxlVmFsdWUnIGluIHJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IG4xID0gbm9ybWFsaXplTnVtYmVyKGxlZnQuZG91YmxlVmFsdWUpO1xuICAgICAgICBjb25zdCBuMiA9IG5vcm1hbGl6ZU51bWJlcihyaWdodC5kb3VibGVWYWx1ZSk7XG4gICAgICAgIGlmIChuMSA9PT0gbjIpIHtcbiAgICAgICAgICAgIHJldHVybiBpc05lZ2F0aXZlWmVybyhuMSkgPT09IGlzTmVnYXRpdmVaZXJvKG4yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc05hTihuMSkgJiYgaXNOYU4objIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9iamVjdEVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IGxlZnRNYXAgPSBsZWZ0Lm1hcFZhbHVlLmZpZWxkcyB8fCB7fTtcbiAgICBjb25zdCByaWdodE1hcCA9IHJpZ2h0Lm1hcFZhbHVlLmZpZWxkcyB8fCB7fTtcbiAgICBpZiAob2JqZWN0U2l6ZShsZWZ0TWFwKSAhPT0gb2JqZWN0U2l6ZShyaWdodE1hcCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBsZWZ0TWFwKSB7XG4gICAgICAgIGlmIChsZWZ0TWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGlmIChyaWdodE1hcFtrZXldID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAhdmFsdWVFcXVhbHMobGVmdE1hcFtrZXldLCByaWdodE1hcFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIEFycmF5VmFsdWUgY29udGFpbnMgdGhlIHNwZWNpZmllZCBlbGVtZW50LiAqL1xuZnVuY3Rpb24gYXJyYXlWYWx1ZUNvbnRhaW5zKGhheXN0YWNrLCBuZWVkbGUpIHtcbiAgICByZXR1cm4gKChoYXlzdGFjay52YWx1ZXMgfHwgW10pLmZpbmQodiA9PiB2YWx1ZUVxdWFscyh2LCBuZWVkbGUpKSAhPT0gdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIHZhbHVlQ29tcGFyZShsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0ID09PSByaWdodCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgbGVmdFR5cGUgPSB0eXBlT3JkZXIobGVmdCk7XG4gICAgY29uc3QgcmlnaHRUeXBlID0gdHlwZU9yZGVyKHJpZ2h0KTtcbiAgICBpZiAobGVmdFR5cGUgIT09IHJpZ2h0VHlwZSkge1xuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0VHlwZSwgcmlnaHRUeXBlKTtcbiAgICB9XG4gICAgc3dpdGNoIChsZWZ0VHlwZSkge1xuICAgICAgICBjYXNlIDAgLyogVHlwZU9yZGVyLk51bGxWYWx1ZSAqLzpcbiAgICAgICAgY2FzZSA5MDA3MTk5MjU0NzQwOTkxIC8qIFR5cGVPcmRlci5NYXhWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlIDEgLyogVHlwZU9yZGVyLkJvb2xlYW5WYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQuYm9vbGVhblZhbHVlLCByaWdodC5ib29sZWFuVmFsdWUpO1xuICAgICAgICBjYXNlIDIgLyogVHlwZU9yZGVyLk51bWJlclZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVOdW1iZXJzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgY2FzZSAzIC8qIFR5cGVPcmRlci5UaW1lc3RhbXBWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlVGltZXN0YW1wcyhsZWZ0LnRpbWVzdGFtcFZhbHVlLCByaWdodC50aW1lc3RhbXBWYWx1ZSk7XG4gICAgICAgIGNhc2UgNCAvKiBUeXBlT3JkZXIuU2VydmVyVGltZXN0YW1wVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVRpbWVzdGFtcHMoZ2V0TG9jYWxXcml0ZVRpbWUobGVmdCksIGdldExvY2FsV3JpdGVUaW1lKHJpZ2h0KSk7XG4gICAgICAgIGNhc2UgNSAvKiBUeXBlT3JkZXIuU3RyaW5nVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVV0ZjhTdHJpbmdzKGxlZnQuc3RyaW5nVmFsdWUsIHJpZ2h0LnN0cmluZ1ZhbHVlKTtcbiAgICAgICAgY2FzZSA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUJsb2JzKGxlZnQuYnl0ZXNWYWx1ZSwgcmlnaHQuYnl0ZXNWYWx1ZSk7XG4gICAgICAgIGNhc2UgNyAvKiBUeXBlT3JkZXIuUmVmVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVJlZmVyZW5jZXMobGVmdC5yZWZlcmVuY2VWYWx1ZSwgcmlnaHQucmVmZXJlbmNlVmFsdWUpO1xuICAgICAgICBjYXNlIDggLyogVHlwZU9yZGVyLkdlb1BvaW50VmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUdlb1BvaW50cyhsZWZ0Lmdlb1BvaW50VmFsdWUsIHJpZ2h0Lmdlb1BvaW50VmFsdWUpO1xuICAgICAgICBjYXNlIDkgLyogVHlwZU9yZGVyLkFycmF5VmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUFycmF5cyhsZWZ0LmFycmF5VmFsdWUsIHJpZ2h0LmFycmF5VmFsdWUpO1xuICAgICAgICBjYXNlIDEwIC8qIFR5cGVPcmRlci5WZWN0b3JWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlVmVjdG9ycyhsZWZ0Lm1hcFZhbHVlLCByaWdodC5tYXBWYWx1ZSk7XG4gICAgICAgIGNhc2UgMTEgLyogVHlwZU9yZGVyLk9iamVjdFZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVNYXBzKGxlZnQubWFwVmFsdWUsIHJpZ2h0Lm1hcFZhbHVlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IGZhaWwoMHg1YWUwLCB7IGxlZnRUeXBlIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgbGVmdE51bWJlciA9IG5vcm1hbGl6ZU51bWJlcihsZWZ0LmludGVnZXJWYWx1ZSB8fCBsZWZ0LmRvdWJsZVZhbHVlKTtcbiAgICBjb25zdCByaWdodE51bWJlciA9IG5vcm1hbGl6ZU51bWJlcihyaWdodC5pbnRlZ2VyVmFsdWUgfHwgcmlnaHQuZG91YmxlVmFsdWUpO1xuICAgIGlmIChsZWZ0TnVtYmVyIDwgcmlnaHROdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZWZ0TnVtYmVyID4gcmlnaHROdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlZnROdW1iZXIgPT09IHJpZ2h0TnVtYmVyKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gb25lIG9yIGJvdGggYXJlIE5hTi5cbiAgICAgICAgaWYgKGlzTmFOKGxlZnROdW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNOYU4ocmlnaHROdW1iZXIpID8gMCA6IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlVGltZXN0YW1wcyhsZWZ0LCByaWdodCkge1xuICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgdHlwZW9mIHJpZ2h0ID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBsZWZ0Lmxlbmd0aCA9PT0gcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgY29uc3QgbGVmdFRpbWVzdGFtcCA9IG5vcm1hbGl6ZVRpbWVzdGFtcChsZWZ0KTtcbiAgICBjb25zdCByaWdodFRpbWVzdGFtcCA9IG5vcm1hbGl6ZVRpbWVzdGFtcChyaWdodCk7XG4gICAgY29uc3QgY29tcGFyaXNvbiA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFRpbWVzdGFtcC5zZWNvbmRzLCByaWdodFRpbWVzdGFtcC5zZWNvbmRzKTtcbiAgICBpZiAoY29tcGFyaXNvbiAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY29tcGFyaXNvbjtcbiAgICB9XG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFRpbWVzdGFtcC5uYW5vcywgcmlnaHRUaW1lc3RhbXAubmFub3MpO1xufVxuZnVuY3Rpb24gY29tcGFyZVJlZmVyZW5jZXMobGVmdFBhdGgsIHJpZ2h0UGF0aCkge1xuICAgIGNvbnN0IGxlZnRTZWdtZW50cyA9IGxlZnRQYXRoLnNwbGl0KCcvJyk7XG4gICAgY29uc3QgcmlnaHRTZWdtZW50cyA9IHJpZ2h0UGF0aC5zcGxpdCgnLycpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdFNlZ21lbnRzLmxlbmd0aCAmJiBpIDwgcmlnaHRTZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb21wYXJpc29uID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0U2VnbWVudHNbaV0sIHJpZ2h0U2VnbWVudHNbaV0pO1xuICAgICAgICBpZiAoY29tcGFyaXNvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFNlZ21lbnRzLmxlbmd0aCwgcmlnaHRTZWdtZW50cy5sZW5ndGgpO1xufVxuZnVuY3Rpb24gY29tcGFyZUdlb1BvaW50cyhsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IGNvbXBhcmlzb24gPSBwcmltaXRpdmVDb21wYXJhdG9yKG5vcm1hbGl6ZU51bWJlcihsZWZ0LmxhdGl0dWRlKSwgbm9ybWFsaXplTnVtYmVyKHJpZ2h0LmxhdGl0dWRlKSk7XG4gICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmlzb247XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKG5vcm1hbGl6ZU51bWJlcihsZWZ0LmxvbmdpdHVkZSksIG5vcm1hbGl6ZU51bWJlcihyaWdodC5sb25naXR1ZGUpKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVCbG9icyhsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IGxlZnRCeXRlcyA9IG5vcm1hbGl6ZUJ5dGVTdHJpbmcobGVmdCk7XG4gICAgY29uc3QgcmlnaHRCeXRlcyA9IG5vcm1hbGl6ZUJ5dGVTdHJpbmcocmlnaHQpO1xuICAgIHJldHVybiBsZWZ0Qnl0ZXMuY29tcGFyZVRvKHJpZ2h0Qnl0ZXMpO1xufVxuZnVuY3Rpb24gY29tcGFyZUFycmF5cyhsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IGxlZnRBcnJheSA9IGxlZnQudmFsdWVzIHx8IFtdO1xuICAgIGNvbnN0IHJpZ2h0QXJyYXkgPSByaWdodC52YWx1ZXMgfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0QXJyYXkubGVuZ3RoICYmIGkgPCByaWdodEFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNvbXBhcmUgPSB2YWx1ZUNvbXBhcmUobGVmdEFycmF5W2ldLCByaWdodEFycmF5W2ldKTtcbiAgICAgICAgaWYgKGNvbXBhcmUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRBcnJheS5sZW5ndGgsIHJpZ2h0QXJyYXkubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVWZWN0b3JzKGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgbGVmdE1hcCA9IGxlZnQuZmllbGRzIHx8IHt9O1xuICAgIGNvbnN0IHJpZ2h0TWFwID0gcmlnaHQuZmllbGRzIHx8IHt9O1xuICAgIC8vIFRoZSB2ZWN0b3IgaXMgYSBtYXAsIGJ1dCBvbmx5IHZlY3RvciB2YWx1ZSBpcyBjb21wYXJlZC5cbiAgICBjb25zdCBsZWZ0QXJyYXlWYWx1ZSA9IGxlZnRNYXBbVkVDVE9SX01BUF9WRUNUT1JTX0tFWV0/LmFycmF5VmFsdWU7XG4gICAgY29uc3QgcmlnaHRBcnJheVZhbHVlID0gcmlnaHRNYXBbVkVDVE9SX01BUF9WRUNUT1JTX0tFWV0/LmFycmF5VmFsdWU7XG4gICAgY29uc3QgbGVuZ3RoQ29tcGFyZSA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdEFycmF5VmFsdWU/LnZhbHVlcz8ubGVuZ3RoIHx8IDAsIHJpZ2h0QXJyYXlWYWx1ZT8udmFsdWVzPy5sZW5ndGggfHwgMCk7XG4gICAgaWYgKGxlbmd0aENvbXBhcmUgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aENvbXBhcmU7XG4gICAgfVxuICAgIHJldHVybiBjb21wYXJlQXJyYXlzKGxlZnRBcnJheVZhbHVlLCByaWdodEFycmF5VmFsdWUpO1xufVxuZnVuY3Rpb24gY29tcGFyZU1hcHMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdCA9PT0gTUFYX1ZBTFVFLm1hcFZhbHVlICYmIHJpZ2h0ID09PSBNQVhfVkFMVUUubWFwVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlZnQgPT09IE1BWF9WQUxVRS5tYXBWYWx1ZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmlnaHQgPT09IE1BWF9WQUxVRS5tYXBWYWx1ZSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGNvbnN0IGxlZnRNYXAgPSBsZWZ0LmZpZWxkcyB8fCB7fTtcbiAgICBjb25zdCBsZWZ0S2V5cyA9IE9iamVjdC5rZXlzKGxlZnRNYXApO1xuICAgIGNvbnN0IHJpZ2h0TWFwID0gcmlnaHQuZmllbGRzIHx8IHt9O1xuICAgIGNvbnN0IHJpZ2h0S2V5cyA9IE9iamVjdC5rZXlzKHJpZ2h0TWFwKTtcbiAgICAvLyBFdmVuIHRob3VnaCBNYXBWYWx1ZXMgYXJlIGxpa2VseSBzb3J0ZWQgY29ycmVjdGx5IGJhc2VkIG9uIHRoZWlyIGluc2VydGlvblxuICAgIC8vIG9yZGVyIChlLmcuIHdoZW4gcmVjZWl2ZWQgZnJvbSB0aGUgYmFja2VuZCksIGxvY2FsIG1vZGlmaWNhdGlvbnMgY2FuIGJyaW5nXG4gICAgLy8gZWxlbWVudHMgb3V0IG9mIG9yZGVyLiBXZSBuZWVkIHRvIHJlLXNvcnQgdGhlIGVsZW1lbnRzIHRvIGVuc3VyZSB0aGF0XG4gICAgLy8gY2Fub25pY2FsIElEcyBhcmUgaW5kZXBlbmRlbnQgb2YgaW5zZXJ0aW9uIG9yZGVyLlxuICAgIGxlZnRLZXlzLnNvcnQoKTtcbiAgICByaWdodEtleXMuc29ydCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoICYmIGkgPCByaWdodEtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qga2V5Q29tcGFyZSA9IGNvbXBhcmVVdGY4U3RyaW5ncyhsZWZ0S2V5c1tpXSwgcmlnaHRLZXlzW2ldKTtcbiAgICAgICAgaWYgKGtleUNvbXBhcmUgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlDb21wYXJlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBhcmUgPSB2YWx1ZUNvbXBhcmUobGVmdE1hcFtsZWZ0S2V5c1tpXV0sIHJpZ2h0TWFwW3JpZ2h0S2V5c1tpXV0pO1xuICAgICAgICBpZiAoY29tcGFyZSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdEtleXMubGVuZ3RoLCByaWdodEtleXMubGVuZ3RoKTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBjYW5vbmljYWwgSUQgZm9yIHRoZSBwcm92aWRlZCBmaWVsZCB2YWx1ZSAoYXMgdXNlZCBpbiBUYXJnZXRcbiAqIHNlcmlhbGl6YXRpb24pLlxuICovXG5mdW5jdGlvbiBjYW5vbmljYWxJZCh2YWx1ZSkge1xuICAgIHJldHVybiBjYW5vbmlmeVZhbHVlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5VmFsdWUodmFsdWUpIHtcbiAgICBpZiAoJ251bGxWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2Jvb2xlYW5WYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdmFsdWUuYm9vbGVhblZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgnaW50ZWdlclZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gJycgKyB2YWx1ZS5pbnRlZ2VyVmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdkb3VibGVWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdmFsdWUuZG91YmxlVmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCd0aW1lc3RhbXBWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbm9uaWZ5VGltZXN0YW1wKHZhbHVlLnRpbWVzdGFtcFZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3N0cmluZ1ZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuc3RyaW5nVmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdieXRlc1ZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2Fub25pZnlCeXRlU3RyaW5nKHZhbHVlLmJ5dGVzVmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICgncmVmZXJlbmNlVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYW5vbmlmeVJlZmVyZW5jZSh2YWx1ZS5yZWZlcmVuY2VWYWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdnZW9Qb2ludFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2Fub25pZnlHZW9Qb2ludCh2YWx1ZS5nZW9Qb2ludFZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2FycmF5VmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYW5vbmlmeUFycmF5KHZhbHVlLmFycmF5VmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnbWFwVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYW5vbmlmeU1hcCh2YWx1ZS5tYXBWYWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgweGVlNGQsIHsgdmFsdWUgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2Fub25pZnlCeXRlU3RyaW5nKGJ5dGVTdHJpbmcpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplQnl0ZVN0cmluZyhieXRlU3RyaW5nKS50b0Jhc2U2NCgpO1xufVxuZnVuY3Rpb24gY2Fub25pZnlUaW1lc3RhbXAodGltZXN0YW1wKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFRpbWVzdGFtcCA9IG5vcm1hbGl6ZVRpbWVzdGFtcCh0aW1lc3RhbXApO1xuICAgIHJldHVybiBgdGltZSgke25vcm1hbGl6ZWRUaW1lc3RhbXAuc2Vjb25kc30sJHtub3JtYWxpemVkVGltZXN0YW1wLm5hbm9zfSlgO1xufVxuZnVuY3Rpb24gY2Fub25pZnlHZW9Qb2ludChnZW9Qb2ludCkge1xuICAgIHJldHVybiBgZ2VvKCR7Z2VvUG9pbnQubGF0aXR1ZGV9LCR7Z2VvUG9pbnQubG9uZ2l0dWRlfSlgO1xufVxuZnVuY3Rpb24gY2Fub25pZnlSZWZlcmVuY2UocmVmZXJlbmNlVmFsdWUpIHtcbiAgICByZXR1cm4gRG9jdW1lbnRLZXkuZnJvbU5hbWUocmVmZXJlbmNlVmFsdWUpLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBjYW5vbmlmeU1hcChtYXBWYWx1ZSkge1xuICAgIC8vIEl0ZXJhdGlvbiBvcmRlciBpbiBKYXZhU2NyaXB0IGlzIG5vdCBndWFyYW50ZWVkLiBUbyBlbnN1cmUgdGhhdCB3ZSBnZW5lcmF0ZVxuICAgIC8vIG1hdGNoaW5nIGNhbm9uaWNhbCBJRHMgZm9yIGlkZW50aWNhbCBtYXBzLCB3ZSBuZWVkIHRvIHNvcnQgdGhlIGtleXMuXG4gICAgY29uc3Qgc29ydGVkS2V5cyA9IE9iamVjdC5rZXlzKG1hcFZhbHVlLmZpZWxkcyB8fCB7fSkuc29ydCgpO1xuICAgIGxldCByZXN1bHQgPSAneyc7XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBzb3J0ZWRLZXlzKSB7XG4gICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBgJHtrZXl9OiR7Y2Fub25pZnlWYWx1ZShtYXBWYWx1ZS5maWVsZHNba2V5XSl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCArICd9Jztcbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5QXJyYXkoYXJyYXlWYWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSAnWyc7XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGFycmF5VmFsdWUudmFsdWVzIHx8IFtdKSB7XG4gICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBjYW5vbmlmeVZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCArICddJztcbn1cbi8qKlxuICogUmV0dXJucyBhbiBhcHByb3hpbWF0ZSAoYW5kIHdpbGRseSBpbmFjY3VyYXRlKSBpbi1tZW1vcnkgc2l6ZSBmb3IgdGhlIGZpZWxkXG4gKiB2YWx1ZS5cbiAqXG4gKiBUaGUgbWVtb3J5IHNpemUgdGFrZXMgaW50byBhY2NvdW50IG9ubHkgdGhlIGFjdHVhbCB1c2VyIGRhdGEgYXMgaXQgcmVzaWRlc1xuICogaW4gbWVtb3J5IGFuZCBpZ25vcmVzIG9iamVjdCBvdmVyaGVhZC5cbiAqL1xuZnVuY3Rpb24gZXN0aW1hdGVCeXRlU2l6ZSh2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZU9yZGVyKHZhbHVlKSkge1xuICAgICAgICBjYXNlIDAgLyogVHlwZU9yZGVyLk51bGxWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICBjYXNlIDEgLyogVHlwZU9yZGVyLkJvb2xlYW5WYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICBjYXNlIDIgLyogVHlwZU9yZGVyLk51bWJlclZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIGNhc2UgMyAvKiBUeXBlT3JkZXIuVGltZXN0YW1wVmFsdWUgKi86XG4gICAgICAgICAgICAvLyBUaW1lc3RhbXBzIGFyZSBtYWRlIHVwIG9mIHR3byBkaXN0aW5jdCBudW1iZXJzIChzZWNvbmRzICsgbmFub3NlY29uZHMpXG4gICAgICAgICAgICByZXR1cm4gMTY7XG4gICAgICAgIGNhc2UgNCAvKiBUeXBlT3JkZXIuU2VydmVyVGltZXN0YW1wVmFsdWUgKi86XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gZ2V0UHJldmlvdXNWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNWYWx1ZSA/IDE2ICsgZXN0aW1hdGVCeXRlU2l6ZShwcmV2aW91c1ZhbHVlKSA6IDE2O1xuICAgICAgICBjYXNlIDUgLyogVHlwZU9yZGVyLlN0cmluZ1ZhbHVlICovOlxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvRGF0YV9zdHJ1Y3R1cmVzOlxuICAgICAgICAgICAgLy8gXCJKYXZhU2NyaXB0J3MgU3RyaW5nIHR5cGUgaXMgWy4uLl0gYSBzZXQgb2YgZWxlbWVudHMgb2YgMTYtYml0IHVuc2lnbmVkXG4gICAgICAgICAgICAvLyBpbnRlZ2VyIHZhbHVlc1wiXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3RyaW5nVmFsdWUubGVuZ3RoICogMjtcbiAgICAgICAgY2FzZSA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplQnl0ZVN0cmluZyh2YWx1ZS5ieXRlc1ZhbHVlKS5hcHByb3hpbWF0ZUJ5dGVTaXplKCk7XG4gICAgICAgIGNhc2UgNyAvKiBUeXBlT3JkZXIuUmVmVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUucmVmZXJlbmNlVmFsdWUubGVuZ3RoO1xuICAgICAgICBjYXNlIDggLyogVHlwZU9yZGVyLkdlb1BvaW50VmFsdWUgKi86XG4gICAgICAgICAgICAvLyBHZW9Qb2ludHMgYXJlIG1hZGUgdXAgb2YgdHdvIGRpc3RpbmN0IG51bWJlcnMgKGxhdGl0dWRlICsgbG9uZ2l0dWRlKVxuICAgICAgICAgICAgcmV0dXJuIDE2O1xuICAgICAgICBjYXNlIDkgLyogVHlwZU9yZGVyLkFycmF5VmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gZXN0aW1hdGVBcnJheUJ5dGVTaXplKHZhbHVlLmFycmF5VmFsdWUpO1xuICAgICAgICBjYXNlIDEwIC8qIFR5cGVPcmRlci5WZWN0b3JWYWx1ZSAqLzpcbiAgICAgICAgY2FzZSAxMSAvKiBUeXBlT3JkZXIuT2JqZWN0VmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gZXN0aW1hdGVNYXBCeXRlU2l6ZSh2YWx1ZS5tYXBWYWx1ZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBmYWlsKDB4MzRhZSwgeyB2YWx1ZSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBlc3RpbWF0ZU1hcEJ5dGVTaXplKG1hcFZhbHVlKSB7XG4gICAgbGV0IHNpemUgPSAwO1xuICAgIGZvckVhY2gobWFwVmFsdWUuZmllbGRzLCAoa2V5LCB2YWwpID0+IHtcbiAgICAgICAgc2l6ZSArPSBrZXkubGVuZ3RoICsgZXN0aW1hdGVCeXRlU2l6ZSh2YWwpO1xuICAgIH0pO1xuICAgIHJldHVybiBzaXplO1xufVxuZnVuY3Rpb24gZXN0aW1hdGVBcnJheUJ5dGVTaXplKGFycmF5VmFsdWUpIHtcbiAgICByZXR1cm4gKGFycmF5VmFsdWUudmFsdWVzIHx8IFtdKS5yZWR1Y2UoKHByZXZpb3VzU2l6ZSwgdmFsdWUpID0+IHByZXZpb3VzU2l6ZSArIGVzdGltYXRlQnl0ZVNpemUodmFsdWUpLCAwKTtcbn1cbi8qKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHZhbHVlIGZvciB0aGUgcHJvdmlkZWQgZGF0YWJhc2UgYW5kIGtleS4gKi9cbmZ1bmN0aW9uIHJlZlZhbHVlKGRhdGFiYXNlSWQsIGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlZmVyZW5jZVZhbHVlOiBgcHJvamVjdHMvJHtkYXRhYmFzZUlkLnByb2plY3RJZH0vZGF0YWJhc2VzLyR7ZGF0YWJhc2VJZC5kYXRhYmFzZX0vZG9jdW1lbnRzLyR7a2V5LnBhdGguY2Fub25pY2FsU3RyaW5nKCl9YFxuICAgIH07XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gSW50ZWdlclZhbHVlIC4gKi9cbmZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICdpbnRlZ2VyVmFsdWUnIGluIHZhbHVlO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgRG91YmxlVmFsdWUuICovXG5mdW5jdGlvbiBpc0RvdWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICdkb3VibGVWYWx1ZScgaW4gdmFsdWU7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgZWl0aGVyIGFuIEludGVnZXJWYWx1ZSBvciBhIERvdWJsZVZhbHVlLiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gaXNJbnRlZ2VyKHZhbHVlKSB8fCBpc0RvdWJsZSh2YWx1ZSk7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gQXJyYXlWYWx1ZS4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAnYXJyYXlWYWx1ZScgaW4gdmFsdWU7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBOdWxsVmFsdWUuICovXG5mdW5jdGlvbiBpc051bGxWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICdudWxsVmFsdWUnIGluIHZhbHVlO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIE5hTi4gKi9cbmZ1bmN0aW9uIGlzTmFuVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAnZG91YmxlVmFsdWUnIGluIHZhbHVlICYmIGlzTmFOKE51bWJlcih2YWx1ZS5kb3VibGVWYWx1ZSkpO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgTWFwVmFsdWUuICovXG5mdW5jdGlvbiBpc01hcFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgJ21hcFZhbHVlJyBpbiB2YWx1ZTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhIFZldG9yVmFsdWUuICovXG5mdW5jdGlvbiBpc1ZlY3RvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgdHlwZSA9ICh2YWx1ZT8ubWFwVmFsdWU/LmZpZWxkcyB8fCB7fSlbVFlQRV9LRVldPy5zdHJpbmdWYWx1ZTtcbiAgICByZXR1cm4gdHlwZSA9PT0gVkVDVE9SX1ZBTFVFX1NFTlRJTkVMO1xufVxuLyoqIENyZWF0ZXMgYSBkZWVwIGNvcHkgb2YgYHNvdXJjZWAuICovXG5mdW5jdGlvbiBkZWVwQ2xvbmUoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5nZW9Qb2ludFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGdlb1BvaW50VmFsdWU6IHsgLi4uc291cmNlLmdlb1BvaW50VmFsdWUgfSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChzb3VyY2UudGltZXN0YW1wVmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHNvdXJjZS50aW1lc3RhbXBWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHsgdGltZXN0YW1wVmFsdWU6IHsgLi4uc291cmNlLnRpbWVzdGFtcFZhbHVlIH0gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc291cmNlLm1hcFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHsgbWFwVmFsdWU6IHsgZmllbGRzOiB7fSB9IH07XG4gICAgICAgIGZvckVhY2goc291cmNlLm1hcFZhbHVlLmZpZWxkcywgKGtleSwgdmFsKSA9PiAodGFyZ2V0Lm1hcFZhbHVlLmZpZWxkc1trZXldID0gZGVlcENsb25lKHZhbCkpKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgZWxzZSBpZiAoc291cmNlLmFycmF5VmFsdWUpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0geyBhcnJheVZhbHVlOiB7IHZhbHVlczogW10gfSB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChzb3VyY2UuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYXJyYXlWYWx1ZS52YWx1ZXNbaV0gPSBkZWVwQ2xvbmUoc291cmNlLmFycmF5VmFsdWUudmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uc291cmNlIH07XG4gICAgfVxufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgVmFsdWUgcmVwcmVzZW50cyB0aGUgY2Fub25pY2FsIHtAbGluayAjTUFYX1ZBTFVFfSAuICovXG5mdW5jdGlvbiBpc01heFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuICgoKCh2YWx1ZS5tYXBWYWx1ZSB8fCB7fSkuZmllbGRzIHx8IHt9KVsnX190eXBlX18nXSB8fCB7fSkuc3RyaW5nVmFsdWUgPT09XG4gICAgICAgIE1BWF9WQUxVRV9UWVBFKTtcbn1cbmNvbnN0IE1JTl9WRUNUT1JfVkFMVUUgPSB7XG4gICAgbWFwVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICBbVFlQRV9LRVldOiB7IHN0cmluZ1ZhbHVlOiBWRUNUT1JfVkFMVUVfU0VOVElORUwgfSxcbiAgICAgICAgICAgIFtWRUNUT1JfTUFQX1ZFQ1RPUlNfS0VZXToge1xuICAgICAgICAgICAgICAgIGFycmF5VmFsdWU6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqIFJldHVybnMgdGhlIGxvd2VzdCB2YWx1ZSBmb3IgdGhlIGdpdmVuIHZhbHVlIHR5cGUgKGluY2x1c2l2ZSkuICovXG5mdW5jdGlvbiB2YWx1ZXNHZXRMb3dlckJvdW5kKHZhbHVlKSB7XG4gICAgaWYgKCdudWxsVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNSU5fVkFMVUU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdib29sZWFuVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGJvb2xlYW5WYWx1ZTogZmFsc2UgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2ludGVnZXJWYWx1ZScgaW4gdmFsdWUgfHwgJ2RvdWJsZVZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBkb3VibGVWYWx1ZTogTmFOIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKCd0aW1lc3RhbXBWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgdGltZXN0YW1wVmFsdWU6IHsgc2Vjb25kczogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgfSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnc3RyaW5nVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IHN0cmluZ1ZhbHVlOiAnJyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnYnl0ZXNWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgYnl0ZXNWYWx1ZTogJycgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3JlZmVyZW5jZVZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcmVmVmFsdWUoRGF0YWJhc2VJZC5lbXB0eSgpLCBEb2N1bWVudEtleS5lbXB0eSgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2dlb1BvaW50VmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGdlb1BvaW50VmFsdWU6IHsgbGF0aXR1ZGU6IC05MCwgbG9uZ2l0dWRlOiAtMTgwIH0gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2FycmF5VmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGFycmF5VmFsdWU6IHt9IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKCdtYXBWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzVmVjdG9yVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gTUlOX1ZFQ1RPUl9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXBWYWx1ZToge30gfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKDB4OGM2NiwgeyB2YWx1ZSB9KTtcbiAgICB9XG59XG4vKiogUmV0dXJucyB0aGUgbGFyZ2VzdCB2YWx1ZSBmb3IgdGhlIGdpdmVuIHZhbHVlIHR5cGUgKGV4Y2x1c2l2ZSkuICovXG5mdW5jdGlvbiB2YWx1ZXNHZXRVcHBlckJvdW5kKHZhbHVlKSB7XG4gICAgaWYgKCdudWxsVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGJvb2xlYW5WYWx1ZTogZmFsc2UgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2Jvb2xlYW5WYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6IE5hTiB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnaW50ZWdlclZhbHVlJyBpbiB2YWx1ZSB8fCAnZG91YmxlVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IHRpbWVzdGFtcFZhbHVlOiB7IHNlY29uZHM6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIH0gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3RpbWVzdGFtcFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBzdHJpbmdWYWx1ZTogJycgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3N0cmluZ1ZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBieXRlc1ZhbHVlOiAnJyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnYnl0ZXNWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHJlZlZhbHVlKERhdGFiYXNlSWQuZW1wdHkoKSwgRG9jdW1lbnRLZXkuZW1wdHkoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdyZWZlcmVuY2VWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZ2VvUG9pbnRWYWx1ZTogeyBsYXRpdHVkZTogLTkwLCBsb25naXR1ZGU6IC0xODAgfSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnZ2VvUG9pbnRWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgYXJyYXlWYWx1ZToge30gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2FycmF5VmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNSU5fVkVDVE9SX1ZBTFVFO1xuICAgIH1cbiAgICBlbHNlIGlmICgnbWFwVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc1ZlY3RvclZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWFwVmFsdWU6IHt9IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1BWF9WQUxVRTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKDB4ZjIwNywgeyB2YWx1ZSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb3dlckJvdW5kQ29tcGFyZShsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IGNtcCA9IHZhbHVlQ29tcGFyZShsZWZ0LnZhbHVlLCByaWdodC52YWx1ZSk7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICBpZiAobGVmdC5pbmNsdXNpdmUgJiYgIXJpZ2h0LmluY2x1c2l2ZSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFsZWZ0LmluY2x1c2l2ZSAmJiByaWdodC5pbmNsdXNpdmUpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gdXBwZXJCb3VuZENvbXBhcmUobGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBjbXAgPSB2YWx1ZUNvbXBhcmUobGVmdC52YWx1ZSwgcmlnaHQudmFsdWUpO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG4gICAgaWYgKGxlZnQuaW5jbHVzaXZlICYmICFyaWdodC5pbmNsdXNpdmUpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFsZWZ0LmluY2x1c2l2ZSAmJiByaWdodC5pbmNsdXNpdmUpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQW4gT2JqZWN0VmFsdWUgcmVwcmVzZW50cyBhIE1hcFZhbHVlIGluIHRoZSBGaXJlc3RvcmUgUHJvdG8gYW5kIG9mZmVycyB0aGVcbiAqIGFiaWxpdHkgdG8gYWRkIGFuZCByZW1vdmUgZmllbGRzICh2aWEgdGhlIE9iamVjdFZhbHVlQnVpbGRlcikuXG4gKi9cbmNsYXNzIE9iamVjdFZhbHVlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RWYWx1ZSh7IG1hcFZhbHVlOiB7fSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBhdGggb3IgbnVsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gdGhlIHBhdGggdG8gc2VhcmNoXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIGF0IHRoZSBwYXRoIG9yIG51bGwgaWYgdGhlIHBhdGggaXMgbm90IHNldC5cbiAgICAgKi9cbiAgICBmaWVsZChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudExldmVsID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSAoY3VycmVudExldmVsLm1hcFZhbHVlLmZpZWxkcyB8fCB7fSlbcGF0aC5nZXQoaSldO1xuICAgICAgICAgICAgICAgIGlmICghaXNNYXBWYWx1ZShjdXJyZW50TGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IChjdXJyZW50TGV2ZWwubWFwVmFsdWUuZmllbGRzIHx8IHt9KVtwYXRoLmxhc3RTZWdtZW50KCldO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbCB8fCBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGZpZWxkIHRvIHRoZSBwcm92aWRlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGZpZWxkIHBhdGggdG8gc2V0LlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICovXG4gICAgc2V0KHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkc01hcCA9IHRoaXMuZ2V0RmllbGRzTWFwKHBhdGgucG9wTGFzdCgpKTtcbiAgICAgICAgZmllbGRzTWFwW3BhdGgubGFzdFNlZ21lbnQoKV0gPSBkZWVwQ2xvbmUodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwcm92aWRlZCBmaWVsZHMgdG8gdGhlIHByb3ZpZGVkIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIC0gQSBtYXAgb2YgZmllbGRzIHRvIHZhbHVlcyAob3IgbnVsbCBmb3IgZGVsZXRlcykuXG4gICAgICovXG4gICAgc2V0QWxsKGRhdGEpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IEZpZWxkUGF0aCQxLmVtcHR5UGF0aCgpO1xuICAgICAgICBsZXQgdXBzZXJ0cyA9IHt9O1xuICAgICAgICBsZXQgZGVsZXRlcyA9IFtdO1xuICAgICAgICBkYXRhLmZvckVhY2goKHZhbHVlLCBwYXRoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXBhcmVudC5pc0ltbWVkaWF0ZVBhcmVudE9mKHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBhY2N1bXVsYXRlZCBjaGFuZ2VzIGF0IHRoaXMgcGFyZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRzTWFwID0gdGhpcy5nZXRGaWVsZHNNYXAocGFyZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5Q2hhbmdlcyhmaWVsZHNNYXAsIHVwc2VydHMsIGRlbGV0ZXMpO1xuICAgICAgICAgICAgICAgIHVwc2VydHMgPSB7fTtcbiAgICAgICAgICAgICAgICBkZWxldGVzID0gW107XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGF0aC5wb3BMYXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB1cHNlcnRzW3BhdGgubGFzdFNlZ21lbnQoKV0gPSBkZWVwQ2xvbmUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlcy5wdXNoKHBhdGgubGFzdFNlZ21lbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmaWVsZHNNYXAgPSB0aGlzLmdldEZpZWxkc01hcChwYXJlbnQpO1xuICAgICAgICB0aGlzLmFwcGx5Q2hhbmdlcyhmaWVsZHNNYXAsIHVwc2VydHMsIGRlbGV0ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBmaWVsZCBhdCB0aGUgc3BlY2lmaWVkIHBhdGguIElmIHRoZXJlIGlzIG5vIGZpZWxkIGF0IHRoZVxuICAgICAqIHNwZWNpZmllZCBwYXRoLCBub3RoaW5nIGlzIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBmaWVsZCBwYXRoIHRvIHJlbW92ZS5cbiAgICAgKi9cbiAgICBkZWxldGUocGF0aCkge1xuICAgICAgICBjb25zdCBuZXN0ZWRWYWx1ZSA9IHRoaXMuZmllbGQocGF0aC5wb3BMYXN0KCkpO1xuICAgICAgICBpZiAoaXNNYXBWYWx1ZShuZXN0ZWRWYWx1ZSkgJiYgbmVzdGVkVmFsdWUubWFwVmFsdWUuZmllbGRzKSB7XG4gICAgICAgICAgICBkZWxldGUgbmVzdGVkVmFsdWUubWFwVmFsdWUuZmllbGRzW3BhdGgubGFzdFNlZ21lbnQoKV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gdmFsdWVFcXVhbHModGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXAgdGhhdCBjb250YWlucyB0aGUgbGVhZiBlbGVtZW50IG9mIGBwYXRoYC4gSWYgdGhlIHBhcmVudFxuICAgICAqIGVudHJ5IGRvZXMgbm90IHlldCBleGlzdCwgb3IgaWYgaXQgaXMgbm90IGEgbWFwLCBhIG5ldyBtYXAgd2lsbCBiZSBjcmVhdGVkLlxuICAgICAqL1xuICAgIGdldEZpZWxkc01hcChwYXRoKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy52YWx1ZTtcbiAgICAgICAgaWYgKCFjdXJyZW50Lm1hcFZhbHVlLmZpZWxkcykge1xuICAgICAgICAgICAgY3VycmVudC5tYXBWYWx1ZSA9IHsgZmllbGRzOiB7fSB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBjdXJyZW50Lm1hcFZhbHVlLmZpZWxkc1twYXRoLmdldChpKV07XG4gICAgICAgICAgICBpZiAoIWlzTWFwVmFsdWUobmV4dCkgfHwgIW5leHQubWFwVmFsdWUuZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHsgbWFwVmFsdWU6IHsgZmllbGRzOiB7fSB9IH07XG4gICAgICAgICAgICAgICAgY3VycmVudC5tYXBWYWx1ZS5maWVsZHNbcGF0aC5nZXQoaSldID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50Lm1hcFZhbHVlLmZpZWxkcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9kaWZpZXMgYGZpZWxkc01hcGAgYnkgYWRkaW5nLCByZXBsYWNpbmcgb3IgZGVsZXRpbmcgdGhlIHNwZWNpZmllZFxuICAgICAqIGVudHJpZXMuXG4gICAgICovXG4gICAgYXBwbHlDaGFuZ2VzKGZpZWxkc01hcCwgaW5zZXJ0cywgZGVsZXRlcykge1xuICAgICAgICBmb3JFYWNoKGluc2VydHMsIChrZXksIHZhbCkgPT4gKGZpZWxkc01hcFtrZXldID0gdmFsKSk7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgZGVsZXRlcykge1xuICAgICAgICAgICAgZGVsZXRlIGZpZWxkc01hcFtmaWVsZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0VmFsdWUoZGVlcENsb25lKHRoaXMudmFsdWUpKTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgYSBGaWVsZE1hc2sgYnVpbHQgZnJvbSBhbGwgZmllbGRzIGluIGEgTWFwVmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RGaWVsZE1hc2sodmFsdWUpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICBmb3JFYWNoKHZhbHVlLmZpZWxkcywgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFBhdGggPSBuZXcgRmllbGRQYXRoJDEoW2tleV0pO1xuICAgICAgICBpZiAoaXNNYXBWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5lc3RlZE1hc2sgPSBleHRyYWN0RmllbGRNYXNrKHZhbHVlLm1hcFZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IG5lc3RlZEZpZWxkcyA9IG5lc3RlZE1hc2suZmllbGRzO1xuICAgICAgICAgICAgaWYgKG5lc3RlZEZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSB0aGUgZW1wdHkgbWFwIGJ5IGFkZGluZyBpdCB0byB0aGUgRmllbGRNYXNrLlxuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGN1cnJlbnRQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvciBuZXN0ZWQgYW5kIG5vbi1lbXB0eSBPYmplY3RWYWx1ZXMsIGFkZCB0aGUgRmllbGRQYXRoIG9mIHRoZVxuICAgICAgICAgICAgICAgIC8vIGxlYWYgbm9kZXMuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuZXN0ZWRQYXRoIG9mIG5lc3RlZEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChjdXJyZW50UGF0aC5jaGlsZChuZXN0ZWRQYXRoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIG5lc3RlZCBhbmQgbm9uLWVtcHR5IE9iamVjdFZhbHVlcywgYWRkIHRoZSBGaWVsZFBhdGggb2YgdGhlIGxlYWZcbiAgICAgICAgICAgIC8vIG5vZGVzLlxuICAgICAgICAgICAgZmllbGRzLnB1c2goY3VycmVudFBhdGgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBGaWVsZE1hc2soZmllbGRzKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmVwcmVzZW50cyBhIGRvY3VtZW50IGluIEZpcmVzdG9yZSB3aXRoIGEga2V5LCB2ZXJzaW9uLCBkYXRhIGFuZCB3aGV0aGVyIGl0XG4gKiBoYXMgbG9jYWwgbXV0YXRpb25zIGFwcGxpZWQgdG8gaXQuXG4gKlxuICogRG9jdW1lbnRzIGNhbiB0cmFuc2l0aW9uIGJldHdlZW4gc3RhdGVzIHZpYSBgY29udmVydFRvRm91bmREb2N1bWVudCgpYCxcbiAqIGBjb252ZXJ0VG9Ob0RvY3VtZW50KClgIGFuZCBgY29udmVydFRvVW5rbm93bkRvY3VtZW50KClgLiBJZiBhIGRvY3VtZW50IGRvZXNcbiAqIG5vdCB0cmFuc2l0aW9uIHRvIG9uZSBvZiB0aGVzZSBzdGF0ZXMgZXZlbiBhZnRlciBhbGwgbXV0YXRpb25zIGhhdmUgYmVlblxuICogYXBwbGllZCwgYGlzVmFsaWREb2N1bWVudCgpYCByZXR1cm5zIGZhbHNlIGFuZCB0aGUgZG9jdW1lbnQgc2hvdWxkIGJlIHJlbW92ZWRcbiAqIGZyb20gYWxsIHZpZXdzLlxuICovXG5jbGFzcyBNdXRhYmxlRG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgZG9jdW1lbnRUeXBlLCB2ZXJzaW9uLCByZWFkVGltZSwgY3JlYXRlVGltZSwgZGF0YSwgZG9jdW1lbnRTdGF0ZSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5kb2N1bWVudFR5cGUgPSBkb2N1bWVudFR5cGU7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMucmVhZFRpbWUgPSByZWFkVGltZTtcbiAgICAgICAgdGhpcy5jcmVhdGVUaW1lID0gY3JlYXRlVGltZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID0gZG9jdW1lbnRTdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRvY3VtZW50IHdpdGggbm8ga25vd24gdmVyc2lvbiBvciBkYXRhLCBidXQgd2hpY2ggY2FuIHNlcnZlIGFzXG4gICAgICogYmFzZSBkb2N1bWVudCBmb3IgbXV0YXRpb25zLlxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdJbnZhbGlkRG9jdW1lbnQoZG9jdW1lbnRLZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlRG9jdW1lbnQoZG9jdW1lbnRLZXksIDAgLyogRG9jdW1lbnRUeXBlLklOVkFMSUQgKi8sIFxuICAgICAgICAvKiB2ZXJzaW9uICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXG4gICAgICAgIC8qIHJlYWRUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXG4gICAgICAgIC8qIGNyZWF0ZVRpbWUgKi8gU25hcHNob3RWZXJzaW9uLm1pbigpLCBPYmplY3RWYWx1ZS5lbXB0eSgpLCAwIC8qIERvY3VtZW50U3RhdGUuU1lOQ0VEICovKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBkb2N1bWVudCB0aGF0IGlzIGtub3duIHRvIGV4aXN0IHdpdGggdGhlIGdpdmVuIGRhdGEgYXQgdGhlXG4gICAgICogZ2l2ZW4gdmVyc2lvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3Rm91bmREb2N1bWVudChkb2N1bWVudEtleSwgdmVyc2lvbiwgY3JlYXRlVGltZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlRG9jdW1lbnQoZG9jdW1lbnRLZXksIDEgLyogRG9jdW1lbnRUeXBlLkZPVU5EX0RPQ1VNRU5UICovLCBcbiAgICAgICAgLyogdmVyc2lvbiAqLyB2ZXJzaW9uLCBcbiAgICAgICAgLyogcmVhZFRpbWUgKi8gU25hcHNob3RWZXJzaW9uLm1pbigpLCBcbiAgICAgICAgLyogY3JlYXRlVGltZSAqLyBjcmVhdGVUaW1lLCB2YWx1ZSwgMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLyk7XG4gICAgfVxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IGRvY3VtZW50IHRoYXQgaXMga25vd24gdG8gbm90IGV4aXN0IGF0IHRoZSBnaXZlbiB2ZXJzaW9uLiAqL1xuICAgIHN0YXRpYyBuZXdOb0RvY3VtZW50KGRvY3VtZW50S2V5LCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZURvY3VtZW50KGRvY3VtZW50S2V5LCAyIC8qIERvY3VtZW50VHlwZS5OT19ET0NVTUVOVCAqLywgXG4gICAgICAgIC8qIHZlcnNpb24gKi8gdmVyc2lvbiwgXG4gICAgICAgIC8qIHJlYWRUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXG4gICAgICAgIC8qIGNyZWF0ZVRpbWUgKi8gU25hcHNob3RWZXJzaW9uLm1pbigpLCBPYmplY3RWYWx1ZS5lbXB0eSgpLCAwIC8qIERvY3VtZW50U3RhdGUuU1lOQ0VEICovKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBkb2N1bWVudCB0aGF0IGlzIGtub3duIHRvIGV4aXN0IGF0IHRoZSBnaXZlbiB2ZXJzaW9uIGJ1dFxuICAgICAqIHdob3NlIGRhdGEgaXMgbm90IGtub3duIChlLmcuIGEgZG9jdW1lbnQgdGhhdCB3YXMgdXBkYXRlZCB3aXRob3V0IGEga25vd25cbiAgICAgKiBiYXNlIGRvY3VtZW50KS5cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3VW5rbm93bkRvY3VtZW50KGRvY3VtZW50S2V5LCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZURvY3VtZW50KGRvY3VtZW50S2V5LCAzIC8qIERvY3VtZW50VHlwZS5VTktOT1dOX0RPQ1VNRU5UICovLCBcbiAgICAgICAgLyogdmVyc2lvbiAqLyB2ZXJzaW9uLCBcbiAgICAgICAgLyogcmVhZFRpbWUgKi8gU25hcHNob3RWZXJzaW9uLm1pbigpLCBcbiAgICAgICAgLyogY3JlYXRlVGltZSAqLyBTbmFwc2hvdFZlcnNpb24ubWluKCksIE9iamVjdFZhbHVlLmVtcHR5KCksIDIgLyogRG9jdW1lbnRTdGF0ZS5IQVNfQ09NTUlUVEVEX01VVEFUSU9OUyAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGRvY3VtZW50IHR5cGUgdG8gaW5kaWNhdGUgdGhhdCBpdCBleGlzdHMgYW5kIHRoYXQgaXRzIHZlcnNpb25cbiAgICAgKiBhbmQgZGF0YSBhcmUga25vd24uXG4gICAgICovXG4gICAgY29udmVydFRvRm91bmREb2N1bWVudCh2ZXJzaW9uLCB2YWx1ZSkge1xuICAgICAgICAvLyBJZiBhIGRvY3VtZW50IGlzIHN3aXRjaGluZyBzdGF0ZSBmcm9tIGJlaW5nIGFuIGludmFsaWQgb3IgZGVsZXRlZFxuICAgICAgICAvLyBkb2N1bWVudCB0byBhIHZhbGlkIChGT1VORF9ET0NVTUVOVCkgZG9jdW1lbnQsIGVpdGhlciBkdWUgdG8gcmVjZWl2aW5nIGFuXG4gICAgICAgIC8vIHVwZGF0ZSBmcm9tIFdhdGNoIG9yIGR1ZSB0byBhcHBseWluZyBhIGxvY2FsIHNldCBtdXRhdGlvbiBvbiB0b3BcbiAgICAgICAgLy8gb2YgYSBkZWxldGVkIGRvY3VtZW50LCBvdXIgYmVzdCBndWVzcyBhYm91dCBpdHMgY3JlYXRlVGltZSB3b3VsZCBiZSB0aGVcbiAgICAgICAgLy8gdmVyc2lvbiBhdCB3aGljaCB0aGUgZG9jdW1lbnQgdHJhbnNpdGlvbmVkIHRvIGEgRk9VTkRfRE9DVU1FTlQuXG4gICAgICAgIGlmICh0aGlzLmNyZWF0ZVRpbWUuaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpICYmXG4gICAgICAgICAgICAodGhpcy5kb2N1bWVudFR5cGUgPT09IDIgLyogRG9jdW1lbnRUeXBlLk5PX0RPQ1VNRU5UICovIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudFR5cGUgPT09IDAgLyogRG9jdW1lbnRUeXBlLklOVkFMSUQgKi8pKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRpbWUgPSB2ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID0gMSAvKiBEb2N1bWVudFR5cGUuRk9VTkRfRE9DVU1FTlQgKi87XG4gICAgICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSAwIC8qIERvY3VtZW50U3RhdGUuU1lOQ0VEICovO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgZG9jdW1lbnQgdHlwZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGRvZXNuJ3QgZXhpc3QgYXQgdGhlIGdpdmVuXG4gICAgICogdmVyc2lvbi5cbiAgICAgKi9cbiAgICBjb252ZXJ0VG9Ob0RvY3VtZW50KHZlcnNpb24pIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5kb2N1bWVudFR5cGUgPSAyIC8qIERvY3VtZW50VHlwZS5OT19ET0NVTUVOVCAqLztcbiAgICAgICAgdGhpcy5kYXRhID0gT2JqZWN0VmFsdWUuZW1wdHkoKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID0gMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGRvY3VtZW50IHR5cGUgdG8gaW5kaWNhdGUgdGhhdCBpdCBleGlzdHMgYXQgYSBnaXZlbiB2ZXJzaW9uIGJ1dFxuICAgICAqIHRoYXQgaXRzIGRhdGEgaXMgbm90IGtub3duIChlLmcuIGEgZG9jdW1lbnQgdGhhdCB3YXMgdXBkYXRlZCB3aXRob3V0IGEga25vd25cbiAgICAgKiBiYXNlIGRvY3VtZW50KS5cbiAgICAgKi9cbiAgICBjb252ZXJ0VG9Vbmtub3duRG9jdW1lbnQodmVyc2lvbikge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLmRvY3VtZW50VHlwZSA9IDMgLyogRG9jdW1lbnRUeXBlLlVOS05PV05fRE9DVU1FTlQgKi87XG4gICAgICAgIHRoaXMuZGF0YSA9IE9iamVjdFZhbHVlLmVtcHR5KCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9IDIgLyogRG9jdW1lbnRTdGF0ZS5IQVNfQ09NTUlUVEVEX01VVEFUSU9OUyAqLztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID0gMiAvKiBEb2N1bWVudFN0YXRlLkhBU19DT01NSVRURURfTVVUQVRJT05TICovO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0SGFzTG9jYWxNdXRhdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9IDEgLyogRG9jdW1lbnRTdGF0ZS5IQVNfTE9DQUxfTVVUQVRJT05TICovO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRSZWFkVGltZShyZWFkVGltZSkge1xuICAgICAgICB0aGlzLnJlYWRUaW1lID0gcmVhZFRpbWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgaGFzTG9jYWxNdXRhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50U3RhdGUgPT09IDEgLyogRG9jdW1lbnRTdGF0ZS5IQVNfTE9DQUxfTVVUQVRJT05TICovO1xuICAgIH1cbiAgICBnZXQgaGFzQ29tbWl0dGVkTXV0YXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFN0YXRlID09PSAyIC8qIERvY3VtZW50U3RhdGUuSEFTX0NPTU1JVFRFRF9NVVRBVElPTlMgKi87XG4gICAgfVxuICAgIGdldCBoYXNQZW5kaW5nV3JpdGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNMb2NhbE11dGF0aW9ucyB8fCB0aGlzLmhhc0NvbW1pdHRlZE11dGF0aW9ucztcbiAgICB9XG4gICAgaXNWYWxpZERvY3VtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFR5cGUgIT09IDAgLyogRG9jdW1lbnRUeXBlLklOVkFMSUQgKi87XG4gICAgfVxuICAgIGlzRm91bmREb2N1bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUeXBlID09PSAxIC8qIERvY3VtZW50VHlwZS5GT1VORF9ET0NVTUVOVCAqLztcbiAgICB9XG4gICAgaXNOb0RvY3VtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFR5cGUgPT09IDIgLyogRG9jdW1lbnRUeXBlLk5PX0RPQ1VNRU5UICovO1xuICAgIH1cbiAgICBpc1Vua25vd25Eb2N1bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUeXBlID09PSAzIC8qIERvY3VtZW50VHlwZS5VTktOT1dOX0RPQ1VNRU5UICovO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBNdXRhYmxlRG9jdW1lbnQgJiZcbiAgICAgICAgICAgIHRoaXMua2V5LmlzRXF1YWwob3RoZXIua2V5KSAmJlxuICAgICAgICAgICAgdGhpcy52ZXJzaW9uLmlzRXF1YWwob3RoZXIudmVyc2lvbikgJiZcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID09PSBvdGhlci5kb2N1bWVudFR5cGUgJiZcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9PT0gb3RoZXIuZG9jdW1lbnRTdGF0ZSAmJlxuICAgICAgICAgICAgdGhpcy5kYXRhLmlzRXF1YWwob3RoZXIuZGF0YSkpO1xuICAgIH1cbiAgICBtdXRhYmxlQ29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlRG9jdW1lbnQodGhpcy5rZXksIHRoaXMuZG9jdW1lbnRUeXBlLCB0aGlzLnZlcnNpb24sIHRoaXMucmVhZFRpbWUsIHRoaXMuY3JlYXRlVGltZSwgdGhpcy5kYXRhLmNsb25lKCksIHRoaXMuZG9jdW1lbnRTdGF0ZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKGBEb2N1bWVudCgke3RoaXMua2V5fSwgJHt0aGlzLnZlcnNpb259LCAke0pTT04uc3RyaW5naWZ5KHRoaXMuZGF0YS52YWx1ZSl9LCBgICtcbiAgICAgICAgICAgIGB7Y3JlYXRlVGltZTogJHt0aGlzLmNyZWF0ZVRpbWV9fSksIGAgK1xuICAgICAgICAgICAgYHtkb2N1bWVudFR5cGU6ICR7dGhpcy5kb2N1bWVudFR5cGV9fSksIGAgK1xuICAgICAgICAgICAgYHtkb2N1bWVudFN0YXRlOiAke3RoaXMuZG9jdW1lbnRTdGF0ZX19KWApO1xuICAgIH1cbn1cbi8qKlxuICogQ29tcGFyZXMgdGhlIHZhbHVlIGZvciBmaWVsZCBgZmllbGRgIGluIHRoZSBwcm92aWRlZCBkb2N1bWVudHMuIFRocm93cyBpZlxuICogdGhlIGZpZWxkIGRvZXMgbm90IGV4aXN0IGluIGJvdGggZG9jdW1lbnRzLlxuICovXG5mdW5jdGlvbiBjb21wYXJlRG9jdW1lbnRzQnlGaWVsZChmaWVsZCwgZDEsIGQyKSB7XG4gICAgY29uc3QgdjEgPSBkMS5kYXRhLmZpZWxkKGZpZWxkKTtcbiAgICBjb25zdCB2MiA9IGQyLmRhdGEuZmllbGQoZmllbGQpO1xuICAgIGlmICh2MSAhPT0gbnVsbCAmJiB2MiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWVDb21wYXJlKHYxLCB2Mik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgweGE3ODYpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmVwcmVzZW50cyBhIGJvdW5kIG9mIGEgcXVlcnkuXG4gKlxuICogVGhlIGJvdW5kIGlzIHNwZWNpZmllZCB3aXRoIHRoZSBnaXZlbiBjb21wb25lbnRzIHJlcHJlc2VudGluZyBhIHBvc2l0aW9uIGFuZFxuICogd2hldGhlciBpdCdzIGp1c3QgYmVmb3JlIG9yIGp1c3QgYWZ0ZXIgdGhlIHBvc2l0aW9uIChyZWxhdGl2ZSB0byB3aGF0ZXZlciB0aGVcbiAqIHF1ZXJ5IG9yZGVyIGlzKS5cbiAqXG4gKiBUaGUgcG9zaXRpb24gcmVwcmVzZW50cyBhIGxvZ2ljYWwgaW5kZXggcG9zaXRpb24gZm9yIGEgcXVlcnkuIEl0J3MgYSBwcmVmaXhcbiAqIG9mIHZhbHVlcyBmb3IgdGhlIChwb3RlbnRpYWxseSBpbXBsaWNpdCkgb3JkZXIgYnkgY2xhdXNlcyBvZiBhIHF1ZXJ5LlxuICpcbiAqIEJvdW5kIHByb3ZpZGVzIGEgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBkb2N1bWVudCBjb21lcyBiZWZvcmUgb3JcbiAqIGFmdGVyIGEgYm91bmQuIFRoaXMgaXMgaW5mbHVlbmNlZCBieSB3aGV0aGVyIHRoZSBwb3NpdGlvbiBpcyBqdXN0IGJlZm9yZSBvclxuICoganVzdCBhZnRlciB0aGUgcHJvdmlkZWQgdmFsdWVzLlxuICovXG5jbGFzcyBCb3VuZCB7XG4gICAgY29uc3RydWN0b3IocG9zaXRpb24sIGluY2x1c2l2ZSkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHRoaXMuaW5jbHVzaXZlID0gaW5jbHVzaXZlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJvdW5kQ29tcGFyZVRvRG9jdW1lbnQoYm91bmQsIG9yZGVyQnksIGRvYykge1xuICAgIGxldCBjb21wYXJpc29uID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvdW5kLnBvc2l0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9yZGVyQnlDb21wb25lbnQgPSBvcmRlckJ5W2ldO1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBib3VuZC5wb3NpdGlvbltpXTtcbiAgICAgICAgaWYgKG9yZGVyQnlDb21wb25lbnQuZmllbGQuaXNLZXlGaWVsZCgpKSB7XG4gICAgICAgICAgICBjb21wYXJpc29uID0gRG9jdW1lbnRLZXkuY29tcGFyYXRvcihEb2N1bWVudEtleS5mcm9tTmFtZShjb21wb25lbnQucmVmZXJlbmNlVmFsdWUpLCBkb2Mua2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY1ZhbHVlID0gZG9jLmRhdGEuZmllbGQob3JkZXJCeUNvbXBvbmVudC5maWVsZCk7XG4gICAgICAgICAgICBjb21wYXJpc29uID0gdmFsdWVDb21wYXJlKGNvbXBvbmVudCwgZG9jVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmRlckJ5Q29tcG9uZW50LmRpciA9PT0gXCJkZXNjXCIgLyogRGlyZWN0aW9uLkRFU0NFTkRJTkcgKi8pIHtcbiAgICAgICAgICAgIGNvbXBhcmlzb24gPSBjb21wYXJpc29uICogLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21wYXJpc29uO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBkb2N1bWVudCBzb3J0cyBhZnRlciBhIGJvdW5kIHVzaW5nIHRoZSBwcm92aWRlZCBzb3J0XG4gKiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gYm91bmRTb3J0c0FmdGVyRG9jdW1lbnQoYm91bmQsIG9yZGVyQnksIGRvYykge1xuICAgIGNvbnN0IGNvbXBhcmlzb24gPSBib3VuZENvbXBhcmVUb0RvY3VtZW50KGJvdW5kLCBvcmRlckJ5LCBkb2MpO1xuICAgIHJldHVybiBib3VuZC5pbmNsdXNpdmUgPyBjb21wYXJpc29uID49IDAgOiBjb21wYXJpc29uID4gMDtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgZG9jdW1lbnQgc29ydHMgYmVmb3JlIGEgYm91bmQgdXNpbmcgdGhlIHByb3ZpZGVkIHNvcnRcbiAqIG9yZGVyLlxuICovXG5mdW5jdGlvbiBib3VuZFNvcnRzQmVmb3JlRG9jdW1lbnQoYm91bmQsIG9yZGVyQnksIGRvYykge1xuICAgIGNvbnN0IGNvbXBhcmlzb24gPSBib3VuZENvbXBhcmVUb0RvY3VtZW50KGJvdW5kLCBvcmRlckJ5LCBkb2MpO1xuICAgIHJldHVybiBib3VuZC5pbmNsdXNpdmUgPyBjb21wYXJpc29uIDw9IDAgOiBjb21wYXJpc29uIDwgMDtcbn1cbmZ1bmN0aW9uIGJvdW5kRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJpZ2h0ID09PSBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChyaWdodCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsZWZ0LmluY2x1c2l2ZSAhPT0gcmlnaHQuaW5jbHVzaXZlIHx8XG4gICAgICAgIGxlZnQucG9zaXRpb24ubGVuZ3RoICE9PSByaWdodC5wb3NpdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnQucG9zaXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGVmdFBvc2l0aW9uID0gbGVmdC5wb3NpdGlvbltpXTtcbiAgICAgICAgY29uc3QgcmlnaHRQb3NpdGlvbiA9IHJpZ2h0LnBvc2l0aW9uW2ldO1xuICAgICAgICBpZiAoIXZhbHVlRXF1YWxzKGxlZnRQb3NpdGlvbiwgcmlnaHRQb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQW4gb3JkZXJpbmcgb24gYSBmaWVsZCwgaW4gc29tZSBEaXJlY3Rpb24uIERpcmVjdGlvbiBkZWZhdWx0cyB0byBBU0NFTkRJTkcuXG4gKi9cbmNsYXNzIE9yZGVyQnkge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBkaXIgPSBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi8pIHtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICB9XG59XG5mdW5jdGlvbiBjYW5vbmlmeU9yZGVyQnkob3JkZXJCeSkge1xuICAgIC8vIFRPRE8oYi8yOTE4MzE2NSk6IE1ha2UgdGhpcyBjb2xsaXNpb24gcm9idXN0LlxuICAgIHJldHVybiBvcmRlckJ5LmZpZWxkLmNhbm9uaWNhbFN0cmluZygpICsgb3JkZXJCeS5kaXI7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlPcmRlckJ5KG9yZGVyQnkpIHtcbiAgICByZXR1cm4gYCR7b3JkZXJCeS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKX0gKCR7b3JkZXJCeS5kaXJ9KWA7XG59XG5mdW5jdGlvbiBvcmRlckJ5RXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQuZGlyID09PSByaWdodC5kaXIgJiYgbGVmdC5maWVsZC5pc0VxdWFsKHJpZ2h0LmZpZWxkKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEZpbHRlciB7XG59XG5jbGFzcyBGaWVsZEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIG9wLCB2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmlsdGVyIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShmaWVsZCwgb3AsIHZhbHVlKSB7XG4gICAgICAgIGlmIChmaWVsZC5pc0tleUZpZWxkKCkpIHtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovIHx8IG9wID09PSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUtleUZpZWxkSW5GaWx0ZXIoZmllbGQsIG9wLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEtleUZpZWxkRmlsdGVyKGZpZWxkLCBvcCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSBcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlDb250YWluc0ZpbHRlcihmaWVsZCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5GaWx0ZXIoZmllbGQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcCA9PT0gXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm90SW5GaWx0ZXIoZmllbGQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlDb250YWluc0FueUZpbHRlcihmaWVsZCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWVsZEZpbHRlcihmaWVsZCwgb3AsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlS2V5RmllbGRJbkZpbHRlcihmaWVsZCwgb3AsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovXG4gICAgICAgICAgICA/IG5ldyBLZXlGaWVsZEluRmlsdGVyKGZpZWxkLCB2YWx1ZSlcbiAgICAgICAgICAgIDogbmV3IEtleUZpZWxkTm90SW5GaWx0ZXIoZmllbGQsIHZhbHVlKTtcbiAgICB9XG4gICAgbWF0Y2hlcyhkb2MpIHtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcbiAgICAgICAgLy8gVHlwZXMgZG8gbm90IGhhdmUgdG8gbWF0Y2ggaW4gTk9UX0VRVUFMIGZpbHRlcnMuXG4gICAgICAgIGlmICh0aGlzLm9wID09PSBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovKSB7XG4gICAgICAgICAgICByZXR1cm4gKG90aGVyICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgb3RoZXIubnVsbFZhbHVlID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXNDb21wYXJpc29uKHZhbHVlQ29tcGFyZShvdGhlciwgdGhpcy52YWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGNvbXBhcmUgdHlwZXMgd2l0aCBtYXRjaGluZyBiYWNrZW5kIG9yZGVyIChzdWNoIGFzIGRvdWJsZSBhbmQgaW50KS5cbiAgICAgICAgcmV0dXJuIChvdGhlciAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZU9yZGVyKHRoaXMudmFsdWUpID09PSB0eXBlT3JkZXIob3RoZXIpICYmXG4gICAgICAgICAgICB0aGlzLm1hdGNoZXNDb21wYXJpc29uKHZhbHVlQ29tcGFyZShvdGhlciwgdGhpcy52YWx1ZSkpKTtcbiAgICB9XG4gICAgbWF0Y2hlc0NvbXBhcmlzb24oY29tcGFyaXNvbikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMub3ApIHtcbiAgICAgICAgICAgIGNhc2UgXCI8XCIgLyogT3BlcmF0b3IuTEVTU19USEFOICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uIDwgMDtcbiAgICAgICAgICAgIGNhc2UgXCI8PVwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTl9PUl9FUVVBTCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA8PSAwO1xuICAgICAgICAgICAgY2FzZSBcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPT09IDA7XG4gICAgICAgICAgICBjYXNlIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gIT09IDA7XG4gICAgICAgICAgICBjYXNlIFwiPlwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTiAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA+IDA7XG4gICAgICAgICAgICBjYXNlIFwiPj1cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU5fT1JfRVFVQUwgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPj0gMDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoMHhiOGEyLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiB0aGlzLm9wXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNJbmVxdWFsaXR5KCkge1xuICAgICAgICByZXR1cm4gKFtcbiAgICAgICAgICAgIFwiPFwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTiAqLyxcbiAgICAgICAgICAgIFwiPD1cIiAvKiBPcGVyYXRvci5MRVNTX1RIQU5fT1JfRVFVQUwgKi8sXG4gICAgICAgICAgICBcIj5cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU4gKi8sXG4gICAgICAgICAgICBcIj49XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOX09SX0VRVUFMICovLFxuICAgICAgICAgICAgXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLyxcbiAgICAgICAgICAgIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovXG4gICAgICAgIF0uaW5kZXhPZih0aGlzLm9wKSA+PSAwKTtcbiAgICB9XG4gICAgZ2V0RmxhdHRlbmVkRmlsdGVycygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICB9XG4gICAgZ2V0RmlsdGVycygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICB9XG59XG5jbGFzcyBDb21wb3NpdGVGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpbHRlcnMsIG9wKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IGZpbHRlcnM7XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICAgICAgdGhpcy5tZW1vaXplZEZsYXR0ZW5lZEZpbHRlcnMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmlsdGVyIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShmaWx0ZXJzLCBvcCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZUZpbHRlcihmaWx0ZXJzLCBvcCk7XG4gICAgfVxuICAgIG1hdGNoZXMoZG9jKSB7XG4gICAgICAgIGlmIChjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKHRoaXMpKSB7XG4gICAgICAgICAgICAvLyBGb3IgY29uanVuY3Rpb25zLCBhbGwgZmlsdGVycyBtdXN0IG1hdGNoLCBzbyByZXR1cm4gZmFsc2UgaWYgYW55IGZpbHRlciBkb2Vzbid0IG1hdGNoLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVycy5maW5kKGZpbHRlciA9PiAhZmlsdGVyLm1hdGNoZXMoZG9jKSkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBkaXNqdW5jdGlvbnMsIGF0IGxlYXN0IG9uZSBmaWx0ZXIgc2hvdWxkIG1hdGNoLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVycy5maW5kKGZpbHRlciA9PiBmaWx0ZXIubWF0Y2hlcyhkb2MpKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEZsYXR0ZW5lZEZpbHRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLm1lbW9pemVkRmxhdHRlbmVkRmlsdGVycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVtb2l6ZWRGbGF0dGVuZWRGaWx0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVtb2l6ZWRGbGF0dGVuZWRGaWx0ZXJzID0gdGhpcy5maWx0ZXJzLnJlZHVjZSgocmVzdWx0LCBzdWJmaWx0ZXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KHN1YmZpbHRlci5nZXRGbGF0dGVuZWRGaWx0ZXJzKCkpO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1lbW9pemVkRmxhdHRlbmVkRmlsdGVycztcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIG11dGFibGUgY29weSBvZiBgdGhpcy5maWx0ZXJzYFxuICAgIGdldEZpbHRlcnMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFtdLCB0aGlzLmZpbHRlcnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2l0ZUZpbHRlcklzQ29uanVuY3Rpb24oY29tcG9zaXRlRmlsdGVyKSB7XG4gICAgcmV0dXJuIGNvbXBvc2l0ZUZpbHRlci5vcCA9PT0gXCJhbmRcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5BTkQgKi87XG59XG5mdW5jdGlvbiBjb21wb3NpdGVGaWx0ZXJJc0Rpc2p1bmN0aW9uKGNvbXBvc2l0ZUZpbHRlcikge1xuICAgIHJldHVybiBjb21wb3NpdGVGaWx0ZXIub3AgPT09IFwib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqLztcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZmlsdGVyIGlzIGEgY29uanVuY3Rpb24gb2YgZmllbGQgZmlsdGVycyBvbmx5LiBSZXR1cm5zIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gY29tcG9zaXRlRmlsdGVySXNGbGF0Q29uanVuY3Rpb24oY29tcG9zaXRlRmlsdGVyKSB7XG4gICAgcmV0dXJuIChjb21wb3NpdGVGaWx0ZXJJc0ZsYXQoY29tcG9zaXRlRmlsdGVyKSAmJlxuICAgICAgICBjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKGNvbXBvc2l0ZUZpbHRlcikpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBmaWx0ZXIgZG9lcyBub3QgY29udGFpbiBhbnkgY29tcG9zaXRlIGZpbHRlcnMuIFJldHVybnMgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBjb21wb3NpdGVGaWx0ZXJJc0ZsYXQoY29tcG9zaXRlRmlsdGVyKSB7XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgY29tcG9zaXRlRmlsdGVyLmZpbHRlcnMpIHtcbiAgICAgICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2Fub25pZnlGaWx0ZXIoZmlsdGVyKSB7XG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgIC8vIFRPRE8oYi8yOTE4MzE2NSk6IFRlY2huaWNhbGx5LCB0aGlzIHdvbid0IGJlIHVuaXF1ZSBpZiB0d28gdmFsdWVzIGhhdmVcbiAgICAgICAgLy8gdGhlIHNhbWUgZGVzY3JpcHRpb24sIHN1Y2ggYXMgdGhlIGludCAzIGFuZCB0aGUgc3RyaW5nIFwiM1wiLiBTbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gYWRkIHRoZSB0eXBlcyBpbiBoZXJlIHNvbWVob3csIHRvby5cbiAgICAgICAgcmV0dXJuIChmaWx0ZXIuZmllbGQuY2Fub25pY2FsU3RyaW5nKCkgK1xuICAgICAgICAgICAgZmlsdGVyLm9wLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgY2Fub25pY2FsSWQoZmlsdGVyLnZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbXBvc2l0ZUZpbHRlcklzRmxhdENvbmp1bmN0aW9uKGZpbHRlcikpIHtcbiAgICAgICAgLy8gT2xkZXIgU0RLIHZlcnNpb25zIHVzZSBhbiBpbXBsaWNpdCBBTkQgb3BlcmF0aW9uIGJldHdlZW4gdGhlaXIgZmlsdGVycy5cbiAgICAgICAgLy8gSW4gdGhlIG5ldyBTREsgdmVyc2lvbnMsIHRoZSBkZXZlbG9wZXIgbWF5IHVzZSBhbiBleHBsaWNpdCBBTkQgZmlsdGVyLlxuICAgICAgICAvLyBUbyBzdGF5IGNvbnNpc3RlbnQgd2l0aCB0aGUgb2xkIHVzYWdlcywgd2UgYWRkIGEgc3BlY2lhbCBjYXNlIHRvIGVuc3VyZVxuICAgICAgICAvLyB0aGUgY2Fub25pY2FsIElEIGZvciB0aGVzZSB0d28gYXJlIHRoZSBzYW1lLiBGb3IgZXhhbXBsZTpcbiAgICAgICAgLy8gYGNvbC53aGVyZUVxdWFscyhcImFcIiwgMSkud2hlcmVFcXVhbHMoXCJiXCIsIDIpYCBzaG91bGQgaGF2ZSB0aGUgc2FtZVxuICAgICAgICAvLyBjYW5vbmljYWwgSUQgYXMgYGNvbC53aGVyZShhbmQoZXF1YWxzKFwiYVwiLDEpLCBlcXVhbHMoXCJiXCIsMikpKWAuXG4gICAgICAgIHJldHVybiBmaWx0ZXIuZmlsdGVycy5tYXAoZmlsdGVyID0+IGNhbm9uaWZ5RmlsdGVyKGZpbHRlcikpLmpvaW4oJywnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGZpbHRlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlclxuICAgICAgICBjb25zdCBjYW5vbmljYWxJZHNTdHJpbmcgPSBmaWx0ZXIuZmlsdGVyc1xuICAgICAgICAgICAgLm1hcChmaWx0ZXIgPT4gY2Fub25pZnlGaWx0ZXIoZmlsdGVyKSlcbiAgICAgICAgICAgIC5qb2luKCcsJyk7XG4gICAgICAgIHJldHVybiBgJHtmaWx0ZXIub3B9KCR7Y2Fub25pY2FsSWRzU3RyaW5nfSlgO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbHRlckVxdWFscyhmMSwgZjIpIHtcbiAgICBpZiAoZjEgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcikge1xuICAgICAgICByZXR1cm4gZmllbGRGaWx0ZXJFcXVhbHMoZjEsIGYyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZjEgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUZpbHRlckVxdWFscyhmMSwgZjIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmFpbCgweDRiZWYpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpZWxkRmlsdGVyRXF1YWxzKGYxLCBmMikge1xuICAgIHJldHVybiAoZjIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlciAmJlxuICAgICAgICBmMS5vcCA9PT0gZjIub3AgJiZcbiAgICAgICAgZjEuZmllbGQuaXNFcXVhbChmMi5maWVsZCkgJiZcbiAgICAgICAgdmFsdWVFcXVhbHMoZjEudmFsdWUsIGYyLnZhbHVlKSk7XG59XG5mdW5jdGlvbiBjb21wb3NpdGVGaWx0ZXJFcXVhbHMoZjEsIGYyKSB7XG4gICAgaWYgKGYyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyICYmXG4gICAgICAgIGYxLm9wID09PSBmMi5vcCAmJlxuICAgICAgICBmMS5maWx0ZXJzLmxlbmd0aCA9PT0gZjIuZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgc3ViRmlsdGVyc01hdGNoID0gZjEuZmlsdGVycy5yZWR1Y2UoKHJlc3VsdCwgZjFGaWx0ZXIsIGluZGV4KSA9PiByZXN1bHQgJiYgZmlsdGVyRXF1YWxzKGYxRmlsdGVyLCBmMi5maWx0ZXJzW2luZGV4XSksIHRydWUpO1xuICAgICAgICByZXR1cm4gc3ViRmlsdGVyc01hdGNoO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFJldHVybnMgYSBuZXcgY29tcG9zaXRlIGZpbHRlciB0aGF0IGNvbnRhaW5zIGFsbCBmaWx0ZXIgZnJvbVxuICogYGNvbXBvc2l0ZUZpbHRlcmAgcGx1cyBhbGwgdGhlIGdpdmVuIGZpbHRlcnMgaW4gYG90aGVyRmlsdGVyc2AuXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2l0ZUZpbHRlcldpdGhBZGRlZEZpbHRlcnMoY29tcG9zaXRlRmlsdGVyLCBvdGhlckZpbHRlcnMpIHtcbiAgICBjb25zdCBtZXJnZWRGaWx0ZXJzID0gY29tcG9zaXRlRmlsdGVyLmZpbHRlcnMuY29uY2F0KG90aGVyRmlsdGVycyk7XG4gICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUobWVyZ2VkRmlsdGVycywgY29tcG9zaXRlRmlsdGVyLm9wKTtcbn1cbi8qKiBSZXR1cm5zIGEgZGVidWcgZGVzY3JpcHRpb24gZm9yIGBmaWx0ZXJgLiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5RmlsdGVyKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcikge1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5RmllbGRGaWx0ZXIoZmlsdGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlDb21wb3NpdGVGaWx0ZXIoZmlsdGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAnRmlsdGVyJztcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlDb21wb3NpdGVGaWx0ZXIoZmlsdGVyKSB7XG4gICAgcmV0dXJuIChmaWx0ZXIub3AudG9TdHJpbmcoKSArXG4gICAgICAgIGAge2AgK1xuICAgICAgICBmaWx0ZXIuZ2V0RmlsdGVycygpLm1hcChzdHJpbmdpZnlGaWx0ZXIpLmpvaW4oJyAsJykgK1xuICAgICAgICAnfScpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5RmllbGRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgcmV0dXJuIGAke2ZpbHRlci5maWVsZC5jYW5vbmljYWxTdHJpbmcoKX0gJHtmaWx0ZXIub3B9ICR7Y2Fub25pY2FsSWQoZmlsdGVyLnZhbHVlKX1gO1xufVxuLyoqIEZpbHRlciB0aGF0IG1hdGNoZXMgb24ga2V5IGZpZWxkcyAoaS5lLiAnX19uYW1lX18nKS4gKi9cbmNsYXNzIEtleUZpZWxkRmlsdGVyIGV4dGVuZHMgRmllbGRGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBvcCwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoZmllbGQsIG9wLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMua2V5ID0gRG9jdW1lbnRLZXkuZnJvbU5hbWUodmFsdWUucmVmZXJlbmNlVmFsdWUpO1xuICAgIH1cbiAgICBtYXRjaGVzKGRvYykge1xuICAgICAgICBjb25zdCBjb21wYXJpc29uID0gRG9jdW1lbnRLZXkuY29tcGFyYXRvcihkb2Mua2V5LCB0aGlzLmtleSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoZXNDb21wYXJpc29uKGNvbXBhcmlzb24pO1xuICAgIH1cbn1cbi8qKiBGaWx0ZXIgdGhhdCBtYXRjaGVzIG9uIGtleSBmaWVsZHMgd2l0aGluIGFuIGFycmF5LiAqL1xuY2xhc3MgS2V5RmllbGRJbkZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoZmllbGQsIFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLywgdmFsdWUpO1xuICAgICAgICB0aGlzLmtleXMgPSBleHRyYWN0RG9jdW1lbnRLZXlzRnJvbUFycmF5VmFsdWUoXCJpblwiIC8qIE9wZXJhdG9yLklOICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIG1hdGNoZXMoZG9jKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMuc29tZShrZXkgPT4ga2V5LmlzRXF1YWwoZG9jLmtleSkpO1xuICAgIH1cbn1cbi8qKiBGaWx0ZXIgdGhhdCBtYXRjaGVzIG9uIGtleSBmaWVsZHMgbm90IHByZXNlbnQgd2l0aGluIGFuIGFycmF5LiAqL1xuY2xhc3MgS2V5RmllbGROb3RJbkZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoZmllbGQsIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMua2V5cyA9IGV4dHJhY3REb2N1bWVudEtleXNGcm9tQXJyYXlWYWx1ZShcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBtYXRjaGVzKGRvYykge1xuICAgICAgICByZXR1cm4gIXRoaXMua2V5cy5zb21lKGtleSA9PiBrZXkuaXNFcXVhbChkb2Mua2V5KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXh0cmFjdERvY3VtZW50S2V5c0Zyb21BcnJheVZhbHVlKG9wLCB2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUuYXJyYXlWYWx1ZT8udmFsdWVzIHx8IFtdKS5tYXAodiA9PiB7XG4gICAgICAgIHJldHVybiBEb2N1bWVudEtleS5mcm9tTmFtZSh2LnJlZmVyZW5jZVZhbHVlKTtcbiAgICB9KTtcbn1cbi8qKiBBIEZpbHRlciB0aGF0IGltcGxlbWVudHMgdGhlIGFycmF5LWNvbnRhaW5zIG9wZXJhdG9yLiAqL1xuY2xhc3MgQXJyYXlDb250YWluc0ZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoZmllbGQsIFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBtYXRjaGVzKGRvYykge1xuICAgICAgICBjb25zdCBvdGhlciA9IGRvYy5kYXRhLmZpZWxkKHRoaXMuZmllbGQpO1xuICAgICAgICByZXR1cm4gaXNBcnJheShvdGhlcikgJiYgYXJyYXlWYWx1ZUNvbnRhaW5zKG90aGVyLmFycmF5VmFsdWUsIHRoaXMudmFsdWUpO1xuICAgIH1cbn1cbi8qKiBBIEZpbHRlciB0aGF0IGltcGxlbWVudHMgdGhlIElOIG9wZXJhdG9yLiAqL1xuY2xhc3MgSW5GaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkLCBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgbWF0Y2hlcyhkb2MpIHtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcbiAgICAgICAgcmV0dXJuIG90aGVyICE9PSBudWxsICYmIGFycmF5VmFsdWVDb250YWlucyh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIG90aGVyKTtcbiAgICB9XG59XG4vKiogQSBGaWx0ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBub3QtaW4gb3BlcmF0b3IuICovXG5jbGFzcyBOb3RJbkZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoZmllbGQsIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIG1hdGNoZXMoZG9jKSB7XG4gICAgICAgIGlmIChhcnJheVZhbHVlQ29udGFpbnModGhpcy52YWx1ZS5hcnJheVZhbHVlLCB7IG51bGxWYWx1ZTogJ05VTExfVkFMVUUnIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcbiAgICAgICAgcmV0dXJuIChvdGhlciAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgb3RoZXIubnVsbFZhbHVlID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFhcnJheVZhbHVlQ29udGFpbnModGhpcy52YWx1ZS5hcnJheVZhbHVlLCBvdGhlcikpO1xuICAgIH1cbn1cbi8qKiBBIEZpbHRlciB0aGF0IGltcGxlbWVudHMgdGhlIGFycmF5LWNvbnRhaW5zLWFueSBvcGVyYXRvci4gKi9cbmNsYXNzIEFycmF5Q29udGFpbnNBbnlGaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkLCBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBtYXRjaGVzKGRvYykge1xuICAgICAgICBjb25zdCBvdGhlciA9IGRvYy5kYXRhLmZpZWxkKHRoaXMuZmllbGQpO1xuICAgICAgICBpZiAoIWlzQXJyYXkob3RoZXIpIHx8ICFvdGhlci5hcnJheVZhbHVlLnZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdGhlci5hcnJheVZhbHVlLnZhbHVlcy5zb21lKHZhbCA9PiBhcnJheVZhbHVlQ29udGFpbnModGhpcy52YWx1ZS5hcnJheVZhbHVlLCB2YWwpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nXG5jbGFzcyBUYXJnZXRJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihwYXRoLCBjb2xsZWN0aW9uR3JvdXAgPSBudWxsLCBvcmRlckJ5ID0gW10sIGZpbHRlcnMgPSBbXSwgbGltaXQgPSBudWxsLCBzdGFydEF0ID0gbnVsbCwgZW5kQXQgPSBudWxsKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbkdyb3VwID0gY29sbGVjdGlvbkdyb3VwO1xuICAgICAgICB0aGlzLm9yZGVyQnkgPSBvcmRlckJ5O1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgICAgICB0aGlzLmxpbWl0ID0gbGltaXQ7XG4gICAgICAgIHRoaXMuc3RhcnRBdCA9IHN0YXJ0QXQ7XG4gICAgICAgIHRoaXMuZW5kQXQgPSBlbmRBdDtcbiAgICAgICAgdGhpcy5tZW1vaXplZENhbm9uaWNhbElkID0gbnVsbDtcbiAgICB9XG59XG4vKipcbiAqIEluaXRpYWxpemVzIGEgVGFyZ2V0IHdpdGggYSBwYXRoIGFuZCBvcHRpb25hbCBhZGRpdGlvbmFsIHF1ZXJ5IGNvbnN0cmFpbnRzLlxuICogUGF0aCBtdXN0IGN1cnJlbnRseSBiZSBlbXB0eSBpZiB0aGlzIGlzIGEgY29sbGVjdGlvbiBncm91cCBxdWVyeS5cbiAqXG4gKiBOT1RFOiB5b3Ugc2hvdWxkIGFsd2F5cyBjb25zdHJ1Y3QgYFRhcmdldGAgZnJvbSBgUXVlcnkudG9UYXJnZXRgIGluc3RlYWQgb2ZcbiAqIHVzaW5nIHRoaXMgZmFjdG9yeSBtZXRob2QsIGJlY2F1c2UgYFF1ZXJ5YCBwcm92aWRlcyBhbiBpbXBsaWNpdCBgb3JkZXJCeWBcbiAqIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBuZXdUYXJnZXQocGF0aCwgY29sbGVjdGlvbkdyb3VwID0gbnVsbCwgb3JkZXJCeSA9IFtdLCBmaWx0ZXJzID0gW10sIGxpbWl0ID0gbnVsbCwgc3RhcnRBdCA9IG51bGwsIGVuZEF0ID0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgVGFyZ2V0SW1wbChwYXRoLCBjb2xsZWN0aW9uR3JvdXAsIG9yZGVyQnksIGZpbHRlcnMsIGxpbWl0LCBzdGFydEF0LCBlbmRBdCk7XG59XG5mdW5jdGlvbiBjYW5vbmlmeVRhcmdldCh0YXJnZXQpIHtcbiAgICBjb25zdCB0YXJnZXRJbXBsID0gZGVidWdDYXN0KHRhcmdldCk7XG4gICAgaWYgKHRhcmdldEltcGwubWVtb2l6ZWRDYW5vbmljYWxJZCA9PT0gbnVsbCkge1xuICAgICAgICBsZXQgc3RyID0gdGFyZ2V0SW1wbC5wYXRoLmNhbm9uaWNhbFN0cmluZygpO1xuICAgICAgICBpZiAodGFyZ2V0SW1wbC5jb2xsZWN0aW9uR3JvdXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciArPSAnfGNnOicgKyB0YXJnZXRJbXBsLmNvbGxlY3Rpb25Hcm91cDtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gJ3xmOic7XG4gICAgICAgIHN0ciArPSB0YXJnZXRJbXBsLmZpbHRlcnMubWFwKGYgPT4gY2Fub25pZnlGaWx0ZXIoZikpLmpvaW4oJywnKTtcbiAgICAgICAgc3RyICs9ICd8b2I6JztcbiAgICAgICAgc3RyICs9IHRhcmdldEltcGwub3JkZXJCeS5tYXAobyA9PiBjYW5vbmlmeU9yZGVyQnkobykpLmpvaW4oJywnKTtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZCh0YXJnZXRJbXBsLmxpbWl0KSkge1xuICAgICAgICAgICAgc3RyICs9ICd8bDonO1xuICAgICAgICAgICAgc3RyICs9IHRhcmdldEltcGwubGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldEltcGwuc3RhcnRBdCkge1xuICAgICAgICAgICAgc3RyICs9ICd8bGI6JztcbiAgICAgICAgICAgIHN0ciArPSB0YXJnZXRJbXBsLnN0YXJ0QXQuaW5jbHVzaXZlID8gJ2I6JyA6ICdhOic7XG4gICAgICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5zdGFydEF0LnBvc2l0aW9uLm1hcChwID0+IGNhbm9uaWNhbElkKHApKS5qb2luKCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldEltcGwuZW5kQXQpIHtcbiAgICAgICAgICAgIHN0ciArPSAnfHViOic7XG4gICAgICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5lbmRBdC5pbmNsdXNpdmUgPyAnYTonIDogJ2I6JztcbiAgICAgICAgICAgIHN0ciArPSB0YXJnZXRJbXBsLmVuZEF0LnBvc2l0aW9uLm1hcChwID0+IGNhbm9uaWNhbElkKHApKS5qb2luKCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0SW1wbC5tZW1vaXplZENhbm9uaWNhbElkID0gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0SW1wbC5tZW1vaXplZENhbm9uaWNhbElkO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5VGFyZ2V0KHRhcmdldCkge1xuICAgIGxldCBzdHIgPSB0YXJnZXQucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICBpZiAodGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCAhPT0gbnVsbCkge1xuICAgICAgICBzdHIgKz0gJyBjb2xsZWN0aW9uR3JvdXA9JyArIHRhcmdldC5jb2xsZWN0aW9uR3JvdXA7XG4gICAgfVxuICAgIGlmICh0YXJnZXQuZmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0ciArPSBgLCBmaWx0ZXJzOiBbJHt0YXJnZXQuZmlsdGVyc1xuICAgICAgICAgICAgLm1hcChmID0+IHN0cmluZ2lmeUZpbHRlcihmKSlcbiAgICAgICAgICAgIC5qb2luKCcsICcpfV1gO1xuICAgIH1cbiAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHRhcmdldC5saW1pdCkpIHtcbiAgICAgICAgc3RyICs9ICcsIGxpbWl0OiAnICsgdGFyZ2V0LmxpbWl0O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0Lm9yZGVyQnkubGVuZ3RoID4gMCkge1xuICAgICAgICBzdHIgKz0gYCwgb3JkZXJCeTogWyR7dGFyZ2V0Lm9yZGVyQnlcbiAgICAgICAgICAgIC5tYXAobyA9PiBzdHJpbmdpZnlPcmRlckJ5KG8pKVxuICAgICAgICAgICAgLmpvaW4oJywgJyl9XWA7XG4gICAgfVxuICAgIGlmICh0YXJnZXQuc3RhcnRBdCkge1xuICAgICAgICBzdHIgKz0gJywgc3RhcnRBdDogJztcbiAgICAgICAgc3RyICs9IHRhcmdldC5zdGFydEF0LmluY2x1c2l2ZSA/ICdiOicgOiAnYTonO1xuICAgICAgICBzdHIgKz0gdGFyZ2V0LnN0YXJ0QXQucG9zaXRpb24ubWFwKHAgPT4gY2Fub25pY2FsSWQocCkpLmpvaW4oJywnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldC5lbmRBdCkge1xuICAgICAgICBzdHIgKz0gJywgZW5kQXQ6ICc7XG4gICAgICAgIHN0ciArPSB0YXJnZXQuZW5kQXQuaW5jbHVzaXZlID8gJ2E6JyA6ICdiOic7XG4gICAgICAgIHN0ciArPSB0YXJnZXQuZW5kQXQucG9zaXRpb24ubWFwKHAgPT4gY2Fub25pY2FsSWQocCkpLmpvaW4oJywnKTtcbiAgICB9XG4gICAgcmV0dXJuIGBUYXJnZXQoJHtzdHJ9KWA7XG59XG5mdW5jdGlvbiB0YXJnZXRFcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5saW1pdCAhPT0gcmlnaHQubGltaXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGVmdC5vcmRlckJ5Lmxlbmd0aCAhPT0gcmlnaHQub3JkZXJCeS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnQub3JkZXJCeS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIW9yZGVyQnlFcXVhbHMobGVmdC5vcmRlckJ5W2ldLCByaWdodC5vcmRlckJ5W2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChsZWZ0LmZpbHRlcnMubGVuZ3RoICE9PSByaWdodC5maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghZmlsdGVyRXF1YWxzKGxlZnQuZmlsdGVyc1tpXSwgcmlnaHQuZmlsdGVyc1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVmdC5jb2xsZWN0aW9uR3JvdXAgIT09IHJpZ2h0LmNvbGxlY3Rpb25Hcm91cCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghbGVmdC5wYXRoLmlzRXF1YWwocmlnaHQucGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWJvdW5kRXF1YWxzKGxlZnQuc3RhcnRBdCwgcmlnaHQuc3RhcnRBdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYm91bmRFcXVhbHMobGVmdC5lbmRBdCwgcmlnaHQuZW5kQXQpO1xufVxuZnVuY3Rpb24gdGFyZ2V0SXNEb2N1bWVudFRhcmdldCh0YXJnZXQpIHtcbiAgICByZXR1cm4gKERvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkodGFyZ2V0LnBhdGgpICYmXG4gICAgICAgIHRhcmdldC5jb2xsZWN0aW9uR3JvdXAgPT09IG51bGwgJiZcbiAgICAgICAgdGFyZ2V0LmZpbHRlcnMubGVuZ3RoID09PSAwKTtcbn1cbi8qKiBSZXR1cm5zIHRoZSBmaWVsZCBmaWx0ZXJzIHRoYXQgdGFyZ2V0IHRoZSBnaXZlbiBmaWVsZCBwYXRoLiAqL1xuZnVuY3Rpb24gdGFyZ2V0R2V0RmllbGRGaWx0ZXJzRm9yUGF0aCh0YXJnZXQsIHBhdGgpIHtcbiAgICByZXR1cm4gdGFyZ2V0LmZpbHRlcnMuZmlsdGVyKGYgPT4gZiBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyICYmIGYuZmllbGQuaXNFcXVhbChwYXRoKSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlcyB0aGF0IGFyZSB1c2VkIGluIEFSUkFZX0NPTlRBSU5TIG9yIEFSUkFZX0NPTlRBSU5TX0FOWVxuICogZmlsdGVycy4gUmV0dXJucyBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIHN1Y2ggZmlsdGVycy5cbiAqL1xuZnVuY3Rpb24gdGFyZ2V0R2V0QXJyYXlWYWx1ZXModGFyZ2V0LCBmaWVsZEluZGV4KSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IGZpZWxkSW5kZXhHZXRBcnJheVNlZ21lbnQoZmllbGRJbmRleCk7XG4gICAgaWYgKHNlZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWVsZEZpbHRlciBvZiB0YXJnZXRHZXRGaWVsZEZpbHRlcnNGb3JQYXRoKHRhcmdldCwgc2VnbWVudC5maWVsZFBhdGgpKSB7XG4gICAgICAgIHN3aXRjaCAoZmllbGRGaWx0ZXIub3ApIHtcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkRmlsdGVyLnZhbHVlLmFycmF5VmFsdWUudmFsdWVzIHx8IFtdO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtmaWVsZEZpbHRlci52YWx1ZV07XG4gICAgICAgICAgICAvLyBSZW1haW5pbmcgZmlsdGVycyBhcmUgbm90IGFycmF5IGZpbHRlcnMuXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGxpc3Qgb2YgdmFsdWVzIHRoYXQgYXJlIHVzZWQgaW4gIT0gb3IgTk9UX0lOIGZpbHRlcnMuIFJldHVybnNcbiAqIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gc3VjaCBmaWx0ZXJzLlxuICovXG5mdW5jdGlvbiB0YXJnZXRHZXROb3RJblZhbHVlcyh0YXJnZXQsIGZpZWxkSW5kZXgpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIGZpZWxkSW5kZXhHZXREaXJlY3Rpb25hbFNlZ21lbnRzKGZpZWxkSW5kZXgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRGaWx0ZXIgb2YgdGFyZ2V0R2V0RmllbGRGaWx0ZXJzRm9yUGF0aCh0YXJnZXQsIHNlZ21lbnQuZmllbGRQYXRoKSkge1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZEZpbHRlci5vcCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJpblwiIC8qIE9wZXJhdG9yLklOICovOlxuICAgICAgICAgICAgICAgICAgICAvLyBFbmNvZGUgZXF1YWxpdHkgcHJlZml4LCB3aGljaCBpcyBlbmNvZGVkIGluIHRoZSBpbmRleCB2YWx1ZSBiZWZvcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGluZXF1YWxpdHkgKGUuZy4gYGEgPT0gJ2EnICYmIGIgIT0gJ2InYCBpcyBlbmNvZGVkIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGB2YWx1ZSAhPSAnYWInYCkuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5zZXQoc2VnbWVudC5maWVsZFBhdGguY2Fub25pY2FsU3RyaW5nKCksIGZpZWxkRmlsdGVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi86XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdEluL05vdEVxdWFsIGlzIGFsd2F5cyBhIHN1ZmZpeC4gVGhlcmUgY2Fubm90IGJlIGFueSByZW1haW5pbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VnbWVudHMgYW5kIGhlbmNlIHdlIGNhbiByZXR1cm4gZWFybHkgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnNldChzZWdtZW50LmZpZWxkUGF0aC5jYW5vbmljYWxTdHJpbmcoKSwgZmllbGRGaWx0ZXIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZXMudmFsdWVzKCkpO1xuICAgICAgICAgICAgICAgIC8vIFJlbWFpbmluZyBmaWx0ZXJzIGNhbm5vdCBiZSB1c2VkIGFzIG5vdEluIGJvdW5kcy5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogUmV0dXJucyBhIGxvd2VyIGJvdW5kIG9mIGZpZWxkIHZhbHVlcyB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgc3RhcnRpbmcgcG9pbnQgdG9cbiAqIHNjYW4gdGhlIGluZGV4IGRlZmluZWQgYnkgYGZpZWxkSW5kZXhgLiBSZXR1cm5zIGBNSU5fVkFMVUVgIGlmIG5vIGxvd2VyIGJvdW5kXG4gKiBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHRhcmdldEdldExvd2VyQm91bmQodGFyZ2V0LCBmaWVsZEluZGV4KSB7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgbGV0IGluY2x1c2l2ZSA9IHRydWU7XG4gICAgLy8gRm9yIGVhY2ggc2VnbWVudCwgcmV0cmlldmUgYSBsb3dlciBib3VuZCBpZiB0aGVyZSBpcyBhIHN1aXRhYmxlIGZpbHRlciBvclxuICAgIC8vIHN0YXJ0QXQuXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIGZpZWxkSW5kZXhHZXREaXJlY3Rpb25hbFNlZ21lbnRzKGZpZWxkSW5kZXgpKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRCb3VuZCA9IHNlZ21lbnQua2luZCA9PT0gMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovXG4gICAgICAgICAgICA/IHRhcmdldEdldEFzY2VuZGluZ0JvdW5kKHRhcmdldCwgc2VnbWVudC5maWVsZFBhdGgsIHRhcmdldC5zdGFydEF0KVxuICAgICAgICAgICAgOiB0YXJnZXRHZXREZXNjZW5kaW5nQm91bmQodGFyZ2V0LCBzZWdtZW50LmZpZWxkUGF0aCwgdGFyZ2V0LnN0YXJ0QXQpO1xuICAgICAgICB2YWx1ZXMucHVzaChzZWdtZW50Qm91bmQudmFsdWUpO1xuICAgICAgICBpbmNsdXNpdmUgJiYgKGluY2x1c2l2ZSA9IHNlZ21lbnRCb3VuZC5pbmNsdXNpdmUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJvdW5kKHZhbHVlcywgaW5jbHVzaXZlKTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiB1cHBlciBib3VuZCBvZiBmaWVsZCB2YWx1ZXMgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBlbmRpbmcgcG9pbnRcbiAqIHdoZW4gc2Nhbm5pbmcgdGhlIGluZGV4IGRlZmluZWQgYnkgYGZpZWxkSW5kZXhgLiBSZXR1cm5zIGBNQVhfVkFMVUVgIGlmIG5vXG4gKiB1cHBlciBib3VuZCBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHRhcmdldEdldFVwcGVyQm91bmQodGFyZ2V0LCBmaWVsZEluZGV4KSB7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgbGV0IGluY2x1c2l2ZSA9IHRydWU7XG4gICAgLy8gRm9yIGVhY2ggc2VnbWVudCwgcmV0cmlldmUgYW4gdXBwZXIgYm91bmQgaWYgdGhlcmUgaXMgYSBzdWl0YWJsZSBmaWx0ZXIgb3JcbiAgICAvLyBlbmRBdC5cbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoZmllbGRJbmRleCkpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudEJvdW5kID0gc2VnbWVudC5raW5kID09PSAwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi9cbiAgICAgICAgICAgID8gdGFyZ2V0R2V0RGVzY2VuZGluZ0JvdW5kKHRhcmdldCwgc2VnbWVudC5maWVsZFBhdGgsIHRhcmdldC5lbmRBdClcbiAgICAgICAgICAgIDogdGFyZ2V0R2V0QXNjZW5kaW5nQm91bmQodGFyZ2V0LCBzZWdtZW50LmZpZWxkUGF0aCwgdGFyZ2V0LmVuZEF0KTtcbiAgICAgICAgdmFsdWVzLnB1c2goc2VnbWVudEJvdW5kLnZhbHVlKTtcbiAgICAgICAgaW5jbHVzaXZlICYmIChpbmNsdXNpdmUgPSBzZWdtZW50Qm91bmQuaW5jbHVzaXZlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCb3VuZCh2YWx1ZXMsIGluY2x1c2l2ZSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIHRvIHVzZSBhcyB0aGUgbG93ZXIgYm91bmQgZm9yIGFzY2VuZGluZyBpbmRleCBzZWdtZW50IGF0XG4gKiB0aGUgcHJvdmlkZWQgYGZpZWxkUGF0aGAgKG9yIHRoZSB1cHBlciBib3VuZCBmb3IgYW4gZGVzY2VuZGluZyBzZWdtZW50KS5cbiAqL1xuZnVuY3Rpb24gdGFyZ2V0R2V0QXNjZW5kaW5nQm91bmQodGFyZ2V0LCBmaWVsZFBhdGgsIGJvdW5kKSB7XG4gICAgbGV0IHZhbHVlID0gTUlOX1ZBTFVFO1xuICAgIGxldCBpbmNsdXNpdmUgPSB0cnVlO1xuICAgIC8vIFByb2Nlc3MgYWxsIGZpbHRlcnMgdG8gZmluZCBhIHZhbHVlIGZvciB0aGUgY3VycmVudCBmaWVsZCBzZWdtZW50XG4gICAgZm9yIChjb25zdCBmaWVsZEZpbHRlciBvZiB0YXJnZXRHZXRGaWVsZEZpbHRlcnNGb3JQYXRoKHRhcmdldCwgZmllbGRQYXRoKSkge1xuICAgICAgICBsZXQgZmlsdGVyVmFsdWUgPSBNSU5fVkFMVUU7XG4gICAgICAgIGxldCBmaWx0ZXJJbmNsdXNpdmUgPSB0cnVlO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkRmlsdGVyLm9wKSB7XG4gICAgICAgICAgICBjYXNlIFwiPFwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTiAqLzpcbiAgICAgICAgICAgIGNhc2UgXCI8PVwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTl9PUl9FUVVBTCAqLzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IHZhbHVlc0dldExvd2VyQm91bmQoZmllbGRGaWx0ZXIudmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi86XG4gICAgICAgICAgICBjYXNlIFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLzpcbiAgICAgICAgICAgIGNhc2UgXCI+PVwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTl9PUl9FUVVBTCAqLzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IGZpZWxkRmlsdGVyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIj5cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU4gKi86XG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSBmaWVsZEZpbHRlci52YWx1ZTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJJbmNsdXNpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLzpcbiAgICAgICAgICAgIGNhc2UgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi86XG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSBNSU5fVkFMVUU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBSZW1haW5pbmcgZmlsdGVycyBjYW5ub3QgYmUgdXNlZCBhcyBsb3dlciBib3VuZHMuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd2VyQm91bmRDb21wYXJlKHsgdmFsdWUsIGluY2x1c2l2ZSB9LCB7IHZhbHVlOiBmaWx0ZXJWYWx1ZSwgaW5jbHVzaXZlOiBmaWx0ZXJJbmNsdXNpdmUgfSkgPCAwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZpbHRlclZhbHVlO1xuICAgICAgICAgICAgaW5jbHVzaXZlID0gZmlsdGVySW5jbHVzaXZlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGFkZGl0aW9uYWwgYm91bmQsIGNvbXBhcmUgdGhlIHZhbHVlcyBhZ2FpbnN0IHRoZSBleGlzdGluZ1xuICAgIC8vIHJhbmdlIHRvIHNlZSBpZiB3ZSBjYW4gbmFycm93IHRoZSBzY29wZS5cbiAgICBpZiAoYm91bmQgIT09IG51bGwpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXQub3JkZXJCeS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgb3JkZXJCeSA9IHRhcmdldC5vcmRlckJ5W2ldO1xuICAgICAgICAgICAgaWYgKG9yZGVyQnkuZmllbGQuaXNFcXVhbChmaWVsZFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yVmFsdWUgPSBib3VuZC5wb3NpdGlvbltpXTtcbiAgICAgICAgICAgICAgICBpZiAobG93ZXJCb3VuZENvbXBhcmUoeyB2YWx1ZSwgaW5jbHVzaXZlIH0sIHsgdmFsdWU6IGN1cnNvclZhbHVlLCBpbmNsdXNpdmU6IGJvdW5kLmluY2x1c2l2ZSB9KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjdXJzb3JWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlID0gYm91bmQuaW5jbHVzaXZlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB2YWx1ZSwgaW5jbHVzaXZlIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIHRvIHVzZSBhcyB0aGUgdXBwZXIgYm91bmQgZm9yIGFzY2VuZGluZyBpbmRleCBzZWdtZW50IGF0XG4gKiB0aGUgcHJvdmlkZWQgYGZpZWxkUGF0aGAgKG9yIHRoZSBsb3dlciBib3VuZCBmb3IgYSBkZXNjZW5kaW5nIHNlZ21lbnQpLlxuICovXG5mdW5jdGlvbiB0YXJnZXRHZXREZXNjZW5kaW5nQm91bmQodGFyZ2V0LCBmaWVsZFBhdGgsIGJvdW5kKSB7XG4gICAgbGV0IHZhbHVlID0gTUFYX1ZBTFVFO1xuICAgIGxldCBpbmNsdXNpdmUgPSB0cnVlO1xuICAgIC8vIFByb2Nlc3MgYWxsIGZpbHRlcnMgdG8gZmluZCBhIHZhbHVlIGZvciB0aGUgY3VycmVudCBmaWVsZCBzZWdtZW50XG4gICAgZm9yIChjb25zdCBmaWVsZEZpbHRlciBvZiB0YXJnZXRHZXRGaWVsZEZpbHRlcnNGb3JQYXRoKHRhcmdldCwgZmllbGRQYXRoKSkge1xuICAgICAgICBsZXQgZmlsdGVyVmFsdWUgPSBNQVhfVkFMVUU7XG4gICAgICAgIGxldCBmaWx0ZXJJbmNsdXNpdmUgPSB0cnVlO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkRmlsdGVyLm9wKSB7XG4gICAgICAgICAgICBjYXNlIFwiPj1cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU5fT1JfRVFVQUwgKi86XG4gICAgICAgICAgICBjYXNlIFwiPlwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTiAqLzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IHZhbHVlc0dldFVwcGVyQm91bmQoZmllbGRGaWx0ZXIudmFsdWUpO1xuICAgICAgICAgICAgICAgIGZpbHRlckluY2x1c2l2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi86XG4gICAgICAgICAgICBjYXNlIFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLzpcbiAgICAgICAgICAgIGNhc2UgXCI8PVwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTl9PUl9FUVVBTCAqLzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IGZpZWxkRmlsdGVyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIjxcIiAvKiBPcGVyYXRvci5MRVNTX1RIQU4gKi86XG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSBmaWVsZEZpbHRlci52YWx1ZTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJJbmNsdXNpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLzpcbiAgICAgICAgICAgIGNhc2UgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi86XG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSBNQVhfVkFMVUU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBSZW1haW5pbmcgZmlsdGVycyBjYW5ub3QgYmUgdXNlZCBhcyB1cHBlciBib3VuZHMuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwcGVyQm91bmRDb21wYXJlKHsgdmFsdWUsIGluY2x1c2l2ZSB9LCB7IHZhbHVlOiBmaWx0ZXJWYWx1ZSwgaW5jbHVzaXZlOiBmaWx0ZXJJbmNsdXNpdmUgfSkgPiAwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZpbHRlclZhbHVlO1xuICAgICAgICAgICAgaW5jbHVzaXZlID0gZmlsdGVySW5jbHVzaXZlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGFkZGl0aW9uYWwgYm91bmQsIGNvbXBhcmUgdGhlIHZhbHVlcyBhZ2FpbnN0IHRoZSBleGlzdGluZ1xuICAgIC8vIHJhbmdlIHRvIHNlZSBpZiB3ZSBjYW4gbmFycm93IHRoZSBzY29wZS5cbiAgICBpZiAoYm91bmQgIT09IG51bGwpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXQub3JkZXJCeS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgb3JkZXJCeSA9IHRhcmdldC5vcmRlckJ5W2ldO1xuICAgICAgICAgICAgaWYgKG9yZGVyQnkuZmllbGQuaXNFcXVhbChmaWVsZFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yVmFsdWUgPSBib3VuZC5wb3NpdGlvbltpXTtcbiAgICAgICAgICAgICAgICBpZiAodXBwZXJCb3VuZENvbXBhcmUoeyB2YWx1ZSwgaW5jbHVzaXZlIH0sIHsgdmFsdWU6IGN1cnNvclZhbHVlLCBpbmNsdXNpdmU6IGJvdW5kLmluY2x1c2l2ZSB9KSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjdXJzb3JWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlID0gYm91bmQuaW5jbHVzaXZlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB2YWx1ZSwgaW5jbHVzaXZlIH07XG59XG4vKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHNlZ21lbnRzIG9mIGEgcGVyZmVjdCBpbmRleCBmb3IgdGhpcyB0YXJnZXQuICovXG5mdW5jdGlvbiB0YXJnZXRHZXRTZWdtZW50Q291bnQodGFyZ2V0KSB7XG4gICAgbGV0IGZpZWxkcyA9IG5ldyBTb3J0ZWRTZXQoRmllbGRQYXRoJDEuY29tcGFyYXRvcik7XG4gICAgbGV0IGhhc0FycmF5U2VnbWVudCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHRhcmdldC5maWx0ZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViRmlsdGVyIG9mIGZpbHRlci5nZXRGbGF0dGVuZWRGaWx0ZXJzKCkpIHtcbiAgICAgICAgICAgIC8vIF9fbmFtZV9fIGlzIG5vdCBhbiBleHBsaWNpdCBzZWdtZW50IG9mIGFueSBpbmRleCwgc28gd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAgICAgLy8gY291bnQgaXQuXG4gICAgICAgICAgICBpZiAoc3ViRmlsdGVyLmZpZWxkLmlzS2V5RmllbGQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQVJSQVlfQ09OVEFJTlMgb3IgQVJSQVlfQ09OVEFJTlNfQU5ZIGZpbHRlcnMgbXVzdCBiZSBjb3VudGVkIHNlcGFyYXRlbHkuXG4gICAgICAgICAgICAvLyBGb3IgaW5zdGFuY2UsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgYW4gaW5kZXggZm9yIFwiYSBBUlJBWSBhIEFTQ1wiLiBFdmVuXG4gICAgICAgICAgICAvLyB0aG91Z2ggdGhlc2UgYXJlIG9uIHRoZSBzYW1lIGZpZWxkLCB0aGV5IHNob3VsZCBiZSBjb3VudGVkIGFzIHR3b1xuICAgICAgICAgICAgLy8gc2VwYXJhdGUgc2VnbWVudHMgaW4gYW4gaW5kZXguXG4gICAgICAgICAgICBpZiAoc3ViRmlsdGVyLm9wID09PSBcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi8gfHxcbiAgICAgICAgICAgICAgICBzdWJGaWx0ZXIub3AgPT09IFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovKSB7XG4gICAgICAgICAgICAgICAgaGFzQXJyYXlTZWdtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpZWxkcyA9IGZpZWxkcy5hZGQoc3ViRmlsdGVyLmZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9yZGVyQnkgb2YgdGFyZ2V0Lm9yZGVyQnkpIHtcbiAgICAgICAgLy8gX19uYW1lX18gaXMgbm90IGFuIGV4cGxpY2l0IHNlZ21lbnQgb2YgYW55IGluZGV4LCBzbyB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICAgIC8vIGNvdW50IGl0LlxuICAgICAgICBpZiAoIW9yZGVyQnkuZmllbGQuaXNLZXlGaWVsZCgpKSB7XG4gICAgICAgICAgICBmaWVsZHMgPSBmaWVsZHMuYWRkKG9yZGVyQnkuZmllbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHMuc2l6ZSArIChoYXNBcnJheVNlZ21lbnQgPyAxIDogMCk7XG59XG5mdW5jdGlvbiB0YXJnZXRIYXNMaW1pdCh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0LmxpbWl0ICE9PSBudWxsO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBRdWVyeSBlbmNhcHN1bGF0ZXMgYWxsIHRoZSBxdWVyeSBhdHRyaWJ1dGVzIHdlIHN1cHBvcnQgaW4gdGhlIFNESy4gSXQgY2FuXG4gKiBiZSBydW4gYWdhaW5zdCB0aGUgTG9jYWxTdG9yZSwgYXMgd2VsbCBhcyBiZSBjb252ZXJ0ZWQgdG8gYSBgVGFyZ2V0YCB0b1xuICogcXVlcnkgdGhlIFJlbW90ZVN0b3JlIHJlc3VsdHMuXG4gKlxuICogVmlzaWJsZSBmb3IgdGVzdGluZy5cbiAqL1xuY2xhc3MgUXVlcnlJbXBsIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIFF1ZXJ5IHdpdGggYSBwYXRoIGFuZCBvcHRpb25hbCBhZGRpdGlvbmFsIHF1ZXJ5IGNvbnN0cmFpbnRzLlxuICAgICAqIFBhdGggbXVzdCBjdXJyZW50bHkgYmUgZW1wdHkgaWYgdGhpcyBpcyBhIGNvbGxlY3Rpb24gZ3JvdXAgcXVlcnkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGF0aCwgY29sbGVjdGlvbkdyb3VwID0gbnVsbCwgZXhwbGljaXRPcmRlckJ5ID0gW10sIGZpbHRlcnMgPSBbXSwgbGltaXQgPSBudWxsLCBsaW1pdFR5cGUgPSBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8sIHN0YXJ0QXQgPSBudWxsLCBlbmRBdCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXAgPSBjb2xsZWN0aW9uR3JvdXA7XG4gICAgICAgIHRoaXMuZXhwbGljaXRPcmRlckJ5ID0gZXhwbGljaXRPcmRlckJ5O1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgICAgICB0aGlzLmxpbWl0ID0gbGltaXQ7XG4gICAgICAgIHRoaXMubGltaXRUeXBlID0gbGltaXRUeXBlO1xuICAgICAgICB0aGlzLnN0YXJ0QXQgPSBzdGFydEF0O1xuICAgICAgICB0aGlzLmVuZEF0ID0gZW5kQXQ7XG4gICAgICAgIHRoaXMubWVtb2l6ZWROb3JtYWxpemVkT3JkZXJCeSA9IG51bGw7XG4gICAgICAgIC8vIFRoZSBjb3JyZXNwb25kaW5nIGBUYXJnZXRgIG9mIHRoaXMgYFF1ZXJ5YCBpbnN0YW5jZSwgZm9yIHVzZSB3aXRoXG4gICAgICAgIC8vIG5vbi1hZ2dyZWdhdGUgcXVlcmllcy5cbiAgICAgICAgdGhpcy5tZW1vaXplZFRhcmdldCA9IG51bGw7XG4gICAgICAgIC8vIFRoZSBjb3JyZXNwb25kaW5nIGBUYXJnZXRgIG9mIHRoaXMgYFF1ZXJ5YCBpbnN0YW5jZSwgZm9yIHVzZSB3aXRoXG4gICAgICAgIC8vIGFnZ3JlZ2F0ZSBxdWVyaWVzLiBVbmxpa2UgdGFyZ2V0cyBmb3Igbm9uLWFnZ3JlZ2F0ZSBxdWVyaWVzLFxuICAgICAgICAvLyBhZ2dyZWdhdGUgcXVlcnkgdGFyZ2V0cyBkbyBub3QgY29udGFpbiBub3JtYWxpemVkIG9yZGVyLWJ5cywgdGhleSBvbmx5XG4gICAgICAgIC8vIGNvbnRhaW4gZXhwbGljaXQgb3JkZXItYnlzLlxuICAgICAgICB0aGlzLm1lbW9pemVkQWdncmVnYXRlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRBdCkgO1xuICAgICAgICBpZiAodGhpcy5lbmRBdCkgO1xuICAgIH1cbn1cbi8qKiBDcmVhdGVzIGEgbmV3IFF1ZXJ5IGluc3RhbmNlIHdpdGggdGhlIG9wdGlvbnMgcHJvdmlkZWQuICovXG5mdW5jdGlvbiBuZXdRdWVyeShwYXRoLCBjb2xsZWN0aW9uR3JvdXAsIGV4cGxpY2l0T3JkZXJCeSwgZmlsdGVycywgbGltaXQsIGxpbWl0VHlwZSwgc3RhcnRBdCwgZW5kQXQpIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChwYXRoLCBjb2xsZWN0aW9uR3JvdXAsIGV4cGxpY2l0T3JkZXJCeSwgZmlsdGVycywgbGltaXQsIGxpbWl0VHlwZSwgc3RhcnRBdCwgZW5kQXQpO1xufVxuLyoqIENyZWF0ZXMgYSBuZXcgUXVlcnkgZm9yIGEgcXVlcnkgdGhhdCBtYXRjaGVzIGFsbCBkb2N1bWVudHMgYXQgYHBhdGhgICovXG5mdW5jdGlvbiBuZXdRdWVyeUZvclBhdGgocGF0aCkge1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHBhdGgpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gY29udmVydCBhIGNvbGxlY3Rpb24gZ3JvdXAgcXVlcnkgaW50byBhIGNvbGxlY3Rpb24gcXVlcnkgYXQgYVxuICogc3BlY2lmaWMgcGF0aC4gVGhpcyBpcyB1c2VkIHdoZW4gZXhlY3V0aW5nIGNvbGxlY3Rpb24gZ3JvdXAgcXVlcmllcywgc2luY2VcbiAqIHdlIGhhdmUgdG8gc3BsaXQgdGhlIHF1ZXJ5IGludG8gYSBzZXQgb2YgY29sbGVjdGlvbiBxdWVyaWVzIGF0IG11bHRpcGxlXG4gKiBwYXRocy5cbiAqL1xuZnVuY3Rpb24gYXNDb2xsZWN0aW9uUXVlcnlBdFBhdGgocXVlcnksIHBhdGgpIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChwYXRoLCBcbiAgICAvKmNvbGxlY3Rpb25Hcm91cD0qLyBudWxsLCBxdWVyeS5leHBsaWNpdE9yZGVyQnkuc2xpY2UoKSwgcXVlcnkuZmlsdGVycy5zbGljZSgpLCBxdWVyeS5saW1pdCwgcXVlcnkubGltaXRUeXBlLCBxdWVyeS5zdGFydEF0LCBxdWVyeS5lbmRBdCk7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHF1ZXJ5IGRvZXMgbm90IHNwZWNpZnkgYW55IHF1ZXJ5IGNvbnN0cmFpbnRzIHRoYXRcbiAqIGNvdWxkIHJlbW92ZSByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBxdWVyeU1hdGNoZXNBbGxEb2N1bWVudHMocXVlcnkpIHtcbiAgICByZXR1cm4gKHF1ZXJ5LmZpbHRlcnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgIHF1ZXJ5LmxpbWl0ID09PSBudWxsICYmXG4gICAgICAgIHF1ZXJ5LnN0YXJ0QXQgPT0gbnVsbCAmJlxuICAgICAgICBxdWVyeS5lbmRBdCA9PSBudWxsICYmXG4gICAgICAgIChxdWVyeS5leHBsaWNpdE9yZGVyQnkubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAocXVlcnkuZXhwbGljaXRPcmRlckJ5Lmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeVswXS5maWVsZC5pc0tleUZpZWxkKCkpKSk7XG59XG4vLyBSZXR1cm5zIHRoZSBzb3J0ZWQgc2V0IG9mIGluZXF1YWxpdHkgZmlsdGVyIGZpZWxkcyB1c2VkIGluIHRoaXMgcXVlcnkuXG5mdW5jdGlvbiBnZXRJbmVxdWFsaXR5RmlsdGVyRmllbGRzKHF1ZXJ5KSB7XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBTb3J0ZWRTZXQoRmllbGRQYXRoJDEuY29tcGFyYXRvcik7XG4gICAgcXVlcnkuZmlsdGVycy5mb3JFYWNoKChmaWx0ZXIpID0+IHtcbiAgICAgICAgY29uc3Qgc3ViRmlsdGVycyA9IGZpbHRlci5nZXRGbGF0dGVuZWRGaWx0ZXJzKCk7XG4gICAgICAgIHN1YkZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmlzSW5lcXVhbGl0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmaWx0ZXIuZmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFF1ZXJ5IGZvciBhIGNvbGxlY3Rpb24gZ3JvdXAgcXVlcnkgdGhhdCBtYXRjaGVzIGFsbCBkb2N1bWVudHNcbiAqIHdpdGhpbiB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbiBncm91cC5cbiAqL1xuZnVuY3Rpb24gbmV3UXVlcnlGb3JDb2xsZWN0aW9uR3JvdXAoY29sbGVjdGlvbklkKSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwoUmVzb3VyY2VQYXRoLmVtcHR5UGF0aCgpLCBjb2xsZWN0aW9uSWQpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHF1ZXJ5IG1hdGNoZXMgYSBzaW5nbGUgZG9jdW1lbnQgYnkgcGF0aCAocmF0aGVyIHRoYW4gYVxuICogY29sbGVjdGlvbikuXG4gKi9cbmZ1bmN0aW9uIGlzRG9jdW1lbnRRdWVyeSQxKHF1ZXJ5KSB7XG4gICAgcmV0dXJuIChEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHF1ZXJ5LnBhdGgpICYmXG4gICAgICAgIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCA9PT0gbnVsbCAmJlxuICAgICAgICBxdWVyeS5maWx0ZXJzLmxlbmd0aCA9PT0gMCk7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcXVlcnkgbWF0Y2hlcyBhIGNvbGxlY3Rpb24gZ3JvdXAgcmF0aGVyIHRoYW4gYSBzcGVjaWZpY1xuICogY29sbGVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gaXNDb2xsZWN0aW9uR3JvdXBRdWVyeShxdWVyeSkge1xuICAgIHJldHVybiBxdWVyeS5jb2xsZWN0aW9uR3JvdXAgIT09IG51bGw7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgb3JkZXItYnkgY29uc3RyYWludCB0aGF0IGlzIHVzZWQgdG8gZXhlY3V0ZSB0aGUgUXVlcnksXG4gKiB3aGljaCBjYW4gYmUgZGlmZmVyZW50IGZyb20gdGhlIG9yZGVyLWJ5IGNvbnN0cmFpbnRzIHRoZSB1c2VyIHByb3ZpZGVkIChlLmcuXG4gKiB0aGUgU0RLIGFuZCBiYWNrZW5kIGFsd2F5cyBvcmRlcnMgYnkgYF9fbmFtZV9fYCkuIFRoZSBub3JtYWxpemVkIG9yZGVyLWJ5XG4gKiBpbmNsdWRlcyBpbXBsaWNpdCBvcmRlci1ieXMgaW4gYWRkaXRpb24gdG8gdGhlIGV4cGxpY2l0IHVzZXIgcHJvdmlkZWRcbiAqIG9yZGVyLWJ5cy5cbiAqL1xuZnVuY3Rpb24gcXVlcnlOb3JtYWxpemVkT3JkZXJCeShxdWVyeSkge1xuICAgIGNvbnN0IHF1ZXJ5SW1wbCA9IGRlYnVnQ2FzdChxdWVyeSk7XG4gICAgaWYgKHF1ZXJ5SW1wbC5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5ID09PSBudWxsKSB7XG4gICAgICAgIHF1ZXJ5SW1wbC5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5ID0gW107XG4gICAgICAgIGNvbnN0IGZpZWxkc05vcm1hbGl6ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8vIEFueSBleHBsaWNpdCBvcmRlciBieSBmaWVsZHMgc2hvdWxkIGJlIGFkZGVkIGFzIGlzLlxuICAgICAgICBmb3IgKGNvbnN0IG9yZGVyQnkgb2YgcXVlcnlJbXBsLmV4cGxpY2l0T3JkZXJCeSkge1xuICAgICAgICAgICAgcXVlcnlJbXBsLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnkucHVzaChvcmRlckJ5KTtcbiAgICAgICAgICAgIGZpZWxkc05vcm1hbGl6ZWQuYWRkKG9yZGVyQnkuZmllbGQuY2Fub25pY2FsU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBvcmRlciBvZiB0aGUgaW1wbGljaXQgb3JkZXJpbmcgYWx3YXlzIG1hdGNoZXMgdGhlIGxhc3QgZXhwbGljaXQgb3JkZXIgYnkuXG4gICAgICAgIGNvbnN0IGxhc3REaXJlY3Rpb24gPSBxdWVyeUltcGwuZXhwbGljaXRPcmRlckJ5Lmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gcXVlcnlJbXBsLmV4cGxpY2l0T3JkZXJCeVtxdWVyeUltcGwuZXhwbGljaXRPcmRlckJ5Lmxlbmd0aCAtIDFdLmRpclxuICAgICAgICAgICAgOiBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi87XG4gICAgICAgIC8vIEFueSBpbmVxdWFsaXR5IGZpZWxkcyBub3QgZXhwbGljaXRseSBvcmRlcmVkIHNob3VsZCBiZSBpbXBsaWNpdGx5IG9yZGVyZWQgaW4gYSBsZXhpY29ncmFwaGljYWxcbiAgICAgICAgLy8gb3JkZXIuIFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGluZXF1YWxpdHkgZmlsdGVycyBvbiB0aGUgc2FtZSBmaWVsZCwgdGhlIGZpZWxkIHNob3VsZCBiZSBhZGRlZFxuICAgICAgICAvLyBvbmx5IG9uY2UuXG4gICAgICAgIC8vIE5vdGU6IGBTb3J0ZWRTZXQ8RmllbGRQYXRoPmAgc29ydHMgdGhlIGtleSBmaWVsZCBiZWZvcmUgb3RoZXIgZmllbGRzLiBIb3dldmVyLCB3ZSB3YW50IHRoZSBrZXlcbiAgICAgICAgLy8gZmllbGQgdG8gYmUgc29ydGVkIGxhc3QuXG4gICAgICAgIGNvbnN0IGluZXF1YWxpdHlGaWVsZHMgPSBnZXRJbmVxdWFsaXR5RmlsdGVyRmllbGRzKHF1ZXJ5SW1wbCk7XG4gICAgICAgIGluZXF1YWxpdHlGaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICBpZiAoIWZpZWxkc05vcm1hbGl6ZWQuaGFzKGZpZWxkLmNhbm9uaWNhbFN0cmluZygpKSAmJlxuICAgICAgICAgICAgICAgICFmaWVsZC5pc0tleUZpZWxkKCkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWROb3JtYWxpemVkT3JkZXJCeS5wdXNoKG5ldyBPcmRlckJ5KGZpZWxkLCBsYXN0RGlyZWN0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBZGQgdGhlIGRvY3VtZW50IGtleSBmaWVsZCB0byB0aGUgbGFzdCBpZiBpdCBpcyBub3QgZXhwbGljaXRseSBvcmRlcmVkLlxuICAgICAgICBpZiAoIWZpZWxkc05vcm1hbGl6ZWQuaGFzKEZpZWxkUGF0aCQxLmtleUZpZWxkKCkuY2Fub25pY2FsU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWROb3JtYWxpemVkT3JkZXJCeS5wdXNoKG5ldyBPcmRlckJ5KEZpZWxkUGF0aCQxLmtleUZpZWxkKCksIGxhc3REaXJlY3Rpb24pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcXVlcnlJbXBsLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnk7XG59XG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYFF1ZXJ5YCBpbnN0YW5jZSB0byBpdHMgY29ycmVzcG9uZGluZyBgVGFyZ2V0YCByZXByZXNlbnRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gcXVlcnlUb1RhcmdldChxdWVyeSkge1xuICAgIGNvbnN0IHF1ZXJ5SW1wbCA9IGRlYnVnQ2FzdChxdWVyeSk7XG4gICAgaWYgKCFxdWVyeUltcGwubWVtb2l6ZWRUYXJnZXQpIHtcbiAgICAgICAgcXVlcnlJbXBsLm1lbW9pemVkVGFyZ2V0ID0gX3F1ZXJ5VG9UYXJnZXQocXVlcnlJbXBsLCBxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5KHF1ZXJ5KSk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeUltcGwubWVtb2l6ZWRUYXJnZXQ7XG59XG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYFF1ZXJ5YCBpbnN0YW5jZSB0byBpdHMgY29ycmVzcG9uZGluZyBgVGFyZ2V0YCByZXByZXNlbnRhdGlvbixcbiAqIGZvciB1c2Ugd2l0aGluIGFuIGFnZ3JlZ2F0ZSBxdWVyeS4gVW5saWtlIHRhcmdldHMgZm9yIG5vbi1hZ2dyZWdhdGUgcXVlcmllcyxcbiAqIGFnZ3JlZ2F0ZSBxdWVyeSB0YXJnZXRzIGRvIG5vdCBjb250YWluIG5vcm1hbGl6ZWQgb3JkZXItYnlzLCB0aGV5IG9ubHlcbiAqIGNvbnRhaW4gZXhwbGljaXQgb3JkZXItYnlzLlxuICovXG5mdW5jdGlvbiBxdWVyeVRvQWdncmVnYXRlVGFyZ2V0KHF1ZXJ5KSB7XG4gICAgY29uc3QgcXVlcnlJbXBsID0gZGVidWdDYXN0KHF1ZXJ5KTtcbiAgICBpZiAoIXF1ZXJ5SW1wbC5tZW1vaXplZEFnZ3JlZ2F0ZVRhcmdldCkge1xuICAgICAgICAvLyBEbyBub3QgaW5jbHVkZSBpbXBsaWNpdCBvcmRlci1ieXMgZm9yIGFnZ3JlZ2F0ZSBxdWVyaWVzLlxuICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWRBZ2dyZWdhdGVUYXJnZXQgPSBfcXVlcnlUb1RhcmdldChxdWVyeUltcGwsIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeSk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeUltcGwubWVtb2l6ZWRBZ2dyZWdhdGVUYXJnZXQ7XG59XG5mdW5jdGlvbiBfcXVlcnlUb1RhcmdldChxdWVyeUltcGwsIG9yZGVyQnlzKSB7XG4gICAgaWYgKHF1ZXJ5SW1wbC5saW1pdFR5cGUgPT09IFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqLykge1xuICAgICAgICByZXR1cm4gbmV3VGFyZ2V0KHF1ZXJ5SW1wbC5wYXRoLCBxdWVyeUltcGwuY29sbGVjdGlvbkdyb3VwLCBvcmRlckJ5cywgcXVlcnlJbXBsLmZpbHRlcnMsIHF1ZXJ5SW1wbC5saW1pdCwgcXVlcnlJbXBsLnN0YXJ0QXQsIHF1ZXJ5SW1wbC5lbmRBdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBGbGlwIHRoZSBvcmRlckJ5IGRpcmVjdGlvbnMgc2luY2Ugd2Ugd2FudCB0aGUgbGFzdCByZXN1bHRzXG4gICAgICAgIG9yZGVyQnlzID0gb3JkZXJCeXMubWFwKG9yZGVyQnkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGlyID0gb3JkZXJCeS5kaXIgPT09IFwiZGVzY1wiIC8qIERpcmVjdGlvbi5ERVNDRU5ESU5HICovXG4gICAgICAgICAgICAgICAgPyBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi9cbiAgICAgICAgICAgICAgICA6IFwiZGVzY1wiIC8qIERpcmVjdGlvbi5ERVNDRU5ESU5HICovO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPcmRlckJ5KG9yZGVyQnkuZmllbGQsIGRpcik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHN3YXAgdGhlIGN1cnNvcnMgdG8gbWF0Y2ggdGhlIG5vdy1mbGlwcGVkIHF1ZXJ5IG9yZGVyaW5nLlxuICAgICAgICBjb25zdCBzdGFydEF0ID0gcXVlcnlJbXBsLmVuZEF0XG4gICAgICAgICAgICA/IG5ldyBCb3VuZChxdWVyeUltcGwuZW5kQXQucG9zaXRpb24sIHF1ZXJ5SW1wbC5lbmRBdC5pbmNsdXNpdmUpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGNvbnN0IGVuZEF0ID0gcXVlcnlJbXBsLnN0YXJ0QXRcbiAgICAgICAgICAgID8gbmV3IEJvdW5kKHF1ZXJ5SW1wbC5zdGFydEF0LnBvc2l0aW9uLCBxdWVyeUltcGwuc3RhcnRBdC5pbmNsdXNpdmUpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIC8vIE5vdyByZXR1cm4gYXMgYSBMaW1pdFR5cGUuRmlyc3QgcXVlcnkuXG4gICAgICAgIHJldHVybiBuZXdUYXJnZXQocXVlcnlJbXBsLnBhdGgsIHF1ZXJ5SW1wbC5jb2xsZWN0aW9uR3JvdXAsIG9yZGVyQnlzLCBxdWVyeUltcGwuZmlsdGVycywgcXVlcnlJbXBsLmxpbWl0LCBzdGFydEF0LCBlbmRBdCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcXVlcnlXaXRoQWRkZWRGaWx0ZXIocXVlcnksIGZpbHRlcikge1xuICAgIGNvbnN0IG5ld0ZpbHRlcnMgPSBxdWVyeS5maWx0ZXJzLmNvbmNhdChbZmlsdGVyXSk7XG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkucGF0aCwgcXVlcnkuY29sbGVjdGlvbkdyb3VwLCBxdWVyeS5leHBsaWNpdE9yZGVyQnkuc2xpY2UoKSwgbmV3RmlsdGVycywgcXVlcnkubGltaXQsIHF1ZXJ5LmxpbWl0VHlwZSwgcXVlcnkuc3RhcnRBdCwgcXVlcnkuZW5kQXQpO1xufVxuZnVuY3Rpb24gcXVlcnlXaXRoQWRkZWRPcmRlckJ5KHF1ZXJ5LCBvcmRlckJ5KSB7XG4gICAgLy8gVE9ETyhkaW1vbmQpOiB2YWxpZGF0ZSB0aGF0IG9yZGVyQnkgZG9lcyBub3QgbGlzdCB0aGUgc2FtZSBrZXkgdHdpY2UuXG4gICAgY29uc3QgbmV3T3JkZXJCeSA9IHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5jb25jYXQoW29yZGVyQnldKTtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5wYXRoLCBxdWVyeS5jb2xsZWN0aW9uR3JvdXAsIG5ld09yZGVyQnksIHF1ZXJ5LmZpbHRlcnMuc2xpY2UoKSwgcXVlcnkubGltaXQsIHF1ZXJ5LmxpbWl0VHlwZSwgcXVlcnkuc3RhcnRBdCwgcXVlcnkuZW5kQXQpO1xufVxuZnVuY3Rpb24gcXVlcnlXaXRoTGltaXQocXVlcnksIGxpbWl0LCBsaW1pdFR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5wYXRoLCBxdWVyeS5jb2xsZWN0aW9uR3JvdXAsIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5zbGljZSgpLCBxdWVyeS5maWx0ZXJzLnNsaWNlKCksIGxpbWl0LCBsaW1pdFR5cGUsIHF1ZXJ5LnN0YXJ0QXQsIHF1ZXJ5LmVuZEF0KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5V2l0aFN0YXJ0QXQocXVlcnksIGJvdW5kKSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkucGF0aCwgcXVlcnkuY29sbGVjdGlvbkdyb3VwLCBxdWVyeS5leHBsaWNpdE9yZGVyQnkuc2xpY2UoKSwgcXVlcnkuZmlsdGVycy5zbGljZSgpLCBxdWVyeS5saW1pdCwgcXVlcnkubGltaXRUeXBlLCBib3VuZCwgcXVlcnkuZW5kQXQpO1xufVxuZnVuY3Rpb24gcXVlcnlXaXRoRW5kQXQocXVlcnksIGJvdW5kKSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkucGF0aCwgcXVlcnkuY29sbGVjdGlvbkdyb3VwLCBxdWVyeS5leHBsaWNpdE9yZGVyQnkuc2xpY2UoKSwgcXVlcnkuZmlsdGVycy5zbGljZSgpLCBxdWVyeS5saW1pdCwgcXVlcnkubGltaXRUeXBlLCBxdWVyeS5zdGFydEF0LCBib3VuZCk7XG59XG5mdW5jdGlvbiBxdWVyeUVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiAodGFyZ2V0RXF1YWxzKHF1ZXJ5VG9UYXJnZXQobGVmdCksIHF1ZXJ5VG9UYXJnZXQocmlnaHQpKSAmJlxuICAgICAgICBsZWZ0LmxpbWl0VHlwZSA9PT0gcmlnaHQubGltaXRUeXBlKTtcbn1cbi8vIFRPRE8oYi8yOTE4MzE2NSk6IFRoaXMgaXMgdXNlZCB0byBnZXQgYSB1bmlxdWUgc3RyaW5nIGZyb20gYSBxdWVyeSB0bywgZm9yXG4vLyBleGFtcGxlLCB1c2UgYXMgYSBkaWN0aW9uYXJ5IGtleSwgYnV0IHRoZSBpbXBsZW1lbnRhdGlvbiBpcyBzdWJqZWN0IHRvXG4vLyBjb2xsaXNpb25zLiBNYWtlIGl0IGNvbGxpc2lvbi1mcmVlLlxuZnVuY3Rpb24gY2Fub25pZnlRdWVyeShxdWVyeSkge1xuICAgIHJldHVybiBgJHtjYW5vbmlmeVRhcmdldChxdWVyeVRvVGFyZ2V0KHF1ZXJ5KSl9fGx0OiR7cXVlcnkubGltaXRUeXBlfWA7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlRdWVyeShxdWVyeSkge1xuICAgIHJldHVybiBgUXVlcnkodGFyZ2V0PSR7c3RyaW5naWZ5VGFyZ2V0KHF1ZXJ5VG9UYXJnZXQocXVlcnkpKX07IGxpbWl0VHlwZT0ke3F1ZXJ5LmxpbWl0VHlwZX0pYDtcbn1cbi8qKiBSZXR1cm5zIHdoZXRoZXIgYGRvY2AgbWF0Y2hlcyB0aGUgY29uc3RyYWludHMgb2YgYHF1ZXJ5YC4gKi9cbmZ1bmN0aW9uIHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZG9jKSB7XG4gICAgcmV0dXJuIChkb2MuaXNGb3VuZERvY3VtZW50KCkgJiZcbiAgICAgICAgcXVlcnlNYXRjaGVzUGF0aEFuZENvbGxlY3Rpb25Hcm91cChxdWVyeSwgZG9jKSAmJlxuICAgICAgICBxdWVyeU1hdGNoZXNPcmRlckJ5KHF1ZXJ5LCBkb2MpICYmXG4gICAgICAgIHF1ZXJ5TWF0Y2hlc0ZpbHRlcnMocXVlcnksIGRvYykgJiZcbiAgICAgICAgcXVlcnlNYXRjaGVzQm91bmRzKHF1ZXJ5LCBkb2MpKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5TWF0Y2hlc1BhdGhBbmRDb2xsZWN0aW9uR3JvdXAocXVlcnksIGRvYykge1xuICAgIGNvbnN0IGRvY1BhdGggPSBkb2Mua2V5LnBhdGg7XG4gICAgaWYgKHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBOT1RFOiB0aGlzLnBhdGggaXMgY3VycmVudGx5IGFsd2F5cyBlbXB0eSBzaW5jZSB3ZSBkb24ndCBleHBvc2UgQ29sbGVjdGlvblxuICAgICAgICAvLyBHcm91cCBxdWVyaWVzIHJvb3RlZCBhdCBhIGRvY3VtZW50IHBhdGggeWV0LlxuICAgICAgICByZXR1cm4gKGRvYy5rZXkuaGFzQ29sbGVjdGlvbklkKHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCkgJiZcbiAgICAgICAgICAgIHF1ZXJ5LnBhdGguaXNQcmVmaXhPZihkb2NQYXRoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKERvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkocXVlcnkucGF0aCkpIHtcbiAgICAgICAgLy8gZXhhY3QgbWF0Y2ggZm9yIGRvY3VtZW50IHF1ZXJpZXNcbiAgICAgICAgcmV0dXJuIHF1ZXJ5LnBhdGguaXNFcXVhbChkb2NQYXRoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHNoYWxsb3cgYW5jZXN0b3IgcXVlcmllcyBieSBkZWZhdWx0XG4gICAgICAgIHJldHVybiBxdWVyeS5wYXRoLmlzSW1tZWRpYXRlUGFyZW50T2YoZG9jUGF0aCk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGRvY3VtZW50IG11c3QgaGF2ZSBhIHZhbHVlIGZvciBldmVyeSBvcmRlcmluZyBjbGF1c2UgaW4gb3JkZXIgdG8gc2hvdyB1cFxuICogaW4gdGhlIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5TWF0Y2hlc09yZGVyQnkocXVlcnksIGRvYykge1xuICAgIC8vIFdlIG11c3QgdXNlIGBxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5KClgIHRvIGdldCB0aGUgbGlzdCBvZiBhbGwgb3JkZXJCeXMgKGJvdGggaW1wbGljaXQgYW5kIGV4cGxpY2l0KS5cbiAgICAvLyBOb3RlIHRoYXQgZm9yIE9SIHF1ZXJpZXMsIG9yZGVyQnkgYXBwbGllcyB0byBhbGwgZGlzanVuY3Rpb24gdGVybXMgYW5kIGltcGxpY2l0IG9yZGVyQnlzIG11c3RcbiAgICAvLyBiZSB0YWtlbiBpbnRvIGFjY291bnQuIEZvciBleGFtcGxlLCB0aGUgcXVlcnkgXCJhID4gMSB8fCBiPT0xXCIgaGFzIGFuIGltcGxpY2l0IFwib3JkZXJCeSBhXCIgZHVlXG4gICAgLy8gdG8gdGhlIGluZXF1YWxpdHksIGFuZCBpcyBldmFsdWF0ZWQgYXMgXCJhID4gMSBvcmRlckJ5IGEgfHwgYj09MSBvcmRlckJ5IGFcIi5cbiAgICAvLyBBIGRvY3VtZW50IHdpdGggY29udGVudCBvZiB7YjoxfSBtYXRjaGVzIHRoZSBmaWx0ZXJzLCBidXQgZG9lcyBub3QgbWF0Y2ggdGhlIG9yZGVyQnkgYmVjYXVzZVxuICAgIC8vIGl0J3MgbWlzc2luZyB0aGUgZmllbGQgJ2EnLlxuICAgIGZvciAoY29uc3Qgb3JkZXJCeSBvZiBxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5KHF1ZXJ5KSkge1xuICAgICAgICAvLyBvcmRlci1ieSBrZXkgYWx3YXlzIG1hdGNoZXNcbiAgICAgICAgaWYgKCFvcmRlckJ5LmZpZWxkLmlzS2V5RmllbGQoKSAmJiBkb2MuZGF0YS5maWVsZChvcmRlckJ5LmZpZWxkKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcXVlcnlNYXRjaGVzRmlsdGVycyhxdWVyeSwgZG9jKSB7XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgcXVlcnkuZmlsdGVycykge1xuICAgICAgICBpZiAoIWZpbHRlci5tYXRjaGVzKGRvYykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKiBNYWtlcyBzdXJlIGEgZG9jdW1lbnQgaXMgd2l0aGluIHRoZSBib3VuZHMsIGlmIHByb3ZpZGVkLiAqL1xuZnVuY3Rpb24gcXVlcnlNYXRjaGVzQm91bmRzKHF1ZXJ5LCBkb2MpIHtcbiAgICBpZiAocXVlcnkuc3RhcnRBdCAmJlxuICAgICAgICAhYm91bmRTb3J0c0JlZm9yZURvY3VtZW50KHF1ZXJ5LnN0YXJ0QXQsIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpLCBkb2MpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmVuZEF0ICYmXG4gICAgICAgICFib3VuZFNvcnRzQWZ0ZXJEb2N1bWVudChxdWVyeS5lbmRBdCwgcXVlcnlOb3JtYWxpemVkT3JkZXJCeShxdWVyeSksIGRvYykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY29sbGVjdGlvbiBncm91cCB0aGF0IHRoaXMgcXVlcnkgdGFyZ2V0cy5cbiAqXG4gKiBQT1JUSU5HIE5PVEU6IFRoaXMgaXMgb25seSB1c2VkIGluIHRoZSBXZWIgU0RLIHRvIGZhY2lsaXRhdGUgbXVsdGktdGFiXG4gKiBzeW5jaHJvbml6YXRpb24gZm9yIHF1ZXJ5IHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5Q29sbGVjdGlvbkdyb3VwKHF1ZXJ5KSB7XG4gICAgcmV0dXJuIChxdWVyeS5jb2xsZWN0aW9uR3JvdXAgfHxcbiAgICAgICAgKHF1ZXJ5LnBhdGgubGVuZ3RoICUgMiA9PT0gMVxuICAgICAgICAgICAgPyBxdWVyeS5wYXRoLmxhc3RTZWdtZW50KClcbiAgICAgICAgICAgIDogcXVlcnkucGF0aC5nZXQocXVlcnkucGF0aC5sZW5ndGggLSAyKSkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjb21wYXJlIHR3byBkb2N1bWVudHNcbiAqIGJhc2VkIG9uIHRoZSBRdWVyeSdzIG9yZGVyaW5nIGNvbnN0cmFpbnQuXG4gKi9cbmZ1bmN0aW9uIG5ld1F1ZXJ5Q29tcGFyYXRvcihxdWVyeSkge1xuICAgIHJldHVybiAoZDEsIGQyKSA9PiB7XG4gICAgICAgIGxldCBjb21wYXJlZE9uS2V5RmllbGQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wID0gY29tcGFyZURvY3Mob3JkZXJCeSwgZDEsIGQyKTtcbiAgICAgICAgICAgIGlmIChjb21wICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wYXJlZE9uS2V5RmllbGQgPSBjb21wYXJlZE9uS2V5RmllbGQgfHwgb3JkZXJCeS5maWVsZC5pc0tleUZpZWxkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVEb2NzKG9yZGVyQnksIGQxLCBkMikge1xuICAgIGNvbnN0IGNvbXBhcmlzb24gPSBvcmRlckJ5LmZpZWxkLmlzS2V5RmllbGQoKVxuICAgICAgICA/IERvY3VtZW50S2V5LmNvbXBhcmF0b3IoZDEua2V5LCBkMi5rZXkpXG4gICAgICAgIDogY29tcGFyZURvY3VtZW50c0J5RmllbGQob3JkZXJCeS5maWVsZCwgZDEsIGQyKTtcbiAgICBzd2l0Y2ggKG9yZGVyQnkuZGlyKSB7XG4gICAgICAgIGNhc2UgXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovOlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb247XG4gICAgICAgIGNhc2UgXCJkZXNjXCIgLyogRGlyZWN0aW9uLkRFU0NFTkRJTkcgKi86XG4gICAgICAgICAgICByZXR1cm4gLTEgKiBjb21wYXJpc29uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoMHg0ZDRlLCB7IGRpcmVjdGlvbjogb3JkZXJCeS5kaXIgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIG1hcCBpbXBsZW1lbnRhdGlvbiB0aGF0IHVzZXMgb2JqZWN0cyBhcyBrZXlzLiBPYmplY3RzIG11c3QgaGF2ZSBhblxuICogYXNzb2NpYXRlZCBlcXVhbHMgZnVuY3Rpb24gYW5kIG11c3QgYmUgaW1tdXRhYmxlLiBFbnRyaWVzIGluIHRoZSBtYXAgYXJlXG4gKiBzdG9yZWQgdG9nZXRoZXIgd2l0aCB0aGUga2V5IGJlaW5nIHByb2R1Y2VkIGZyb20gdGhlIG1hcEtleUZuLiBUaGlzIG1hcFxuICogYXV0b21hdGljYWxseSBoYW5kbGVzIGNvbGxpc2lvbnMgb2Yga2V5cy5cbiAqL1xuY2xhc3MgT2JqZWN0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihtYXBLZXlGbiwgZXF1YWxzRm4pIHtcbiAgICAgICAgdGhpcy5tYXBLZXlGbiA9IG1hcEtleUZuO1xuICAgICAgICB0aGlzLmVxdWFsc0ZuID0gZXF1YWxzRm47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5uZXIgbWFwIGZvciBhIGtleS92YWx1ZSBwYWlyLiBEdWUgdG8gdGhlIHBvc3NpYmlsaXR5IG9mIGNvbGxpc2lvbnMgd2VcbiAgICAgICAgICoga2VlcCBhIGxpc3Qgb2YgZW50cmllcyB0aGF0IHdlIGRvIGEgbGluZWFyIHNlYXJjaCB0aHJvdWdoIHRvIGZpbmQgYW4gYWN0dWFsXG4gICAgICAgICAqIG1hdGNoLiBOb3RlIHRoYXQgY29sbGlzaW9ucyBzaG91bGQgYmUgcmFyZSwgc28gd2Ugc3RpbGwgZXhwZWN0IG5lYXJcbiAgICAgICAgICogY29uc3RhbnQgdGltZSBsb29rdXBzIGluIHByYWN0aWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbm5lciA9IHt9O1xuICAgICAgICAvKiogVGhlIG51bWJlciBvZiBlbnRyaWVzIHN0b3JlZCBpbiB0aGUgbWFwICovXG4gICAgICAgIHRoaXMuaW5uZXJTaXplID0gMDtcbiAgICB9XG4gICAgLyoqIEdldCBhIHZhbHVlIGZvciB0aGlzIGtleSwgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXMgbm90IGV4aXN0LiAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLm1hcEtleUZuKGtleSk7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLmlubmVyW2lkXTtcbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtvdGhlcktleSwgdmFsdWVdIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0ZuKG90aGVyS2V5LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSkgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqIFB1dCB0aGlzIGtleSBhbmQgdmFsdWUgaW4gdGhlIG1hcC4gKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMubWFwS2V5Rm4oa2V5KTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuaW5uZXJbaWRdO1xuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyW2lkXSA9IFtba2V5LCB2YWx1ZV1dO1xuICAgICAgICAgICAgdGhpcy5pbm5lclNpemUrKztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0ZuKG1hdGNoZXNbaV1bMF0sIGtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHVwZGF0aW5nIGFuIGV4aXN0aW5nIGVudHJ5IGFuZCBkb2VzIG5vdCBpbmNyZWFzZSBgaW5uZXJTaXplYC5cbiAgICAgICAgICAgICAgICBtYXRjaGVzW2ldID0gW2tleSwgdmFsdWVdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXRjaGVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgdGhpcy5pbm5lclNpemUrKztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoaXMga2V5IGZyb20gdGhlIG1hcC4gUmV0dXJucyBhIGJvb2xlYW4gaWYgYW55dGhpbmcgd2FzIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMubWFwS2V5Rm4oa2V5KTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuaW5uZXJbaWRdO1xuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHNGbihtYXRjaGVzW2ldWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmlubmVyW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyU2l6ZS0tO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yRWFjaChmbikge1xuICAgICAgICBmb3JFYWNoKHRoaXMuaW5uZXIsIChfLCBlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgZm4oaywgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gaXNFbXB0eSh0aGlzLmlubmVyKTtcbiAgICB9XG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXJTaXplO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IEVNUFRZX01VVEFCTEVfRE9DVU1FTlRfTUFQID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbmZ1bmN0aW9uIG11dGFibGVEb2N1bWVudE1hcCgpIHtcbiAgICByZXR1cm4gRU1QVFlfTVVUQUJMRV9ET0NVTUVOVF9NQVA7XG59XG5jb25zdCBFTVBUWV9ET0NVTUVOVF9NQVAgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xuZnVuY3Rpb24gZG9jdW1lbnRNYXAoLi4uZG9jcykge1xuICAgIGxldCBtYXAgPSBFTVBUWV9ET0NVTUVOVF9NQVA7XG4gICAgZm9yIChjb25zdCBkb2Mgb2YgZG9jcykge1xuICAgICAgICBtYXAgPSBtYXAuaW5zZXJ0KGRvYy5rZXksIGRvYyk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG5mdW5jdGlvbiBuZXdPdmVybGF5ZWREb2N1bWVudE1hcCgpIHtcbiAgICByZXR1cm4gbmV3RG9jdW1lbnRLZXlNYXAoKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRPdmVybGF5ZWREb2N1bWVudE1hcFRvRG9jdW1lbnRNYXAoY29sbGVjdGlvbikge1xuICAgIGxldCBkb2N1bWVudHMgPSBFTVBUWV9ET0NVTUVOVF9NQVA7XG4gICAgY29sbGVjdGlvbi5mb3JFYWNoKChrLCB2KSA9PiAoZG9jdW1lbnRzID0gZG9jdW1lbnRzLmluc2VydChrLCB2Lm92ZXJsYXllZERvY3VtZW50KSkpO1xuICAgIHJldHVybiBkb2N1bWVudHM7XG59XG5mdW5jdGlvbiBuZXdPdmVybGF5TWFwKCkge1xuICAgIHJldHVybiBuZXdEb2N1bWVudEtleU1hcCgpO1xufVxuZnVuY3Rpb24gbmV3TXV0YXRpb25NYXAoKSB7XG4gICAgcmV0dXJuIG5ld0RvY3VtZW50S2V5TWFwKCk7XG59XG5mdW5jdGlvbiBuZXdEb2N1bWVudEtleU1hcCgpIHtcbiAgICByZXR1cm4gbmV3IE9iamVjdE1hcChrZXkgPT4ga2V5LnRvU3RyaW5nKCksIChsLCByKSA9PiBsLmlzRXF1YWwocikpO1xufVxuY29uc3QgRU1QVFlfRE9DVU1FTlRfVkVSU0lPTl9NQVAgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xuZnVuY3Rpb24gZG9jdW1lbnRWZXJzaW9uTWFwKCkge1xuICAgIHJldHVybiBFTVBUWV9ET0NVTUVOVF9WRVJTSU9OX01BUDtcbn1cbmNvbnN0IEVNUFRZX0RPQ1VNRU5UX0tFWV9TRVQgPSBuZXcgU29ydGVkU2V0KERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xuZnVuY3Rpb24gZG9jdW1lbnRLZXlTZXQoLi4ua2V5cykge1xuICAgIGxldCBzZXQgPSBFTVBUWV9ET0NVTUVOVF9LRVlfU0VUO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgc2V0ID0gc2V0LmFkZChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0O1xufVxuY29uc3QgRU1QVFlfVEFSR0VUX0lEX1NFVCA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XG5mdW5jdGlvbiB0YXJnZXRJZFNldCgpIHtcbiAgICByZXR1cm4gRU1QVFlfVEFSR0VUX0lEX1NFVDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyBhbiBEb3VibGVWYWx1ZSBmb3IgYHZhbHVlYCB0aGF0IGlzIGVuY29kZWQgYmFzZWQgdGhlIHNlcmlhbGl6ZXInc1xuICogYHVzZVByb3RvM0pzb25gIHNldHRpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvRG91YmxlKHNlcmlhbGl6ZXIsIHZhbHVlKSB7XG4gICAgaWYgKHNlcmlhbGl6ZXIudXNlUHJvdG8zSnNvbikge1xuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb3VibGVWYWx1ZTogJ05hTicgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiAnSW5maW5pdHknIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6ICctSW5maW5pdHknIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6IGlzTmVnYXRpdmVaZXJvKHZhbHVlKSA/ICctMCcgOiB2YWx1ZSB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIEludGVnZXJWYWx1ZSBmb3IgYHZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHsgaW50ZWdlclZhbHVlOiAnJyArIHZhbHVlIH07XG59XG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSBmb3IgYSBudW1iZXIgdGhhdCdzIGFwcHJvcHJpYXRlIHRvIHB1dCBpbnRvIGEgcHJvdG8uXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIEludGVnZXJWYWx1ZSBpZiBpdCBjYW4gc2FmZWx5IHJlcHJlc2VudCB0aGUgdmFsdWUsXG4gKiBvdGhlcndpc2UgYSBEb3VibGVWYWx1ZSBpcyByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIoc2VyaWFsaXplciwgdmFsdWUpIHtcbiAgICByZXR1cm4gaXNTYWZlSW50ZWdlcih2YWx1ZSkgPyB0b0ludGVnZXIodmFsdWUpIDogdG9Eb3VibGUoc2VyaWFsaXplciwgdmFsdWUpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIFVzZWQgdG8gcmVwcmVzZW50IGEgZmllbGQgdHJhbnNmb3JtIG9uIGEgbXV0YXRpb24uICovXG5jbGFzcyBUcmFuc2Zvcm1PcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgc3RydWN0dXJhbCB0eXBlIG9mIGBUcmFuc2Zvcm1PcGVyYXRpb25gIGlzIHVuaXF1ZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNTQ1MVxuICAgICAgICB0aGlzLl8gPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgbG9jYWwgdHJhbnNmb3JtIHJlc3VsdCBhZ2FpbnN0IHRoZSBwcm92aWRlZCBgcHJldmlvdXNWYWx1ZWAsXG4gKiBvcHRpb25hbGx5IHVzaW5nIHRoZSBwcm92aWRlZCBsb2NhbFdyaXRlVGltZS5cbiAqL1xuZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm1PcGVyYXRpb25Ub0xvY2FsVmlldyh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUsIGxvY2FsV3JpdGVUaW1lKSB7XG4gICAgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gc2VydmVyVGltZXN0YW1wJDEobG9jYWxXcml0ZVRpbWUsIHByZXZpb3VzVmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBhcHBseUFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5QXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhcHBseU51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb25Ub0xvY2FsVmlldyh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogQ29tcHV0ZXMgYSBmaW5hbCB0cmFuc2Zvcm0gcmVzdWx0IGFmdGVyIHRoZSB0cmFuc2Zvcm0gaGFzIGJlZW4gYWNrbm93bGVkZ2VkXG4gKiBieSB0aGUgc2VydmVyLCBwb3RlbnRpYWxseSB1c2luZyB0aGUgc2VydmVyLXByb3ZpZGVkIHRyYW5zZm9ybVJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm1PcGVyYXRpb25Ub1JlbW90ZURvY3VtZW50KHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSwgdHJhbnNmb3JtUmVzdWx0KSB7XG4gICAgLy8gVGhlIHNlcnZlciBqdXN0IHNlbmRzIG51bGwgYXMgdGhlIHRyYW5zZm9ybSByZXN1bHQgZm9yIGFycmF5IG9wZXJhdGlvbnMsXG4gICAgLy8gc28gd2UgaGF2ZSB0byBjYWxjdWxhdGUgYSByZXN1bHQgdGhlIHNhbWUgYXMgd2UgZG8gZm9yIGxvY2FsXG4gICAgLy8gYXBwbGljYXRpb25zLlxuICAgIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBhcHBseUFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5QXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybVJlc3VsdDtcbn1cbi8qKlxuICogSWYgdGhpcyB0cmFuc2Zvcm0gb3BlcmF0aW9uIGlzIG5vdCBpZGVtcG90ZW50LCByZXR1cm5zIHRoZSBiYXNlIHZhbHVlIHRvXG4gKiBwZXJzaXN0IGZvciB0aGlzIHRyYW5zZm9ybS4gSWYgYSBiYXNlIHZhbHVlIGlzIHJldHVybmVkLCB0aGUgdHJhbnNmb3JtXG4gKiBvcGVyYXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgdG8gdGhpcyBiYXNlIHZhbHVlLCBldmVuIGlmIGRvY3VtZW50IGhhc1xuICogYWxyZWFkeSBiZWVuIHVwZGF0ZWQuXG4gKlxuICogQmFzZSB2YWx1ZXMgcHJvdmlkZSBjb25zaXN0ZW50IGJlaGF2aW9yIGZvciBub24taWRlbXBvdGVudCB0cmFuc2Zvcm1zIGFuZFxuICogYWxsb3cgdXMgdG8gcmV0dXJuIHRoZSBzYW1lIGxhdGVuY3ktY29tcGVuc2F0ZWQgdmFsdWUgZXZlbiBpZiB0aGUgYmFja2VuZFxuICogaGFzIGFscmVhZHkgYXBwbGllZCB0aGUgdHJhbnNmb3JtIG9wZXJhdGlvbi4gVGhlIGJhc2UgdmFsdWUgaXMgbnVsbCBmb3JcbiAqIGlkZW1wb3RlbnQgdHJhbnNmb3JtcywgYXMgdGhleSBjYW4gYmUgcmUtcGxheWVkIGV2ZW4gaWYgdGhlIGJhY2tlbmQgaGFzXG4gKiBhbHJlYWR5IGFwcGxpZWQgdGhlbS5cbiAqXG4gKiBAcmV0dXJucyBhIGJhc2UgdmFsdWUgdG8gc3RvcmUgYWxvbmcgd2l0aCB0aGUgbXV0YXRpb24sIG9yIG51bGwgZm9yXG4gKiBpZGVtcG90ZW50IHRyYW5zZm9ybXMuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVUcmFuc2Zvcm1PcGVyYXRpb25CYXNlVmFsdWUodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKSB7XG4gICAgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIE51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGlzTnVtYmVyKHByZXZpb3VzVmFsdWUpID8gcHJldmlvdXNWYWx1ZSA6IHsgaW50ZWdlclZhbHVlOiAwIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtT3BlcmF0aW9uRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uICYmXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gYXJyYXlFcXVhbHMobGVmdC5lbGVtZW50cywgcmlnaHQuZWxlbWVudHMsIHZhbHVlRXF1YWxzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVmdCBpbnN0YW5jZW9mIEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uICYmXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKGxlZnQuZWxlbWVudHMsIHJpZ2h0LmVsZW1lbnRzLCB2YWx1ZUVxdWFscyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlZnQgaW5zdGFuY2VvZiBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uICYmXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gdmFsdWVFcXVhbHMobGVmdC5vcGVyYW5kLCByaWdodC5vcGVyYW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIChsZWZ0IGluc3RhbmNlb2YgU2VydmVyVGltZXN0YW1wVHJhbnNmb3JtICYmXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgU2VydmVyVGltZXN0YW1wVHJhbnNmb3JtKTtcbn1cbi8qKiBUcmFuc2Zvcm1zIGEgdmFsdWUgaW50byBhIHNlcnZlci1nZW5lcmF0ZWQgdGltZXN0YW1wLiAqL1xuY2xhc3MgU2VydmVyVGltZXN0YW1wVHJhbnNmb3JtIGV4dGVuZHMgVHJhbnNmb3JtT3BlcmF0aW9uIHtcbn1cbi8qKiBUcmFuc2Zvcm1zIGFuIGFycmF5IHZhbHVlIHZpYSBhIHVuaW9uIG9wZXJhdGlvbi4gKi9cbmNsYXNzIEFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24gZXh0ZW5kcyBUcmFuc2Zvcm1PcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseUFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWVzID0gY29lcmNlZEZpZWxkVmFsdWVzQXJyYXkocHJldmlvdXNWYWx1ZSk7XG4gICAgZm9yIChjb25zdCB0b1VuaW9uIG9mIHRyYW5zZm9ybS5lbGVtZW50cykge1xuICAgICAgICBpZiAoIXZhbHVlcy5zb21lKGVsZW1lbnQgPT4gdmFsdWVFcXVhbHMoZWxlbWVudCwgdG9VbmlvbikpKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0b1VuaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBhcnJheVZhbHVlOiB7IHZhbHVlcyB9IH07XG59XG4vKiogVHJhbnNmb3JtcyBhbiBhcnJheSB2YWx1ZSB2aWEgYSByZW1vdmUgb3BlcmF0aW9uLiAqL1xuY2xhc3MgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24gZXh0ZW5kcyBUcmFuc2Zvcm1PcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseUFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSkge1xuICAgIGxldCB2YWx1ZXMgPSBjb2VyY2VkRmllbGRWYWx1ZXNBcnJheShwcmV2aW91c1ZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IHRvUmVtb3ZlIG9mIHRyYW5zZm9ybS5lbGVtZW50cykge1xuICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKGVsZW1lbnQgPT4gIXZhbHVlRXF1YWxzKGVsZW1lbnQsIHRvUmVtb3ZlKSk7XG4gICAgfVxuICAgIHJldHVybiB7IGFycmF5VmFsdWU6IHsgdmFsdWVzIH0gfTtcbn1cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgYmFja2VuZCBzZW1hbnRpY3MgZm9yIGxvY2FsbHkgY29tcHV0ZWQgTlVNRVJJQ19BREQgKGluY3JlbWVudClcbiAqIHRyYW5zZm9ybXMuIENvbnZlcnRzIGFsbCBmaWVsZCB2YWx1ZXMgdG8gaW50ZWdlcnMgb3IgZG91YmxlcywgYnV0IHVubGlrZSB0aGVcbiAqIGJhY2tlbmQgZG9lcyBub3QgY2FwIGludGVnZXIgdmFsdWVzIGF0IDJeNjMuIEluc3RlYWQsIEphdmFTY3JpcHQgbnVtYmVyXG4gKiBhcml0aG1ldGljIGlzIHVzZWQgYW5kIHByZWNpc2lvbiBsb3NzIGNhbiBvY2N1ciBmb3IgdmFsdWVzIGdyZWF0ZXIgdGhhbiAyXjUzLlxuICovXG5jbGFzcyBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uIGV4dGVuZHMgVHJhbnNmb3JtT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyLCBvcGVyYW5kKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgICAgIHRoaXMub3BlcmFuZCA9IG9wZXJhbmQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uVG9Mb2NhbFZpZXcodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKSB7XG4gICAgLy8gUE9SVElORyBOT1RFOiBTaW5jZSBKYXZhU2NyaXB0J3MgaW50ZWdlciBhcml0aG1ldGljIGlzIGxpbWl0ZWQgdG8gNTMgYml0XG4gICAgLy8gcHJlY2lzaW9uIGFuZCByZXNvbHZlcyBvdmVyZmxvd3MgYnkgcmVkdWNpbmcgcHJlY2lzaW9uLCB3ZSBkbyBub3RcbiAgICAvLyBtYW51YWxseSBjYXAgb3ZlcmZsb3dzIGF0IDJeNjMuXG4gICAgY29uc3QgYmFzZVZhbHVlID0gY29tcHV0ZVRyYW5zZm9ybU9wZXJhdGlvbkJhc2VWYWx1ZSh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpO1xuICAgIGNvbnN0IHN1bSA9IGFzTnVtYmVyKGJhc2VWYWx1ZSkgKyBhc051bWJlcih0cmFuc2Zvcm0ub3BlcmFuZCk7XG4gICAgaWYgKGlzSW50ZWdlcihiYXNlVmFsdWUpICYmIGlzSW50ZWdlcih0cmFuc2Zvcm0ub3BlcmFuZCkpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50ZWdlcihzdW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRvRG91YmxlKHRyYW5zZm9ybS5zZXJpYWxpemVyLCBzdW0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5pbnRlZ2VyVmFsdWUgfHwgdmFsdWUuZG91YmxlVmFsdWUpO1xufVxuZnVuY3Rpb24gY29lcmNlZEZpZWxkVmFsdWVzQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuYXJyYXlWYWx1ZS52YWx1ZXNcbiAgICAgICAgPyB2YWx1ZS5hcnJheVZhbHVlLnZhbHVlcy5zbGljZSgpXG4gICAgICAgIDogW107XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogQSBmaWVsZCBwYXRoIGFuZCB0aGUgVHJhbnNmb3JtT3BlcmF0aW9uIHRvIHBlcmZvcm0gdXBvbiBpdC4gKi9cbmNsYXNzIEZpZWxkVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgfVxufVxuZnVuY3Rpb24gZmllbGRUcmFuc2Zvcm1FcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gKGxlZnQuZmllbGQuaXNFcXVhbChyaWdodC5maWVsZCkgJiZcbiAgICAgICAgdHJhbnNmb3JtT3BlcmF0aW9uRXF1YWxzKGxlZnQudHJhbnNmb3JtLCByaWdodC50cmFuc2Zvcm0pKTtcbn1cbmZ1bmN0aW9uIGZpZWxkVHJhbnNmb3Jtc0FyZUVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPT09IHVuZGVmaW5lZCAmJiByaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobGVmdCAmJiByaWdodCkge1xuICAgICAgICByZXR1cm4gYXJyYXlFcXVhbHMobGVmdCwgcmlnaHQsIChsLCByKSA9PiBmaWVsZFRyYW5zZm9ybUVxdWFscyhsLCByKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKiBUaGUgcmVzdWx0IG9mIHN1Y2Nlc3NmdWxseSBhcHBseWluZyBhIG11dGF0aW9uIHRvIHRoZSBiYWNrZW5kLiAqL1xuY2xhc3MgTXV0YXRpb25SZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJzaW9uIGF0IHdoaWNoIHRoZSBtdXRhdGlvbiB3YXMgY29tbWl0dGVkOlxuICAgICAqXG4gICAgICogLSBGb3IgbW9zdCBvcGVyYXRpb25zLCB0aGlzIGlzIHRoZSB1cGRhdGVUaW1lIGluIHRoZSBXcml0ZVJlc3VsdC5cbiAgICAgKiAtIEZvciBkZWxldGVzLCB0aGUgY29tbWl0VGltZSBvZiB0aGUgV3JpdGVSZXNwb25zZSAoYmVjYXVzZSBkZWxldGVzIGFyZVxuICAgICAqICAgbm90IHN0b3JlZCBhbmQgaGF2ZSBubyB1cGRhdGVUaW1lKS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGVzZSB2ZXJzaW9ucyBjYW4gYmUgZGlmZmVyZW50OiBOby1vcCB3cml0ZXMgd2lsbCBub3QgY2hhbmdlXG4gICAgICogdGhlIHVwZGF0ZVRpbWUgZXZlbiB0aG91Z2ggdGhlIGNvbW1pdFRpbWUgYWR2YW5jZXMuXG4gICAgICovXG4gICAgdmVyc2lvbiwgXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdGluZyBmaWVsZHMgcmV0dXJuZWQgZnJvbSB0aGUgYmFja2VuZCBhZnRlciBhIG11dGF0aW9uXG4gICAgICogY29udGFpbmluZyBmaWVsZCB0cmFuc2Zvcm1zIGhhcyBiZWVuIGNvbW1pdHRlZC4gQ29udGFpbnMgb25lIEZpZWxkVmFsdWVcbiAgICAgKiBmb3IgZWFjaCBGaWVsZFRyYW5zZm9ybSB0aGF0IHdhcyBpbiB0aGUgbXV0YXRpb24uXG4gICAgICpcbiAgICAgKiBXaWxsIGJlIGVtcHR5IGlmIHRoZSBtdXRhdGlvbiBkaWQgbm90IGNvbnRhaW4gYW55IGZpZWxkIHRyYW5zZm9ybXMuXG4gICAgICovXG4gICAgdHJhbnNmb3JtUmVzdWx0cykge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVJlc3VsdHMgPSB0cmFuc2Zvcm1SZXN1bHRzO1xuICAgIH1cbn1cbi8qKlxuICogRW5jb2RlcyBhIHByZWNvbmRpdGlvbiBmb3IgYSBtdXRhdGlvbi4gVGhpcyBmb2xsb3dzIHRoZSBtb2RlbCB0aGF0IHRoZVxuICogYmFja2VuZCBhY2NlcHRzIHdpdGggdGhlIHNwZWNpYWwgY2FzZSBvZiBhbiBleHBsaWNpdCBcImVtcHR5XCIgcHJlY29uZGl0aW9uXG4gKiAobWVhbmluZyBubyBwcmVjb25kaXRpb24pLlxuICovXG5jbGFzcyBQcmVjb25kaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHVwZGF0ZVRpbWUsIGV4aXN0cykge1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWUgPSB1cGRhdGVUaW1lO1xuICAgICAgICB0aGlzLmV4aXN0cyA9IGV4aXN0cztcbiAgICB9XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgZW1wdHkgUHJlY29uZGl0aW9uLiAqL1xuICAgIHN0YXRpYyBub25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByZWNvbmRpdGlvbigpO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBQcmVjb25kaXRpb24gd2l0aCBhbiBleGlzdHMgZmxhZy4gKi9cbiAgICBzdGF0aWMgZXhpc3RzKGV4aXN0cykge1xuICAgICAgICByZXR1cm4gbmV3IFByZWNvbmRpdGlvbih1bmRlZmluZWQsIGV4aXN0cyk7XG4gICAgfVxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IFByZWNvbmRpdGlvbiBiYXNlZCBvbiBhIHZlcnNpb24gYSBkb2N1bWVudCBleGlzdHMgYXQuICovXG4gICAgc3RhdGljIHVwZGF0ZVRpbWUodmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IFByZWNvbmRpdGlvbih2ZXJzaW9uKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgd2hldGhlciB0aGlzIFByZWNvbmRpdGlvbiBpcyBlbXB0eS4gKi9cbiAgICBnZXQgaXNOb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVUaW1lID09PSB1bmRlZmluZWQgJiYgdGhpcy5leGlzdHMgPT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKHRoaXMuZXhpc3RzID09PSBvdGhlci5leGlzdHMgJiZcbiAgICAgICAgICAgICh0aGlzLnVwZGF0ZVRpbWVcbiAgICAgICAgICAgICAgICA/ICEhb3RoZXIudXBkYXRlVGltZSAmJiB0aGlzLnVwZGF0ZVRpbWUuaXNFcXVhbChvdGhlci51cGRhdGVUaW1lKVxuICAgICAgICAgICAgICAgIDogIW90aGVyLnVwZGF0ZVRpbWUpKTtcbiAgICB9XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBwcmVjb25kaXRpb25zIGlzIHZhbGlkIGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQuICovXG5mdW5jdGlvbiBwcmVjb25kaXRpb25Jc1ZhbGlkRm9yRG9jdW1lbnQocHJlY29uZGl0aW9uLCBkb2N1bWVudCkge1xuICAgIGlmIChwcmVjb25kaXRpb24udXBkYXRlVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAoZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkgJiZcbiAgICAgICAgICAgIGRvY3VtZW50LnZlcnNpb24uaXNFcXVhbChwcmVjb25kaXRpb24udXBkYXRlVGltZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcmVjb25kaXRpb24uZXhpc3RzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHByZWNvbmRpdGlvbi5leGlzdHMgPT09IGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLyoqXG4gKiBBIG11dGF0aW9uIGRlc2NyaWJlcyBhIHNlbGYtY29udGFpbmVkIGNoYW5nZSB0byBhIGRvY3VtZW50LiBNdXRhdGlvbnMgY2FuXG4gKiBjcmVhdGUsIHJlcGxhY2UsIGRlbGV0ZSwgYW5kIHVwZGF0ZSBzdWJzZXRzIG9mIGRvY3VtZW50cy5cbiAqXG4gKiBNdXRhdGlvbnMgbm90IG9ubHkgYWN0IG9uIHRoZSB2YWx1ZSBvZiB0aGUgZG9jdW1lbnQgYnV0IGFsc28gaXRzIHZlcnNpb24uXG4gKlxuICogRm9yIGxvY2FsIG11dGF0aW9ucyAobXV0YXRpb25zIHRoYXQgaGF2ZW4ndCBiZWVuIGNvbW1pdHRlZCB5ZXQpLCB3ZSBwcmVzZXJ2ZVxuICogdGhlIGV4aXN0aW5nIHZlcnNpb24gZm9yIFNldCBhbmQgUGF0Y2ggbXV0YXRpb25zLiBGb3IgRGVsZXRlIG11dGF0aW9ucywgd2VcbiAqIHJlc2V0IHRoZSB2ZXJzaW9uIHRvIDAuXG4gKlxuICogSGVyZSdzIHRoZSBleHBlY3RlZCB0cmFuc2l0aW9uIHRhYmxlLlxuICpcbiAqIE1VVEFUSU9OICAgICAgICAgICBBUFBMSUVEIFRPICAgICAgICAgICAgUkVTVUxUUyBJTlxuICpcbiAqIFNldE11dGF0aW9uICAgICAgICBEb2N1bWVudCh2MykgICAgICAgICAgRG9jdW1lbnQodjMpXG4gKiBTZXRNdXRhdGlvbiAgICAgICAgTm9Eb2N1bWVudCh2MykgICAgICAgIERvY3VtZW50KHYwKVxuICogU2V0TXV0YXRpb24gICAgICAgIEludmFsaWREb2N1bWVudCh2MCkgICBEb2N1bWVudCh2MClcbiAqIFBhdGNoTXV0YXRpb24gICAgICBEb2N1bWVudCh2MykgICAgICAgICAgRG9jdW1lbnQodjMpXG4gKiBQYXRjaE11dGF0aW9uICAgICAgTm9Eb2N1bWVudCh2MykgICAgICAgIE5vRG9jdW1lbnQodjMpXG4gKiBQYXRjaE11dGF0aW9uICAgICAgSW52YWxpZERvY3VtZW50KHYwKSAgIFVua25vd25Eb2N1bWVudCh2MylcbiAqIERlbGV0ZU11dGF0aW9uICAgICBEb2N1bWVudCh2MykgICAgICAgICAgTm9Eb2N1bWVudCh2MClcbiAqIERlbGV0ZU11dGF0aW9uICAgICBOb0RvY3VtZW50KHYzKSAgICAgICAgTm9Eb2N1bWVudCh2MClcbiAqIERlbGV0ZU11dGF0aW9uICAgICBJbnZhbGlkRG9jdW1lbnQodjApICAgTm9Eb2N1bWVudCh2MClcbiAqXG4gKiBGb3IgYWNrbm93bGVkZ2VkIG11dGF0aW9ucywgd2UgdXNlIHRoZSB1cGRhdGVUaW1lIG9mIHRoZSBXcml0ZVJlc3BvbnNlIGFzXG4gKiB0aGUgcmVzdWx0aW5nIHZlcnNpb24gZm9yIFNldCBhbmQgUGF0Y2ggbXV0YXRpb25zLiBBcyBkZWxldGVzIGhhdmUgbm9cbiAqIGV4cGxpY2l0IHVwZGF0ZSB0aW1lLCB3ZSB1c2UgdGhlIGNvbW1pdFRpbWUgb2YgdGhlIFdyaXRlUmVzcG9uc2UgZm9yXG4gKiBEZWxldGUgbXV0YXRpb25zLlxuICpcbiAqIElmIGEgbXV0YXRpb24gaXMgYWNrbm93bGVkZ2VkIGJ5IHRoZSBiYWNrZW5kIGJ1dCBmYWlscyB0aGUgcHJlY29uZGl0aW9uIGNoZWNrXG4gKiBsb2NhbGx5LCB3ZSB0cmFuc2l0aW9uIHRvIGFuIGBVbmtub3duRG9jdW1lbnRgIGFuZCByZWx5IG9uIFdhdGNoIHRvIHNlbmQgdXNcbiAqIHRoZSB1cGRhdGVkIHZlcnNpb24uXG4gKlxuICogRmllbGQgdHJhbnNmb3JtcyBhcmUgdXNlZCBvbmx5IHdpdGggUGF0Y2ggYW5kIFNldCBNdXRhdGlvbnMuIFdlIHVzZSB0aGVcbiAqIGB1cGRhdGVUcmFuc2Zvcm1zYCBtZXNzYWdlIHRvIHN0b3JlIHRyYW5zZm9ybXMsIHJhdGhlciB0aGFuIHRoZSBgdHJhbnNmb3Jtc2BzXG4gKiBtZXNzYWdlcy5cbiAqXG4gKiAjIyBTdWJjbGFzc2luZyBOb3Rlc1xuICpcbiAqIEV2ZXJ5IHR5cGUgb2YgbXV0YXRpb24gbmVlZHMgdG8gaW1wbGVtZW50IGl0cyBvd24gYXBwbHlUb1JlbW90ZURvY3VtZW50KCkgYW5kXG4gKiBhcHBseVRvTG9jYWxWaWV3KCkgdG8gaW1wbGVtZW50IHRoZSBhY3R1YWwgYmVoYXZpb3Igb2YgYXBwbHlpbmcgdGhlIG11dGF0aW9uXG4gKiB0byBzb21lIHNvdXJjZSBkb2N1bWVudCAoc2VlIGBzZXRNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudCgpYCBmb3IgYW5cbiAqIGV4YW1wbGUpLlxuICovXG5jbGFzcyBNdXRhdGlvbiB7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBtZXRob2QgdG8gY2FsY3VsYXRlIGEgYE11dGF0aW9uYCByZXByZXNlbnRpbmcgdGhlIG92ZXJsYXkgZnJvbSB0aGVcbiAqIGZpbmFsIHN0YXRlIG9mIHRoZSBkb2N1bWVudCwgYW5kIGEgYEZpZWxkTWFza2AgcmVwcmVzZW50aW5nIHRoZSBmaWVsZHMgdGhhdFxuICogYXJlIG11dGF0ZWQgYnkgdGhlIGxvY2FsIG11dGF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlT3ZlcmxheU11dGF0aW9uKGRvYywgbWFzaykge1xuICAgIGlmICghZG9jLmhhc0xvY2FsTXV0YXRpb25zIHx8IChtYXNrICYmIG1hc2suZmllbGRzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIG1hc2sgaXMgbnVsbCB3aGVuIHNldHMgb3IgZGVsZXRlcyBhcmUgYXBwbGllZCB0byB0aGUgY3VycmVudCBkb2N1bWVudC5cbiAgICBpZiAobWFzayA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoZG9jLmlzTm9Eb2N1bWVudCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbGV0ZU11dGF0aW9uKGRvYy5rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXRNdXRhdGlvbihkb2Mua2V5LCBkb2MuZGF0YSwgUHJlY29uZGl0aW9uLm5vbmUoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGRvY1ZhbHVlID0gZG9jLmRhdGE7XG4gICAgICAgIGNvbnN0IHBhdGNoVmFsdWUgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xuICAgICAgICBsZXQgbWFza1NldCA9IG5ldyBTb3J0ZWRTZXQoRmllbGRQYXRoJDEuY29tcGFyYXRvcik7XG4gICAgICAgIGZvciAobGV0IHBhdGggb2YgbWFzay5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmICghbWFza1NldC5oYXMocGF0aCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBkb2NWYWx1ZS5maWVsZChwYXRoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZGVsZXRpbmcgYSBuZXN0ZWQgZmllbGQsIHdlIHRha2UgdGhlIGltbWVkaWF0ZSBwYXJlbnQgYXNcbiAgICAgICAgICAgICAgICAvLyB0aGUgbWFzayB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcmVzdWx0aW5nIG11dGF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIEp1c3RpZmljYXRpb246IE5lc3RlZCBmaWVsZHMgY2FuIGNyZWF0ZSBwYXJlbnQgZmllbGRzIGltcGxpY2l0bHkuIElmXG4gICAgICAgICAgICAgICAgLy8gb25seSBhIGxlYWYgZW50cnkgaXMgZGVsZXRlZCBpbiBsYXRlciBtdXRhdGlvbnMsIHRoZSBwYXJlbnQgZmllbGRcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgc3RpbGwgcmVtYWluLCBidXQgd2UgbWF5IGhhdmUgbG9zdCB0aGlzIGluZm9ybWF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIG11dGF0aW9uIChmb28uYmFyIDEpLCB0aGVuIG11dGF0aW9uIChmb28uYmFyIGRlbGV0ZSgpKS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGxlYXZlcyB0aGUgZmluYWwgcmVzdWx0IChmb28sIHt9KS4gRGVzcGl0ZSB0aGUgZmFjdCB0aGF0IGBkb2NgXG4gICAgICAgICAgICAgICAgLy8gaGFzIHRoZSBjb3JyZWN0IHJlc3VsdCwgYGZvb2AgaXMgbm90IGluIGBtYXNrYCwgYW5kIHRoZSByZXN1bHRpbmdcbiAgICAgICAgICAgICAgICAvLyBtdXRhdGlvbiB3b3VsZCBtaXNzIGBmb29gLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHBhdGgucG9wTGFzdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRvY1ZhbHVlLmZpZWxkKHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hWYWx1ZS5kZWxldGUocGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaFZhbHVlLnNldChwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hc2tTZXQgPSBtYXNrU2V0LmFkZChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhdGNoTXV0YXRpb24oZG9jLmtleSwgcGF0Y2hWYWx1ZSwgbmV3IEZpZWxkTWFzayhtYXNrU2V0LnRvQXJyYXkoKSksIFByZWNvbmRpdGlvbi5ub25lKCkpO1xuICAgIH1cbn1cbi8qKlxuICogQXBwbGllcyB0aGlzIG11dGF0aW9uIHRvIHRoZSBnaXZlbiBkb2N1bWVudCBmb3IgdGhlIHB1cnBvc2VzIG9mIGNvbXB1dGluZyBhXG4gKiBuZXcgcmVtb3RlIGRvY3VtZW50LiBJZiB0aGUgaW5wdXQgZG9jdW1lbnQgZG9lc24ndCBtYXRjaCB0aGUgZXhwZWN0ZWQgc3RhdGVcbiAqIChlLmcuIGl0IGlzIGludmFsaWQgb3Igb3V0ZGF0ZWQpLCB0aGUgZG9jdW1lbnQgdHlwZSBtYXkgdHJhbnNpdGlvbiB0b1xuICogdW5rbm93bi5cbiAqXG4gKiBAcGFyYW0gbXV0YXRpb24gLSBUaGUgbXV0YXRpb24gdG8gYXBwbHkuXG4gKiBAcGFyYW0gZG9jdW1lbnQgLSBUaGUgZG9jdW1lbnQgdG8gbXV0YXRlLiBUaGUgaW5wdXQgZG9jdW1lbnQgY2FuIGJlIGFuXG4gKiAgICAgaW52YWxpZCBkb2N1bWVudCBpZiB0aGUgY2xpZW50IGhhcyBubyBrbm93bGVkZ2Ugb2YgdGhlIHByZS1tdXRhdGlvbiBzdGF0ZVxuICogICAgIG9mIHRoZSBkb2N1bWVudC5cbiAqIEBwYXJhbSBtdXRhdGlvblJlc3VsdCAtIFRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIG11dGF0aW9uIGZyb20gdGhlIGJhY2tlbmQuXG4gKi9cbmZ1bmN0aW9uIG11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQpIHtcbiAgICBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBTZXRNdXRhdGlvbikge1xuICAgICAgICBzZXRNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBQYXRjaE11dGF0aW9uKSB7XG4gICAgICAgIHBhdGNoTXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWxldGVNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KTtcbiAgICB9XG59XG4vKipcbiAqIEFwcGxpZXMgdGhpcyBtdXRhdGlvbiB0byB0aGUgZ2l2ZW4gZG9jdW1lbnQgZm9yIHRoZSBwdXJwb3NlcyBvZiBjb21wdXRpbmdcbiAqIHRoZSBuZXcgbG9jYWwgdmlldyBvZiBhIGRvY3VtZW50LiBJZiB0aGUgaW5wdXQgZG9jdW1lbnQgZG9lc24ndCBtYXRjaCB0aGVcbiAqIGV4cGVjdGVkIHN0YXRlLCB0aGUgZG9jdW1lbnQgaXMgbm90IG1vZGlmaWVkLlxuICpcbiAqIEBwYXJhbSBtdXRhdGlvbiAtIFRoZSBtdXRhdGlvbiB0byBhcHBseS5cbiAqIEBwYXJhbSBkb2N1bWVudCAtIFRoZSBkb2N1bWVudCB0byBtdXRhdGUuIFRoZSBpbnB1dCBkb2N1bWVudCBjYW4gYmUgYW5cbiAqICAgICBpbnZhbGlkIGRvY3VtZW50IGlmIHRoZSBjbGllbnQgaGFzIG5vIGtub3dsZWRnZSBvZiB0aGUgcHJlLW11dGF0aW9uIHN0YXRlXG4gKiAgICAgb2YgdGhlIGRvY3VtZW50LlxuICogQHBhcmFtIHByZXZpb3VzTWFzayAtIFRoZSBmaWVsZHMgdGhhdCBoYXZlIGJlZW4gdXBkYXRlZCBiZWZvcmUgYXBwbHlpbmcgdGhpcyBtdXRhdGlvbi5cbiAqIEBwYXJhbSBsb2NhbFdyaXRlVGltZSAtIEEgdGltZXN0YW1wIGluZGljYXRpbmcgdGhlIGxvY2FsIHdyaXRlIHRpbWUgb2YgdGhlXG4gKiAgICAgYmF0Y2ggdGhpcyBtdXRhdGlvbiBpcyBhIHBhcnQgb2YuXG4gKiBAcmV0dXJucyBBIGBGaWVsZE1hc2tgIHJlcHJlc2VudGluZyB0aGUgZmllbGRzIHRoYXQgYXJlIGNoYW5nZWQgYnkgYXBwbHlpbmcgdGhpcyBtdXRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgcHJldmlvdXNNYXNrLCBsb2NhbFdyaXRlVGltZSkge1xuICAgIGlmIChtdXRhdGlvbiBpbnN0YW5jZW9mIFNldE11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBzZXRNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBwcmV2aW91c01hc2ssIGxvY2FsV3JpdGVUaW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBQYXRjaE11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBwYXRjaE11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIHByZXZpb3VzTWFzaywgbG9jYWxXcml0ZVRpbWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZU11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIHByZXZpb3VzTWFzayk7XG4gICAgfVxufVxuLyoqXG4gKiBJZiB0aGlzIG11dGF0aW9uIGlzIG5vdCBpZGVtcG90ZW50LCByZXR1cm5zIHRoZSBiYXNlIHZhbHVlIHRvIHBlcnNpc3Qgd2l0aFxuICogdGhpcyBtdXRhdGlvbi4gSWYgYSBiYXNlIHZhbHVlIGlzIHJldHVybmVkLCB0aGUgbXV0YXRpb24gaXMgYWx3YXlzIGFwcGxpZWRcbiAqIHRvIHRoaXMgYmFzZSB2YWx1ZSwgZXZlbiBpZiBkb2N1bWVudCBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWQuXG4gKlxuICogVGhlIGJhc2UgdmFsdWUgaXMgYSBzcGFyc2Ugb2JqZWN0IHRoYXQgY29uc2lzdHMgb2Ygb25seSB0aGUgZG9jdW1lbnRcbiAqIGZpZWxkcyBmb3Igd2hpY2ggdGhpcyBtdXRhdGlvbiBjb250YWlucyBhIG5vbi1pZGVtcG90ZW50IHRyYW5zZm9ybWF0aW9uXG4gKiAoZS5nLiBhIG51bWVyaWMgaW5jcmVtZW50KS4gVGhlIHByb3ZpZGVkIHZhbHVlIGd1YXJhbnRlZXMgY29uc2lzdGVudFxuICogYmVoYXZpb3IgZm9yIG5vbi1pZGVtcG90ZW50IHRyYW5zZm9ybXMgYW5kIGFsbG93IHVzIHRvIHJldHVybiB0aGUgc2FtZVxuICogbGF0ZW5jeS1jb21wZW5zYXRlZCB2YWx1ZSBldmVuIGlmIHRoZSBiYWNrZW5kIGhhcyBhbHJlYWR5IGFwcGxpZWQgdGhlXG4gKiBtdXRhdGlvbi4gVGhlIGJhc2UgdmFsdWUgaXMgbnVsbCBmb3IgaWRlbXBvdGVudCBtdXRhdGlvbnMsIGFzIHRoZXkgY2FuIGJlXG4gKiByZS1wbGF5ZWQgZXZlbiBpZiB0aGUgYmFja2VuZCBoYXMgYWxyZWFkeSBhcHBsaWVkIHRoZW0uXG4gKlxuICogQHJldHVybnMgYSBiYXNlIHZhbHVlIHRvIHN0b3JlIGFsb25nIHdpdGggdGhlIG11dGF0aW9uLCBvciBudWxsIGZvclxuICogaWRlbXBvdGVudCBtdXRhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG11dGF0aW9uRXh0cmFjdEJhc2VWYWx1ZShtdXRhdGlvbiwgZG9jdW1lbnQpIHtcbiAgICBsZXQgYmFzZU9iamVjdCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBmaWVsZFRyYW5zZm9ybSBvZiBtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZSA9IGRvY3VtZW50LmRhdGEuZmllbGQoZmllbGRUcmFuc2Zvcm0uZmllbGQpO1xuICAgICAgICBjb25zdCBjb2VyY2VkVmFsdWUgPSBjb21wdXRlVHJhbnNmb3JtT3BlcmF0aW9uQmFzZVZhbHVlKGZpZWxkVHJhbnNmb3JtLnRyYW5zZm9ybSwgZXhpc3RpbmdWYWx1ZSB8fCBudWxsKTtcbiAgICAgICAgaWYgKGNvZXJjZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoYmFzZU9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJhc2VPYmplY3QgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFzZU9iamVjdC5zZXQoZmllbGRUcmFuc2Zvcm0uZmllbGQsIGNvZXJjZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2VPYmplY3QgPyBiYXNlT2JqZWN0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIG11dGF0aW9uRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSAhPT0gcmlnaHQudHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghbGVmdC5rZXkuaXNFcXVhbChyaWdodC5rZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFsZWZ0LnByZWNvbmRpdGlvbi5pc0VxdWFsKHJpZ2h0LnByZWNvbmRpdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWZpZWxkVHJhbnNmb3Jtc0FyZUVxdWFsKGxlZnQuZmllbGRUcmFuc2Zvcm1zLCByaWdodC5maWVsZFRyYW5zZm9ybXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gMCAvKiBNdXRhdGlvblR5cGUuU2V0ICovKSB7XG4gICAgICAgIHJldHVybiBsZWZ0LnZhbHVlLmlzRXF1YWwocmlnaHQudmFsdWUpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSAxIC8qIE11dGF0aW9uVHlwZS5QYXRjaCAqLykge1xuICAgICAgICByZXR1cm4gKGxlZnQuZGF0YS5pc0VxdWFsKHJpZ2h0LmRhdGEpICYmXG4gICAgICAgICAgICBsZWZ0LmZpZWxkTWFzay5pc0VxdWFsKHJpZ2h0LmZpZWxkTWFzaykpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQSBtdXRhdGlvbiB0aGF0IGNyZWF0ZXMgb3IgcmVwbGFjZXMgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBrZXkgd2l0aCB0aGVcbiAqIG9iamVjdCB2YWx1ZSBjb250ZW50cy5cbiAqL1xuY2xhc3MgU2V0TXV0YXRpb24gZXh0ZW5kcyBNdXRhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSwgcHJlY29uZGl0aW9uLCBmaWVsZFRyYW5zZm9ybXMgPSBbXSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnByZWNvbmRpdGlvbiA9IHByZWNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXM7XG4gICAgICAgIHRoaXMudHlwZSA9IDAgLyogTXV0YXRpb25UeXBlLlNldCAqLztcbiAgICB9XG4gICAgZ2V0RmllbGRNYXNrKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KSB7XG4gICAgLy8gVW5saWtlIHNldE11dGF0aW9uQXBwbHlUb0xvY2FsVmlldywgaWYgd2UncmUgYXBwbHlpbmcgYSBtdXRhdGlvbiB0byBhXG4gICAgLy8gcmVtb3RlIGRvY3VtZW50IHRoZSBzZXJ2ZXIgaGFzIGFjY2VwdGVkIHRoZSBtdXRhdGlvbiBzbyB0aGUgcHJlY29uZGl0aW9uXG4gICAgLy8gbXVzdCBoYXZlIGhlbGQuXG4gICAgY29uc3QgbmV3RGF0YSA9IG11dGF0aW9uLnZhbHVlLmNsb25lKCk7XG4gICAgY29uc3QgdHJhbnNmb3JtUmVzdWx0cyA9IHNlcnZlclRyYW5zZm9ybVJlc3VsdHMobXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQudHJhbnNmb3JtUmVzdWx0cyk7XG4gICAgbmV3RGF0YS5zZXRBbGwodHJhbnNmb3JtUmVzdWx0cyk7XG4gICAgZG9jdW1lbnRcbiAgICAgICAgLmNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQobXV0YXRpb25SZXN1bHQudmVyc2lvbiwgbmV3RGF0YSlcbiAgICAgICAgLnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpO1xufVxuZnVuY3Rpb24gc2V0TXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgcHJldmlvdXNNYXNrLCBsb2NhbFdyaXRlVGltZSkge1xuICAgIGlmICghcHJlY29uZGl0aW9uSXNWYWxpZEZvckRvY3VtZW50KG11dGF0aW9uLnByZWNvbmRpdGlvbiwgZG9jdW1lbnQpKSB7XG4gICAgICAgIC8vIFRoZSBtdXRhdGlvbiBmYWlsZWQgdG8gYXBwbHkgKGUuZy4gYSBkb2N1bWVudCBJRCBjcmVhdGVkIHdpdGggYWRkKClcbiAgICAgICAgLy8gY2F1c2VkIGEgbmFtZSBjb2xsaXNpb24pLlxuICAgICAgICByZXR1cm4gcHJldmlvdXNNYXNrO1xuICAgIH1cbiAgICBjb25zdCBuZXdEYXRhID0gbXV0YXRpb24udmFsdWUuY2xvbmUoKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHRzID0gbG9jYWxUcmFuc2Zvcm1SZXN1bHRzKG11dGF0aW9uLmZpZWxkVHJhbnNmb3JtcywgbG9jYWxXcml0ZVRpbWUsIGRvY3VtZW50KTtcbiAgICBuZXdEYXRhLnNldEFsbCh0cmFuc2Zvcm1SZXN1bHRzKTtcbiAgICBkb2N1bWVudFxuICAgICAgICAuY29udmVydFRvRm91bmREb2N1bWVudChkb2N1bWVudC52ZXJzaW9uLCBuZXdEYXRhKVxuICAgICAgICAuc2V0SGFzTG9jYWxNdXRhdGlvbnMoKTtcbiAgICByZXR1cm4gbnVsbDsgLy8gU2V0TXV0YXRpb24gb3ZlcndyaXRlcyBhbGwgZmllbGRzLlxufVxuLyoqXG4gKiBBIG11dGF0aW9uIHRoYXQgbW9kaWZpZXMgZmllbGRzIG9mIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4ga2V5IHdpdGggdGhlXG4gKiBnaXZlbiB2YWx1ZXMuIFRoZSB2YWx1ZXMgYXJlIGFwcGxpZWQgdGhyb3VnaCBhIGZpZWxkIG1hc2s6XG4gKlxuICogICogV2hlbiBhIGZpZWxkIGlzIGluIGJvdGggdGhlIG1hc2sgYW5kIHRoZSB2YWx1ZXMsIHRoZSBjb3JyZXNwb25kaW5nIGZpZWxkXG4gKiAgICBpcyB1cGRhdGVkLlxuICogICogV2hlbiBhIGZpZWxkIGlzIGluIG5laXRoZXIgdGhlIG1hc2sgbm9yIHRoZSB2YWx1ZXMsIHRoZSBjb3JyZXNwb25kaW5nXG4gKiAgICBmaWVsZCBpcyB1bm1vZGlmaWVkLlxuICogICogV2hlbiBhIGZpZWxkIGlzIGluIHRoZSBtYXNrIGJ1dCBub3QgaW4gdGhlIHZhbHVlcywgdGhlIGNvcnJlc3BvbmRpbmcgZmllbGRcbiAqICAgIGlzIGRlbGV0ZWQuXG4gKiAgKiBXaGVuIGEgZmllbGQgaXMgbm90IGluIHRoZSBtYXNrIGJ1dCBpcyBpbiB0aGUgdmFsdWVzLCB0aGUgdmFsdWVzIG1hcCBpc1xuICogICAgaWdub3JlZC5cbiAqL1xuY2xhc3MgUGF0Y2hNdXRhdGlvbiBleHRlbmRzIE11dGF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIGRhdGEsIGZpZWxkTWFzaywgcHJlY29uZGl0aW9uLCBmaWVsZFRyYW5zZm9ybXMgPSBbXSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5maWVsZE1hc2sgPSBmaWVsZE1hc2s7XG4gICAgICAgIHRoaXMucHJlY29uZGl0aW9uID0gcHJlY29uZGl0aW9uO1xuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IGZpZWxkVHJhbnNmb3JtcztcbiAgICAgICAgdGhpcy50eXBlID0gMSAvKiBNdXRhdGlvblR5cGUuUGF0Y2ggKi87XG4gICAgfVxuICAgIGdldEZpZWxkTWFzaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRNYXNrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCkge1xuICAgIGlmICghcHJlY29uZGl0aW9uSXNWYWxpZEZvckRvY3VtZW50KG11dGF0aW9uLnByZWNvbmRpdGlvbiwgZG9jdW1lbnQpKSB7XG4gICAgICAgIC8vIFNpbmNlIHRoZSBtdXRhdGlvbiB3YXMgbm90IHJlamVjdGVkLCB3ZSBrbm93IHRoYXQgdGhlIHByZWNvbmRpdGlvblxuICAgICAgICAvLyBtYXRjaGVkIG9uIHRoZSBiYWNrZW5kLiBXZSB0aGVyZWZvcmUgbXVzdCBub3QgaGF2ZSB0aGUgZXhwZWN0ZWQgdmVyc2lvblxuICAgICAgICAvLyBvZiB0aGUgZG9jdW1lbnQgaW4gb3VyIGNhY2hlIGFuZCBjb252ZXJ0IHRvIGFuIFVua25vd25Eb2N1bWVudCB3aXRoIGFcbiAgICAgICAgLy8ga25vd24gdXBkYXRlVGltZS5cbiAgICAgICAgZG9jdW1lbnQuY29udmVydFRvVW5rbm93bkRvY3VtZW50KG11dGF0aW9uUmVzdWx0LnZlcnNpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdHMgPSBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzKG11dGF0aW9uLmZpZWxkVHJhbnNmb3JtcywgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0LnRyYW5zZm9ybVJlc3VsdHMpO1xuICAgIGNvbnN0IG5ld0RhdGEgPSBkb2N1bWVudC5kYXRhO1xuICAgIG5ld0RhdGEuc2V0QWxsKGdldFBhdGNoKG11dGF0aW9uKSk7XG4gICAgbmV3RGF0YS5zZXRBbGwodHJhbnNmb3JtUmVzdWx0cyk7XG4gICAgZG9jdW1lbnRcbiAgICAgICAgLmNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQobXV0YXRpb25SZXN1bHQudmVyc2lvbiwgbmV3RGF0YSlcbiAgICAgICAgLnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpO1xufVxuZnVuY3Rpb24gcGF0Y2hNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBwcmV2aW91c01hc2ssIGxvY2FsV3JpdGVUaW1lKSB7XG4gICAgaWYgKCFwcmVjb25kaXRpb25Jc1ZhbGlkRm9yRG9jdW1lbnQobXV0YXRpb24ucHJlY29uZGl0aW9uLCBkb2N1bWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzTWFzaztcbiAgICB9XG4gICAgY29uc3QgdHJhbnNmb3JtUmVzdWx0cyA9IGxvY2FsVHJhbnNmb3JtUmVzdWx0cyhtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMsIGxvY2FsV3JpdGVUaW1lLCBkb2N1bWVudCk7XG4gICAgY29uc3QgbmV3RGF0YSA9IGRvY3VtZW50LmRhdGE7XG4gICAgbmV3RGF0YS5zZXRBbGwoZ2V0UGF0Y2gobXV0YXRpb24pKTtcbiAgICBuZXdEYXRhLnNldEFsbCh0cmFuc2Zvcm1SZXN1bHRzKTtcbiAgICBkb2N1bWVudFxuICAgICAgICAuY29udmVydFRvRm91bmREb2N1bWVudChkb2N1bWVudC52ZXJzaW9uLCBuZXdEYXRhKVxuICAgICAgICAuc2V0SGFzTG9jYWxNdXRhdGlvbnMoKTtcbiAgICBpZiAocHJldmlvdXNNYXNrID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcHJldmlvdXNNYXNrXG4gICAgICAgIC51bmlvbldpdGgobXV0YXRpb24uZmllbGRNYXNrLmZpZWxkcylcbiAgICAgICAgLnVuaW9uV2l0aChtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMubWFwKHRyYW5zZm9ybSA9PiB0cmFuc2Zvcm0uZmllbGQpKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIEZpZWxkUGF0aC9WYWx1ZSBtYXAgd2l0aCB0aGUgY29udGVudCBvZiB0aGUgUGF0Y2hNdXRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UGF0Y2gobXV0YXRpb24pIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgbXV0YXRpb24uZmllbGRNYXNrLmZpZWxkcy5mb3JFYWNoKGZpZWxkUGF0aCA9PiB7XG4gICAgICAgIGlmICghZmllbGRQYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBtdXRhdGlvbi5kYXRhLmZpZWxkKGZpZWxkUGF0aCk7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGZpZWxkUGF0aCwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGxpc3Qgb2YgXCJ0cmFuc2Zvcm0gcmVzdWx0c1wiIChhIHRyYW5zZm9ybSByZXN1bHQgaXMgYSBmaWVsZCB2YWx1ZVxuICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYSB0cmFuc2Zvcm0pIGZvciB1c2UgYWZ0ZXIgYSBtdXRhdGlvblxuICogY29udGFpbmluZyB0cmFuc2Zvcm1zIGhhcyBiZWVuIGFja25vd2xlZGdlZCBieSB0aGUgc2VydmVyLlxuICpcbiAqIEBwYXJhbSBmaWVsZFRyYW5zZm9ybXMgLSBUaGUgZmllbGQgdHJhbnNmb3JtcyB0byBhcHBseSB0aGUgcmVzdWx0IHRvLlxuICogQHBhcmFtIG11dGFibGVEb2N1bWVudCAtIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBkb2N1bWVudCBhZnRlciBhcHBseWluZyBhbGxcbiAqIHByZXZpb3VzIG11dGF0aW9ucy5cbiAqIEBwYXJhbSBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzIC0gVGhlIHRyYW5zZm9ybSByZXN1bHRzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIuXG4gKiBAcmV0dXJucyBUaGUgdHJhbnNmb3JtIHJlc3VsdHMgbGlzdC5cbiAqL1xuZnVuY3Rpb24gc2VydmVyVHJhbnNmb3JtUmVzdWx0cyhmaWVsZFRyYW5zZm9ybXMsIG11dGFibGVEb2N1bWVudCwgc2VydmVyVHJhbnNmb3JtUmVzdWx0cykge1xuICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdHMgPSBuZXcgTWFwKCk7XG4gICAgaGFyZEFzc2VydChmaWVsZFRyYW5zZm9ybXMubGVuZ3RoID09PSBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzLmxlbmd0aCwgMHg3ZjkwLCB7XG4gICAgICAgIHNlcnZlclRyYW5zZm9ybVJlc3VsdENvdW50OiBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzLmxlbmd0aCxcbiAgICAgICAgZmllbGRUcmFuc2Zvcm1Db3VudDogZmllbGRUcmFuc2Zvcm1zLmxlbmd0aFxuICAgIH0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VydmVyVHJhbnNmb3JtUmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmaWVsZFRyYW5zZm9ybSA9IGZpZWxkVHJhbnNmb3Jtc1tpXTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZmllbGRUcmFuc2Zvcm0udHJhbnNmb3JtO1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gbXV0YWJsZURvY3VtZW50LmRhdGEuZmllbGQoZmllbGRUcmFuc2Zvcm0uZmllbGQpO1xuICAgICAgICB0cmFuc2Zvcm1SZXN1bHRzLnNldChmaWVsZFRyYW5zZm9ybS5maWVsZCwgYXBwbHlUcmFuc2Zvcm1PcGVyYXRpb25Ub1JlbW90ZURvY3VtZW50KHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSwgc2VydmVyVHJhbnNmb3JtUmVzdWx0c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtUmVzdWx0cztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGxpc3Qgb2YgXCJ0cmFuc2Zvcm0gcmVzdWx0c1wiIChhIHRyYW5zZm9ybSByZXN1bHQgaXMgYSBmaWVsZCB2YWx1ZVxuICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYSB0cmFuc2Zvcm0pIGZvciB1c2Ugd2hlbiBhcHBseWluZyBhXG4gKiB0cmFuc2Zvcm0gbG9jYWxseS5cbiAqXG4gKiBAcGFyYW0gZmllbGRUcmFuc2Zvcm1zIC0gVGhlIGZpZWxkIHRyYW5zZm9ybXMgdG8gYXBwbHkgdGhlIHJlc3VsdCB0by5cbiAqIEBwYXJhbSBsb2NhbFdyaXRlVGltZSAtIFRoZSBsb2NhbCB0aW1lIG9mIHRoZSBtdXRhdGlvbiAodXNlZCB0b1xuICogICAgIGdlbmVyYXRlIFNlcnZlclRpbWVzdGFtcFZhbHVlcykuXG4gKiBAcGFyYW0gbXV0YWJsZURvY3VtZW50IC0gVGhlIGRvY3VtZW50IHRvIGFwcGx5IHRyYW5zZm9ybXMgb24uXG4gKiBAcmV0dXJucyBUaGUgdHJhbnNmb3JtIHJlc3VsdHMgbGlzdC5cbiAqL1xuZnVuY3Rpb24gbG9jYWxUcmFuc2Zvcm1SZXN1bHRzKGZpZWxkVHJhbnNmb3JtcywgbG9jYWxXcml0ZVRpbWUsIG11dGFibGVEb2N1bWVudCkge1xuICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdHMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBmaWVsZFRyYW5zZm9ybSBvZiBmaWVsZFRyYW5zZm9ybXMpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZmllbGRUcmFuc2Zvcm0udHJhbnNmb3JtO1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gbXV0YWJsZURvY3VtZW50LmRhdGEuZmllbGQoZmllbGRUcmFuc2Zvcm0uZmllbGQpO1xuICAgICAgICB0cmFuc2Zvcm1SZXN1bHRzLnNldChmaWVsZFRyYW5zZm9ybS5maWVsZCwgYXBwbHlUcmFuc2Zvcm1PcGVyYXRpb25Ub0xvY2FsVmlldyh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUsIGxvY2FsV3JpdGVUaW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1SZXN1bHRzO1xufVxuLyoqIEEgbXV0YXRpb24gdGhhdCBkZWxldGVzIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4ga2V5LiAqL1xuY2xhc3MgRGVsZXRlTXV0YXRpb24gZXh0ZW5kcyBNdXRhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBwcmVjb25kaXRpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucHJlY29uZGl0aW9uID0gcHJlY29uZGl0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAyIC8qIE11dGF0aW9uVHlwZS5EZWxldGUgKi87XG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gW107XG4gICAgfVxuICAgIGdldEZpZWxkTWFzaygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVsZXRlTXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCkge1xuICAgIC8vIFVubGlrZSBhcHBseVRvTG9jYWxWaWV3LCBpZiB3ZSdyZSBhcHBseWluZyBhIG11dGF0aW9uIHRvIGEgcmVtb3RlXG4gICAgLy8gZG9jdW1lbnQgdGhlIHNlcnZlciBoYXMgYWNjZXB0ZWQgdGhlIG11dGF0aW9uIHNvIHRoZSBwcmVjb25kaXRpb24gbXVzdFxuICAgIC8vIGhhdmUgaGVsZC5cbiAgICBkb2N1bWVudFxuICAgICAgICAuY29udmVydFRvTm9Eb2N1bWVudChtdXRhdGlvblJlc3VsdC52ZXJzaW9uKVxuICAgICAgICAuc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCk7XG59XG5mdW5jdGlvbiBkZWxldGVNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBwcmV2aW91c01hc2spIHtcbiAgICBpZiAocHJlY29uZGl0aW9uSXNWYWxpZEZvckRvY3VtZW50KG11dGF0aW9uLnByZWNvbmRpdGlvbiwgZG9jdW1lbnQpKSB7XG4gICAgICAgIGRvY3VtZW50LmNvbnZlcnRUb05vRG9jdW1lbnQoZG9jdW1lbnQudmVyc2lvbikuc2V0SGFzTG9jYWxNdXRhdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwcmV2aW91c01hc2s7XG59XG4vKipcbiAqIEEgbXV0YXRpb24gdGhhdCB2ZXJpZmllcyB0aGUgZXhpc3RlbmNlIG9mIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4ga2V5IHdpdGhcbiAqIHRoZSBwcm92aWRlZCBwcmVjb25kaXRpb24uXG4gKlxuICogVGhlIGB2ZXJpZnlgIG9wZXJhdGlvbiBpcyBvbmx5IHVzZWQgaW4gVHJhbnNhY3Rpb25zLCBhbmQgdGhpcyBjbGFzcyBzZXJ2ZXNcbiAqIHByaW1hcmlseSB0byBmYWNpbGl0YXRlIHNlcmlhbGl6YXRpb24gaW50byBwcm90b3MuXG4gKi9cbmNsYXNzIFZlcmlmeU11dGF0aW9uIGV4dGVuZHMgTXV0YXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgcHJlY29uZGl0aW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnByZWNvbmRpdGlvbiA9IHByZWNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy50eXBlID0gMyAvKiBNdXRhdGlvblR5cGUuVmVyaWZ5ICovO1xuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IFtdO1xuICAgIH1cbiAgICBnZXRGaWVsZE1hc2soKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBiYXRjaCBvZiBtdXRhdGlvbnMgdGhhdCB3aWxsIGJlIHNlbnQgYXMgb25lIHVuaXQgdG8gdGhlIGJhY2tlbmQuXG4gKi9cbmNsYXNzIE11dGF0aW9uQmF0Y2gge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBiYXRjaElkIC0gVGhlIHVuaXF1ZSBJRCBvZiB0aGlzIG11dGF0aW9uIGJhdGNoLlxuICAgICAqIEBwYXJhbSBsb2NhbFdyaXRlVGltZSAtIFRoZSBvcmlnaW5hbCB3cml0ZSB0aW1lIG9mIHRoaXMgbXV0YXRpb24uXG4gICAgICogQHBhcmFtIGJhc2VNdXRhdGlvbnMgLSBNdXRhdGlvbnMgdGhhdCBhcmUgdXNlZCB0byBwb3B1bGF0ZSB0aGUgYmFzZVxuICAgICAqIHZhbHVlcyB3aGVuIHRoaXMgbXV0YXRpb24gaXMgYXBwbGllZCBsb2NhbGx5LiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvY2FsbHlcbiAgICAgKiBvdmVyd3JpdGUgdmFsdWVzIHRoYXQgYXJlIHBlcnNpc3RlZCBpbiB0aGUgcmVtb3RlIGRvY3VtZW50IGNhY2hlLiBCYXNlXG4gICAgICogbXV0YXRpb25zIGFyZSBuZXZlciBzZW50IHRvIHRoZSBiYWNrZW5kLlxuICAgICAqIEBwYXJhbSBtdXRhdGlvbnMgLSBUaGUgdXNlci1wcm92aWRlZCBtdXRhdGlvbnMgaW4gdGhpcyBtdXRhdGlvbiBiYXRjaC5cbiAgICAgKiBVc2VyLXByb3ZpZGVkIG11dGF0aW9ucyBhcmUgYXBwbGllZCBib3RoIGxvY2FsbHkgYW5kIHJlbW90ZWx5IG9uIHRoZVxuICAgICAqIGJhY2tlbmQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmF0Y2hJZCwgbG9jYWxXcml0ZVRpbWUsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucykge1xuICAgICAgICB0aGlzLmJhdGNoSWQgPSBiYXRjaElkO1xuICAgICAgICB0aGlzLmxvY2FsV3JpdGVUaW1lID0gbG9jYWxXcml0ZVRpbWU7XG4gICAgICAgIHRoaXMuYmFzZU11dGF0aW9ucyA9IGJhc2VNdXRhdGlvbnM7XG4gICAgICAgIHRoaXMubXV0YXRpb25zID0gbXV0YXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFsbCB0aGUgbXV0YXRpb25zIGluIHRoaXMgTXV0YXRpb25CYXRjaCB0byB0aGUgc3BlY2lmaWVkIGRvY3VtZW50XG4gICAgICogdG8gY29tcHV0ZSB0aGUgc3RhdGUgb2YgdGhlIHJlbW90ZSBkb2N1bWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50IC0gVGhlIGRvY3VtZW50IHRvIGFwcGx5IG11dGF0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0gYmF0Y2hSZXN1bHQgLSBUaGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBNdXRhdGlvbkJhdGNoIHRvIHRoZVxuICAgICAqIGJhY2tlbmQuXG4gICAgICovXG4gICAgYXBwbHlUb1JlbW90ZURvY3VtZW50KGRvY3VtZW50LCBiYXRjaFJlc3VsdCkge1xuICAgICAgICBjb25zdCBtdXRhdGlvblJlc3VsdHMgPSBiYXRjaFJlc3VsdC5tdXRhdGlvblJlc3VsdHM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uID0gdGhpcy5tdXRhdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAobXV0YXRpb24ua2V5LmlzRXF1YWwoZG9jdW1lbnQua2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uUmVzdWx0ID0gbXV0YXRpb25SZXN1bHRzW2ldO1xuICAgICAgICAgICAgICAgIG11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBsb2NhbCB2aWV3IG9mIGEgZG9jdW1lbnQgZ2l2ZW4gYWxsIHRoZSBtdXRhdGlvbnMgaW4gdGhpc1xuICAgICAqIGJhdGNoLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50IC0gVGhlIGRvY3VtZW50IHRvIGFwcGx5IG11dGF0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0gbXV0YXRlZEZpZWxkcyAtIEZpZWxkcyB0aGF0IGhhdmUgYmVlbiB1cGRhdGVkIGJlZm9yZSBhcHBseWluZyB0aGlzIG11dGF0aW9uIGJhdGNoLlxuICAgICAqIEByZXR1cm5zIEEgYEZpZWxkTWFza2AgcmVwcmVzZW50aW5nIGFsbCB0aGUgZmllbGRzIHRoYXQgYXJlIG11dGF0ZWQuXG4gICAgICovXG4gICAgYXBwbHlUb0xvY2FsVmlldyhkb2N1bWVudCwgbXV0YXRlZEZpZWxkcykge1xuICAgICAgICAvLyBGaXJzdCwgYXBwbHkgdGhlIGJhc2Ugc3RhdGUuIFRoaXMgYWxsb3dzIHVzIHRvIGFwcGx5IG5vbi1pZGVtcG90ZW50XG4gICAgICAgIC8vIHRyYW5zZm9ybSBhZ2FpbnN0IGEgY29uc2lzdGVudCBzZXQgb2YgdmFsdWVzLlxuICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIHRoaXMuYmFzZU11dGF0aW9ucykge1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLmtleS5pc0VxdWFsKGRvY3VtZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICBtdXRhdGVkRmllbGRzID0gbXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRlZEZpZWxkcywgdGhpcy5sb2NhbFdyaXRlVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2Vjb25kLCBhcHBseSBhbGwgdXNlci1wcm92aWRlZCBtdXRhdGlvbnMuXG4gICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgdGhpcy5tdXRhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi5rZXkuaXNFcXVhbChkb2N1bWVudC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgbXV0YXRlZEZpZWxkcyA9IG11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0ZWRGaWVsZHMsIHRoaXMubG9jYWxXcml0ZVRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtdXRhdGVkRmllbGRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbG9jYWwgdmlldyBmb3IgYWxsIHByb3ZpZGVkIGRvY3VtZW50cyBnaXZlbiB0aGUgbXV0YXRpb25zIGluXG4gICAgICogdGhpcyBiYXRjaC4gUmV0dXJucyBhIGBEb2N1bWVudEtleWAgdG8gYE11dGF0aW9uYCBtYXAgd2hpY2ggY2FuIGJlIHVzZWQgdG9cbiAgICAgKiByZXBsYWNlIGFsbCB0aGUgbXV0YXRpb24gYXBwbGljYXRpb25zLlxuICAgICAqL1xuICAgIGFwcGx5VG9Mb2NhbERvY3VtZW50U2V0KGRvY3VtZW50TWFwLCBkb2N1bWVudHNXaXRob3V0UmVtb3RlVmVyc2lvbikge1xuICAgICAgICAvLyBUT0RPKG1yc2NobWlkdCk6IFRoaXMgaW1wbGVtZW50YXRpb24gaXMgTyhuXjIpLiBJZiB3ZSBhcHBseSB0aGUgbXV0YXRpb25zXG4gICAgICAgIC8vIGRpcmVjdGx5IChhcyBkb25lIGluIGBhcHBseVRvTG9jYWxWaWV3KClgKSwgd2UgY2FuIHJlZHVjZSB0aGUgY29tcGxleGl0eVxuICAgICAgICAvLyB0byBPKG4pLlxuICAgICAgICBjb25zdCBvdmVybGF5cyA9IG5ld011dGF0aW9uTWFwKCk7XG4gICAgICAgIHRoaXMubXV0YXRpb25zLmZvckVhY2gobSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5ZWREb2N1bWVudCA9IGRvY3VtZW50TWFwLmdldChtLmtleSk7XG4gICAgICAgICAgICAvLyBUT0RPKG11dGFibGVkb2N1bWVudHMpOiBUaGlzIG1ldGhvZCBzaG91bGQgdGFrZSBhIE11dGFibGVEb2N1bWVudE1hcFxuICAgICAgICAgICAgLy8gYW5kIHdlIHNob3VsZCByZW1vdmUgdGhpcyBjYXN0LlxuICAgICAgICAgICAgY29uc3QgbXV0YWJsZURvY3VtZW50ID0gb3ZlcmxheWVkRG9jdW1lbnQub3ZlcmxheWVkRG9jdW1lbnQ7XG4gICAgICAgICAgICBsZXQgbXV0YXRlZEZpZWxkcyA9IHRoaXMuYXBwbHlUb0xvY2FsVmlldyhtdXRhYmxlRG9jdW1lbnQsIG92ZXJsYXllZERvY3VtZW50Lm11dGF0ZWRGaWVsZHMpO1xuICAgICAgICAgICAgLy8gU2V0IG11dGF0ZWRGaWVsZHMgdG8gbnVsbCBpZiB0aGUgZG9jdW1lbnQgaXMgb25seSBmcm9tIGxvY2FsIG11dGF0aW9ucy5cbiAgICAgICAgICAgIC8vIFRoaXMgY3JlYXRlcyBhIFNldCBvciBEZWxldGUgbXV0YXRpb24sIGluc3RlYWQgb2YgdHJ5aW5nIHRvIGNyZWF0ZSBhXG4gICAgICAgICAgICAvLyBwYXRjaCBtdXRhdGlvbiBhcyB0aGUgb3ZlcmxheS5cbiAgICAgICAgICAgIG11dGF0ZWRGaWVsZHMgPSBkb2N1bWVudHNXaXRob3V0UmVtb3RlVmVyc2lvbi5oYXMobS5rZXkpXG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiBtdXRhdGVkRmllbGRzO1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGNhbGN1bGF0ZU92ZXJsYXlNdXRhdGlvbihtdXRhYmxlRG9jdW1lbnQsIG11dGF0ZWRGaWVsZHMpO1xuICAgICAgICAgICAgaWYgKG92ZXJsYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5cy5zZXQobS5rZXksIG92ZXJsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtdXRhYmxlRG9jdW1lbnQuaXNWYWxpZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgICAgICBtdXRhYmxlRG9jdW1lbnQuY29udmVydFRvTm9Eb2N1bWVudChTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG92ZXJsYXlzO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdXRhdGlvbnMucmVkdWNlKChrZXlzLCBtKSA9PiBrZXlzLmFkZChtLmtleSksIGRvY3VtZW50S2V5U2V0KCkpO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5iYXRjaElkID09PSBvdGhlci5iYXRjaElkICYmXG4gICAgICAgICAgICBhcnJheUVxdWFscyh0aGlzLm11dGF0aW9ucywgb3RoZXIubXV0YXRpb25zLCAobCwgcikgPT4gbXV0YXRpb25FcXVhbHMobCwgcikpICYmXG4gICAgICAgICAgICBhcnJheUVxdWFscyh0aGlzLmJhc2VNdXRhdGlvbnMsIG90aGVyLmJhc2VNdXRhdGlvbnMsIChsLCByKSA9PiBtdXRhdGlvbkVxdWFscyhsLCByKSkpO1xuICAgIH1cbn1cbi8qKiBUaGUgcmVzdWx0IG9mIGFwcGx5aW5nIGEgbXV0YXRpb24gYmF0Y2ggdG8gdGhlIGJhY2tlbmQuICovXG5jbGFzcyBNdXRhdGlvbkJhdGNoUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihiYXRjaCwgY29tbWl0VmVyc2lvbiwgbXV0YXRpb25SZXN1bHRzLCBcbiAgICAvKipcbiAgICAgKiBBIHByZS1jb21wdXRlZCBtYXBwaW5nIGZyb20gZWFjaCBtdXRhdGVkIGRvY3VtZW50IHRvIHRoZSByZXN1bHRpbmdcbiAgICAgKiB2ZXJzaW9uLlxuICAgICAqL1xuICAgIGRvY1ZlcnNpb25zKSB7XG4gICAgICAgIHRoaXMuYmF0Y2ggPSBiYXRjaDtcbiAgICAgICAgdGhpcy5jb21taXRWZXJzaW9uID0gY29tbWl0VmVyc2lvbjtcbiAgICAgICAgdGhpcy5tdXRhdGlvblJlc3VsdHMgPSBtdXRhdGlvblJlc3VsdHM7XG4gICAgICAgIHRoaXMuZG9jVmVyc2lvbnMgPSBkb2NWZXJzaW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBNdXRhdGlvbkJhdGNoUmVzdWx0IGZvciB0aGUgZ2l2ZW4gYmF0Y2ggYW5kIHJlc3VsdHMuIFRoZXJlXG4gICAgICogbXVzdCBiZSBvbmUgcmVzdWx0IGZvciBlYWNoIG11dGF0aW9uIGluIHRoZSBiYXRjaC4gVGhpcyBzdGF0aWMgZmFjdG9yeVxuICAgICAqIGNhY2hlcyBhIGRvY3VtZW50PSZndDt2ZXJzaW9uIG1hcHBpbmcgKGRvY1ZlcnNpb25zKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShiYXRjaCwgY29tbWl0VmVyc2lvbiwgcmVzdWx0cykge1xuICAgICAgICBoYXJkQXNzZXJ0KGJhdGNoLm11dGF0aW9ucy5sZW5ndGggPT09IHJlc3VsdHMubGVuZ3RoLCAweGU1ZGEsIHtcbiAgICAgICAgICAgIG11dGF0aW9uc1NlbnQ6IGJhdGNoLm11dGF0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHRzUmVjZWl2ZWQ6IHJlc3VsdHMubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdmVyc2lvbk1hcCA9IGRvY3VtZW50VmVyc2lvbk1hcCgpO1xuICAgICAgICBjb25zdCBtdXRhdGlvbnMgPSBiYXRjaC5tdXRhdGlvbnM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJzaW9uTWFwID0gdmVyc2lvbk1hcC5pbnNlcnQobXV0YXRpb25zW2ldLmtleSwgcmVzdWx0c1tpXS52ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE11dGF0aW9uQmF0Y2hSZXN1bHQoYmF0Y2gsIGNvbW1pdFZlcnNpb24sIHJlc3VsdHMsIHZlcnNpb25NYXApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYW4gb3ZlcmxheSBjb21wdXRlZCBieSBGaXJlc3RvcmUuXG4gKlxuICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgYSBtdXRhdGlvbiBhbmQgdGhlIGxhcmdlc3QgYmF0Y2ggaWQgaW4gRmlyZXN0b3JlIHdoZW5cbiAqIHRoZSBtdXRhdGlvbiB3YXMgY3JlYXRlZC5cbiAqL1xuY2xhc3MgT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IobGFyZ2VzdEJhdGNoSWQsIG11dGF0aW9uKSB7XG4gICAgICAgIHRoaXMubGFyZ2VzdEJhdGNoSWQgPSBsYXJnZXN0QmF0Y2hJZDtcbiAgICAgICAgdGhpcy5tdXRhdGlvbiA9IG11dGF0aW9uO1xuICAgIH1cbiAgICBnZXRLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11dGF0aW9uLmtleTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgIT09IG51bGwgJiYgdGhpcy5tdXRhdGlvbiA9PT0gb3RoZXIubXV0YXRpb247XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYE92ZXJsYXl7XG4gICAgICBsYXJnZXN0QmF0Y2hJZDogJHt0aGlzLmxhcmdlc3RCYXRjaElkfSxcbiAgICAgIG11dGF0aW9uOiAke3RoaXMubXV0YXRpb24udG9TdHJpbmcoKX1cbiAgICB9YDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBFeGlzdGVuY2VGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvdW50LCB1bmNoYW5nZWROYW1lcykge1xuICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICAgIHRoaXMudW5jaGFuZ2VkTmFtZXMgPSB1bmNoYW5nZWROYW1lcztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEVycm9yIENvZGVzIGRlc2NyaWJpbmcgdGhlIGRpZmZlcmVudCB3YXlzIEdSUEMgY2FuIGZhaWwuIFRoZXNlIGFyZSBjb3BpZWRcbiAqIGRpcmVjdGx5IGZyb20gR1JQQydzIHNvdXJjZXMgaGVyZTpcbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvYmNlZWM5NGVhNGZjNWYwMDg1ZDgxMjM1ZDhlMWMwNjc5OGRjMzQxYS9pbmNsdWRlL2dycGMlMkIlMkIvaW1wbC9jb2RlZ2VuL3N0YXR1c19jb2RlX2VudW0uaFxuICpcbiAqIEltcG9ydGFudCEgVGhlIG5hbWVzIG9mIHRoZXNlIGlkZW50aWZpZXJzIG1hdHRlciBiZWNhdXNlIHRoZSBzdHJpbmcgZm9ybXNcbiAqIGFyZSB1c2VkIGZvciByZXZlcnNlIGxvb2t1cHMgZnJvbSB0aGUgd2ViY2hhbm5lbCBzdHJlYW0uIERvIE5PVCBjaGFuZ2UgdGhlXG4gKiBuYW1lcyBvZiB0aGVzZSBpZGVudGlmaWVycyBvciBjaGFuZ2UgdGhpcyBpbnRvIGEgY29uc3QgZW51bS5cbiAqL1xudmFyIFJwY0NvZGU7XG4oZnVuY3Rpb24gKFJwY0NvZGUpIHtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIkNBTkNFTExFRFwiXSA9IDFdID0gXCJDQU5DRUxMRURcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJVTktOT1dOXCJdID0gMl0gPSBcIlVOS05PV05cIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gM10gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJERUFETElORV9FWENFRURFRFwiXSA9IDRdID0gXCJERUFETElORV9FWENFRURFRFwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIk5PVF9GT1VORFwiXSA9IDVdID0gXCJOT1RfRk9VTkRcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJBTFJFQURZX0VYSVNUU1wiXSA9IDZdID0gXCJBTFJFQURZX0VYSVNUU1wiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIlBFUk1JU1NJT05fREVOSUVEXCJdID0gN10gPSBcIlBFUk1JU1NJT05fREVOSUVEXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiVU5BVVRIRU5USUNBVEVEXCJdID0gMTZdID0gXCJVTkFVVEhFTlRJQ0FURURcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJSRVNPVVJDRV9FWEhBVVNURURcIl0gPSA4XSA9IFwiUkVTT1VSQ0VfRVhIQVVTVEVEXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiRkFJTEVEX1BSRUNPTkRJVElPTlwiXSA9IDldID0gXCJGQUlMRURfUFJFQ09ORElUSU9OXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiQUJPUlRFRFwiXSA9IDEwXSA9IFwiQUJPUlRFRFwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIk9VVF9PRl9SQU5HRVwiXSA9IDExXSA9IFwiT1VUX09GX1JBTkdFXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiVU5JTVBMRU1FTlRFRFwiXSA9IDEyXSA9IFwiVU5JTVBMRU1FTlRFRFwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIklOVEVSTkFMXCJdID0gMTNdID0gXCJJTlRFUk5BTFwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIlVOQVZBSUxBQkxFXCJdID0gMTRdID0gXCJVTkFWQUlMQUJMRVwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIkRBVEFfTE9TU1wiXSA9IDE1XSA9IFwiREFUQV9MT1NTXCI7XG59KShScGNDb2RlIHx8IChScGNDb2RlID0ge30pKTtcbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGVycm9yIGNvZGUgcmVwcmVzZW50cyBhIHBlcm1hbmVudCBlcnJvciB3aGVuIHJlY2VpdmVkXG4gKiBpbiByZXNwb25zZSB0byBhIG5vbi13cml0ZSBvcGVyYXRpb24uXG4gKlxuICogU2VlIGlzUGVybWFuZW50V3JpdGVFcnJvciBmb3IgY2xhc3NpZnlpbmcgd3JpdGUgZXJyb3JzLlxuICovXG5mdW5jdGlvbiBpc1Blcm1hbmVudEVycm9yKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSBDb2RlLk9LOlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoMHhmZGFhKTtcbiAgICAgICAgY2FzZSBDb2RlLkNBTkNFTExFRDpcbiAgICAgICAgY2FzZSBDb2RlLlVOS05PV046XG4gICAgICAgIGNhc2UgQ29kZS5ERUFETElORV9FWENFRURFRDpcbiAgICAgICAgY2FzZSBDb2RlLlJFU09VUkNFX0VYSEFVU1RFRDpcbiAgICAgICAgY2FzZSBDb2RlLklOVEVSTkFMOlxuICAgICAgICBjYXNlIENvZGUuVU5BVkFJTEFCTEU6XG4gICAgICAgIC8vIFVuYXV0aGVudGljYXRlZCBtZWFucyBzb21ldGhpbmcgd2VudCB3cm9uZyB3aXRoIG91ciB0b2tlbiBhbmQgd2UgbmVlZFxuICAgICAgICAvLyB0byByZXRyeSB3aXRoIG5ldyBjcmVkZW50aWFscyB3aGljaCB3aWxsIGhhcHBlbiBhdXRvbWF0aWNhbGx5LlxuICAgICAgICBjYXNlIENvZGUuVU5BVVRIRU5USUNBVEVEOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlIENvZGUuSU5WQUxJRF9BUkdVTUVOVDpcbiAgICAgICAgY2FzZSBDb2RlLk5PVF9GT1VORDpcbiAgICAgICAgY2FzZSBDb2RlLkFMUkVBRFlfRVhJU1RTOlxuICAgICAgICBjYXNlIENvZGUuUEVSTUlTU0lPTl9ERU5JRUQ6XG4gICAgICAgIGNhc2UgQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OOlxuICAgICAgICAvLyBBYm9ydGVkIG1pZ2h0IGJlIHJldHJpZWQgaW4gc29tZSBzY2VuYXJpb3MsIGJ1dCB0aGF0IGlzIGRlcGVuZGVudCBvblxuICAgICAgICAvLyB0aGUgY29udGV4dCBhbmQgc2hvdWxkIGhhbmRsZWQgaW5kaXZpZHVhbGx5IGJ5IHRoZSBjYWxsaW5nIGNvZGUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYXBpcy9kZXNpZ24vZXJyb3JzLlxuICAgICAgICBjYXNlIENvZGUuQUJPUlRFRDpcbiAgICAgICAgY2FzZSBDb2RlLk9VVF9PRl9SQU5HRTpcbiAgICAgICAgY2FzZSBDb2RlLlVOSU1QTEVNRU5URUQ6XG4gICAgICAgIGNhc2UgQ29kZS5EQVRBX0xPU1M6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWlsKDB4M2M2YiwgeyBjb2RlIH0pO1xuICAgIH1cbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGVycm9yIGNvZGUgcmVwcmVzZW50cyBhIHBlcm1hbmVudCBlcnJvciB3aGVuIHJlY2VpdmVkXG4gKiBpbiByZXNwb25zZSB0byBhIHdyaXRlIG9wZXJhdGlvbi5cbiAqXG4gKiBXcml0ZSBvcGVyYXRpb25zIG11c3QgYmUgaGFuZGxlZCBzcGVjaWFsbHkgYmVjYXVzZSBhcyBvZiBiLzExOTQzNzc2NCwgQUJPUlRFRFxuICogZXJyb3JzIG9uIHRoZSB3cml0ZSBzdHJlYW0gc2hvdWxkIGJlIHJldHJpZWQgdG9vIChldmVuIHRob3VnaCBBQk9SVEVEIGVycm9yc1xuICogYXJlIG5vdCBnZW5lcmFsbHkgcmV0cnlhYmxlKS5cbiAqXG4gKiBOb3RlIHRoYXQgZHVyaW5nIHRoZSBpbml0aWFsIGhhbmRzaGFrZSBvbiB0aGUgd3JpdGUgc3RyZWFtIGFuIEFCT1JURUQgZXJyb3JcbiAqIHNpZ25hbHMgdGhhdCB3ZSBzaG91bGQgZGlzY2FyZCBvdXIgc3RyZWFtIHRva2VuIChpLmUuIGl0IGlzIHBlcm1hbmVudCkuIFRoaXNcbiAqIG1lYW5zIGEgaGFuZHNoYWtlIGVycm9yIHNob3VsZCBiZSBjbGFzc2lmaWVkIHdpdGggaXNQZXJtYW5lbnRFcnJvciwgYWJvdmUuXG4gKi9cbmZ1bmN0aW9uIGlzUGVybWFuZW50V3JpdGVFcnJvcihjb2RlKSB7XG4gICAgcmV0dXJuIGlzUGVybWFuZW50RXJyb3IoY29kZSkgJiYgY29kZSAhPT0gQ29kZS5BQk9SVEVEO1xufVxuLyoqXG4gKiBNYXBzIGFuIGVycm9yIENvZGUgZnJvbSBHUlBDIHN0YXR1cyBjb2RlIG51bWJlciwgbGlrZSAwLCAxLCBvciAxNC4gVGhlc2VcbiAqIGFyZSBub3QgdGhlIHNhbWUgYXMgSFRUUCBzdGF0dXMgY29kZXMuXG4gKlxuICogQHJldHVybnMgVGhlIENvZGUgZXF1aXZhbGVudCB0byB0aGUgZ2l2ZW4gR1JQQyBzdGF0dXMgY29kZS4gRmFpbHMgaWYgdGhlcmVcbiAqICAgICBpcyBubyBtYXRjaC5cbiAqL1xuZnVuY3Rpb24gbWFwQ29kZUZyb21ScGNDb2RlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IG5vcm1hbGx5IGhhcHBlbiwgYnV0IGluIGNlcnRhaW4gZXJyb3IgY2FzZXMgKGxpa2UgdHJ5aW5nXG4gICAgICAgIC8vIHRvIHNlbmQgaW52YWxpZCBwcm90byBtZXNzYWdlcykgd2UgbWF5IGdldCBhbiBlcnJvciB3aXRoIG5vIEdSUEMgY29kZS5cbiAgICAgICAgbG9nRXJyb3IoJ0dSUEMgZXJyb3IgaGFzIG5vIC5jb2RlJyk7XG4gICAgICAgIHJldHVybiBDb2RlLlVOS05PV047XG4gICAgfVxuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIFJwY0NvZGUuT0s6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5PSztcbiAgICAgICAgY2FzZSBScGNDb2RlLkNBTkNFTExFRDpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkNBTkNFTExFRDtcbiAgICAgICAgY2FzZSBScGNDb2RlLlVOS05PV046XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5VTktOT1dOO1xuICAgICAgICBjYXNlIFJwY0NvZGUuREVBRExJTkVfRVhDRUVERUQ6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5ERUFETElORV9FWENFRURFRDtcbiAgICAgICAgY2FzZSBScGNDb2RlLlJFU09VUkNFX0VYSEFVU1RFRDpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlJFU09VUkNFX0VYSEFVU1RFRDtcbiAgICAgICAgY2FzZSBScGNDb2RlLklOVEVSTkFMOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuSU5URVJOQUw7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5VTkFWQUlMQUJMRTpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlVOQVZBSUxBQkxFO1xuICAgICAgICBjYXNlIFJwY0NvZGUuVU5BVVRIRU5USUNBVEVEOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVU5BVVRIRU5USUNBVEVEO1xuICAgICAgICBjYXNlIFJwY0NvZGUuSU5WQUxJRF9BUkdVTUVOVDpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLklOVkFMSURfQVJHVU1FTlQ7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5OT1RfRk9VTkQ6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5OT1RfRk9VTkQ7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5BTFJFQURZX0VYSVNUUzpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkFMUkVBRFlfRVhJU1RTO1xuICAgICAgICBjYXNlIFJwY0NvZGUuUEVSTUlTU0lPTl9ERU5JRUQ6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5QRVJNSVNTSU9OX0RFTklFRDtcbiAgICAgICAgY2FzZSBScGNDb2RlLkZBSUxFRF9QUkVDT05ESVRJT046XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OO1xuICAgICAgICBjYXNlIFJwY0NvZGUuQUJPUlRFRDpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkFCT1JURUQ7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5PVVRfT0ZfUkFOR0U6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5PVVRfT0ZfUkFOR0U7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5VTklNUExFTUVOVEVEOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVU5JTVBMRU1FTlRFRDtcbiAgICAgICAgY2FzZSBScGNDb2RlLkRBVEFfTE9TUzpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkRBVEFfTE9TUztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWlsKDB4OTk5YiwgeyBjb2RlIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQW4gZXJyb3IgZW5jb3VudGVyZWQgd2hpbGUgZGVjb2RpbmcgYmFzZTY0IHN0cmluZy5cbiAqL1xuY2xhc3MgQmFzZTY0RGVjb2RlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdCYXNlNjREZWNvZGVFcnJvcic7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgZ2xvYmFsLCBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgVGVzdGluZ0hvb2tzU3BpLlxuICpcbiAqIFRoaXMgdmFyaWFibGUgd2lsbCBiZSBgbnVsbGAgaW4gYWxsIGNhc2VzIF9leGNlcHRfIHdoZW4gcnVubmluZyBmcm9tXG4gKiBpbnRlZ3JhdGlvbiB0ZXN0cyB0aGF0IGhhdmUgcmVnaXN0ZXJlZCBjYWxsYmFja3MgdG8gYmUgbm90aWZpZWQgb2YgZXZlbnRzXG4gKiB0aGF0IGhhcHBlbiBkdXJpbmcgdGhlIHRlc3QgZXhlY3V0aW9uLlxuICovXG5sZXQgdGVzdGluZ0hvb2tzU3BpID0gbnVsbDtcbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGB0ZXN0aW5nSG9va3NTcGlgIG9iamVjdC5cbiAqIEBwYXJhbSBpbnN0YW5jZSAtIHRoZSBpbnN0YW5jZSB0byBzZXQuXG4gKi9cbmZ1bmN0aW9uIHNldFRlc3RpbmdIb29rc1NwaShpbnN0YW5jZSkge1xuICAgIGlmICh0ZXN0aW5nSG9va3NTcGkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhIFRlc3RpbmdIb29rc1NwaSBpbnN0YW5jZSBpcyBhbHJlYWR5IHNldCcpO1xuICAgIH1cbiAgICB0ZXN0aW5nSG9va3NTcGkgPSBpbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIFBsYXRmb3JtJ3MgJ1RleHRFbmNvZGVyJyBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbmV3VGV4dEVuY29kZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpO1xufVxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgUGxhdGZvcm0ncyAnVGV4dERlY29kZXInIGltcGxlbWVudGF0aW9uLlxuICovXG5mdW5jdGlvbiBuZXdUZXh0RGVjb2RlcigpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTUFYXzY0X0JJVF9VTlNJR05FRF9JTlRFR0VSID0gbmV3IEludGVnZXIoWzB4ZmZmZmZmZmYsIDB4ZmZmZmZmZmZdLCAwKTtcbi8vIEhhc2ggYSBzdHJpbmcgdXNpbmcgbWQ1IGhhc2hpbmcgYWxnb3JpdGhtLlxuZnVuY3Rpb24gZ2V0TWQ1SGFzaFZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgZW5jb2RlZFZhbHVlID0gbmV3VGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpO1xuICAgIGNvbnN0IG1kNSA9IG5ldyBNZDUoKTtcbiAgICBtZDUudXBkYXRlKGVuY29kZWRWYWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG1kNS5kaWdlc3QoKSk7XG59XG4vLyBJbnRlcnByZXQgdGhlIDE2IGJ5dGVzIGFycmF5IGFzIHR3byA2NC1iaXQgdW5zaWduZWQgaW50ZWdlcnMsIGVuY29kZWQgdXNpbmdcbi8vIDLigJlzIGNvbXBsZW1lbnQgdXNpbmcgbGl0dGxlIGVuZGlhbi5cbmZ1bmN0aW9uIGdldDY0Qml0VWludHMoQnl0ZXMpIHtcbiAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhCeXRlcy5idWZmZXIpO1xuICAgIGNvbnN0IGNodW5rMSA9IGRhdGFWaWV3LmdldFVpbnQzMigwLCAvKiBsaXR0bGVFbmRpYW49ICovIHRydWUpO1xuICAgIGNvbnN0IGNodW5rMiA9IGRhdGFWaWV3LmdldFVpbnQzMig0LCAvKiBsaXR0bGVFbmRpYW49ICovIHRydWUpO1xuICAgIGNvbnN0IGNodW5rMyA9IGRhdGFWaWV3LmdldFVpbnQzMig4LCAvKiBsaXR0bGVFbmRpYW49ICovIHRydWUpO1xuICAgIGNvbnN0IGNodW5rNCA9IGRhdGFWaWV3LmdldFVpbnQzMigxMiwgLyogbGl0dGxlRW5kaWFuPSAqLyB0cnVlKTtcbiAgICBjb25zdCBpbnRlZ2VyMSA9IG5ldyBJbnRlZ2VyKFtjaHVuazEsIGNodW5rMl0sIDApO1xuICAgIGNvbnN0IGludGVnZXIyID0gbmV3IEludGVnZXIoW2NodW5rMywgY2h1bms0XSwgMCk7XG4gICAgcmV0dXJuIFtpbnRlZ2VyMSwgaW50ZWdlcjJdO1xufVxuY2xhc3MgQmxvb21GaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGJpdG1hcCwgcGFkZGluZywgaGFzaENvdW50KSB7XG4gICAgICAgIHRoaXMuYml0bWFwID0gYml0bWFwO1xuICAgICAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICB0aGlzLmhhc2hDb3VudCA9IGhhc2hDb3VudDtcbiAgICAgICAgaWYgKHBhZGRpbmcgPCAwIHx8IHBhZGRpbmcgPj0gOCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJsb29tRmlsdGVyRXJyb3IoYEludmFsaWQgcGFkZGluZzogJHtwYWRkaW5nfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNoQ291bnQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQmxvb21GaWx0ZXJFcnJvcihgSW52YWxpZCBoYXNoIGNvdW50OiAke2hhc2hDb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYml0bWFwLmxlbmd0aCA+IDAgJiYgdGhpcy5oYXNoQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIC8vIE9ubHkgZW1wdHkgYmxvb20gZmlsdGVyIGNhbiBoYXZlIDAgaGFzaCBjb3VudC5cbiAgICAgICAgICAgIHRocm93IG5ldyBCbG9vbUZpbHRlckVycm9yKGBJbnZhbGlkIGhhc2ggY291bnQ6ICR7aGFzaENvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaXRtYXAubGVuZ3RoID09PSAwICYmIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgICAgIC8vIEVtcHR5IGJsb29tIGZpbHRlciBzaG91bGQgaGF2ZSAwIHBhZGRpbmcuXG4gICAgICAgICAgICB0aHJvdyBuZXcgQmxvb21GaWx0ZXJFcnJvcihgSW52YWxpZCBwYWRkaW5nIHdoZW4gYml0bWFwIGxlbmd0aCBpcyAwOiAke3BhZGRpbmd9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaXRDb3VudCA9IGJpdG1hcC5sZW5ndGggKiA4IC0gcGFkZGluZztcbiAgICAgICAgLy8gU2V0IHRoZSBiaXQgY291bnQgaW4gSW50ZWdlciB0byBhdm9pZCByZXBldGl0aW9uIGluIG1pZ2h0Q29udGFpbigpLlxuICAgICAgICB0aGlzLmJpdENvdW50SW5JbnRlZ2VyID0gSW50ZWdlci5mcm9tTnVtYmVyKHRoaXMuYml0Q291bnQpO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGl0aCBoYXNoIHZhbHVlIGJhc2VkIG9uIHRoZSBoYXNoZWQgNjRiaXQgaW50ZWdlcnMsXG4gICAgLy8gYW5kIGNhbGN1bGF0ZSBpdHMgY29ycmVzcG9uZGluZyBiaXQgaW5kZXggaW4gdGhlIGJpdG1hcCB0byBiZSBjaGVja2VkLlxuICAgIGdldEJpdEluZGV4KG51bTEsIG51bTIsIGhhc2hJbmRleCkge1xuICAgICAgICAvLyBDYWxjdWxhdGUgaGFzaGVkIHZhbHVlIGgoaSkgPSBoMSArIChpICogaDIpLlxuICAgICAgICBsZXQgaGFzaFZhbHVlID0gbnVtMS5hZGQobnVtMi5tdWx0aXBseShJbnRlZ2VyLmZyb21OdW1iZXIoaGFzaEluZGV4KSkpO1xuICAgICAgICAvLyBXcmFwIGlmIGhhc2ggdmFsdWUgb3ZlcmZsb3cgNjRiaXQuXG4gICAgICAgIGlmIChoYXNoVmFsdWUuY29tcGFyZShNQVhfNjRfQklUX1VOU0lHTkVEX0lOVEVHRVIpID09PSAxKSB7XG4gICAgICAgICAgICBoYXNoVmFsdWUgPSBuZXcgSW50ZWdlcihbaGFzaFZhbHVlLmdldEJpdHMoMCksIGhhc2hWYWx1ZS5nZXRCaXRzKDEpXSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc2hWYWx1ZS5tb2R1bG8odGhpcy5iaXRDb3VudEluSW50ZWdlcikudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHdoZXRoZXIgdGhlIGJpdCBvbiB0aGUgZ2l2ZW4gaW5kZXggaW4gdGhlIGJpdG1hcCBpcyBzZXQgdG8gMS5cbiAgICBpc0JpdFNldChpbmRleCkge1xuICAgICAgICAvLyBUbyByZXRyaWV2ZSBiaXQgbiwgY2FsY3VsYXRlOiAoYml0bWFwW24gLyA4XSAmICgweDAxIDw8IChuICUgOCkpKS5cbiAgICAgICAgY29uc3QgYnl0ZSA9IHRoaXMuYml0bWFwW01hdGguZmxvb3IoaW5kZXggLyA4KV07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGluZGV4ICUgODtcbiAgICAgICAgcmV0dXJuIChieXRlICYgKDB4MDEgPDwgb2Zmc2V0KSkgIT09IDA7XG4gICAgfVxuICAgIG1pZ2h0Q29udGFpbih2YWx1ZSkge1xuICAgICAgICAvLyBFbXB0eSBiaXRtYXAgc2hvdWxkIGFsd2F5cyByZXR1cm4gZmFsc2Ugb24gbWVtYmVyc2hpcCBjaGVjay5cbiAgICAgICAgaWYgKHRoaXMuYml0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZDVIYXNoZWRWYWx1ZSA9IGdldE1kNUhhc2hWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IFtoYXNoMSwgaGFzaDJdID0gZ2V0NjRCaXRVaW50cyhtZDVIYXNoZWRWYWx1ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5oYXNoQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEJpdEluZGV4KGhhc2gxLCBoYXNoMiwgaSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNCaXRTZXQoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIGJsb29tIGZpbHRlciBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LiAqL1xuICAgIHN0YXRpYyBjcmVhdGUoYml0Q291bnQsIGhhc2hDb3VudCwgY29udGFpbnMpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IGJpdENvdW50ICUgOCA9PT0gMCA/IDAgOiA4IC0gKGJpdENvdW50ICUgOCk7XG4gICAgICAgIGNvbnN0IGJpdG1hcCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChiaXRDb3VudCAvIDgpKTtcbiAgICAgICAgY29uc3QgYmxvb21GaWx0ZXIgPSBuZXcgQmxvb21GaWx0ZXIoYml0bWFwLCBwYWRkaW5nLCBoYXNoQ291bnQpO1xuICAgICAgICBjb250YWlucy5mb3JFYWNoKGl0ZW0gPT4gYmxvb21GaWx0ZXIuaW5zZXJ0KGl0ZW0pKTtcbiAgICAgICAgcmV0dXJuIGJsb29tRmlsdGVyO1xuICAgIH1cbiAgICBpbnNlcnQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYml0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZDVIYXNoZWRWYWx1ZSA9IGdldE1kNUhhc2hWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IFtoYXNoMSwgaGFzaDJdID0gZ2V0NjRCaXRVaW50cyhtZDVIYXNoZWRWYWx1ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5oYXNoQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEJpdEluZGV4KGhhc2gxLCBoYXNoMiwgaSk7XG4gICAgICAgICAgICB0aGlzLnNldEJpdChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Qml0KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZGV4T2ZCeXRlID0gTWF0aC5mbG9vcihpbmRleCAvIDgpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAlIDg7XG4gICAgICAgIHRoaXMuYml0bWFwW2luZGV4T2ZCeXRlXSB8PSAweDAxIDw8IG9mZnNldDtcbiAgICB9XG59XG5jbGFzcyBCbG9vbUZpbHRlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQmxvb21GaWx0ZXJFcnJvcic7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBldmVudCBmcm9tIHRoZSBSZW1vdGVTdG9yZS4gSXQgaXMgc3BsaXQgaW50byB0YXJnZXRDaGFuZ2VzIChjaGFuZ2VzIHRvIHRoZVxuICogc3RhdGUgb3IgdGhlIHNldCBvZiBkb2N1bWVudHMgaW4gb3VyIHdhdGNoZWQgdGFyZ2V0cykgYW5kIGRvY3VtZW50VXBkYXRlc1xuICogKGNoYW5nZXMgdG8gdGhlIGFjdHVhbCBkb2N1bWVudHMpLlxuICovXG5jbGFzcyBSZW1vdGVFdmVudCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIHNuYXBzaG90IHZlcnNpb24gdGhpcyBldmVudCBicmluZ3MgdXMgdXAgdG8sIG9yIE1JTiBpZiBub3Qgc2V0LlxuICAgICAqL1xuICAgIHNuYXBzaG90VmVyc2lvbiwgXG4gICAgLyoqXG4gICAgICogQSBtYXAgZnJvbSB0YXJnZXQgdG8gY2hhbmdlcyB0byB0aGUgdGFyZ2V0LiBTZWUgVGFyZ2V0Q2hhbmdlLlxuICAgICAqL1xuICAgIHRhcmdldENoYW5nZXMsIFxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIHRhcmdldHMgdGhhdCBpcyBrbm93biB0byBiZSBpbmNvbnNpc3RlbnQsIGFuZCB0aGUgcHVycG9zZSBmb3JcbiAgICAgKiByZS1saXN0ZW5pbmcuIExpc3RlbnMgZm9yIHRoZXNlIHRhcmdldHMgc2hvdWxkIGJlIHJlLWVzdGFibGlzaGVkIHdpdGhvdXRcbiAgICAgKiByZXN1bWUgdG9rZW5zLlxuICAgICAqL1xuICAgIHRhcmdldE1pc21hdGNoZXMsIFxuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHdoaWNoIGRvY3VtZW50cyBoYXZlIGNoYW5nZWQgb3IgYmVlbiBkZWxldGVkLCBhbG9uZyB3aXRoIHRoZVxuICAgICAqIGRvYydzIG5ldyB2YWx1ZXMgKGlmIG5vdCBkZWxldGVkKS5cbiAgICAgKi9cbiAgICBkb2N1bWVudFVwZGF0ZXMsIFxuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHdoaWNoIGRvY3VtZW50IHVwZGF0ZXMgYXJlIGR1ZSBvbmx5IHRvIGxpbWJvIHJlc29sdXRpb24gdGFyZ2V0cy5cbiAgICAgKi9cbiAgICByZXNvbHZlZExpbWJvRG9jdW1lbnRzKSB7XG4gICAgICAgIHRoaXMuc25hcHNob3RWZXJzaW9uID0gc25hcHNob3RWZXJzaW9uO1xuICAgICAgICB0aGlzLnRhcmdldENoYW5nZXMgPSB0YXJnZXRDaGFuZ2VzO1xuICAgICAgICB0aGlzLnRhcmdldE1pc21hdGNoZXMgPSB0YXJnZXRNaXNtYXRjaGVzO1xuICAgICAgICB0aGlzLmRvY3VtZW50VXBkYXRlcyA9IGRvY3VtZW50VXBkYXRlcztcbiAgICAgICAgdGhpcy5yZXNvbHZlZExpbWJvRG9jdW1lbnRzID0gcmVzb2x2ZWRMaW1ib0RvY3VtZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSEFDSzogVmlld3MgcmVxdWlyZSBSZW1vdGVFdmVudHMgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHZpZXcgaXNcbiAgICAgKiBDVVJSRU5ULCBidXQgc2Vjb25kYXJ5IHRhYnMgZG9uJ3QgcmVjZWl2ZSByZW1vdGUgZXZlbnRzLiBTbyB0aGlzIG1ldGhvZCBpc1xuICAgICAqIHVzZWQgdG8gY3JlYXRlIGEgc3ludGhlc2l6ZWQgUmVtb3RlRXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0byBhcHBseSBhXG4gICAgICogQ1VSUkVOVCBzdGF0dXMgY2hhbmdlIHRvIGEgVmlldywgZm9yIHF1ZXJpZXMgZXhlY3V0ZWQgaW4gYSBkaWZmZXJlbnQgdGFiLlxuICAgICAqL1xuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHlcbiAgICBzdGF0aWMgY3JlYXRlU3ludGhlc2l6ZWRSZW1vdGVFdmVudEZvckN1cnJlbnRDaGFuZ2UodGFyZ2V0SWQsIGN1cnJlbnQsIHJlc3VtZVRva2VuKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldENoYW5nZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRhcmdldENoYW5nZXMuc2V0KHRhcmdldElkLCBUYXJnZXRDaGFuZ2UuY3JlYXRlU3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2VGb3JDdXJyZW50Q2hhbmdlKHRhcmdldElkLCBjdXJyZW50LCByZXN1bWVUb2tlbikpO1xuICAgICAgICByZXR1cm4gbmV3IFJlbW90ZUV2ZW50KFNuYXBzaG90VmVyc2lvbi5taW4oKSwgdGFyZ2V0Q2hhbmdlcywgbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKSwgbXV0YWJsZURvY3VtZW50TWFwKCksIGRvY3VtZW50S2V5U2V0KCkpO1xuICAgIH1cbn1cbi8qKlxuICogQSBUYXJnZXRDaGFuZ2Ugc3BlY2lmaWVzIHRoZSBzZXQgb2YgY2hhbmdlcyBmb3IgYSBzcGVjaWZpYyB0YXJnZXQgYXMgcGFydCBvZlxuICogYSBSZW1vdGVFdmVudC4gVGhlc2UgY2hhbmdlcyB0cmFjayB3aGljaCBkb2N1bWVudHMgYXJlIGFkZGVkLCBtb2RpZmllZCBvclxuICogcmVtb3ZlZCwgYXMgd2VsbCBhcyB0aGUgdGFyZ2V0J3MgcmVzdW1lIHRva2VuIGFuZCB3aGV0aGVyIHRoZSB0YXJnZXQgaXNcbiAqIG1hcmtlZCBDVVJSRU5ULlxuICogVGhlIGFjdHVhbCBjaGFuZ2VzICp0byogZG9jdW1lbnRzIGFyZSBub3QgcGFydCBvZiB0aGUgVGFyZ2V0Q2hhbmdlIHNpbmNlXG4gKiBkb2N1bWVudHMgbWF5IGJlIHBhcnQgb2YgbXVsdGlwbGUgdGFyZ2V0cy5cbiAqL1xuY2xhc3MgVGFyZ2V0Q2hhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBBbiBvcGFxdWUsIHNlcnZlci1hc3NpZ25lZCB0b2tlbiB0aGF0IGFsbG93cyB3YXRjaGluZyBhIHF1ZXJ5IHRvIGJlIHJlc3VtZWRcbiAgICAgKiBhZnRlciBkaXNjb25uZWN0aW5nIHdpdGhvdXQgcmV0cmFuc21pdHRpbmcgYWxsIHRoZSBkYXRhIHRoYXQgbWF0Y2hlcyB0aGVcbiAgICAgKiBxdWVyeS4gVGhlIHJlc3VtZSB0b2tlbiBlc3NlbnRpYWxseSBpZGVudGlmaWVzIGEgcG9pbnQgaW4gdGltZSBmcm9tIHdoaWNoXG4gICAgICogdGhlIHNlcnZlciBzaG91bGQgcmVzdW1lIHNlbmRpbmcgcmVzdWx0cy5cbiAgICAgKi9cbiAgICByZXN1bWVUb2tlbiwgXG4gICAgLyoqXG4gICAgICogVGhlIFwiY3VycmVudFwiIChzeW5jZWQpIHN0YXR1cyBvZiB0aGlzIHRhcmdldC4gTm90ZSB0aGF0IFwiY3VycmVudFwiXG4gICAgICogaGFzIHNwZWNpYWwgbWVhbmluZyBpbiB0aGUgUlBDIHByb3RvY29sIHRoYXQgaW1wbGllcyB0aGF0IGEgdGFyZ2V0IGlzXG4gICAgICogYm90aCB1cC10by1kYXRlIGFuZCBjb25zaXN0ZW50IHdpdGggdGhlIHJlc3Qgb2YgdGhlIHdhdGNoIHN0cmVhbS5cbiAgICAgKi9cbiAgICBjdXJyZW50LCBcbiAgICAvKipcbiAgICAgKiBUaGUgc2V0IG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgbmV3bHkgYXNzaWduZWQgdG8gdGhpcyB0YXJnZXQgYXMgcGFydCBvZlxuICAgICAqIHRoaXMgcmVtb3RlIGV2ZW50LlxuICAgICAqL1xuICAgIGFkZGVkRG9jdW1lbnRzLCBcbiAgICAvKipcbiAgICAgKiBUaGUgc2V0IG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgYWxyZWFkeSBhc3NpZ25lZCB0byB0aGlzIHRhcmdldCBidXQgcmVjZWl2ZWRcbiAgICAgKiBhbiB1cGRhdGUgZHVyaW5nIHRoaXMgcmVtb3RlIGV2ZW50LlxuICAgICAqL1xuICAgIG1vZGlmaWVkRG9jdW1lbnRzLCBcbiAgICAvKipcbiAgICAgKiBUaGUgc2V0IG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgcmVtb3ZlZCBmcm9tIHRoaXMgdGFyZ2V0IGFzIHBhcnQgb2YgdGhpc1xuICAgICAqIHJlbW90ZSBldmVudC5cbiAgICAgKi9cbiAgICByZW1vdmVkRG9jdW1lbnRzKSB7XG4gICAgICAgIHRoaXMucmVzdW1lVG9rZW4gPSByZXN1bWVUb2tlbjtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgdGhpcy5hZGRlZERvY3VtZW50cyA9IGFkZGVkRG9jdW1lbnRzO1xuICAgICAgICB0aGlzLm1vZGlmaWVkRG9jdW1lbnRzID0gbW9kaWZpZWREb2N1bWVudHM7XG4gICAgICAgIHRoaXMucmVtb3ZlZERvY3VtZW50cyA9IHJlbW92ZWREb2N1bWVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gY3JlYXRlIGEgc3ludGhlc2l6ZWQgVGFyZ2V0Q2hhbmdlcyB0aGF0IGNhbiBiZSB1c2VkIHRvXG4gICAgICogYXBwbHkgYSBDVVJSRU5UIHN0YXR1cyBjaGFuZ2UgdG8gYSBWaWV3IChmb3IgcXVlcmllcyBleGVjdXRlZCBpbiBhIGRpZmZlcmVudFxuICAgICAqIHRhYikgb3IgZm9yIG5ldyBxdWVyaWVzICh0byByYWlzZSBzbmFwc2hvdHMgd2l0aCBjb3JyZWN0IENVUlJFTlQgc3RhdHVzKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2VGb3JDdXJyZW50Q2hhbmdlKHRhcmdldElkLCBjdXJyZW50LCByZXN1bWVUb2tlbikge1xuICAgICAgICByZXR1cm4gbmV3IFRhcmdldENoYW5nZShyZXN1bWVUb2tlbiwgY3VycmVudCwgZG9jdW1lbnRLZXlTZXQoKSwgZG9jdW1lbnRLZXlTZXQoKSwgZG9jdW1lbnRLZXlTZXQoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hhbmdlZCBkb2N1bWVudCBhbmQgYSBsaXN0IG9mIHRhcmdldCBpZHMgdG8gd2hpY2ggdGhpcyBjaGFuZ2VcbiAqIGFwcGxpZXMuXG4gKlxuICogSWYgZG9jdW1lbnQgaGFzIGJlZW4gZGVsZXRlZCBOb0RvY3VtZW50IHdpbGwgYmUgcHJvdmlkZWQuXG4gKi9cbmNsYXNzIERvY3VtZW50V2F0Y2hDaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgbmV3IGRvY3VtZW50IGFwcGxpZXMgdG8gYWxsIG9mIHRoZXNlIHRhcmdldHMuICovXG4gICAgdXBkYXRlZFRhcmdldElkcywgXG4gICAgLyoqIFRoZSBuZXcgZG9jdW1lbnQgaXMgcmVtb3ZlZCBmcm9tIGFsbCBvZiB0aGVzZSB0YXJnZXRzLiAqL1xuICAgIHJlbW92ZWRUYXJnZXRJZHMsIFxuICAgIC8qKiBUaGUga2V5IG9mIHRoZSBkb2N1bWVudCBmb3IgdGhpcyBjaGFuZ2UuICovXG4gICAga2V5LCBcbiAgICAvKipcbiAgICAgKiBUaGUgbmV3IGRvY3VtZW50IG9yIE5vRG9jdW1lbnQgaWYgaXQgd2FzIGRlbGV0ZWQuIElzIG51bGwgaWYgdGhlXG4gICAgICogZG9jdW1lbnQgd2VudCBvdXQgb2YgdmlldyB3aXRob3V0IHRoZSBzZXJ2ZXIgc2VuZGluZyBhIG5ldyBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBuZXdEb2MpIHtcbiAgICAgICAgdGhpcy51cGRhdGVkVGFyZ2V0SWRzID0gdXBkYXRlZFRhcmdldElkcztcbiAgICAgICAgdGhpcy5yZW1vdmVkVGFyZ2V0SWRzID0gcmVtb3ZlZFRhcmdldElkcztcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMubmV3RG9jID0gbmV3RG9jO1xuICAgIH1cbn1cbmNsYXNzIEV4aXN0ZW5jZUZpbHRlckNoYW5nZSB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0SWQsIGV4aXN0ZW5jZUZpbHRlcikge1xuICAgICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XG4gICAgICAgIHRoaXMuZXhpc3RlbmNlRmlsdGVyID0gZXhpc3RlbmNlRmlsdGVyO1xuICAgIH1cbn1cbmNsYXNzIFdhdGNoVGFyZ2V0Q2hhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogV2hhdCBraW5kIG9mIGNoYW5nZSBvY2N1cnJlZCB0byB0aGUgd2F0Y2ggdGFyZ2V0LiAqL1xuICAgIHN0YXRlLCBcbiAgICAvKiogVGhlIHRhcmdldCBJRHMgdGhhdCB3ZXJlIGFkZGVkL3JlbW92ZWQvc2V0LiAqL1xuICAgIHRhcmdldElkcywgXG4gICAgLyoqXG4gICAgICogQW4gb3BhcXVlLCBzZXJ2ZXItYXNzaWduZWQgdG9rZW4gdGhhdCBhbGxvd3Mgd2F0Y2hpbmcgYSB0YXJnZXQgdG8gYmVcbiAgICAgKiByZXN1bWVkIGFmdGVyIGRpc2Nvbm5lY3Rpbmcgd2l0aG91dCByZXRyYW5zbWl0dGluZyBhbGwgdGhlIGRhdGEgdGhhdFxuICAgICAqIG1hdGNoZXMgdGhlIHRhcmdldC4gVGhlIHJlc3VtZSB0b2tlbiBlc3NlbnRpYWxseSBpZGVudGlmaWVzIGEgcG9pbnQgaW5cbiAgICAgKiB0aW1lIGZyb20gd2hpY2ggdGhlIHNlcnZlciBzaG91bGQgcmVzdW1lIHNlbmRpbmcgcmVzdWx0cy5cbiAgICAgKi9cbiAgICByZXN1bWVUb2tlbiA9IEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcsIFxuICAgIC8qKiBBbiBSUEMgZXJyb3IgaW5kaWNhdGluZyB3aHkgdGhlIHdhdGNoIGZhaWxlZC4gKi9cbiAgICBjYXVzZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnRhcmdldElkcyA9IHRhcmdldElkcztcbiAgICAgICAgdGhpcy5yZXN1bWVUb2tlbiA9IHJlc3VtZVRva2VuO1xuICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgfVxufVxuLyoqIFRyYWNrcyB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgYSBXYXRjaCB0YXJnZXQuICovXG5jbGFzcyBUYXJnZXRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHBlbmRpbmcgcmVzcG9uc2VzIChhZGRzIG9yIHJlbW92ZXMpIHRoYXQgd2UgYXJlIHdhaXRpbmcgb24uXG4gICAgICAgICAqIFdlIG9ubHkgY29uc2lkZXIgdGFyZ2V0cyBhY3RpdmUgdGhhdCBoYXZlIG5vIHBlbmRpbmcgcmVzcG9uc2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBkb2N1bWVudCBjaGFuZ2VzIHNpbmNlIHRoZSBsYXN0IHJhaXNlZCBzbmFwc2hvdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlc2UgY2hhbmdlcyBhcmUgY29udGludW91c2x5IHVwZGF0ZWQgYXMgd2UgcmVjZWl2ZSBkb2N1bWVudCB1cGRhdGVzIGFuZFxuICAgICAgICAgKiBhbHdheXMgcmVmbGVjdCB0aGUgY3VycmVudCBzZXQgb2YgY2hhbmdlcyBhZ2FpbnN0IHRoZSBsYXN0IGlzc3VlZCBzbmFwc2hvdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZG9jdW1lbnRDaGFuZ2VzID0gc25hcHNob3RDaGFuZ2VzTWFwKCk7XG4gICAgICAgIC8qKiBTZWUgcHVibGljIGdldHRlcnMgZm9yIGV4cGxhbmF0aW9ucyBvZiB0aGVzZSBmaWVsZHMuICovXG4gICAgICAgIHRoaXMuX3Jlc3VtZVRva2VuID0gQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORztcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIHRhcmdldCBzdGF0ZSBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIG5leHQgc25hcHNob3QuIFdlXG4gICAgICAgICAqIGluaXRpYWxpemUgdG8gdHJ1ZSBzbyB0aGF0IG5ld2x5LWFkZGVkIHRhcmdldHMgYXJlIGluY2x1ZGVkIGluIHRoZSBuZXh0XG4gICAgICAgICAqIFJlbW90ZUV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgdGFyZ2V0IGhhcyBiZWVuIG1hcmtlZCAnY3VycmVudCcuXG4gICAgICpcbiAgICAgKiAnQ3VycmVudCcgaGFzIHNwZWNpYWwgbWVhbmluZyBpbiB0aGUgUlBDIHByb3RvY29sOiBJdCBpbXBsaWVzIHRoYXQgdGhlXG4gICAgICogV2F0Y2ggYmFja2VuZCBoYXMgc2VudCB1cyBhbGwgY2hhbmdlcyB1cCB0byB0aGUgcG9pbnQgYXQgd2hpY2ggdGhlIHRhcmdldFxuICAgICAqIHdhcyBhZGRlZCBhbmQgdGhhdCB0aGUgdGFyZ2V0IGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgcmVzdCBvZiB0aGUgd2F0Y2hcbiAgICAgKiBzdHJlYW0uXG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICAgIH1cbiAgICAvKiogVGhlIGxhc3QgcmVzdW1lIHRva2VuIHNlbnQgdG8gdXMgZm9yIHRoaXMgdGFyZ2V0LiAqL1xuICAgIGdldCByZXN1bWVUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VtZVRva2VuO1xuICAgIH1cbiAgICAvKiogV2hldGhlciB0aGlzIHRhcmdldCBoYXMgcGVuZGluZyB0YXJnZXQgYWRkcyBvciB0YXJnZXQgcmVtb3Zlcy4gKi9cbiAgICBnZXQgaXNQZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nUmVzcG9uc2VzICE9PSAwO1xuICAgIH1cbiAgICAvKiogV2hldGhlciB3ZSBoYXZlIG1vZGlmaWVkIGFueSBzdGF0ZSB0aGF0IHNob3VsZCB0cmlnZ2VyIGEgc25hcHNob3QuICovXG4gICAgZ2V0IGhhc1BlbmRpbmdDaGFuZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzUGVuZGluZ0NoYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIHJlc3VtZSB0b2tlbiB0byB0aGUgVGFyZ2V0Q2hhbmdlLCBidXQgb25seSB3aGVuIGl0IGhhcyBhIG5ld1xuICAgICAqIHZhbHVlLiBFbXB0eSByZXN1bWVUb2tlbnMgYXJlIGRpc2NhcmRlZC5cbiAgICAgKi9cbiAgICB1cGRhdGVSZXN1bWVUb2tlbihyZXN1bWVUb2tlbikge1xuICAgICAgICBpZiAocmVzdW1lVG9rZW4uYXBwcm94aW1hdGVCeXRlU2l6ZSgpID4gMCkge1xuICAgICAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVzdW1lVG9rZW4gPSByZXN1bWVUb2tlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGFyZ2V0IGNoYW5nZSBmcm9tIHRoZSBjdXJyZW50IHNldCBvZiBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogVG8gcmVzZXQgdGhlIGRvY3VtZW50IGNoYW5nZXMgYWZ0ZXIgcmFpc2luZyB0aGlzIHNuYXBzaG90LCBjYWxsXG4gICAgICogYGNsZWFyUGVuZGluZ0NoYW5nZXMoKWAuXG4gICAgICovXG4gICAgdG9UYXJnZXRDaGFuZ2UoKSB7XG4gICAgICAgIGxldCBhZGRlZERvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIGxldCBtb2RpZmllZERvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIGxldCByZW1vdmVkRG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudENoYW5nZXMuZm9yRWFjaCgoa2V5LCBjaGFuZ2VUeXBlKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYW5nZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgYWRkZWREb2N1bWVudHMgPSBhZGRlZERvY3VtZW50cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi86XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRG9jdW1lbnRzID0gbW9kaWZpZWREb2N1bWVudHMuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi86XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWREb2N1bWVudHMgPSByZW1vdmVkRG9jdW1lbnRzLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBmYWlsKDB4OTQ4MSwgeyBjaGFuZ2VUeXBlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXRDaGFuZ2UodGhpcy5fcmVzdW1lVG9rZW4sIHRoaXMuX2N1cnJlbnQsIGFkZGVkRG9jdW1lbnRzLCBtb2RpZmllZERvY3VtZW50cywgcmVtb3ZlZERvY3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgZG9jdW1lbnQgY2hhbmdlcyBhbmQgc2V0cyBgaGFzUGVuZGluZ0NoYW5nZXNgIHRvIGZhbHNlLlxuICAgICAqL1xuICAgIGNsZWFyUGVuZGluZ0NoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMuX2hhc1BlbmRpbmdDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRDaGFuZ2VzID0gc25hcHNob3RDaGFuZ2VzTWFwKCk7XG4gICAgfVxuICAgIGFkZERvY3VtZW50Q2hhbmdlKGtleSwgY2hhbmdlVHlwZSkge1xuICAgICAgICB0aGlzLl9oYXNQZW5kaW5nQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRDaGFuZ2VzID0gdGhpcy5kb2N1bWVudENoYW5nZXMuaW5zZXJ0KGtleSwgY2hhbmdlVHlwZSk7XG4gICAgfVxuICAgIHJlbW92ZURvY3VtZW50Q2hhbmdlKGtleSkge1xuICAgICAgICB0aGlzLl9oYXNQZW5kaW5nQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRDaGFuZ2VzID0gdGhpcy5kb2N1bWVudENoYW5nZXMucmVtb3ZlKGtleSk7XG4gICAgfVxuICAgIHJlY29yZFBlbmRpbmdUYXJnZXRSZXF1ZXN0KCkge1xuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMgKz0gMTtcbiAgICB9XG4gICAgcmVjb3JkVGFyZ2V0UmVzcG9uc2UoKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcyAtPSAxO1xuICAgICAgICBoYXJkQXNzZXJ0KHRoaXMucGVuZGluZ1Jlc3BvbnNlcyA+PSAwLCAweDBjYTksIHsgcGVuZGluZ1Jlc3BvbnNlczogdGhpcy5wZW5kaW5nUmVzcG9uc2VzIH0pO1xuICAgIH1cbiAgICBtYXJrQ3VycmVudCgpIHtcbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG59XG5jb25zdCBMT0dfVEFHJGcgPSAnV2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yJztcbi8qKlxuICogQSBoZWxwZXIgY2xhc3MgdG8gYWNjdW11bGF0ZSB3YXRjaCBjaGFuZ2VzIGludG8gYSBSZW1vdGVFdmVudC5cbiAqL1xuY2xhc3MgV2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGFQcm92aWRlciA9IG1ldGFkYXRhUHJvdmlkZXI7XG4gICAgICAgIC8qKiBUaGUgaW50ZXJuYWwgc3RhdGUgb2YgYWxsIHRyYWNrZWQgdGFyZ2V0cy4gKi9cbiAgICAgICAgdGhpcy50YXJnZXRTdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKiBLZWVwcyB0cmFjayBvZiB0aGUgZG9jdW1lbnRzIHRvIHVwZGF0ZSBzaW5jZSB0aGUgbGFzdCByYWlzZWQgc25hcHNob3QuICovXG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlcyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXNCeVRhcmdldCA9IGRvY3VtZW50VGFyZ2V0TWFwKCk7XG4gICAgICAgIC8qKiBBIG1hcHBpbmcgb2YgZG9jdW1lbnQga2V5cyB0byB0aGVpciBzZXQgb2YgdGFyZ2V0IElEcy4gKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID0gZG9jdW1lbnRUYXJnZXRNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIHRhcmdldHMgd2l0aCBleGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoZXMuIFRoZXNlIHRhcmdldHMgYXJlXG4gICAgICAgICAqIGtub3duIHRvIGJlIGluY29uc2lzdGVudCBhbmQgdGhlaXIgbGlzdGVucyBuZWVkcyB0byBiZSByZS1lc3RhYmxpc2hlZCBieVxuICAgICAgICAgKiBSZW1vdGVTdG9yZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVuZGluZ1RhcmdldFJlc2V0cyA9IG5ldyBTb3J0ZWRNYXAocHJpbWl0aXZlQ29tcGFyYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBhbmQgYWRkcyB0aGUgRG9jdW1lbnRXYXRjaENoYW5nZSB0byB0aGUgY3VycmVudCBzZXQgb2YgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVEb2N1bWVudENoYW5nZShkb2NDaGFuZ2UpIHtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiBkb2NDaGFuZ2UudXBkYXRlZFRhcmdldElkcykge1xuICAgICAgICAgICAgaWYgKGRvY0NoYW5nZS5uZXdEb2MgJiYgZG9jQ2hhbmdlLm5ld0RvYy5pc0ZvdW5kRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRG9jdW1lbnRUb1RhcmdldCh0YXJnZXRJZCwgZG9jQ2hhbmdlLm5ld0RvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwgZG9jQ2hhbmdlLmtleSwgZG9jQ2hhbmdlLm5ld0RvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiBkb2NDaGFuZ2UucmVtb3ZlZFRhcmdldElkcykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVEb2N1bWVudEZyb21UYXJnZXQodGFyZ2V0SWQsIGRvY0NoYW5nZS5rZXksIGRvY0NoYW5nZS5uZXdEb2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBQcm9jZXNzZXMgYW5kIGFkZHMgdGhlIFdhdGNoVGFyZ2V0Q2hhbmdlIHRvIHRoZSBjdXJyZW50IHNldCBvZiBjaGFuZ2VzLiAqL1xuICAgIGhhbmRsZVRhcmdldENoYW5nZSh0YXJnZXRDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoVGFyZ2V0KHRhcmdldENoYW5nZSwgdGFyZ2V0SWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0U3RhdGUgPSB0aGlzLmVuc3VyZVRhcmdldFN0YXRlKHRhcmdldElkKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFyZ2V0Q2hhbmdlLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuTm9DaGFuZ2UgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUudXBkYXRlUmVzdW1lVG9rZW4odGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5BZGRlZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBkZWNyZW1lbnQgdGhlIG51bWJlciBvZiBwZW5kaW5nIGFja3MgbmVlZGVkIGZyb20gd2F0Y2hcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRoaXMgdGFyZ2V0SWQuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLnJlY29yZFRhcmdldFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0U3RhdGUuaXNQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgZnJlc2hseSBhZGRlZCB0YXJnZXQsIHNvIHdlIG5lZWQgdG8gcmVzZXQgYW55IHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHdlIGhhZCBwcmV2aW91c2x5LiBUaGlzIGNhbiBoYXBwZW4gZS5nLiB3aGVuIHJlbW92ZSBhbmQgYWRkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiYWNrIGEgdGFyZ2V0IGZvciBleGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS5jbGVhclBlbmRpbmdDaGFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUudXBkYXRlUmVzdW1lVG9rZW4odGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVtb3ZlZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIHJlbW92ZWQgdGFyZ2V0cyB0byB3ZSBjYW4gcG9zdC1maWx0ZXIgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhbnkgdGFyZ2V0IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZGVjcmVtZW50IHRoZSBudW1iZXIgb2YgcGVuZGluZyBhY2tzIG5lZWRlZCBmcm9tIHdhdGNoXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciB0aGlzIHRhcmdldElkLlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS5yZWNvcmRUYXJnZXRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFN0YXRlLmlzUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLkN1cnJlbnQgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUubWFya0N1cnJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLnVwZGF0ZVJlc3VtZVRva2VuKHRhcmdldENoYW5nZS5yZXN1bWVUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVzZXQgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHRhcmdldCBhbmQgc3ludGhlc2l6ZXMgcmVtb3ZlcyBmb3IgYWxsIGV4aXN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb2N1bWVudHMuIFRoZSBiYWNrZW5kIHdpbGwgcmUtYWRkIGFueSBkb2N1bWVudHMgdGhhdCBzdGlsbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2ggdGhlIHRhcmdldCBiZWZvcmUgaXQgc2VuZHMgdGhlIG5leHQgZ2xvYmFsIHNuYXBzaG90LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldFRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS51cGRhdGVSZXN1bWVUb2tlbih0YXJnZXRDaGFuZ2UucmVzdW1lVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGZhaWwoMHhkZGQ2LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogdGFyZ2V0Q2hhbmdlLnN0YXRlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhbGwgdGFyZ2V0SWRzIHRoYXQgdGhlIHdhdGNoIGNoYW5nZSBhcHBsaWVzIHRvOiBlaXRoZXIgdGhlXG4gICAgICogdGFyZ2V0SWRzIGV4cGxpY2l0bHkgbGlzdGVkIGluIHRoZSBjaGFuZ2Ugb3IgdGhlIHRhcmdldElkcyBvZiBhbGwgY3VycmVudGx5XG4gICAgICogYWN0aXZlIHRhcmdldHMuXG4gICAgICovXG4gICAgZm9yRWFjaFRhcmdldCh0YXJnZXRDaGFuZ2UsIGZuKSB7XG4gICAgICAgIGlmICh0YXJnZXRDaGFuZ2UudGFyZ2V0SWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRhcmdldENoYW5nZS50YXJnZXRJZHMuZm9yRWFjaChmbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldFN0YXRlcy5mb3JFYWNoKChfLCB0YXJnZXRJZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgICAgICBmbih0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBleGlzdGVuY2UgZmlsdGVycyBhbmQgc3ludGhlc2l6ZXMgZGVsZXRlcyBmb3IgZmlsdGVyIG1pc21hdGNoZXMuXG4gICAgICogVGFyZ2V0cyB0aGF0IGFyZSBpbnZhbGlkYXRlZCBieSBmaWx0ZXIgbWlzbWF0Y2hlcyBhcmUgYWRkZWQgdG9cbiAgICAgKiBgcGVuZGluZ1RhcmdldFJlc2V0c2AuXG4gICAgICovXG4gICAgaGFuZGxlRXhpc3RlbmNlRmlsdGVyKHdhdGNoQ2hhbmdlKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gd2F0Y2hDaGFuZ2UudGFyZ2V0SWQ7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQ291bnQgPSB3YXRjaENoYW5nZS5leGlzdGVuY2VGaWx0ZXIuY291bnQ7XG4gICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSB0aGlzLnRhcmdldERhdGFGb3JBY3RpdmVUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICBpZiAodGFyZ2V0RGF0YSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0RGF0YS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAodGFyZ2V0SXNEb2N1bWVudFRhcmdldCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGV4aXN0ZW5jZSBmaWx0ZXIgdG9sZCB1cyB0aGUgZG9jdW1lbnQgZG9lcyBub3QgZXhpc3QuIFdlIGRlZHVjZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHRoaXMgZG9jdW1lbnQgZG9lcyBub3QgZXhpc3QgYW5kIGFwcGx5IGEgZGVsZXRlZCBkb2N1bWVudCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBvdXIgdXBkYXRlcy4gV2l0aG91dCBhcHBseWluZyB0aGlzIGRlbGV0ZWQgZG9jdW1lbnQgdGhlcmUgbWlnaHQgYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5vdGhlciBxdWVyeSB0aGF0IHdpbGwgcmFpc2UgdGhpcyBkb2N1bWVudCBhcyBwYXJ0IG9mIGEgc25hcHNob3RcbiAgICAgICAgICAgICAgICAgICAgLy8gdW50aWwgaXQgaXMgcmVzb2x2ZWQsIGVzc2VudGlhbGx5IGV4cG9zaW5nIGluY29uc2lzdGVuY3kgYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAvLyBxdWVyaWVzLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBuZXcgRG9jdW1lbnRLZXkodGFyZ2V0LnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwga2V5LCBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudChrZXksIFNuYXBzaG90VmVyc2lvbi5taW4oKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFyZEFzc2VydChleHBlY3RlZENvdW50ID09PSAxLCAweDRlMmQsIHsgZXhwZWN0ZWRDb3VudCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U2l6ZSA9IHRoaXMuZ2V0Q3VycmVudERvY3VtZW50Q291bnRGb3JUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgICAgIC8vIEV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2guIE1hcmsgdGhlIGRvY3VtZW50cyBhcyBiZWluZyBpbiBsaW1ibywgYW5kXG4gICAgICAgICAgICAgICAgLy8gcmFpc2UgYSBzbmFwc2hvdCB3aXRoIGBpc0Zyb21DYWNoZTp0cnVlYC5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNpemUgIT09IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgYmxvb20gZmlsdGVyIHRvIGlkZW50aWZ5IGFuZCBtYXJrIHJlbW92ZWQgZG9jdW1lbnRzLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9vbUZpbHRlciA9IHRoaXMucGFyc2VCbG9vbUZpbHRlcih3YXRjaENoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGJsb29tRmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuYXBwbHlCbG9vbUZpbHRlcihibG9vbUZpbHRlciwgd2F0Y2hDaGFuZ2UsIGN1cnJlbnRTaXplKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAxIC8qIEJsb29tRmlsdGVyQXBwbGljYXRpb25TdGF0dXMuU2tpcHBlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gMCAvKiBCbG9vbUZpbHRlckFwcGxpY2F0aW9uU3RhdHVzLlN1Y2Nlc3MgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGJsb29tIGZpbHRlciBhcHBsaWNhdGlvbiBmYWlscywgd2UgcmVzZXQgdGhlIG1hcHBpbmcgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIHJlLXJ1biBvZiB0aGUgcXVlcnkuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0VGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1cnBvc2UgPSBzdGF0dXMgPT09IDIgLyogQmxvb21GaWx0ZXJBcHBsaWNhdGlvblN0YXR1cy5GYWxzZVBvc2l0aXZlICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIlRhcmdldFB1cnBvc2VFeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaEJsb29tXCIgLyogVGFyZ2V0UHVycG9zZS5FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaEJsb29tICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlRhcmdldFB1cnBvc2VFeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaFwiIC8qIFRhcmdldFB1cnBvc2UuRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2ggKi87XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUYXJnZXRSZXNldHMgPSB0aGlzLnBlbmRpbmdUYXJnZXRSZXNldHMuaW5zZXJ0KHRhcmdldElkLCBwdXJwb3NlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ZXN0aW5nSG9va3NTcGk/Lm5vdGlmeU9uRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2goY3JlYXRlRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hJbmZvRm9yVGVzdGluZ0hvb2tzKGN1cnJlbnRTaXplLCB3YXRjaENoYW5nZS5leGlzdGVuY2VGaWx0ZXIsIHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXREYXRhYmFzZUlkKCksIGJsb29tRmlsdGVyLCBzdGF0dXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIGJsb29tIGZpbHRlciBmcm9tIHRoZSBcInVuY2hhbmdlZF9uYW1lc1wiIGZpZWxkIG9mIGFuIGV4aXN0ZW5jZVxuICAgICAqIGZpbHRlci5cbiAgICAgKi9cbiAgICBwYXJzZUJsb29tRmlsdGVyKHdhdGNoQ2hhbmdlKSB7XG4gICAgICAgIGNvbnN0IHVuY2hhbmdlZE5hbWVzID0gd2F0Y2hDaGFuZ2UuZXhpc3RlbmNlRmlsdGVyLnVuY2hhbmdlZE5hbWVzO1xuICAgICAgICBpZiAoIXVuY2hhbmdlZE5hbWVzIHx8ICF1bmNoYW5nZWROYW1lcy5iaXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGJpdHM6IHsgYml0bWFwID0gJycsIHBhZGRpbmcgPSAwIH0sIGhhc2hDb3VudCA9IDAgfSA9IHVuY2hhbmdlZE5hbWVzO1xuICAgICAgICBsZXQgbm9ybWFsaXplZEJpdG1hcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRCaXRtYXAgPSBub3JtYWxpemVCeXRlU3RyaW5nKGJpdG1hcCkudG9VaW50OEFycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEJhc2U2NERlY29kZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nV2FybignRGVjb2RpbmcgdGhlIGJhc2U2NCBibG9vbSBmaWx0ZXIgaW4gZXhpc3RlbmNlIGZpbHRlciBmYWlsZWQgKCcgK1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSArXG4gICAgICAgICAgICAgICAgICAgICcpOyBpZ25vcmluZyB0aGUgYmxvb20gZmlsdGVyIGFuZCBmYWxsaW5nIGJhY2sgdG8gZnVsbCByZS1xdWVyeS4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYmxvb21GaWx0ZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBCbG9vbUZpbHRlciB0aHJvd3MgZXJyb3IgaWYgdGhlIGlucHV0cyBhcmUgaW52YWxpZC5cbiAgICAgICAgICAgIGJsb29tRmlsdGVyID0gbmV3IEJsb29tRmlsdGVyKG5vcm1hbGl6ZWRCaXRtYXAsIHBhZGRpbmcsIGhhc2hDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEJsb29tRmlsdGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dXYXJuKCdCbG9vbUZpbHRlciBlcnJvcjogJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ1dhcm4oJ0FwcGx5aW5nIGJsb29tIGZpbHRlciBmYWlsZWQ6ICcsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvb21GaWx0ZXIuYml0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9vbUZpbHRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkgYmxvb20gZmlsdGVyIHRvIHJlbW92ZSB0aGUgZGVsZXRlZCBkb2N1bWVudHMsIGFuZCByZXR1cm4gdGhlXG4gICAgICogYXBwbGljYXRpb24gc3RhdHVzLlxuICAgICAqL1xuICAgIGFwcGx5Qmxvb21GaWx0ZXIoYmxvb21GaWx0ZXIsIHdhdGNoQ2hhbmdlLCBjdXJyZW50Q291bnQpIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRDb3VudCA9IHdhdGNoQ2hhbmdlLmV4aXN0ZW5jZUZpbHRlci5jb3VudDtcbiAgICAgICAgY29uc3QgcmVtb3ZlZERvY3VtZW50Q291bnQgPSB0aGlzLmZpbHRlclJlbW92ZWREb2N1bWVudHMoYmxvb21GaWx0ZXIsIHdhdGNoQ2hhbmdlLnRhcmdldElkKTtcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkQ291bnQgPT09IGN1cnJlbnRDb3VudCAtIHJlbW92ZWREb2N1bWVudENvdW50XG4gICAgICAgICAgICA/IDAgLyogQmxvb21GaWx0ZXJBcHBsaWNhdGlvblN0YXR1cy5TdWNjZXNzICovXG4gICAgICAgICAgICA6IDIgLyogQmxvb21GaWx0ZXJBcHBsaWNhdGlvblN0YXR1cy5GYWxzZVBvc2l0aXZlICovO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgb3V0IHJlbW92ZWQgZG9jdW1lbnRzIGJhc2VkIG9uIGJsb29tIGZpbHRlciBtZW1iZXJzaGlwIHJlc3VsdCBhbmRcbiAgICAgKiByZXR1cm4gbnVtYmVyIG9mIGRvY3VtZW50cyByZW1vdmVkLlxuICAgICAqL1xuICAgIGZpbHRlclJlbW92ZWREb2N1bWVudHMoYmxvb21GaWx0ZXIsIHRhcmdldElkKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgbGV0IHJlbW92YWxDb3VudCA9IDA7XG4gICAgICAgIGV4aXN0aW5nS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gdGhpcy5tZXRhZGF0YVByb3ZpZGVyLmdldERhdGFiYXNlSWQoKTtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50UGF0aCA9IGBwcm9qZWN0cy8ke2RhdGFiYXNlSWQucHJvamVjdElkfWAgK1xuICAgICAgICAgICAgICAgIGAvZGF0YWJhc2VzLyR7ZGF0YWJhc2VJZC5kYXRhYmFzZX1gICtcbiAgICAgICAgICAgICAgICBgL2RvY3VtZW50cy8ke2tleS5wYXRoLmNhbm9uaWNhbFN0cmluZygpfWA7XG4gICAgICAgICAgICBpZiAoIWJsb29tRmlsdGVyLm1pZ2h0Q29udGFpbihkb2N1bWVudFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEb2N1bWVudEZyb21UYXJnZXQodGFyZ2V0SWQsIGtleSwgLyp1cGRhdGVkRG9jdW1lbnQ9Ki8gbnVsbCk7XG4gICAgICAgICAgICAgICAgcmVtb3ZhbENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVtb3ZhbENvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY3VycmVudGx5IGFjY3VtdWxhdGVkIHN0YXRlIGludG8gYSByZW1vdGUgZXZlbnQgYXQgdGhlXG4gICAgICogcHJvdmlkZWQgc25hcHNob3QgdmVyc2lvbi4gUmVzZXRzIHRoZSBhY2N1bXVsYXRlZCBjaGFuZ2VzIGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICovXG4gICAgY3JlYXRlUmVtb3RlRXZlbnQoc25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldENoYW5nZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudGFyZ2V0U3RhdGVzLmZvckVhY2goKHRhcmdldFN0YXRlLCB0YXJnZXRJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IHRoaXMudGFyZ2V0RGF0YUZvckFjdGl2ZVRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRTdGF0ZS5jdXJyZW50ICYmIHRhcmdldElzRG9jdW1lbnRUYXJnZXQodGFyZ2V0RGF0YS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IHF1ZXJpZXMgZm9yIGRvY3VtZW50IHRoYXQgZG9uJ3QgZXhpc3QgY2FuIHByb2R1Y2UgYW4gZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0IHNldC4gVG8gdXBkYXRlIG91ciBsb2NhbCBjYWNoZSwgd2Ugc3ludGhlc2l6ZSBhIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBpZiB3ZSBoYXZlIG5vdCBwcmV2aW91c2x5IHJlY2VpdmVkIHRoZSBkb2N1bWVudCBmb3IgdGhpc1xuICAgICAgICAgICAgICAgICAgICAvLyB0YXJnZXQuIFRoaXMgcmVzb2x2ZXMgdGhlIGxpbWJvIHN0YXRlIG9mIHRoZSBkb2N1bWVudCwgcmVtb3ZpbmcgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSBsaW1ib0RvY3VtZW50UmVmcy5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiBJZGVhbGx5IHdlIHdvdWxkIGhhdmUgYW4gZXhwbGljaXQgbG9va3VwIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIHJlc3VsdGluZyBpbiBhbiBleHBsaWNpdCBkZWxldGUgbWVzc2FnZSBhbmQgd2UgY291bGRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoaXMgc3BlY2lhbCBsb2dpYy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gbmV3IERvY3VtZW50S2V5KHRhcmdldERhdGEudGFyZ2V0LnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZW5zdXJlRG9jdW1lbnRVcGRhdGVCeVRhcmdldChrZXkpLmhhcyh0YXJnZXRJZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLnRhcmdldENvbnRhaW5zRG9jdW1lbnQodGFyZ2V0SWQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnRGcm9tVGFyZ2V0KHRhcmdldElkLCBrZXksIE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGtleSwgc25hcHNob3RWZXJzaW9uKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFN0YXRlLmhhc1BlbmRpbmdDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENoYW5nZXMuc2V0KHRhcmdldElkLCB0YXJnZXRTdGF0ZS50b1RhcmdldENoYW5nZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUuY2xlYXJQZW5kaW5nQ2hhbmdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZXNvbHZlZExpbWJvRG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgLy8gV2UgZXh0cmFjdCB0aGUgc2V0IG9mIGxpbWJvLW9ubHkgZG9jdW1lbnQgdXBkYXRlcyBhcyB0aGUgR0MgbG9naWNcbiAgICAgICAgLy8gc3BlY2lhbC1jYXNlcyBkb2N1bWVudHMgdGhhdCBkbyBub3QgYXBwZWFyIGluIHRoZSB0YXJnZXQgY2FjaGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRPRE8oZ3NvbHRpcyk6IEV4cGFuZCBvbiB0aGlzIGNvbW1lbnQgb25jZSBHQyBpcyBhdmFpbGFibGUgaW4gdGhlIEpTXG4gICAgICAgIC8vIGNsaWVudC5cbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nLmZvckVhY2goKGtleSwgdGFyZ2V0cykgPT4ge1xuICAgICAgICAgICAgbGV0IGlzT25seUxpbWJvVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRhcmdldHMuZm9yRWFjaFdoaWxlKHRhcmdldElkID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gdGhpcy50YXJnZXREYXRhRm9yQWN0aXZlVGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXREYXRhLnB1cnBvc2UgIT09IFwiVGFyZ2V0UHVycG9zZUxpbWJvUmVzb2x1dGlvblwiIC8qIFRhcmdldFB1cnBvc2UuTGltYm9SZXNvbHV0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzT25seUxpbWJvVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc09ubHlMaW1ib1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkTGltYm9Eb2N1bWVudHMgPSByZXNvbHZlZExpbWJvRG9jdW1lbnRzLmFkZChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzLmZvckVhY2goKF8sIGRvYykgPT4gZG9jLnNldFJlYWRUaW1lKHNuYXBzaG90VmVyc2lvbikpO1xuICAgICAgICBjb25zdCByZW1vdGVFdmVudCA9IG5ldyBSZW1vdGVFdmVudChzbmFwc2hvdFZlcnNpb24sIHRhcmdldENoYW5nZXMsIHRoaXMucGVuZGluZ1RhcmdldFJlc2V0cywgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzLCByZXNvbHZlZExpbWJvRG9jdW1lbnRzKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlc0J5VGFyZ2V0ID0gZG9jdW1lbnRUYXJnZXRNYXAoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID0gZG9jdW1lbnRUYXJnZXRNYXAoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nVGFyZ2V0UmVzZXRzID0gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZUV2ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBwcm92aWRlZCBkb2N1bWVudCB0byB0aGUgaW50ZXJuYWwgbGlzdCBvZiBkb2N1bWVudCB1cGRhdGVzIGFuZFxuICAgICAqIGl0cyBkb2N1bWVudCBrZXkgdG8gdGhlIGdpdmVuIHRhcmdldCdzIG1hcHBpbmcuXG4gICAgICovXG4gICAgLy8gVmlzaWJsZSBmb3IgdGVzdGluZy5cbiAgICBhZGREb2N1bWVudFRvVGFyZ2V0KHRhcmdldElkLCBkb2N1bWVudCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlVHlwZSA9IHRoaXMudGFyZ2V0Q29udGFpbnNEb2N1bWVudCh0YXJnZXRJZCwgZG9jdW1lbnQua2V5KVxuICAgICAgICAgICAgPyAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi9cbiAgICAgICAgICAgIDogMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovO1xuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xuICAgICAgICB0YXJnZXRTdGF0ZS5hZGREb2N1bWVudENoYW5nZShkb2N1bWVudC5rZXksIGNoYW5nZVR5cGUpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMuaW5zZXJ0KGRvY3VtZW50LmtleSwgZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXNCeVRhcmdldCA9XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXNCeVRhcmdldC5pbnNlcnQoZG9jdW1lbnQua2V5LCB0aGlzLmVuc3VyZURvY3VtZW50VXBkYXRlQnlUYXJnZXQoZG9jdW1lbnQua2V5KS5hZGQodGFyZ2V0SWQpKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID1cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZy5pbnNlcnQoZG9jdW1lbnQua2V5LCB0aGlzLmVuc3VyZURvY3VtZW50VGFyZ2V0TWFwcGluZyhkb2N1bWVudC5rZXkpLmFkZCh0YXJnZXRJZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm92aWRlZCBkb2N1bWVudCBmcm9tIHRoZSB0YXJnZXQgbWFwcGluZy4gSWYgdGhlXG4gICAgICogZG9jdW1lbnQgbm8gbG9uZ2VyIG1hdGNoZXMgdGhlIHRhcmdldCwgYnV0IHRoZSBkb2N1bWVudCdzIHN0YXRlIGlzIHN0aWxsXG4gICAgICoga25vd24gKGUuZy4gd2Uga25vdyB0aGF0IHRoZSBkb2N1bWVudCB3YXMgZGVsZXRlZCBvciB3ZSByZWNlaXZlZCB0aGUgY2hhbmdlXG4gICAgICogdGhhdCBjYXVzZWQgdGhlIGZpbHRlciBtaXNtYXRjaCksIHRoZSBuZXcgZG9jdW1lbnQgY2FuIGJlIHByb3ZpZGVkXG4gICAgICogdG8gdXBkYXRlIHRoZSByZW1vdGUgZG9jdW1lbnQgY2FjaGUuXG4gICAgICovXG4gICAgLy8gVmlzaWJsZSBmb3IgdGVzdGluZy5cbiAgICByZW1vdmVEb2N1bWVudEZyb21UYXJnZXQodGFyZ2V0SWQsIGtleSwgdXBkYXRlZERvY3VtZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZVRhcmdldCh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xuICAgICAgICBpZiAodGhpcy50YXJnZXRDb250YWluc0RvY3VtZW50KHRhcmdldElkLCBrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXRTdGF0ZS5hZGREb2N1bWVudENoYW5nZShrZXksIDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBkb2N1bWVudCBtYXkgaGF2ZSBlbnRlcmVkIGFuZCBsZWZ0IHRoZSB0YXJnZXQgYmVmb3JlIHdlIHJhaXNlZCBhXG4gICAgICAgICAgICAvLyBzbmFwc2hvdCwgc28gd2UgY2FuIGp1c3QgaWdub3JlIHRoZSBjaGFuZ2UuXG4gICAgICAgICAgICB0YXJnZXRTdGF0ZS5yZW1vdmVEb2N1bWVudENoYW5nZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZyA9XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcuaW5zZXJ0KGtleSwgdGhpcy5lbnN1cmVEb2N1bWVudFRhcmdldE1hcHBpbmcoa2V5KS5kZWxldGUodGFyZ2V0SWQpKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID1cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZy5pbnNlcnQoa2V5LCB0aGlzLmVuc3VyZURvY3VtZW50VGFyZ2V0TWFwcGluZyhrZXkpLmFkZCh0YXJnZXRJZCkpO1xuICAgICAgICBpZiAodXBkYXRlZERvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMuaW5zZXJ0KGtleSwgdXBkYXRlZERvY3VtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgdGhpcy50YXJnZXRTdGF0ZXMuZGVsZXRlKHRhcmdldElkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBjb3VudCBvZiBkb2N1bWVudHMgaW4gdGhlIHRhcmdldC4gVGhpcyBpbmNsdWRlcyBib3RoXG4gICAgICogdGhlIG51bWJlciBvZiBkb2N1bWVudHMgdGhhdCB0aGUgTG9jYWxTdG9yZSBjb25zaWRlcnMgdG8gYmUgcGFydCBvZiB0aGVcbiAgICAgKiB0YXJnZXQgYXMgd2VsbCBhcyBhbnkgYWNjdW11bGF0ZWQgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBnZXRDdXJyZW50RG9jdW1lbnRDb3VudEZvclRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xuICAgICAgICBjb25zdCB0YXJnZXRDaGFuZ2UgPSB0YXJnZXRTdGF0ZS50b1RhcmdldENoYW5nZSgpO1xuICAgICAgICByZXR1cm4gKHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHRhcmdldElkKS5zaXplICtcbiAgICAgICAgICAgIHRhcmdldENoYW5nZS5hZGRlZERvY3VtZW50cy5zaXplIC1cbiAgICAgICAgICAgIHRhcmdldENoYW5nZS5yZW1vdmVkRG9jdW1lbnRzLnNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmNyZW1lbnQgdGhlIG51bWJlciBvZiBhY2tzIG5lZWRlZCBmcm9tIHdhdGNoIGJlZm9yZSB3ZSBjYW4gY29uc2lkZXIgdGhlXG4gICAgICogc2VydmVyIHRvIGJlICdpbi1zeW5jJyB3aXRoIHRoZSBjbGllbnQncyBhY3RpdmUgdGFyZ2V0cy5cbiAgICAgKi9cbiAgICByZWNvcmRQZW5kaW5nVGFyZ2V0UmVxdWVzdCh0YXJnZXRJZCkge1xuICAgICAgICAvLyBGb3IgZWFjaCByZXF1ZXN0IHdlIGdldCB3ZSBuZWVkIHRvIHJlY29yZCB3ZSBuZWVkIGEgcmVzcG9uc2UgZm9yIGl0LlxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xuICAgICAgICB0YXJnZXRTdGF0ZS5yZWNvcmRQZW5kaW5nVGFyZ2V0UmVxdWVzdCgpO1xuICAgIH1cbiAgICBlbnN1cmVUYXJnZXRTdGF0ZSh0YXJnZXRJZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy50YXJnZXRTdGF0ZXMuZ2V0KHRhcmdldElkKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUYXJnZXRTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRTdGF0ZXMuc2V0KHRhcmdldElkLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuc3VyZURvY3VtZW50VGFyZ2V0TWFwcGluZyhrZXkpIHtcbiAgICAgICAgbGV0IHRhcmdldE1hcHBpbmcgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcuZ2V0KGtleSk7XG4gICAgICAgIGlmICghdGFyZ2V0TWFwcGluZykge1xuICAgICAgICAgICAgdGFyZ2V0TWFwcGluZyA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcgPVxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZy5pbnNlcnQoa2V5LCB0YXJnZXRNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0TWFwcGluZztcbiAgICB9XG4gICAgZW5zdXJlRG9jdW1lbnRVcGRhdGVCeVRhcmdldChrZXkpIHtcbiAgICAgICAgbGV0IHRhcmdldE1hcHBpbmcgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXNCeVRhcmdldC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCF0YXJnZXRNYXBwaW5nKSB7XG4gICAgICAgICAgICB0YXJnZXRNYXBwaW5nID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlc0J5VGFyZ2V0ID1cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXNCeVRhcmdldC5pbnNlcnQoa2V5LCB0YXJnZXRNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0TWFwcGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhhdCB0aGUgdXNlciBpcyBzdGlsbCBpbnRlcmVzdGVkIGluIHRoaXMgdGFyZ2V0IChieSBjYWxsaW5nXG4gICAgICogYGdldFRhcmdldERhdGFGb3JUYXJnZXQoKWApIGFuZCB0aGF0IHdlIGFyZSBub3Qgd2FpdGluZyBmb3IgcGVuZGluZyBBRERzXG4gICAgICogZnJvbSB3YXRjaC5cbiAgICAgKi9cbiAgICBpc0FjdGl2ZVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCB0YXJnZXRBY3RpdmUgPSB0aGlzLnRhcmdldERhdGFGb3JBY3RpdmVUYXJnZXQodGFyZ2V0SWQpICE9PSBudWxsO1xuICAgICAgICBpZiAoIXRhcmdldEFjdGl2ZSkge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRnLCAnRGV0ZWN0ZWQgaW5hY3RpdmUgdGFyZ2V0JywgdGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRBY3RpdmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRhcmdldERhdGEgZm9yIGFuIGFjdGl2ZSB0YXJnZXQgKGkuZS4gYSB0YXJnZXQgdGhhdCB0aGUgdXNlclxuICAgICAqIGlzIHN0aWxsIGludGVyZXN0ZWQgaW4gdGhhdCBoYXMgbm8gb3V0c3RhbmRpbmcgdGFyZ2V0IGNoYW5nZSByZXF1ZXN0cykuXG4gICAgICovXG4gICAgdGFyZ2V0RGF0YUZvckFjdGl2ZVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMudGFyZ2V0U3RhdGVzLmdldCh0YXJnZXRJZCk7XG4gICAgICAgIHJldHVybiB0YXJnZXRTdGF0ZSAmJiB0YXJnZXRTdGF0ZS5pc1BlbmRpbmdcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiB0aGlzLm1ldGFkYXRhUHJvdmlkZXIuZ2V0VGFyZ2V0RGF0YUZvclRhcmdldCh0YXJnZXRJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgc3RhdGUgb2YgYSBXYXRjaCB0YXJnZXQgdG8gaXRzIGluaXRpYWwgc3RhdGUgKGUuZy4gc2V0c1xuICAgICAqICdjdXJyZW50JyB0byBmYWxzZSwgY2xlYXJzIHRoZSByZXN1bWUgdG9rZW4gYW5kIHJlbW92ZXMgaXRzIHRhcmdldCBtYXBwaW5nXG4gICAgICogZnJvbSBhbGwgZG9jdW1lbnRzKS5cbiAgICAgKi9cbiAgICByZXNldFRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLnRhcmdldFN0YXRlcy5zZXQodGFyZ2V0SWQsIG5ldyBUYXJnZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gVHJpZ2dlciByZW1vdmFsIGZvciBhbnkgZG9jdW1lbnRzIGN1cnJlbnRseSBtYXBwZWQgdG8gdGhpcyB0YXJnZXQuXG4gICAgICAgIC8vIFRoZXNlIHJlbW92YWxzIHdpbGwgYmUgcGFydCBvZiB0aGUgaW5pdGlhbCBzbmFwc2hvdCBpZiBXYXRjaCBkb2VzIG5vdFxuICAgICAgICAvLyByZXNlbmQgdGhlc2UgZG9jdW1lbnRzLlxuICAgICAgICBjb25zdCBleGlzdGluZ0tleXMgPSB0aGlzLm1ldGFkYXRhUHJvdmlkZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgIGV4aXN0aW5nS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwga2V5LCAvKnVwZGF0ZWREb2N1bWVudD0qLyBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgTG9jYWxTdG9yZSBjb25zaWRlcnMgdGhlIGRvY3VtZW50IHRvIGJlIHBhcnQgb2YgdGhlXG4gICAgICogc3BlY2lmaWVkIHRhcmdldC5cbiAgICAgKi9cbiAgICB0YXJnZXRDb250YWluc0RvY3VtZW50KHRhcmdldElkLCBrZXkpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdLZXlzID0gdGhpcy5tZXRhZGF0YVByb3ZpZGVyLmdldFJlbW90ZUtleXNGb3JUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdLZXlzLmhhcyhrZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRvY3VtZW50VGFyZ2V0TWFwKCkge1xuICAgIHJldHVybiBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xufVxuZnVuY3Rpb24gc25hcHNob3RDaGFuZ2VzTWFwKCkge1xuICAgIHJldHVybiBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xufVxuZnVuY3Rpb24gY3JlYXRlRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hJbmZvRm9yVGVzdGluZ0hvb2tzKGxvY2FsQ2FjaGVDb3VudCwgZXhpc3RlbmNlRmlsdGVyLCBkYXRhYmFzZUlkLCBibG9vbUZpbHRlciwgYmxvb21GaWx0ZXJTdGF0dXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGxvY2FsQ2FjaGVDb3VudCxcbiAgICAgICAgZXhpc3RlbmNlRmlsdGVyQ291bnQ6IGV4aXN0ZW5jZUZpbHRlci5jb3VudCxcbiAgICAgICAgZGF0YWJhc2VJZDogZGF0YWJhc2VJZC5kYXRhYmFzZSxcbiAgICAgICAgcHJvamVjdElkOiBkYXRhYmFzZUlkLnByb2plY3RJZFxuICAgIH07XG4gICAgY29uc3QgdW5jaGFuZ2VkTmFtZXMgPSBleGlzdGVuY2VGaWx0ZXIudW5jaGFuZ2VkTmFtZXM7XG4gICAgaWYgKHVuY2hhbmdlZE5hbWVzKSB7XG4gICAgICAgIHJlc3VsdC5ibG9vbUZpbHRlciA9IHtcbiAgICAgICAgICAgIGFwcGxpZWQ6IGJsb29tRmlsdGVyU3RhdHVzID09PSAwIC8qIEJsb29tRmlsdGVyQXBwbGljYXRpb25TdGF0dXMuU3VjY2VzcyAqLyxcbiAgICAgICAgICAgIGhhc2hDb3VudDogdW5jaGFuZ2VkTmFtZXM/Lmhhc2hDb3VudCA/PyAwLFxuICAgICAgICAgICAgYml0bWFwTGVuZ3RoOiB1bmNoYW5nZWROYW1lcz8uYml0cz8uYml0bWFwPy5sZW5ndGggPz8gMCxcbiAgICAgICAgICAgIHBhZGRpbmc6IHVuY2hhbmdlZE5hbWVzPy5iaXRzPy5wYWRkaW5nID8/IDAsXG4gICAgICAgICAgICBtaWdodENvbnRhaW46ICh2YWx1ZSkgPT4gYmxvb21GaWx0ZXI/Lm1pZ2h0Q29udGFpbih2YWx1ZSkgPz8gZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERJUkVDVElPTlMgPSAoKCkgPT4ge1xuICAgIGNvbnN0IGRpcnMgPSB7fTtcbiAgICBkaXJzW1wiYXNjXCIgLyogRGlyZWN0aW9uLkFTQ0VORElORyAqL10gPSAnQVNDRU5ESU5HJztcbiAgICBkaXJzW1wiZGVzY1wiIC8qIERpcmVjdGlvbi5ERVNDRU5ESU5HICovXSA9ICdERVNDRU5ESU5HJztcbiAgICByZXR1cm4gZGlycztcbn0pKCk7XG5jb25zdCBPUEVSQVRPUlMgPSAoKCkgPT4ge1xuICAgIGNvbnN0IG9wcyA9IHt9O1xuICAgIG9wc1tcIjxcIiAvKiBPcGVyYXRvci5MRVNTX1RIQU4gKi9dID0gJ0xFU1NfVEhBTic7XG4gICAgb3BzW1wiPD1cIiAvKiBPcGVyYXRvci5MRVNTX1RIQU5fT1JfRVFVQUwgKi9dID0gJ0xFU1NfVEhBTl9PUl9FUVVBTCc7XG4gICAgb3BzW1wiPlwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTiAqL10gPSAnR1JFQVRFUl9USEFOJztcbiAgICBvcHNbXCI+PVwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTl9PUl9FUVVBTCAqL10gPSAnR1JFQVRFUl9USEFOX09SX0VRVUFMJztcbiAgICBvcHNbXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovXSA9ICdFUVVBTCc7XG4gICAgb3BzW1wiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi9dID0gJ05PVF9FUVVBTCc7XG4gICAgb3BzW1wiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqL10gPSAnQVJSQVlfQ09OVEFJTlMnO1xuICAgIG9wc1tcImluXCIgLyogT3BlcmF0b3IuSU4gKi9dID0gJ0lOJztcbiAgICBvcHNbXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi9dID0gJ05PVF9JTic7XG4gICAgb3BzW1wiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovXSA9ICdBUlJBWV9DT05UQUlOU19BTlknO1xuICAgIHJldHVybiBvcHM7XG59KSgpO1xuY29uc3QgQ09NUE9TSVRFX09QRVJBVE9SUyA9ICgoKSA9PiB7XG4gICAgY29uc3Qgb3BzID0ge307XG4gICAgb3BzW1wiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovXSA9ICdBTkQnO1xuICAgIG9wc1tcIm9yXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuT1IgKi9dID0gJ09SJztcbiAgICByZXR1cm4gb3BzO1xufSkoKTtcbmZ1bmN0aW9uIGFzc2VydFByZXNlbnQodmFsdWUsIGRlc2NyaXB0aW9uKSB7XG59XG4vKipcbiAqIFRoaXMgY2xhc3MgZ2VuZXJhdGVzIEpzb25PYmplY3QgdmFsdWVzIGZvciB0aGUgRGF0YXN0b3JlIEFQSSBzdWl0YWJsZSBmb3JcbiAqIHNlbmRpbmcgdG8gZWl0aGVyIEdSUEMgc3R1YiBtZXRob2RzIG9yIHZpYSB0aGUgSlNPTi9IVFRQIFJFU1QgQVBJLlxuICpcbiAqIFRoZSBzZXJpYWxpemVyIHN1cHBvcnRzIGJvdGggUHJvdG9idWYuanMgYW5kIFByb3RvMyBKU09OIGZvcm1hdHMuIEJ5XG4gKiBzZXR0aW5nIGB1c2VQcm90bzNKc29uYCB0byB0cnVlLCB0aGUgc2VyaWFsaXplciB3aWxsIHVzZSB0aGUgUHJvdG8zIEpTT05cbiAqIGZvcm1hdC5cbiAqXG4gKiBGb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgUHJvdG8zIEpTT04gZm9ybWF0IGNoZWNrXG4gKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvcHJvdG8zI2pzb25cbiAqXG4gKiBUT0RPKGtsaW10KTogV2UgY2FuIHJlbW92ZSB0aGUgZGF0YWJhc2VJZCBhcmd1bWVudCBpZiB3ZSBrZWVwIHRoZSBmdWxsXG4gKiByZXNvdXJjZSBuYW1lIGluIGRvY3VtZW50cy5cbiAqL1xuY2xhc3MgSnNvblByb3RvU2VyaWFsaXplciB7XG4gICAgY29uc3RydWN0b3IoZGF0YWJhc2VJZCwgdXNlUHJvdG8zSnNvbikge1xuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBkYXRhYmFzZUlkO1xuICAgICAgICB0aGlzLnVzZVByb3RvM0pzb24gPSB1c2VQcm90bzNKc29uO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21ScGNTdGF0dXMoc3RhdHVzKSB7XG4gICAgY29uc3QgY29kZSA9IHN0YXR1cy5jb2RlID09PSB1bmRlZmluZWQgPyBDb2RlLlVOS05PV04gOiBtYXBDb2RlRnJvbVJwY0NvZGUoc3RhdHVzLmNvZGUpO1xuICAgIHJldHVybiBuZXcgRmlyZXN0b3JlRXJyb3IoY29kZSwgc3RhdHVzLm1lc3NhZ2UgfHwgJycpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWUgZm9yIGEgbnVtYmVyIChvciBudWxsKSB0aGF0J3MgYXBwcm9wcmlhdGUgdG8gcHV0IGludG9cbiAqIGEgZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWUgcHJvdG8uXG4gKiBETyBOT1QgVVNFIFRISVMgRk9SIEFOWVRISU5HIEVMU0UuXG4gKiBUaGlzIG1ldGhvZCBjaGVhdHMuIEl0J3MgdHlwZWQgYXMgcmV0dXJuaW5nIFwibnVtYmVyXCIgYmVjYXVzZSB0aGF0J3Mgd2hhdFxuICogb3VyIGdlbmVyYXRlZCBwcm90byBpbnRlcmZhY2VzIHNheSBJbnQzMlZhbHVlIG11c3QgYmUuIEJ1dCBHUlBDIGFjdHVhbGx5XG4gKiBleHBlY3RzIGEgeyB2YWx1ZTogPG51bWJlcj4gfSBzdHJ1Y3QuXG4gKi9cbmZ1bmN0aW9uIHRvSW50MzJQcm90byhzZXJpYWxpemVyLCB2YWwpIHtcbiAgICBpZiAoc2VyaWFsaXplci51c2VQcm90bzNKc29uIHx8IGlzTnVsbE9yVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWwgfTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgKG9yIG51bGwpIGZyb20gYSBnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZSBwcm90by5cbiAqL1xuZnVuY3Rpb24gZnJvbUludDMyUHJvdG8odmFsKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmVzdWx0ID0gdmFsLnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gaXNOdWxsT3JVbmRlZmluZWQocmVzdWx0KSA/IG51bGwgOiByZXN1bHQ7XG59XG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSBmb3IgYSBEYXRlIHRoYXQncyBhcHByb3ByaWF0ZSB0byBwdXQgaW50byBhIHByb3RvLlxuICovXG5mdW5jdGlvbiB0b1RpbWVzdGFtcChzZXJpYWxpemVyLCB0aW1lc3RhbXApIHtcbiAgICBpZiAoc2VyaWFsaXplci51c2VQcm90bzNKc29uKSB7XG4gICAgICAgIC8vIFNlcmlhbGl6ZSB0byBJU08tODYwMSBkYXRlIGZvcm1hdCwgYnV0IHdpdGggZnVsbCBuYW5vIHJlc29sdXRpb24uXG4gICAgICAgIC8vIFNpbmNlIEpTIERhdGUgaGFzIG9ubHkgbWlsbGlzLCBsZXQncyBvbmx5IHVzZSBpdCBmb3IgdGhlIHNlY29uZHMgYW5kXG4gICAgICAgIC8vIHRoZW4gbWFudWFsbHkgYWRkIHRoZSBmcmFjdGlvbnMgdG8gdGhlIGVuZC5cbiAgICAgICAgY29uc3QganNEYXRlU3RyID0gbmV3IERhdGUodGltZXN0YW1wLnNlY29uZHMgKiAxMDAwKS50b0lTT1N0cmluZygpO1xuICAgICAgICAvLyBSZW1vdmUgLnh4eCBmcmFjIHBhcnQgYW5kIFogaW4gdGhlIGVuZC5cbiAgICAgICAgY29uc3Qgc3RyVW50aWxTZWNvbmRzID0ganNEYXRlU3RyLnJlcGxhY2UoL1xcLlxcZCovLCAnJykucmVwbGFjZSgnWicsICcnKTtcbiAgICAgICAgLy8gUGFkIHRoZSBmcmFjdGlvbiBvdXQgdG8gOSBkaWdpdHMgKG5hbm9zKS5cbiAgICAgICAgY29uc3QgbmFub1N0ciA9ICgnMDAwMDAwMDAwJyArIHRpbWVzdGFtcC5uYW5vc2Vjb25kcykuc2xpY2UoLTkpO1xuICAgICAgICByZXR1cm4gYCR7c3RyVW50aWxTZWNvbmRzfS4ke25hbm9TdHJ9WmA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2Vjb25kczogJycgKyB0aW1lc3RhbXAuc2Vjb25kcyxcbiAgICAgICAgICAgIG5hbm9zOiB0aW1lc3RhbXAubmFub3NlY29uZHNcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGEgVGltZXN0YW1wIHR5cGVkIG9iamVjdCBnaXZlbiBwcm90b2J1ZiB0aW1lc3RhbXAgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGZyb21UaW1lc3RhbXAoZGF0ZSkge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5vcm1hbGl6ZVRpbWVzdGFtcChkYXRlKTtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCh0aW1lc3RhbXAuc2Vjb25kcywgdGltZXN0YW1wLm5hbm9zKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHZhbHVlIGZvciBieXRlcyB0aGF0J3MgYXBwcm9wcmlhdGUgdG8gcHV0IGluIGEgcHJvdG8uXG4gKlxuICogVmlzaWJsZSBmb3IgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlcyhzZXJpYWxpemVyLCBieXRlcykge1xuICAgIGlmIChzZXJpYWxpemVyLnVzZVByb3RvM0pzb24pIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvQmFzZTY0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYnl0ZXMudG9VaW50OEFycmF5KCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGEgQnl0ZVN0cmluZyBiYXNlZCBvbiB0aGUgcHJvdG8gc3RyaW5nIHZhbHVlLlxuICovXG5mdW5jdGlvbiBmcm9tQnl0ZXMoc2VyaWFsaXplciwgdmFsdWUpIHtcbiAgICBpZiAoc2VyaWFsaXplci51c2VQcm90bzNKc29uKSB7XG4gICAgICAgIGhhcmRBc3NlcnQodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLCAweGUzMGIpO1xuICAgICAgICByZXR1cm4gQnl0ZVN0cmluZy5mcm9tQmFzZTY0U3RyaW5nKHZhbHVlID8gdmFsdWUgOiAnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoYXJkQXNzZXJ0KHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBib3RoIEJ1ZmZlciBhbmQgVWludDhBcnJheSxcbiAgICAgICAgICAgIC8vIGRlc3BpdGUgdGhlIGZhY3QgdGhhdCBCdWZmZXIgZXh0ZW5kcyBVaW50OEFycmF5LiBJbiBzb21lXG4gICAgICAgICAgICAvLyBlbnZpcm9ubWVudHMsIHN1Y2ggYXMganNkb20sIHRoZSBwcm90b3R5cGUgY2hhaW4gb2YgQnVmZmVyXG4gICAgICAgICAgICAvLyBkb2VzIG5vdCBpbmRpY2F0ZSB0aGF0IGl0IGV4dGVuZHMgVWludDhBcnJheS5cbiAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgQnVmZmVyIHx8XG4gICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksIDB4M2Y0MSk7XG4gICAgICAgIHJldHVybiBCeXRlU3RyaW5nLmZyb21VaW50OEFycmF5KHZhbHVlID8gdmFsdWUgOiBuZXcgVWludDhBcnJheSgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1ZlcnNpb24oc2VyaWFsaXplciwgdmVyc2lvbikge1xuICAgIHJldHVybiB0b1RpbWVzdGFtcChzZXJpYWxpemVyLCB2ZXJzaW9uLnRvVGltZXN0YW1wKCkpO1xufVxuZnVuY3Rpb24gZnJvbVZlcnNpb24odmVyc2lvbikge1xuICAgIGhhcmRBc3NlcnQoISF2ZXJzaW9uLCAweGMwNTApO1xuICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24uZnJvbVRpbWVzdGFtcChmcm9tVGltZXN0YW1wKHZlcnNpb24pKTtcbn1cbmZ1bmN0aW9uIHRvUmVzb3VyY2VOYW1lKGRhdGFiYXNlSWQsIHBhdGgpIHtcbiAgICByZXR1cm4gdG9SZXNvdXJjZVBhdGgoZGF0YWJhc2VJZCwgcGF0aCkuY2Fub25pY2FsU3RyaW5nKCk7XG59XG5mdW5jdGlvbiB0b1Jlc291cmNlUGF0aChkYXRhYmFzZUlkLCBwYXRoKSB7XG4gICAgY29uc3QgcmVzb3VyY2VQYXRoID0gZnVsbHlRdWFsaWZpZWRQcmVmaXhQYXRoKGRhdGFiYXNlSWQpLmNoaWxkKCdkb2N1bWVudHMnKTtcbiAgICByZXR1cm4gcGF0aCA9PT0gdW5kZWZpbmVkID8gcmVzb3VyY2VQYXRoIDogcmVzb3VyY2VQYXRoLmNoaWxkKHBhdGgpO1xufVxuZnVuY3Rpb24gZnJvbVJlc291cmNlTmFtZShuYW1lKSB7XG4gICAgY29uc3QgcmVzb3VyY2UgPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhuYW1lKTtcbiAgICBoYXJkQXNzZXJ0KGlzVmFsaWRSZXNvdXJjZU5hbWUocmVzb3VyY2UpLCAweDI3Y2UsIHsga2V5OiByZXNvdXJjZS50b1N0cmluZygpIH0pO1xuICAgIHJldHVybiByZXNvdXJjZTtcbn1cbmZ1bmN0aW9uIHRvTmFtZShzZXJpYWxpemVyLCBrZXkpIHtcbiAgICByZXR1cm4gdG9SZXNvdXJjZU5hbWUoc2VyaWFsaXplci5kYXRhYmFzZUlkLCBrZXkucGF0aCk7XG59XG5mdW5jdGlvbiBmcm9tTmFtZShzZXJpYWxpemVyLCBuYW1lKSB7XG4gICAgY29uc3QgcmVzb3VyY2UgPSBmcm9tUmVzb3VyY2VOYW1lKG5hbWUpO1xuICAgIGlmIChyZXNvdXJjZS5nZXQoMSkgIT09IHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5wcm9qZWN0SWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RyaWVkIHRvIGRlc2VyaWFsaXplIGtleSBmcm9tIGRpZmZlcmVudCBwcm9qZWN0OiAnICtcbiAgICAgICAgICAgIHJlc291cmNlLmdldCgxKSArXG4gICAgICAgICAgICAnIHZzICcgK1xuICAgICAgICAgICAgc2VyaWFsaXplci5kYXRhYmFzZUlkLnByb2plY3RJZCk7XG4gICAgfVxuICAgIGlmIChyZXNvdXJjZS5nZXQoMykgIT09IHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5kYXRhYmFzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVHJpZWQgdG8gZGVzZXJpYWxpemUga2V5IGZyb20gZGlmZmVyZW50IGRhdGFiYXNlOiAnICtcbiAgICAgICAgICAgIHJlc291cmNlLmdldCgzKSArXG4gICAgICAgICAgICAnIHZzICcgK1xuICAgICAgICAgICAgc2VyaWFsaXplci5kYXRhYmFzZUlkLmRhdGFiYXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShleHRyYWN0TG9jYWxQYXRoRnJvbVJlc291cmNlTmFtZShyZXNvdXJjZSkpO1xufVxuZnVuY3Rpb24gdG9RdWVyeVBhdGgoc2VyaWFsaXplciwgcGF0aCkge1xuICAgIHJldHVybiB0b1Jlc291cmNlTmFtZShzZXJpYWxpemVyLmRhdGFiYXNlSWQsIHBhdGgpO1xufVxuZnVuY3Rpb24gZnJvbVF1ZXJ5UGF0aChuYW1lKSB7XG4gICAgY29uc3QgcmVzb3VyY2VOYW1lID0gZnJvbVJlc291cmNlTmFtZShuYW1lKTtcbiAgICAvLyBJbiB2MWJldGExIHF1ZXJpZXMgZm9yIGNvbGxlY3Rpb25zIGF0IHRoZSByb290IGRpZCBub3QgaGF2ZSBhIHRyYWlsaW5nXG4gICAgLy8gXCIvZG9jdW1lbnRzXCIuIEluIHYxIGFsbCByZXNvdXJjZSBwYXRocyBjb250YWluIFwiL2RvY3VtZW50c1wiLiBQcmVzZXJ2ZSB0aGVcbiAgICAvLyBhYmlsaXR5IHRvIHJlYWQgdGhlIHYxYmV0YTEgZm9ybSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHF1ZXJpZXMgcGVyc2lzdGVkXG4gICAgLy8gaW4gdGhlIGxvY2FsIHRhcmdldCBjYWNoZS5cbiAgICBpZiAocmVzb3VyY2VOYW1lLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICByZXR1cm4gUmVzb3VyY2VQYXRoLmVtcHR5UGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gZXh0cmFjdExvY2FsUGF0aEZyb21SZXNvdXJjZU5hbWUocmVzb3VyY2VOYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEVuY29kZWREYXRhYmFzZUlkKHNlcmlhbGl6ZXIpIHtcbiAgICBjb25zdCBwYXRoID0gbmV3IFJlc291cmNlUGF0aChbXG4gICAgICAgICdwcm9qZWN0cycsXG4gICAgICAgIHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5wcm9qZWN0SWQsXG4gICAgICAgICdkYXRhYmFzZXMnLFxuICAgICAgICBzZXJpYWxpemVyLmRhdGFiYXNlSWQuZGF0YWJhc2VcbiAgICBdKTtcbiAgICByZXR1cm4gcGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGZ1bGx5UXVhbGlmaWVkUHJlZml4UGF0aChkYXRhYmFzZUlkKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBhdGgoW1xuICAgICAgICAncHJvamVjdHMnLFxuICAgICAgICBkYXRhYmFzZUlkLnByb2plY3RJZCxcbiAgICAgICAgJ2RhdGFiYXNlcycsXG4gICAgICAgIGRhdGFiYXNlSWQuZGF0YWJhc2VcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RMb2NhbFBhdGhGcm9tUmVzb3VyY2VOYW1lKHJlc291cmNlTmFtZSkge1xuICAgIGhhcmRBc3NlcnQocmVzb3VyY2VOYW1lLmxlbmd0aCA+IDQgJiYgcmVzb3VyY2VOYW1lLmdldCg0KSA9PT0gJ2RvY3VtZW50cycsIDB4NzFhMywgeyBrZXk6IHJlc291cmNlTmFtZS50b1N0cmluZygpIH0pO1xuICAgIHJldHVybiByZXNvdXJjZU5hbWUucG9wRmlyc3QoNSk7XG59XG4vKiogQ3JlYXRlcyBhIERvY3VtZW50IHByb3RvIGZyb20ga2V5IGFuZCBmaWVsZHMgKGJ1dCBubyBjcmVhdGUvdXBkYXRlIHRpbWUpICovXG5mdW5jdGlvbiB0b011dGF0aW9uRG9jdW1lbnQoc2VyaWFsaXplciwga2V5LCBmaWVsZHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiB0b05hbWUoc2VyaWFsaXplciwga2V5KSxcbiAgICAgICAgZmllbGRzOiBmaWVsZHMudmFsdWUubWFwVmFsdWUuZmllbGRzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvRG9jdW1lbnQoc2VyaWFsaXplciwgZG9jdW1lbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiB0b05hbWUoc2VyaWFsaXplciwgZG9jdW1lbnQua2V5KSxcbiAgICAgICAgZmllbGRzOiBkb2N1bWVudC5kYXRhLnZhbHVlLm1hcFZhbHVlLmZpZWxkcyxcbiAgICAgICAgdXBkYXRlVGltZTogdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgZG9jdW1lbnQudmVyc2lvbi50b1RpbWVzdGFtcCgpKSxcbiAgICAgICAgY3JlYXRlVGltZTogdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgZG9jdW1lbnQuY3JlYXRlVGltZS50b1RpbWVzdGFtcCgpKVxuICAgIH07XG59XG5mdW5jdGlvbiBmcm9tUGlwZWxpbmVSZXNwb25zZShzZXJpYWxpemVyLCBwcm90bywgZG9jdW1lbnQpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICBpZiAocHJvdG8udHJhbnNhY3Rpb24/Lmxlbmd0aCkge1xuICAgICAgICBvdXRwdXQudHJhbnNhY3Rpb24gPSBwcm90by50cmFuc2FjdGlvbjtcbiAgICB9XG4gICAgY29uc3QgZXhlY3V0aW9uVGltZSA9IHByb3RvLmV4ZWN1dGlvblRpbWVcbiAgICAgICAgPyBmcm9tVmVyc2lvbihwcm90by5leGVjdXRpb25UaW1lKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBvdXRwdXQuZXhlY3V0aW9uVGltZSA9IGV4ZWN1dGlvblRpbWU7XG4gICAgaWYgKCEhZG9jdW1lbnQpIHtcbiAgICAgICAgb3V0cHV0LmtleSA9IGRvY3VtZW50Lm5hbWVcbiAgICAgICAgICAgID8gZnJvbU5hbWUoc2VyaWFsaXplciwgZG9jdW1lbnQubmFtZSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBvdXRwdXQuZmllbGRzID0gbmV3IE9iamVjdFZhbHVlKHsgbWFwVmFsdWU6IHsgZmllbGRzOiBkb2N1bWVudC5maWVsZHMgfSB9KTtcbiAgICAgICAgb3V0cHV0LmNyZWF0ZVRpbWUgPSBkb2N1bWVudC5jcmVhdGVUaW1lXG4gICAgICAgICAgICA/IGZyb21WZXJzaW9uKGRvY3VtZW50LmNyZWF0ZVRpbWUpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgb3V0cHV0LnVwZGF0ZVRpbWUgPSBkb2N1bWVudC51cGRhdGVUaW1lXG4gICAgICAgICAgICA/IGZyb21WZXJzaW9uKGRvY3VtZW50LnVwZGF0ZVRpbWUpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIGZyb21Eb2N1bWVudChzZXJpYWxpemVyLCBkb2N1bWVudCwgaGFzQ29tbWl0dGVkTXV0YXRpb25zKSB7XG4gICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgZG9jdW1lbnQubmFtZSk7XG4gICAgY29uc3QgdmVyc2lvbiA9IGZyb21WZXJzaW9uKGRvY3VtZW50LnVwZGF0ZVRpbWUpO1xuICAgIC8vIElmIHdlIHJlYWQgYSBkb2N1bWVudCBmcm9tIHBlcnNpc3RlbmNlIHRoYXQgaXMgbWlzc2luZyBjcmVhdGVUaW1lLCBpdCdzIGR1ZVxuICAgIC8vIHRvIG9sZGVyIFNESyB2ZXJzaW9ucyBub3Qgc3RvcmluZyB0aGlzIGluZm9ybWF0aW9uLiBJbiBzdWNoIGNhc2VzLCB3ZSdsbFxuICAgIC8vIHNldCB0aGUgY3JlYXRlVGltZSB0byB6ZXJvLiBUaGlzIGNhbiBiZSByZW1vdmVkIGluIHRoZSBsb25nIHRlcm0uXG4gICAgY29uc3QgY3JlYXRlVGltZSA9IGRvY3VtZW50LmNyZWF0ZVRpbWVcbiAgICAgICAgPyBmcm9tVmVyc2lvbihkb2N1bWVudC5jcmVhdGVUaW1lKVxuICAgICAgICA6IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IE9iamVjdFZhbHVlKHsgbWFwVmFsdWU6IHsgZmllbGRzOiBkb2N1bWVudC5maWVsZHMgfSB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBNdXRhYmxlRG9jdW1lbnQubmV3Rm91bmREb2N1bWVudChrZXksIHZlcnNpb24sIGNyZWF0ZVRpbWUsIGRhdGEpO1xuICAgIGlmIChoYXNDb21taXR0ZWRNdXRhdGlvbnMpIHtcbiAgICAgICAgcmVzdWx0LnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzQ29tbWl0dGVkTXV0YXRpb25zID8gcmVzdWx0LnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpIDogcmVzdWx0O1xufVxuZnVuY3Rpb24gZnJvbUZvdW5kKHNlcmlhbGl6ZXIsIGRvYykge1xuICAgIGhhcmRBc3NlcnQoISFkb2MuZm91bmQsIDB4YWEzMyk7XG4gICAgYXNzZXJ0UHJlc2VudChkb2MuZm91bmQubmFtZSk7XG4gICAgYXNzZXJ0UHJlc2VudChkb2MuZm91bmQudXBkYXRlVGltZSk7XG4gICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgZG9jLmZvdW5kLm5hbWUpO1xuICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tVmVyc2lvbihkb2MuZm91bmQudXBkYXRlVGltZSk7XG4gICAgY29uc3QgY3JlYXRlVGltZSA9IGRvYy5mb3VuZC5jcmVhdGVUaW1lXG4gICAgICAgID8gZnJvbVZlcnNpb24oZG9jLmZvdW5kLmNyZWF0ZVRpbWUpXG4gICAgICAgIDogU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgT2JqZWN0VmFsdWUoeyBtYXBWYWx1ZTogeyBmaWVsZHM6IGRvYy5mb3VuZC5maWVsZHMgfSB9KTtcbiAgICByZXR1cm4gTXV0YWJsZURvY3VtZW50Lm5ld0ZvdW5kRG9jdW1lbnQoa2V5LCB2ZXJzaW9uLCBjcmVhdGVUaW1lLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGZyb21NaXNzaW5nKHNlcmlhbGl6ZXIsIHJlc3VsdCkge1xuICAgIGhhcmRBc3NlcnQoISFyZXN1bHQubWlzc2luZywgMHgwZjM2KTtcbiAgICBoYXJkQXNzZXJ0KCEhcmVzdWx0LnJlYWRUaW1lLCAweDU5OTUpO1xuICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIHJlc3VsdC5taXNzaW5nKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gZnJvbVZlcnNpb24ocmVzdWx0LnJlYWRUaW1lKTtcbiAgICByZXR1cm4gTXV0YWJsZURvY3VtZW50Lm5ld05vRG9jdW1lbnQoa2V5LCB2ZXJzaW9uKTtcbn1cbmZ1bmN0aW9uIGZyb21CYXRjaEdldERvY3VtZW50c1Jlc3BvbnNlKHNlcmlhbGl6ZXIsIHJlc3VsdCkge1xuICAgIGlmICgnZm91bmQnIGluIHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gZnJvbUZvdW5kKHNlcmlhbGl6ZXIsIHJlc3VsdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdtaXNzaW5nJyBpbiByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGZyb21NaXNzaW5nKHNlcmlhbGl6ZXIsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBmYWlsKDB4MWM0MiwgeyByZXN1bHQgfSk7XG59XG5mdW5jdGlvbiBmcm9tV2F0Y2hDaGFuZ2Uoc2VyaWFsaXplciwgY2hhbmdlKSB7XG4gICAgbGV0IHdhdGNoQ2hhbmdlO1xuICAgIGlmICgndGFyZ2V0Q2hhbmdlJyBpbiBjaGFuZ2UpIHtcbiAgICAgICAgYXNzZXJ0UHJlc2VudChjaGFuZ2UudGFyZ2V0Q2hhbmdlKTtcbiAgICAgICAgLy8gcHJvdG8zIGRlZmF1bHQgdmFsdWUgaXMgdW5zZXQgaW4gSlNPTiAodW5kZWZpbmVkKSwgc28gdXNlICdOT19DSEFOR0UnXG4gICAgICAgIC8vIGlmIHVuc2V0XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZnJvbVdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUoY2hhbmdlLnRhcmdldENoYW5nZS50YXJnZXRDaGFuZ2VUeXBlIHx8ICdOT19DSEFOR0UnKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWRzID0gY2hhbmdlLnRhcmdldENoYW5nZS50YXJnZXRJZHMgfHwgW107XG4gICAgICAgIGNvbnN0IHJlc3VtZVRva2VuID0gZnJvbUJ5dGVzKHNlcmlhbGl6ZXIsIGNoYW5nZS50YXJnZXRDaGFuZ2UucmVzdW1lVG9rZW4pO1xuICAgICAgICBjb25zdCBjYXVzZVByb3RvID0gY2hhbmdlLnRhcmdldENoYW5nZS5jYXVzZTtcbiAgICAgICAgY29uc3QgY2F1c2UgPSBjYXVzZVByb3RvICYmIGZyb21ScGNTdGF0dXMoY2F1c2VQcm90byk7XG4gICAgICAgIHdhdGNoQ2hhbmdlID0gbmV3IFdhdGNoVGFyZ2V0Q2hhbmdlKHN0YXRlLCB0YXJnZXRJZHMsIHJlc3VtZVRva2VuLCBjYXVzZSB8fCBudWxsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2RvY3VtZW50Q2hhbmdlJyBpbiBjaGFuZ2UpIHtcbiAgICAgICAgYXNzZXJ0UHJlc2VudChjaGFuZ2UuZG9jdW1lbnRDaGFuZ2UpO1xuICAgICAgICBjb25zdCBlbnRpdHlDaGFuZ2UgPSBjaGFuZ2UuZG9jdW1lbnRDaGFuZ2U7XG4gICAgICAgIGFzc2VydFByZXNlbnQoZW50aXR5Q2hhbmdlLmRvY3VtZW50KTtcbiAgICAgICAgYXNzZXJ0UHJlc2VudChlbnRpdHlDaGFuZ2UuZG9jdW1lbnQubmFtZSk7XG4gICAgICAgIGFzc2VydFByZXNlbnQoZW50aXR5Q2hhbmdlLmRvY3VtZW50LnVwZGF0ZVRpbWUpO1xuICAgICAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCBlbnRpdHlDaGFuZ2UuZG9jdW1lbnQubmFtZSk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tVmVyc2lvbihlbnRpdHlDaGFuZ2UuZG9jdW1lbnQudXBkYXRlVGltZSk7XG4gICAgICAgIGNvbnN0IGNyZWF0ZVRpbWUgPSBlbnRpdHlDaGFuZ2UuZG9jdW1lbnQuY3JlYXRlVGltZVxuICAgICAgICAgICAgPyBmcm9tVmVyc2lvbihlbnRpdHlDaGFuZ2UuZG9jdW1lbnQuY3JlYXRlVGltZSlcbiAgICAgICAgICAgIDogU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IE9iamVjdFZhbHVlKHtcbiAgICAgICAgICAgIG1hcFZhbHVlOiB7IGZpZWxkczogZW50aXR5Q2hhbmdlLmRvY3VtZW50LmZpZWxkcyB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkb2MgPSBNdXRhYmxlRG9jdW1lbnQubmV3Rm91bmREb2N1bWVudChrZXksIHZlcnNpb24sIGNyZWF0ZVRpbWUsIGRhdGEpO1xuICAgICAgICBjb25zdCB1cGRhdGVkVGFyZ2V0SWRzID0gZW50aXR5Q2hhbmdlLnRhcmdldElkcyB8fCBbXTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZFRhcmdldElkcyA9IGVudGl0eUNoYW5nZS5yZW1vdmVkVGFyZ2V0SWRzIHx8IFtdO1xuICAgICAgICB3YXRjaENoYW5nZSA9IG5ldyBEb2N1bWVudFdhdGNoQ2hhbmdlKHVwZGF0ZWRUYXJnZXRJZHMsIHJlbW92ZWRUYXJnZXRJZHMsIGRvYy5rZXksIGRvYyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdkb2N1bWVudERlbGV0ZScgaW4gY2hhbmdlKSB7XG4gICAgICAgIGFzc2VydFByZXNlbnQoY2hhbmdlLmRvY3VtZW50RGVsZXRlKTtcbiAgICAgICAgY29uc3QgZG9jRGVsZXRlID0gY2hhbmdlLmRvY3VtZW50RGVsZXRlO1xuICAgICAgICBhc3NlcnRQcmVzZW50KGRvY0RlbGV0ZS5kb2N1bWVudCk7XG4gICAgICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIGRvY0RlbGV0ZS5kb2N1bWVudCk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBkb2NEZWxldGUucmVhZFRpbWVcbiAgICAgICAgICAgID8gZnJvbVZlcnNpb24oZG9jRGVsZXRlLnJlYWRUaW1lKVxuICAgICAgICAgICAgOiBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgICAgIGNvbnN0IGRvYyA9IE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGtleSwgdmVyc2lvbik7XG4gICAgICAgIGNvbnN0IHJlbW92ZWRUYXJnZXRJZHMgPSBkb2NEZWxldGUucmVtb3ZlZFRhcmdldElkcyB8fCBbXTtcbiAgICAgICAgd2F0Y2hDaGFuZ2UgPSBuZXcgRG9jdW1lbnRXYXRjaENoYW5nZShbXSwgcmVtb3ZlZFRhcmdldElkcywgZG9jLmtleSwgZG9jKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2RvY3VtZW50UmVtb3ZlJyBpbiBjaGFuZ2UpIHtcbiAgICAgICAgYXNzZXJ0UHJlc2VudChjaGFuZ2UuZG9jdW1lbnRSZW1vdmUpO1xuICAgICAgICBjb25zdCBkb2NSZW1vdmUgPSBjaGFuZ2UuZG9jdW1lbnRSZW1vdmU7XG4gICAgICAgIGFzc2VydFByZXNlbnQoZG9jUmVtb3ZlLmRvY3VtZW50KTtcbiAgICAgICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgZG9jUmVtb3ZlLmRvY3VtZW50KTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZFRhcmdldElkcyA9IGRvY1JlbW92ZS5yZW1vdmVkVGFyZ2V0SWRzIHx8IFtdO1xuICAgICAgICB3YXRjaENoYW5nZSA9IG5ldyBEb2N1bWVudFdhdGNoQ2hhbmdlKFtdLCByZW1vdmVkVGFyZ2V0SWRzLCBrZXksIG51bGwpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnZmlsdGVyJyBpbiBjaGFuZ2UpIHtcbiAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiBpbXBsZW1lbnQgZXhpc3RlbmNlIGZpbHRlciBwYXJzaW5nIHdpdGggc3RyYXRlZ3kuXG4gICAgICAgIGFzc2VydFByZXNlbnQoY2hhbmdlLmZpbHRlcik7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IGNoYW5nZS5maWx0ZXI7XG4gICAgICAgIGFzc2VydFByZXNlbnQoZmlsdGVyLnRhcmdldElkKTtcbiAgICAgICAgY29uc3QgeyBjb3VudCA9IDAsIHVuY2hhbmdlZE5hbWVzIH0gPSBmaWx0ZXI7XG4gICAgICAgIGNvbnN0IGV4aXN0ZW5jZUZpbHRlciA9IG5ldyBFeGlzdGVuY2VGaWx0ZXIoY291bnQsIHVuY2hhbmdlZE5hbWVzKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBmaWx0ZXIudGFyZ2V0SWQ7XG4gICAgICAgIHdhdGNoQ2hhbmdlID0gbmV3IEV4aXN0ZW5jZUZpbHRlckNoYW5nZSh0YXJnZXRJZCwgZXhpc3RlbmNlRmlsdGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKDB4MmQ1MSwgeyBjaGFuZ2UgfSk7XG4gICAgfVxuICAgIHJldHVybiB3YXRjaENoYW5nZTtcbn1cbmZ1bmN0aW9uIGZyb21XYXRjaFRhcmdldENoYW5nZVN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlID09PSAnTk9fQ0hBTkdFJykge1xuICAgICAgICByZXR1cm4gMCAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLk5vQ2hhbmdlICovO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ0FERCcpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5BZGRlZCAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGUgPT09ICdSRU1PVkUnKSB7XG4gICAgICAgIHJldHVybiAyIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVtb3ZlZCAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGUgPT09ICdDVVJSRU5UJykge1xuICAgICAgICByZXR1cm4gMyAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLkN1cnJlbnQgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlID09PSAnUkVTRVQnKSB7XG4gICAgICAgIHJldHVybiA0IC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVzZXQgKi87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgweDk5OTEsIHsgc3RhdGUgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmVyc2lvbkZyb21MaXN0ZW5SZXNwb25zZShjaGFuZ2UpIHtcbiAgICAvLyBXZSBoYXZlIG9ubHkgcmVhY2hlZCBhIGNvbnNpc3RlbnQgc25hcHNob3QgZm9yIHRoZSBlbnRpcmUgc3RyZWFtIGlmIHRoZXJlXG4gICAgLy8gaXMgYSByZWFkX3RpbWUgc2V0IGFuZCBpdCBhcHBsaWVzIHRvIGFsbCB0YXJnZXRzIChpLmUuIHRoZSBsaXN0IG9mXG4gICAgLy8gdGFyZ2V0cyBpcyBlbXB0eSkuIFRoZSBiYWNrZW5kIGlzIGd1YXJhbnRlZWQgdG8gc2VuZCBzdWNoIHJlc3BvbnNlcy5cbiAgICBpZiAoISgndGFyZ2V0Q2hhbmdlJyBpbiBjaGFuZ2UpKSB7XG4gICAgICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldENoYW5nZSA9IGNoYW5nZS50YXJnZXRDaGFuZ2U7XG4gICAgaWYgKHRhcmdldENoYW5nZS50YXJnZXRJZHMgJiYgdGFyZ2V0Q2hhbmdlLnRhcmdldElkcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICB9XG4gICAgaWYgKCF0YXJnZXRDaGFuZ2UucmVhZFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21WZXJzaW9uKHRhcmdldENoYW5nZS5yZWFkVGltZSk7XG59XG5mdW5jdGlvbiB0b011dGF0aW9uKHNlcmlhbGl6ZXIsIG11dGF0aW9uKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBTZXRNdXRhdGlvbikge1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICB1cGRhdGU6IHRvTXV0YXRpb25Eb2N1bWVudChzZXJpYWxpemVyLCBtdXRhdGlvbi5rZXksIG11dGF0aW9uLnZhbHVlKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChtdXRhdGlvbiBpbnN0YW5jZW9mIERlbGV0ZU11dGF0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHsgZGVsZXRlOiB0b05hbWUoc2VyaWFsaXplciwgbXV0YXRpb24ua2V5KSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChtdXRhdGlvbiBpbnN0YW5jZW9mIFBhdGNoTXV0YXRpb24pIHtcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdXBkYXRlOiB0b011dGF0aW9uRG9jdW1lbnQoc2VyaWFsaXplciwgbXV0YXRpb24ua2V5LCBtdXRhdGlvbi5kYXRhKSxcbiAgICAgICAgICAgIHVwZGF0ZU1hc2s6IHRvRG9jdW1lbnRNYXNrKG11dGF0aW9uLmZpZWxkTWFzaylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBWZXJpZnlNdXRhdGlvbikge1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICB2ZXJpZnk6IHRvTmFtZShzZXJpYWxpemVyLCBtdXRhdGlvbi5rZXkpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgweDQwZDcsIHtcbiAgICAgICAgICAgIG11dGF0aW9uVHlwZTogbXV0YXRpb24udHlwZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLmZpZWxkVHJhbnNmb3Jtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3VsdC51cGRhdGVUcmFuc2Zvcm1zID0gbXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLm1hcCh0cmFuc2Zvcm0gPT4gdG9GaWVsZFRyYW5zZm9ybShzZXJpYWxpemVyLCB0cmFuc2Zvcm0pKTtcbiAgICB9XG4gICAgaWYgKCFtdXRhdGlvbi5wcmVjb25kaXRpb24uaXNOb25lKSB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50RG9jdW1lbnQgPSB0b1ByZWNvbmRpdGlvbihzZXJpYWxpemVyLCBtdXRhdGlvbi5wcmVjb25kaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZnJvbU11dGF0aW9uKHNlcmlhbGl6ZXIsIHByb3RvKSB7XG4gICAgY29uc3QgcHJlY29uZGl0aW9uID0gcHJvdG8uY3VycmVudERvY3VtZW50XG4gICAgICAgID8gZnJvbVByZWNvbmRpdGlvbihwcm90by5jdXJyZW50RG9jdW1lbnQpXG4gICAgICAgIDogUHJlY29uZGl0aW9uLm5vbmUoKTtcbiAgICBjb25zdCBmaWVsZFRyYW5zZm9ybXMgPSBwcm90by51cGRhdGVUcmFuc2Zvcm1zXG4gICAgICAgID8gcHJvdG8udXBkYXRlVHJhbnNmb3Jtcy5tYXAodHJhbnNmb3JtID0+IGZyb21GaWVsZFRyYW5zZm9ybShzZXJpYWxpemVyLCB0cmFuc2Zvcm0pKVxuICAgICAgICA6IFtdO1xuICAgIGlmIChwcm90by51cGRhdGUpIHtcbiAgICAgICAgYXNzZXJ0UHJlc2VudChwcm90by51cGRhdGUubmFtZSk7XG4gICAgICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIHByb3RvLnVwZGF0ZS5uYW1lKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXcgT2JqZWN0VmFsdWUoe1xuICAgICAgICAgICAgbWFwVmFsdWU6IHsgZmllbGRzOiBwcm90by51cGRhdGUuZmllbGRzIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm90by51cGRhdGVNYXNrKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZE1hc2sgPSBmcm9tRG9jdW1lbnRNYXNrKHByb3RvLnVwZGF0ZU1hc2spO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXRjaE11dGF0aW9uKGtleSwgdmFsdWUsIGZpZWxkTWFzaywgcHJlY29uZGl0aW9uLCBmaWVsZFRyYW5zZm9ybXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXRNdXRhdGlvbihrZXksIHZhbHVlLCBwcmVjb25kaXRpb24sIGZpZWxkVHJhbnNmb3Jtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocHJvdG8uZGVsZXRlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIHByb3RvLmRlbGV0ZSk7XG4gICAgICAgIHJldHVybiBuZXcgRGVsZXRlTXV0YXRpb24oa2V5LCBwcmVjb25kaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm90by52ZXJpZnkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgcHJvdG8udmVyaWZ5KTtcbiAgICAgICAgcmV0dXJuIG5ldyBWZXJpZnlNdXRhdGlvbihrZXksIHByZWNvbmRpdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgweDA1YjcsIHsgcHJvdG8gfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9QcmVjb25kaXRpb24oc2VyaWFsaXplciwgcHJlY29uZGl0aW9uKSB7XG4gICAgaWYgKHByZWNvbmRpdGlvbi51cGRhdGVUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVwZGF0ZVRpbWU6IHRvVmVyc2lvbihzZXJpYWxpemVyLCBwcmVjb25kaXRpb24udXBkYXRlVGltZSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJlY29uZGl0aW9uLmV4aXN0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7IGV4aXN0czogcHJlY29uZGl0aW9uLmV4aXN0cyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoMHg2YjY5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBmcm9tUHJlY29uZGl0aW9uKHByZWNvbmRpdGlvbikge1xuICAgIGlmIChwcmVjb25kaXRpb24udXBkYXRlVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBQcmVjb25kaXRpb24udXBkYXRlVGltZShmcm9tVmVyc2lvbihwcmVjb25kaXRpb24udXBkYXRlVGltZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcmVjb25kaXRpb24uZXhpc3RzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5leGlzdHMocHJlY29uZGl0aW9uLmV4aXN0cyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJlY29uZGl0aW9uLm5vbmUoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmcm9tV3JpdGVSZXN1bHQocHJvdG8sIGNvbW1pdFRpbWUpIHtcbiAgICAvLyBOT1RFOiBEZWxldGVzIGRvbid0IGhhdmUgYW4gdXBkYXRlVGltZS5cbiAgICBsZXQgdmVyc2lvbiA9IHByb3RvLnVwZGF0ZVRpbWVcbiAgICAgICAgPyBmcm9tVmVyc2lvbihwcm90by51cGRhdGVUaW1lKVxuICAgICAgICA6IGZyb21WZXJzaW9uKGNvbW1pdFRpbWUpO1xuICAgIGlmICh2ZXJzaW9uLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKSkge1xuICAgICAgICAvLyBUaGUgRmlyZXN0b3JlIEVtdWxhdG9yIGN1cnJlbnRseSByZXR1cm5zIGFuIHVwZGF0ZSB0aW1lIG9mIDAgZm9yXG4gICAgICAgIC8vIGRlbGV0ZXMgb2Ygbm9uLWV4aXN0aW5nIGRvY3VtZW50cyAocmF0aGVyIHRoYW4gbnVsbCkuIFRoaXMgYnJlYWtzIHRoZVxuICAgICAgICAvLyB0ZXN0IFwiZ2V0IGRlbGV0ZWQgZG9jIHdoaWxlIG9mZmxpbmUgd2l0aCBzb3VyY2U9Y2FjaGVcIiBhcyBOb0RvY3VtZW50c1xuICAgICAgICAvLyB3aXRoIHZlcnNpb24gMCBhcmUgZmlsdGVyZWQgYnkgSW5kZXhlZERiJ3MgUmVtb3RlRG9jdW1lbnRDYWNoZS5cbiAgICAgICAgLy8gVE9ETygjMjE0OSk6IFJlbW92ZSB0aGlzIHdoZW4gRW11bGF0b3IgaXMgZml4ZWRcbiAgICAgICAgdmVyc2lvbiA9IGZyb21WZXJzaW9uKGNvbW1pdFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE11dGF0aW9uUmVzdWx0KHZlcnNpb24sIHByb3RvLnRyYW5zZm9ybVJlc3VsdHMgfHwgW10pO1xufVxuZnVuY3Rpb24gZnJvbVdyaXRlUmVzdWx0cyhwcm90b3MsIGNvbW1pdFRpbWUpIHtcbiAgICBpZiAocHJvdG9zICYmIHByb3Rvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGhhcmRBc3NlcnQoY29tbWl0VGltZSAhPT0gdW5kZWZpbmVkLCAweDM4MTEpO1xuICAgICAgICByZXR1cm4gcHJvdG9zLm1hcChwcm90byA9PiBmcm9tV3JpdGVSZXN1bHQocHJvdG8sIGNvbW1pdFRpbWUpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0ZpZWxkVHJhbnNmb3JtKHNlcmlhbGl6ZXIsIGZpZWxkVHJhbnNmb3JtKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gZmllbGRUcmFuc2Zvcm0udHJhbnNmb3JtO1xuICAgIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpZWxkUGF0aDogZmllbGRUcmFuc2Zvcm0uZmllbGQuY2Fub25pY2FsU3RyaW5nKCksXG4gICAgICAgICAgICBzZXRUb1NlcnZlclZhbHVlOiAnUkVRVUVTVF9USU1FJ1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWVsZFBhdGg6IGZpZWxkVHJhbnNmb3JtLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpLFxuICAgICAgICAgICAgYXBwZW5kTWlzc2luZ0VsZW1lbnRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiB0cmFuc2Zvcm0uZWxlbWVudHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpZWxkUGF0aDogZmllbGRUcmFuc2Zvcm0uZmllbGQuY2Fub25pY2FsU3RyaW5nKCksXG4gICAgICAgICAgICByZW1vdmVBbGxGcm9tQXJyYXk6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHRyYW5zZm9ybS5lbGVtZW50c1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWVsZFBhdGg6IGZpZWxkVHJhbnNmb3JtLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpLFxuICAgICAgICAgICAgaW5jcmVtZW50OiB0cmFuc2Zvcm0ub3BlcmFuZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgZmFpbCgweDUxYzIsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogZmllbGRUcmFuc2Zvcm0udHJhbnNmb3JtXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21GaWVsZFRyYW5zZm9ybShzZXJpYWxpemVyLCBwcm90bykge1xuICAgIGxldCB0cmFuc2Zvcm0gPSBudWxsO1xuICAgIGlmICgnc2V0VG9TZXJ2ZXJWYWx1ZScgaW4gcHJvdG8pIHtcbiAgICAgICAgaGFyZEFzc2VydChwcm90by5zZXRUb1NlcnZlclZhbHVlID09PSAnUkVRVUVTVF9USU1FJywgMHg0MGY2LCB7IHByb3RvIH0pO1xuICAgICAgICB0cmFuc2Zvcm0gPSBuZXcgU2VydmVyVGltZXN0YW1wVHJhbnNmb3JtKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdhcHBlbmRNaXNzaW5nRWxlbWVudHMnIGluIHByb3RvKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHByb3RvLmFwcGVuZE1pc3NpbmdFbGVtZW50cy52YWx1ZXMgfHwgW107XG4gICAgICAgIHRyYW5zZm9ybSA9IG5ldyBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKHZhbHVlcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdyZW1vdmVBbGxGcm9tQXJyYXknIGluIHByb3RvKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHByb3RvLnJlbW92ZUFsbEZyb21BcnJheS52YWx1ZXMgfHwgW107XG4gICAgICAgIHRyYW5zZm9ybSA9IG5ldyBBcnJheVJlbW92ZVRyYW5zZm9ybU9wZXJhdGlvbih2YWx1ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnaW5jcmVtZW50JyBpbiBwcm90bykge1xuICAgICAgICB0cmFuc2Zvcm0gPSBuZXcgTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbihzZXJpYWxpemVyLCBwcm90by5pbmNyZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmFpbCgweDQwYzgsIHsgcHJvdG8gfSk7XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkUGF0aCA9IEZpZWxkUGF0aCQxLmZyb21TZXJ2ZXJGb3JtYXQocHJvdG8uZmllbGRQYXRoKTtcbiAgICByZXR1cm4gbmV3IEZpZWxkVHJhbnNmb3JtKGZpZWxkUGF0aCwgdHJhbnNmb3JtKTtcbn1cbmZ1bmN0aW9uIHRvRG9jdW1lbnRzVGFyZ2V0KHNlcmlhbGl6ZXIsIHRhcmdldCkge1xuICAgIHJldHVybiB7IGRvY3VtZW50czogW3RvUXVlcnlQYXRoKHNlcmlhbGl6ZXIsIHRhcmdldC5wYXRoKV0gfTtcbn1cbmZ1bmN0aW9uIGZyb21Eb2N1bWVudHNUYXJnZXQoZG9jdW1lbnRzVGFyZ2V0KSB7XG4gICAgY29uc3QgY291bnQgPSBkb2N1bWVudHNUYXJnZXQuZG9jdW1lbnRzLmxlbmd0aDtcbiAgICBoYXJkQXNzZXJ0KGNvdW50ID09PSAxLCAweDA3YWUsIHtcbiAgICAgICAgY291bnRcbiAgICB9KTtcbiAgICBjb25zdCBuYW1lID0gZG9jdW1lbnRzVGFyZ2V0LmRvY3VtZW50c1swXTtcbiAgICByZXR1cm4gcXVlcnlUb1RhcmdldChuZXdRdWVyeUZvclBhdGgoZnJvbVF1ZXJ5UGF0aChuYW1lKSkpO1xufVxuZnVuY3Rpb24gdG9RdWVyeVRhcmdldChzZXJpYWxpemVyLCB0YXJnZXQpIHtcbiAgICAvLyBEaXNzZWN0IHRoZSBwYXRoIGludG8gcGFyZW50LCBjb2xsZWN0aW9uSWQsIGFuZCBvcHRpb25hbCBrZXkgZmlsdGVyLlxuICAgIGNvbnN0IHF1ZXJ5VGFyZ2V0ID0geyBzdHJ1Y3R1cmVkUXVlcnk6IHt9IH07XG4gICAgY29uc3QgcGF0aCA9IHRhcmdldC5wYXRoO1xuICAgIGxldCBwYXJlbnQ7XG4gICAgaWYgKHRhcmdldC5jb2xsZWN0aW9uR3JvdXAgIT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50ID0gcGF0aDtcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5LmZyb20gPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbklkOiB0YXJnZXQuY29sbGVjdGlvbkdyb3VwLFxuICAgICAgICAgICAgICAgIGFsbERlc2NlbmRhbnRzOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJlbnQgPSBwYXRoLnBvcExhc3QoKTtcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5LmZyb20gPSBbeyBjb2xsZWN0aW9uSWQ6IHBhdGgubGFzdFNlZ21lbnQoKSB9XTtcbiAgICB9XG4gICAgcXVlcnlUYXJnZXQucGFyZW50ID0gdG9RdWVyeVBhdGgoc2VyaWFsaXplciwgcGFyZW50KTtcbiAgICBjb25zdCB3aGVyZSA9IHRvRmlsdGVycyh0YXJnZXQuZmlsdGVycyk7XG4gICAgaWYgKHdoZXJlKSB7XG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS53aGVyZSA9IHdoZXJlO1xuICAgIH1cbiAgICBjb25zdCBvcmRlckJ5ID0gdG9PcmRlcih0YXJnZXQub3JkZXJCeSk7XG4gICAgaWYgKG9yZGVyQnkpIHtcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5Lm9yZGVyQnkgPSBvcmRlckJ5O1xuICAgIH1cbiAgICBjb25zdCBsaW1pdCA9IHRvSW50MzJQcm90byhzZXJpYWxpemVyLCB0YXJnZXQubGltaXQpO1xuICAgIGlmIChsaW1pdCAhPT0gbnVsbCkge1xuICAgICAgICBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnkubGltaXQgPSBsaW1pdDtcbiAgICB9XG4gICAgaWYgKHRhcmdldC5zdGFydEF0KSB7XG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS5zdGFydEF0ID0gdG9TdGFydEF0Q3Vyc29yKHRhcmdldC5zdGFydEF0KTtcbiAgICB9XG4gICAgaWYgKHRhcmdldC5lbmRBdCkge1xuICAgICAgICBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnkuZW5kQXQgPSB0b0VuZEF0Q3Vyc29yKHRhcmdldC5lbmRBdCk7XG4gICAgfVxuICAgIHJldHVybiB7IHF1ZXJ5VGFyZ2V0LCBwYXJlbnQgfTtcbn1cbmZ1bmN0aW9uIHRvUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3Qoc2VyaWFsaXplciwgdGFyZ2V0LCBhZ2dyZWdhdGVzLCBza2lwQWxpYXNpbmcpIHtcbiAgICBjb25zdCB7IHF1ZXJ5VGFyZ2V0LCBwYXJlbnQgfSA9IHRvUXVlcnlUYXJnZXQoc2VyaWFsaXplciwgdGFyZ2V0KTtcbiAgICBjb25zdCBhbGlhc01hcCA9IHt9O1xuICAgIGNvbnN0IGFnZ3JlZ2F0aW9ucyA9IFtdO1xuICAgIGxldCBhZ2dyZWdhdGlvbk51bSA9IDA7XG4gICAgYWdncmVnYXRlcy5mb3JFYWNoKGFnZ3JlZ2F0ZSA9PiB7XG4gICAgICAgIC8vIE1hcCBhbGwgY2xpZW50LXNpZGUgYWxpYXNlcyB0byBhIHVuaXF1ZSBzaG9ydC1mb3JtXG4gICAgICAgIC8vIGFsaWFzLiBUaGlzIGF2b2lkcyBpc3N1ZXMgd2l0aCBjbGllbnQtc2lkZSBhbGlhc2VzIHRoYXRcbiAgICAgICAgLy8gZXhjZWVkIHRoZSAxNTAwLWJ5dGUgc3RyaW5nIHNpemUgbGltaXQuXG4gICAgICAgIGNvbnN0IHNlcnZlckFsaWFzID0gc2tpcEFsaWFzaW5nXG4gICAgICAgICAgICA/IGFnZ3JlZ2F0ZS5hbGlhc1xuICAgICAgICAgICAgOiBgYWdncmVnYXRlXyR7YWdncmVnYXRpb25OdW0rK31gO1xuICAgICAgICBhbGlhc01hcFtzZXJ2ZXJBbGlhc10gPSBhZ2dyZWdhdGUuYWxpYXM7XG4gICAgICAgIGlmIChhZ2dyZWdhdGUuYWdncmVnYXRlVHlwZSA9PT0gJ2NvdW50Jykge1xuICAgICAgICAgICAgYWdncmVnYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGFsaWFzOiBzZXJ2ZXJBbGlhcyxcbiAgICAgICAgICAgICAgICBjb3VudDoge31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFnZ3JlZ2F0ZS5hZ2dyZWdhdGVUeXBlID09PSAnYXZnJykge1xuICAgICAgICAgICAgYWdncmVnYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGFsaWFzOiBzZXJ2ZXJBbGlhcyxcbiAgICAgICAgICAgICAgICBhdmc6IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGFnZ3JlZ2F0ZS5maWVsZFBhdGgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWdncmVnYXRlLmFnZ3JlZ2F0ZVR5cGUgPT09ICdzdW0nKSB7XG4gICAgICAgICAgICBhZ2dyZWdhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgYWxpYXM6IHNlcnZlckFsaWFzLFxuICAgICAgICAgICAgICAgIHN1bToge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogdG9GaWVsZFBhdGhSZWZlcmVuY2UoYWdncmVnYXRlLmZpZWxkUGF0aClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgICAgIHN0cnVjdHVyZWRBZ2dyZWdhdGlvblF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgYWdncmVnYXRpb25zLFxuICAgICAgICAgICAgICAgIHN0cnVjdHVyZWRRdWVyeTogcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyZW50OiBxdWVyeVRhcmdldC5wYXJlbnRcbiAgICAgICAgfSxcbiAgICAgICAgYWxpYXNNYXAsXG4gICAgICAgIHBhcmVudFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0UXVlcnlUYXJnZXRUb1F1ZXJ5KHRhcmdldCkge1xuICAgIGxldCBwYXRoID0gZnJvbVF1ZXJ5UGF0aCh0YXJnZXQucGFyZW50KTtcbiAgICBjb25zdCBxdWVyeSA9IHRhcmdldC5zdHJ1Y3R1cmVkUXVlcnk7XG4gICAgY29uc3QgZnJvbUNvdW50ID0gcXVlcnkuZnJvbSA/IHF1ZXJ5LmZyb20ubGVuZ3RoIDogMDtcbiAgICBsZXQgY29sbGVjdGlvbkdyb3VwID0gbnVsbDtcbiAgICBpZiAoZnJvbUNvdW50ID4gMCkge1xuICAgICAgICBoYXJkQXNzZXJ0KGZyb21Db3VudCA9PT0gMSwgMHhmZTI2KTtcbiAgICAgICAgY29uc3QgZnJvbSA9IHF1ZXJ5LmZyb21bMF07XG4gICAgICAgIGlmIChmcm9tLmFsbERlc2NlbmRhbnRzKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uR3JvdXAgPSBmcm9tLmNvbGxlY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLmNoaWxkKGZyb20uY29sbGVjdGlvbklkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZmlsdGVyQnkgPSBbXTtcbiAgICBpZiAocXVlcnkud2hlcmUpIHtcbiAgICAgICAgZmlsdGVyQnkgPSBmcm9tRmlsdGVycyhxdWVyeS53aGVyZSk7XG4gICAgfVxuICAgIGxldCBvcmRlckJ5ID0gW107XG4gICAgaWYgKHF1ZXJ5Lm9yZGVyQnkpIHtcbiAgICAgICAgb3JkZXJCeSA9IGZyb21PcmRlcihxdWVyeS5vcmRlckJ5KTtcbiAgICB9XG4gICAgbGV0IGxpbWl0ID0gbnVsbDtcbiAgICBpZiAocXVlcnkubGltaXQpIHtcbiAgICAgICAgbGltaXQgPSBmcm9tSW50MzJQcm90byhxdWVyeS5saW1pdCk7XG4gICAgfVxuICAgIGxldCBzdGFydEF0ID0gbnVsbDtcbiAgICBpZiAocXVlcnkuc3RhcnRBdCkge1xuICAgICAgICBzdGFydEF0ID0gZnJvbVN0YXJ0QXRDdXJzb3IocXVlcnkuc3RhcnRBdCk7XG4gICAgfVxuICAgIGxldCBlbmRBdCA9IG51bGw7XG4gICAgaWYgKHF1ZXJ5LmVuZEF0KSB7XG4gICAgICAgIGVuZEF0ID0gZnJvbUVuZEF0Q3Vyc29yKHF1ZXJ5LmVuZEF0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1F1ZXJ5KHBhdGgsIGNvbGxlY3Rpb25Hcm91cCwgb3JkZXJCeSwgZmlsdGVyQnksIGxpbWl0LCBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8sIHN0YXJ0QXQsIGVuZEF0KTtcbn1cbmZ1bmN0aW9uIGZyb21RdWVyeVRhcmdldCh0YXJnZXQpIHtcbiAgICByZXR1cm4gcXVlcnlUb1RhcmdldChjb252ZXJ0UXVlcnlUYXJnZXRUb1F1ZXJ5KHRhcmdldCkpO1xufVxuZnVuY3Rpb24gdG9MaXN0ZW5SZXF1ZXN0TGFiZWxzKHNlcmlhbGl6ZXIsIHRhcmdldERhdGEpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRvTGFiZWwodGFyZ2V0RGF0YS5wdXJwb3NlKTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZ29vZy1saXN0ZW4tdGFncyc6IHZhbHVlXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gdG9MYWJlbChwdXJwb3NlKSB7XG4gICAgc3dpdGNoIChwdXJwb3NlKSB7XG4gICAgICAgIGNhc2UgXCJUYXJnZXRQdXJwb3NlTGlzdGVuXCIgLyogVGFyZ2V0UHVycG9zZS5MaXN0ZW4gKi86XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSBcIlRhcmdldFB1cnBvc2VFeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaFwiIC8qIFRhcmdldFB1cnBvc2UuRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2ggKi86XG4gICAgICAgICAgICByZXR1cm4gJ2V4aXN0ZW5jZS1maWx0ZXItbWlzbWF0Y2gnO1xuICAgICAgICBjYXNlIFwiVGFyZ2V0UHVycG9zZUV4aXN0ZW5jZUZpbHRlck1pc21hdGNoQmxvb21cIiAvKiBUYXJnZXRQdXJwb3NlLkV4aXN0ZW5jZUZpbHRlck1pc21hdGNoQmxvb20gKi86XG4gICAgICAgICAgICByZXR1cm4gJ2V4aXN0ZW5jZS1maWx0ZXItbWlzbWF0Y2gtYmxvb20nO1xuICAgICAgICBjYXNlIFwiVGFyZ2V0UHVycG9zZUxpbWJvUmVzb2x1dGlvblwiIC8qIFRhcmdldFB1cnBvc2UuTGltYm9SZXNvbHV0aW9uICovOlxuICAgICAgICAgICAgcmV0dXJuICdsaW1iby1kb2N1bWVudCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgweDcxM2IsIHsgcHVycG9zZSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1RhcmdldChzZXJpYWxpemVyLCB0YXJnZXREYXRhKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXREYXRhLnRhcmdldDtcbiAgICBpZiAodGFyZ2V0SXNEb2N1bWVudFRhcmdldCh0YXJnZXQpKSB7XG4gICAgICAgIHJlc3VsdCA9IHsgZG9jdW1lbnRzOiB0b0RvY3VtZW50c1RhcmdldChzZXJpYWxpemVyLCB0YXJnZXQpIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB7IHF1ZXJ5OiB0b1F1ZXJ5VGFyZ2V0KHNlcmlhbGl6ZXIsIHRhcmdldCkucXVlcnlUYXJnZXQgfTtcbiAgICB9XG4gICAgcmVzdWx0LnRhcmdldElkID0gdGFyZ2V0RGF0YS50YXJnZXRJZDtcbiAgICBpZiAodGFyZ2V0RGF0YS5yZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPiAwKSB7XG4gICAgICAgIHJlc3VsdC5yZXN1bWVUb2tlbiA9IHRvQnl0ZXMoc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5yZXN1bWVUb2tlbik7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQ291bnQgPSB0b0ludDMyUHJvdG8oc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5leHBlY3RlZENvdW50KTtcbiAgICAgICAgaWYgKGV4cGVjdGVkQ291bnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5leHBlY3RlZENvdW50ID0gZXhwZWN0ZWRDb3VudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbi5jb21wYXJlVG8oU25hcHNob3RWZXJzaW9uLm1pbigpKSA+IDApIHtcbiAgICAgICAgLy8gVE9ETyh3dWFuZHkpOiBDb25zaWRlciByZW1vdmluZyBhYm92ZSBjaGVjayBiZWNhdXNlIGl0IGlzIG1vc3QgbGlrZWx5IHRydWUuXG4gICAgICAgIC8vIFJpZ2h0IG5vdywgbWFueSB0ZXN0cyBkZXBlbmQgb24gdGhpcyBiZWhhdmlvdXIgdGhvdWdoIChsZWF2aW5nIG1pbigpIG91dFxuICAgICAgICAvLyBvZiBzZXJpYWxpemF0aW9uKS5cbiAgICAgICAgcmVzdWx0LnJlYWRUaW1lID0gdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24udG9UaW1lc3RhbXAoKSk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQ291bnQgPSB0b0ludDMyUHJvdG8oc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5leHBlY3RlZENvdW50KTtcbiAgICAgICAgaWYgKGV4cGVjdGVkQ291bnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5leHBlY3RlZENvdW50ID0gZXhwZWN0ZWRDb3VudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9GaWx0ZXJzKGZpbHRlcnMpIHtcbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdG9GaWx0ZXIoQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShmaWx0ZXJzLCBcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLykpO1xufVxuZnVuY3Rpb24gZnJvbUZpbHRlcnMoZmlsdGVyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZnJvbUZpbHRlcihmaWx0ZXIpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIgJiZcbiAgICAgICAgY29tcG9zaXRlRmlsdGVySXNGbGF0Q29uanVuY3Rpb24ocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmdldEZpbHRlcnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyZXN1bHRdO1xufVxuZnVuY3Rpb24gZnJvbUZpbHRlcihmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyLnVuYXJ5RmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZyb21VbmFyeUZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaWx0ZXIuZmllbGRGaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZnJvbUZpZWxkRmlsdGVyKGZpbHRlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbHRlci5jb21wb3NpdGVGaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZnJvbUNvbXBvc2l0ZUZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoMHg3NTkxLCB7IGZpbHRlciB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b09yZGVyKG9yZGVyQnlzKSB7XG4gICAgaWYgKG9yZGVyQnlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBvcmRlckJ5cy5tYXAob3JkZXIgPT4gdG9Qcm9wZXJ0eU9yZGVyKG9yZGVyKSk7XG59XG5mdW5jdGlvbiBmcm9tT3JkZXIob3JkZXJCeXMpIHtcbiAgICByZXR1cm4gb3JkZXJCeXMubWFwKG9yZGVyID0+IGZyb21Qcm9wZXJ0eU9yZGVyKG9yZGVyKSk7XG59XG5mdW5jdGlvbiB0b1N0YXJ0QXRDdXJzb3IoY3Vyc29yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmVmb3JlOiBjdXJzb3IuaW5jbHVzaXZlLFxuICAgICAgICB2YWx1ZXM6IGN1cnNvci5wb3NpdGlvblxuICAgIH07XG59XG5mdW5jdGlvbiB0b0VuZEF0Q3Vyc29yKGN1cnNvcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJlZm9yZTogIWN1cnNvci5pbmNsdXNpdmUsXG4gICAgICAgIHZhbHVlczogY3Vyc29yLnBvc2l0aW9uXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21TdGFydEF0Q3Vyc29yKGN1cnNvcikge1xuICAgIGNvbnN0IGluY2x1c2l2ZSA9ICEhY3Vyc29yLmJlZm9yZTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGN1cnNvci52YWx1ZXMgfHwgW107XG4gICAgcmV0dXJuIG5ldyBCb3VuZChwb3NpdGlvbiwgaW5jbHVzaXZlKTtcbn1cbmZ1bmN0aW9uIGZyb21FbmRBdEN1cnNvcihjdXJzb3IpIHtcbiAgICBjb25zdCBpbmNsdXNpdmUgPSAhY3Vyc29yLmJlZm9yZTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGN1cnNvci52YWx1ZXMgfHwgW107XG4gICAgcmV0dXJuIG5ldyBCb3VuZChwb3NpdGlvbiwgaW5jbHVzaXZlKTtcbn1cbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIHRvRGlyZWN0aW9uKGRpcikge1xuICAgIHJldHVybiBESVJFQ1RJT05TW2Rpcl07XG59XG4vLyB2aXNpYmxlIGZvciB0ZXN0aW5nXG5mdW5jdGlvbiBmcm9tRGlyZWN0aW9uKGRpcikge1xuICAgIHN3aXRjaCAoZGlyKSB7XG4gICAgICAgIGNhc2UgJ0FTQ0VORElORyc6XG4gICAgICAgICAgICByZXR1cm4gXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovO1xuICAgICAgICBjYXNlICdERVNDRU5ESU5HJzpcbiAgICAgICAgICAgIHJldHVybiBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqLztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xuZnVuY3Rpb24gdG9PcGVyYXRvck5hbWUob3ApIHtcbiAgICByZXR1cm4gT1BFUkFUT1JTW29wXTtcbn1cbmZ1bmN0aW9uIHRvQ29tcG9zaXRlT3BlcmF0b3JOYW1lKG9wKSB7XG4gICAgcmV0dXJuIENPTVBPU0lURV9PUEVSQVRPUlNbb3BdO1xufVxuZnVuY3Rpb24gZnJvbU9wZXJhdG9yTmFtZShvcCkge1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgY2FzZSAnRVFVQUwnOlxuICAgICAgICAgICAgcmV0dXJuIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLztcbiAgICAgICAgY2FzZSAnTk9UX0VRVUFMJzpcbiAgICAgICAgICAgIHJldHVybiBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovO1xuICAgICAgICBjYXNlICdHUkVBVEVSX1RIQU4nOlxuICAgICAgICAgICAgcmV0dXJuIFwiPlwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTiAqLztcbiAgICAgICAgY2FzZSAnR1JFQVRFUl9USEFOX09SX0VRVUFMJzpcbiAgICAgICAgICAgIHJldHVybiBcIj49XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOX09SX0VRVUFMICovO1xuICAgICAgICBjYXNlICdMRVNTX1RIQU4nOlxuICAgICAgICAgICAgcmV0dXJuIFwiPFwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTiAqLztcbiAgICAgICAgY2FzZSAnTEVTU19USEFOX09SX0VRVUFMJzpcbiAgICAgICAgICAgIHJldHVybiBcIjw9XCIgLyogT3BlcmF0b3IuTEVTU19USEFOX09SX0VRVUFMICovO1xuICAgICAgICBjYXNlICdBUlJBWV9DT05UQUlOUyc6XG4gICAgICAgICAgICByZXR1cm4gXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovO1xuICAgICAgICBjYXNlICdJTic6XG4gICAgICAgICAgICByZXR1cm4gXCJpblwiIC8qIE9wZXJhdG9yLklOICovO1xuICAgICAgICBjYXNlICdOT1RfSU4nOlxuICAgICAgICAgICAgcmV0dXJuIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovO1xuICAgICAgICBjYXNlICdBUlJBWV9DT05UQUlOU19BTlknOlxuICAgICAgICAgICAgcmV0dXJuIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovO1xuICAgICAgICBjYXNlICdPUEVSQVRPUl9VTlNQRUNJRklFRCc6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgweGUyZmUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoMHhjNTRhKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmcm9tQ29tcG9zaXRlT3BlcmF0b3JOYW1lKG9wKSB7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlICdBTkQnOlxuICAgICAgICAgICAgcmV0dXJuIFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovO1xuICAgICAgICBjYXNlICdPUic6XG4gICAgICAgICAgICByZXR1cm4gXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoMHgwNDAyKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShwYXRoKSB7XG4gICAgcmV0dXJuIHsgZmllbGRQYXRoOiBwYXRoLmNhbm9uaWNhbFN0cmluZygpIH07XG59XG5mdW5jdGlvbiBmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpZWxkUmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIEZpZWxkUGF0aCQxLmZyb21TZXJ2ZXJGb3JtYXQoZmllbGRSZWZlcmVuY2UuZmllbGRQYXRoKTtcbn1cbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIHRvUHJvcGVydHlPcmRlcihvcmRlckJ5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKG9yZGVyQnkuZmllbGQpLFxuICAgICAgICBkaXJlY3Rpb246IHRvRGlyZWN0aW9uKG9yZGVyQnkuZGlyKVxuICAgIH07XG59XG5mdW5jdGlvbiBmcm9tUHJvcGVydHlPcmRlcihvcmRlckJ5KSB7XG4gICAgcmV0dXJuIG5ldyBPcmRlckJ5KGZyb21GaWVsZFBhdGhSZWZlcmVuY2Uob3JkZXJCeS5maWVsZCksIGZyb21EaXJlY3Rpb24ob3JkZXJCeS5kaXJlY3Rpb24pKTtcbn1cbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIHRvRmlsdGVyKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcikge1xuICAgICAgICByZXR1cm4gdG9VbmFyeU9yRmllbGRGaWx0ZXIoZmlsdGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB0b0NvbXBvc2l0ZUZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoMHhkNjVkLCB7IGZpbHRlciB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0NvbXBvc2l0ZUZpbHRlcihmaWx0ZXIpIHtcbiAgICBjb25zdCBwcm90b3MgPSBmaWx0ZXIuZ2V0RmlsdGVycygpLm1hcChmaWx0ZXIgPT4gdG9GaWx0ZXIoZmlsdGVyKSk7XG4gICAgaWYgKHByb3Rvcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHByb3Rvc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcG9zaXRlRmlsdGVyOiB7XG4gICAgICAgICAgICBvcDogdG9Db21wb3NpdGVPcGVyYXRvck5hbWUoZmlsdGVyLm9wKSxcbiAgICAgICAgICAgIGZpbHRlcnM6IHByb3Rvc1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvVW5hcnlPckZpZWxkRmlsdGVyKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIub3AgPT09IFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLykge1xuICAgICAgICBpZiAoaXNOYW5WYWx1ZShmaWx0ZXIudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxuICAgICAgICAgICAgICAgICAgICBvcDogJ0lTX05BTidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVsbFZhbHVlKGZpbHRlci52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdW5hcnlGaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZCksXG4gICAgICAgICAgICAgICAgICAgIG9wOiAnSVNfTlVMTCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbHRlci5vcCA9PT0gXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLykge1xuICAgICAgICBpZiAoaXNOYW5WYWx1ZShmaWx0ZXIudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxuICAgICAgICAgICAgICAgICAgICBvcDogJ0lTX05PVF9OQU4nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc051bGxWYWx1ZShmaWx0ZXIudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxuICAgICAgICAgICAgICAgICAgICBvcDogJ0lTX05PVF9OVUxMJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmllbGRGaWx0ZXI6IHtcbiAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxuICAgICAgICAgICAgb3A6IHRvT3BlcmF0b3JOYW1lKGZpbHRlci5vcCksXG4gICAgICAgICAgICB2YWx1ZTogZmlsdGVyLnZhbHVlXG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbVVuYXJ5RmlsdGVyKGZpbHRlcikge1xuICAgIHN3aXRjaCAoZmlsdGVyLnVuYXJ5RmlsdGVyLm9wKSB7XG4gICAgICAgIGNhc2UgJ0lTX05BTic6XG4gICAgICAgICAgICBjb25zdCBuYW5GaWVsZCA9IGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLnVuYXJ5RmlsdGVyLmZpZWxkKTtcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobmFuRmllbGQsIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLywge1xuICAgICAgICAgICAgICAgIGRvdWJsZVZhbHVlOiBOYU5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlICdJU19OVUxMJzpcbiAgICAgICAgICAgIGNvbnN0IG51bGxGaWVsZCA9IGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLnVuYXJ5RmlsdGVyLmZpZWxkKTtcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobnVsbEZpZWxkLCBcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi8sIHtcbiAgICAgICAgICAgICAgICBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgJ0lTX05PVF9OQU4nOlxuICAgICAgICAgICAgY29uc3Qgbm90TmFuRmllbGQgPSBmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci51bmFyeUZpbHRlci5maWVsZCk7XG4gICAgICAgICAgICByZXR1cm4gRmllbGRGaWx0ZXIuY3JlYXRlKG5vdE5hbkZpZWxkLCBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovLCB7XG4gICAgICAgICAgICAgICAgZG91YmxlVmFsdWU6IE5hTlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgJ0lTX05PVF9OVUxMJzpcbiAgICAgICAgICAgIGNvbnN0IG5vdE51bGxGaWVsZCA9IGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLnVuYXJ5RmlsdGVyLmZpZWxkKTtcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobm90TnVsbEZpZWxkLCBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovLCB7XG4gICAgICAgICAgICAgICAgbnVsbFZhbHVlOiAnTlVMTF9WQUxVRSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlICdPUEVSQVRPUl9VTlNQRUNJRklFRCc6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgweGVmODEpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoMHhlZDM2KTtcbiAgICB9XG59XG5mdW5jdGlvbiBmcm9tRmllbGRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgcmV0dXJuIEZpZWxkRmlsdGVyLmNyZWF0ZShmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZEZpbHRlci5maWVsZCksIGZyb21PcGVyYXRvck5hbWUoZmlsdGVyLmZpZWxkRmlsdGVyLm9wKSwgZmlsdGVyLmZpZWxkRmlsdGVyLnZhbHVlKTtcbn1cbmZ1bmN0aW9uIGZyb21Db21wb3NpdGVGaWx0ZXIoZmlsdGVyKSB7XG4gICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUoZmlsdGVyLmNvbXBvc2l0ZUZpbHRlci5maWx0ZXJzLm1hcChmaWx0ZXIgPT4gZnJvbUZpbHRlcihmaWx0ZXIpKSwgZnJvbUNvbXBvc2l0ZU9wZXJhdG9yTmFtZShmaWx0ZXIuY29tcG9zaXRlRmlsdGVyLm9wKSk7XG59XG5mdW5jdGlvbiB0b0RvY3VtZW50TWFzayhmaWVsZE1hc2spIHtcbiAgICBjb25zdCBjYW5vbmljYWxGaWVsZHMgPSBbXTtcbiAgICBmaWVsZE1hc2suZmllbGRzLmZvckVhY2goZmllbGQgPT4gY2Fub25pY2FsRmllbGRzLnB1c2goZmllbGQuY2Fub25pY2FsU3RyaW5nKCkpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWVsZFBhdGhzOiBjYW5vbmljYWxGaWVsZHNcbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbURvY3VtZW50TWFzayhwcm90bykge1xuICAgIGNvbnN0IHBhdGhzID0gcHJvdG8uZmllbGRQYXRocyB8fCBbXTtcbiAgICByZXR1cm4gbmV3IEZpZWxkTWFzayhwYXRocy5tYXAocGF0aCA9PiBGaWVsZFBhdGgkMS5mcm9tU2VydmVyRm9ybWF0KHBhdGgpKSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkUmVzb3VyY2VOYW1lKHBhdGgpIHtcbiAgICAvLyBSZXNvdXJjZSBuYW1lcyBoYXZlIGF0IGxlYXN0IDQgY29tcG9uZW50cyAocHJvamVjdCBJRCwgZGF0YWJhc2UgSUQpXG4gICAgcmV0dXJuIChwYXRoLmxlbmd0aCA+PSA0ICYmXG4gICAgICAgIHBhdGguZ2V0KDApID09PSAncHJvamVjdHMnICYmXG4gICAgICAgIHBhdGguZ2V0KDIpID09PSAnZGF0YWJhc2VzJyk7XG59XG5mdW5jdGlvbiBpc1Byb3RvVmFsdWVTZXJpYWxpemFibGUoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxudmFsdWUpIHtcbiAgICByZXR1cm4gKCEhdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLl90b1Byb3RvID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHZhbHVlLl9wcm90b1ZhbHVlVHlwZSA9PT0gJ1Byb3RvVmFsdWUnKTtcbn1cbmZ1bmN0aW9uIHRvTWFwVmFsdWUoc2VyaWFsaXplciwgaW5wdXQpIHtcbiAgICBjb25zdCBtYXAgPSB7IGZpZWxkczoge30gfTtcbiAgICBpbnB1dC5mb3JFYWNoKChleHAsIGtleSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGVuY29kZSBtYXAgd2l0aCBub24tc3RyaW5nIGtleTogJHtrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbWFwLmZpZWxkc1trZXldID0gZXhwLl90b1Byb3RvKHNlcmlhbGl6ZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1hcFZhbHVlOiBtYXBcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9TdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB7IHN0cmluZ1ZhbHVlOiB2YWx1ZSB9O1xufVxuZnVuY3Rpb24gdG9QaXBlbGluZVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHsgcGlwZWxpbmVWYWx1ZTogdmFsdWUgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQW4gaW1tdXRhYmxlIHNldCBvZiBtZXRhZGF0YSB0aGF0IHRoZSBsb2NhbCBzdG9yZSB0cmFja3MgZm9yIGVhY2ggdGFyZ2V0LlxuICovXG5jbGFzcyBUYXJnZXREYXRhIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVGhlIHRhcmdldCBiZWluZyBsaXN0ZW5lZCB0by4gKi9cbiAgICB0YXJnZXQsIFxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgSUQgdG8gd2hpY2ggdGhlIHRhcmdldCBjb3JyZXNwb25kczsgQXNzaWduZWQgYnkgdGhlXG4gICAgICogTG9jYWxTdG9yZSBmb3IgdXNlciBsaXN0ZW5zIGFuZCBieSB0aGUgU3luY0VuZ2luZSBmb3IgbGltYm8gd2F0Y2hlcy5cbiAgICAgKi9cbiAgICB0YXJnZXRJZCwgXG4gICAgLyoqIFRoZSBwdXJwb3NlIG9mIHRoZSB0YXJnZXQuICovXG4gICAgcHVycG9zZSwgXG4gICAgLyoqXG4gICAgICogVGhlIHNlcXVlbmNlIG51bWJlciBvZiB0aGUgbGFzdCB0cmFuc2FjdGlvbiBkdXJpbmcgd2hpY2ggdGhpcyB0YXJnZXQgZGF0YVxuICAgICAqIHdhcyBtb2RpZmllZC5cbiAgICAgKi9cbiAgICBzZXF1ZW5jZU51bWJlciwgXG4gICAgLyoqIFRoZSBsYXRlc3Qgc25hcHNob3QgdmVyc2lvbiBzZWVuIGZvciB0aGlzIHRhcmdldC4gKi9cbiAgICBzbmFwc2hvdFZlcnNpb24gPSBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIHNuYXBzaG90IHZlcnNpb24gYXQgd2hpY2ggdGhlIGFzc29jaWF0ZWQgdmlld1xuICAgICAqIGNvbnRhaW5lZCBubyBsaW1ibyBkb2N1bWVudHMuXG4gICAgICovXG4gICAgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiA9IFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXG4gICAgLyoqXG4gICAgICogQW4gb3BhcXVlLCBzZXJ2ZXItYXNzaWduZWQgdG9rZW4gdGhhdCBhbGxvd3Mgd2F0Y2hpbmcgYSB0YXJnZXQgdG8gYmVcbiAgICAgKiByZXN1bWVkIGFmdGVyIGRpc2Nvbm5lY3Rpbmcgd2l0aG91dCByZXRyYW5zbWl0dGluZyBhbGwgdGhlIGRhdGEgdGhhdFxuICAgICAqIG1hdGNoZXMgdGhlIHRhcmdldC4gVGhlIHJlc3VtZSB0b2tlbiBlc3NlbnRpYWxseSBpZGVudGlmaWVzIGEgcG9pbnQgaW5cbiAgICAgKiB0aW1lIGZyb20gd2hpY2ggdGhlIHNlcnZlciBzaG91bGQgcmVzdW1lIHNlbmRpbmcgcmVzdWx0cy5cbiAgICAgKi9cbiAgICByZXN1bWVUb2tlbiA9IEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcsIFxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHRoYXQgbGFzdCBtYXRjaGVkIHRoZSBxdWVyeSBhdCB0aGUgcmVzdW1lIHRva2VuIG9yXG4gICAgICogcmVhZCB0aW1lLiBEb2N1bWVudHMgYXJlIGNvdW50ZWQgb25seSB3aGVuIG1ha2luZyBhIGxpc3RlbiByZXF1ZXN0IHdpdGhcbiAgICAgKiByZXN1bWUgdG9rZW4gb3IgcmVhZCB0aW1lLCBvdGhlcndpc2UsIGtlZXAgaXQgbnVsbC5cbiAgICAgKi9cbiAgICBleHBlY3RlZENvdW50ID0gbnVsbCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy50YXJnZXRJZCA9IHRhcmdldElkO1xuICAgICAgICB0aGlzLnB1cnBvc2UgPSBwdXJwb3NlO1xuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIHRoaXMuc25hcHNob3RWZXJzaW9uID0gc25hcHNob3RWZXJzaW9uO1xuICAgICAgICB0aGlzLmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gPSBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uO1xuICAgICAgICB0aGlzLnJlc3VtZVRva2VuID0gcmVzdW1lVG9rZW47XG4gICAgICAgIHRoaXMuZXhwZWN0ZWRDb3VudCA9IGV4cGVjdGVkQ291bnQ7XG4gICAgfVxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHRhcmdldCBkYXRhIGluc3RhbmNlIHdpdGggYW4gdXBkYXRlZCBzZXF1ZW5jZSBudW1iZXIuICovXG4gICAgd2l0aFNlcXVlbmNlTnVtYmVyKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0RGF0YSh0aGlzLnRhcmdldCwgdGhpcy50YXJnZXRJZCwgdGhpcy5wdXJwb3NlLCBzZXF1ZW5jZU51bWJlciwgdGhpcy5zbmFwc2hvdFZlcnNpb24sIHRoaXMubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiwgdGhpcy5yZXN1bWVUb2tlbiwgdGhpcy5leHBlY3RlZENvdW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0YXJnZXQgZGF0YSBpbnN0YW5jZSB3aXRoIGFuIHVwZGF0ZWQgcmVzdW1lIHRva2VuIGFuZFxuICAgICAqIHNuYXBzaG90IHZlcnNpb24uXG4gICAgICovXG4gICAgd2l0aFJlc3VtZVRva2VuKHJlc3VtZVRva2VuLCBzbmFwc2hvdFZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXREYXRhKHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldElkLCB0aGlzLnB1cnBvc2UsIHRoaXMuc2VxdWVuY2VOdW1iZXIsIHNuYXBzaG90VmVyc2lvbiwgdGhpcy5sYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLCByZXN1bWVUb2tlbiwgXG4gICAgICAgIC8qIGV4cGVjdGVkQ291bnQ9ICovIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRhcmdldCBkYXRhIGluc3RhbmNlIHdpdGggYW4gdXBkYXRlZCBleHBlY3RlZCBjb3VudC5cbiAgICAgKi9cbiAgICB3aXRoRXhwZWN0ZWRDb3VudChleHBlY3RlZENvdW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0RGF0YSh0aGlzLnRhcmdldCwgdGhpcy50YXJnZXRJZCwgdGhpcy5wdXJwb3NlLCB0aGlzLnNlcXVlbmNlTnVtYmVyLCB0aGlzLnNuYXBzaG90VmVyc2lvbiwgdGhpcy5sYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLCB0aGlzLnJlc3VtZVRva2VuLCBleHBlY3RlZENvdW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0YXJnZXQgZGF0YSBpbnN0YW5jZSB3aXRoIGFuIHVwZGF0ZWQgbGFzdCBsaW1ibyBmcmVlXG4gICAgICogc25hcHNob3QgdmVyc2lvbiBudW1iZXIuXG4gICAgICovXG4gICAgd2l0aExhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24obGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0SWQsIHRoaXMucHVycG9zZSwgdGhpcy5zZXF1ZW5jZU51bWJlciwgdGhpcy5zbmFwc2hvdFZlcnNpb24sIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIHRoaXMucmVzdW1lVG9rZW4sIHRoaXMuZXhwZWN0ZWRDb3VudCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIFNlcmlhbGl6ZXIgZm9yIHZhbHVlcyBzdG9yZWQgaW4gdGhlIExvY2FsU3RvcmUuICovXG5jbGFzcyBMb2NhbFNlcmlhbGl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlbW90ZVNlcmlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5yZW1vdGVTZXJpYWxpemVyID0gcmVtb3RlU2VyaWFsaXplcjtcbiAgICB9XG59XG4vKiogRGVjb2RlcyBhIHJlbW90ZSBkb2N1bWVudCBmcm9tIHN0b3JhZ2UgbG9jYWxseSB0byBhIERvY3VtZW50LiAqL1xuZnVuY3Rpb24gZnJvbURiUmVtb3RlRG9jdW1lbnQobG9jYWxTZXJpYWxpemVyLCByZW1vdGVEb2MpIHtcbiAgICBsZXQgZG9jO1xuICAgIGlmIChyZW1vdGVEb2MuZG9jdW1lbnQpIHtcbiAgICAgICAgZG9jID0gZnJvbURvY3VtZW50KGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCByZW1vdGVEb2MuZG9jdW1lbnQsICEhcmVtb3RlRG9jLmhhc0NvbW1pdHRlZE11dGF0aW9ucyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlbW90ZURvYy5ub0RvY3VtZW50KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhyZW1vdGVEb2Mubm9Eb2N1bWVudC5wYXRoKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGZyb21EYlRpbWVzdGFtcChyZW1vdGVEb2Mubm9Eb2N1bWVudC5yZWFkVGltZSk7XG4gICAgICAgIGRvYyA9IE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGtleSwgdmVyc2lvbik7XG4gICAgICAgIGlmIChyZW1vdGVEb2MuaGFzQ29tbWl0dGVkTXV0YXRpb25zKSB7XG4gICAgICAgICAgICBkb2Muc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVtb3RlRG9jLnVua25vd25Eb2N1bWVudCkge1xuICAgICAgICBjb25zdCBrZXkgPSBEb2N1bWVudEtleS5mcm9tU2VnbWVudHMocmVtb3RlRG9jLnVua25vd25Eb2N1bWVudC5wYXRoKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGZyb21EYlRpbWVzdGFtcChyZW1vdGVEb2MudW5rbm93bkRvY3VtZW50LnZlcnNpb24pO1xuICAgICAgICBkb2MgPSBNdXRhYmxlRG9jdW1lbnQubmV3VW5rbm93bkRvY3VtZW50KGtleSwgdmVyc2lvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgweGRkODUpO1xuICAgIH1cbiAgICBpZiAocmVtb3RlRG9jLnJlYWRUaW1lKSB7XG4gICAgICAgIGRvYy5zZXRSZWFkVGltZShmcm9tRGJUaW1lc3RhbXBLZXkocmVtb3RlRG9jLnJlYWRUaW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBkb2M7XG59XG4vKiogRW5jb2RlcyBhIGRvY3VtZW50IGZvciBzdG9yYWdlIGxvY2FsbHkuICovXG5mdW5jdGlvbiB0b0RiUmVtb3RlRG9jdW1lbnQobG9jYWxTZXJpYWxpemVyLCBkb2N1bWVudCkge1xuICAgIGNvbnN0IGtleSA9IGRvY3VtZW50LmtleTtcbiAgICBjb25zdCByZW1vdGVEb2MgPSB7XG4gICAgICAgIHByZWZpeFBhdGg6IGtleS5nZXRDb2xsZWN0aW9uUGF0aCgpLnBvcExhc3QoKS50b0FycmF5KCksXG4gICAgICAgIGNvbGxlY3Rpb25Hcm91cDoga2V5LmNvbGxlY3Rpb25Hcm91cCxcbiAgICAgICAgZG9jdW1lbnRJZDoga2V5LnBhdGgubGFzdFNlZ21lbnQoKSxcbiAgICAgICAgcmVhZFRpbWU6IHRvRGJUaW1lc3RhbXBLZXkoZG9jdW1lbnQucmVhZFRpbWUpLFxuICAgICAgICBoYXNDb21taXR0ZWRNdXRhdGlvbnM6IGRvY3VtZW50Lmhhc0NvbW1pdHRlZE11dGF0aW9uc1xuICAgIH07XG4gICAgaWYgKGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpKSB7XG4gICAgICAgIHJlbW90ZURvYy5kb2N1bWVudCA9IHRvRG9jdW1lbnQobG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jdW1lbnQuaXNOb0RvY3VtZW50KCkpIHtcbiAgICAgICAgcmVtb3RlRG9jLm5vRG9jdW1lbnQgPSB7XG4gICAgICAgICAgICBwYXRoOiBrZXkucGF0aC50b0FycmF5KCksXG4gICAgICAgICAgICByZWFkVGltZTogdG9EYlRpbWVzdGFtcChkb2N1bWVudC52ZXJzaW9uKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChkb2N1bWVudC5pc1Vua25vd25Eb2N1bWVudCgpKSB7XG4gICAgICAgIHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQgPSB7XG4gICAgICAgICAgICBwYXRoOiBrZXkucGF0aC50b0FycmF5KCksXG4gICAgICAgICAgICB2ZXJzaW9uOiB0b0RiVGltZXN0YW1wKGRvY3VtZW50LnZlcnNpb24pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgweGUyMzAsIHsgZG9jdW1lbnQgfSk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdGVEb2M7XG59XG5mdW5jdGlvbiB0b0RiVGltZXN0YW1wS2V5KHNuYXBzaG90VmVyc2lvbikge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHNuYXBzaG90VmVyc2lvbi50b1RpbWVzdGFtcCgpO1xuICAgIHJldHVybiBbdGltZXN0YW1wLnNlY29uZHMsIHRpbWVzdGFtcC5uYW5vc2Vjb25kc107XG59XG5mdW5jdGlvbiBmcm9tRGJUaW1lc3RhbXBLZXkoZGJUaW1lc3RhbXBLZXkpIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgVGltZXN0YW1wKGRiVGltZXN0YW1wS2V5WzBdLCBkYlRpbWVzdGFtcEtleVsxXSk7XG4gICAgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5mcm9tVGltZXN0YW1wKHRpbWVzdGFtcCk7XG59XG5mdW5jdGlvbiB0b0RiVGltZXN0YW1wKHNuYXBzaG90VmVyc2lvbikge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHNuYXBzaG90VmVyc2lvbi50b1RpbWVzdGFtcCgpO1xuICAgIHJldHVybiB7IHNlY29uZHM6IHRpbWVzdGFtcC5zZWNvbmRzLCBuYW5vc2Vjb25kczogdGltZXN0YW1wLm5hbm9zZWNvbmRzIH07XG59XG5mdW5jdGlvbiBmcm9tRGJUaW1lc3RhbXAoZGJUaW1lc3RhbXApIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgVGltZXN0YW1wKGRiVGltZXN0YW1wLnNlY29uZHMsIGRiVGltZXN0YW1wLm5hbm9zZWNvbmRzKTtcbiAgICByZXR1cm4gU25hcHNob3RWZXJzaW9uLmZyb21UaW1lc3RhbXAodGltZXN0YW1wKTtcbn1cbi8qKiBFbmNvZGVzIGEgYmF0Y2ggb2YgbXV0YXRpb25zIGludG8gYSBEYk11dGF0aW9uQmF0Y2ggZm9yIGxvY2FsIHN0b3JhZ2UuICovXG5mdW5jdGlvbiB0b0RiTXV0YXRpb25CYXRjaChsb2NhbFNlcmlhbGl6ZXIsIHVzZXJJZCwgYmF0Y2gpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkQmFzZU11dGF0aW9ucyA9IGJhdGNoLmJhc2VNdXRhdGlvbnMubWFwKG0gPT4gdG9NdXRhdGlvbihsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgbSkpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNdXRhdGlvbnMgPSBiYXRjaC5tdXRhdGlvbnMubWFwKG0gPT4gdG9NdXRhdGlvbihsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgbSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgYmF0Y2hJZDogYmF0Y2guYmF0Y2hJZCxcbiAgICAgICAgbG9jYWxXcml0ZVRpbWVNczogYmF0Y2gubG9jYWxXcml0ZVRpbWUudG9NaWxsaXMoKSxcbiAgICAgICAgYmFzZU11dGF0aW9uczogc2VyaWFsaXplZEJhc2VNdXRhdGlvbnMsXG4gICAgICAgIG11dGF0aW9uczogc2VyaWFsaXplZE11dGF0aW9uc1xuICAgIH07XG59XG4vKiogRGVjb2RlcyBhIERiTXV0YXRpb25CYXRjaCBpbnRvIGEgTXV0YXRpb25CYXRjaCAqL1xuZnVuY3Rpb24gZnJvbURiTXV0YXRpb25CYXRjaChsb2NhbFNlcmlhbGl6ZXIsIGRiQmF0Y2gpIHtcbiAgICBjb25zdCBiYXNlTXV0YXRpb25zID0gKGRiQmF0Y2guYmFzZU11dGF0aW9ucyB8fCBbXSkubWFwKG0gPT4gZnJvbU11dGF0aW9uKGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCBtKSk7XG4gICAgLy8gU3F1YXNoIG9sZCB0cmFuc2Zvcm0gbXV0YXRpb25zIGludG8gZXhpc3RpbmcgcGF0Y2ggb3Igc2V0IG11dGF0aW9ucy5cbiAgICAvLyBUaGUgcmVwbGFjZW1lbnQgb2YgcmVwcmVzZW50aW5nIGB0cmFuc2Zvcm1zYCB3aXRoIGB1cGRhdGVfdHJhbnNmb3Jtc2BcbiAgICAvLyBvbiB0aGUgU0RLIG1lYW5zIHRoYXQgb2xkIGB0cmFuc2Zvcm1gIG11dGF0aW9ucyBzdG9yZWQgaW4gSW5kZXhlZERCIG5lZWRcbiAgICAvLyB0byBiZSB1cGRhdGVkIHRvIGB1cGRhdGVfdHJhbnNmb3Jtc2AuXG4gICAgLy8gVE9ETyhiLzE3NDYwODM3NCk6IFJlbW92ZSB0aGlzIGNvZGUgb25jZSB3ZSBwZXJmb3JtIGEgc2NoZW1hIG1pZ3JhdGlvbi5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRiQmF0Y2gubXV0YXRpb25zLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBjdXJyZW50TXV0YXRpb24gPSBkYkJhdGNoLm11dGF0aW9uc1tpXTtcbiAgICAgICAgY29uc3QgaGFzVHJhbnNmb3JtID0gaSArIDEgPCBkYkJhdGNoLm11dGF0aW9ucy5sZW5ndGggJiZcbiAgICAgICAgICAgIGRiQmF0Y2gubXV0YXRpb25zW2kgKyAxXS50cmFuc2Zvcm0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGhhc1RyYW5zZm9ybSkge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtTXV0YXRpb24gPSBkYkJhdGNoLm11dGF0aW9uc1tpICsgMV07XG4gICAgICAgICAgICBjdXJyZW50TXV0YXRpb24udXBkYXRlVHJhbnNmb3JtcyA9XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtTXV0YXRpb24udHJhbnNmb3JtLmZpZWxkVHJhbnNmb3JtcztcbiAgICAgICAgICAgIGRiQmF0Y2gubXV0YXRpb25zLnNwbGljZShpICsgMSwgMSk7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbXV0YXRpb25zID0gZGJCYXRjaC5tdXRhdGlvbnMubWFwKG0gPT4gZnJvbU11dGF0aW9uKGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCBtKSk7XG4gICAgY29uc3QgdGltZXN0YW1wID0gVGltZXN0YW1wLmZyb21NaWxsaXMoZGJCYXRjaC5sb2NhbFdyaXRlVGltZU1zKTtcbiAgICByZXR1cm4gbmV3IE11dGF0aW9uQmF0Y2goZGJCYXRjaC5iYXRjaElkLCB0aW1lc3RhbXAsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucyk7XG59XG4vKiogRGVjb2RlcyBhIERiVGFyZ2V0IGludG8gVGFyZ2V0RGF0YSAqL1xuZnVuY3Rpb24gZnJvbURiVGFyZ2V0KGRiVGFyZ2V0KSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IGZyb21EYlRpbWVzdGFtcChkYlRhcmdldC5yZWFkVGltZSk7XG4gICAgY29uc3QgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiA9IGRiVGFyZ2V0Lmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGZyb21EYlRpbWVzdGFtcChkYlRhcmdldC5sYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKVxuICAgICAgICA6IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICBsZXQgdGFyZ2V0O1xuICAgIGlmIChpc0RvY3VtZW50UXVlcnkoZGJUYXJnZXQucXVlcnkpKSB7XG4gICAgICAgIHRhcmdldCA9IGZyb21Eb2N1bWVudHNUYXJnZXQoZGJUYXJnZXQucXVlcnkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFyZ2V0ID0gZnJvbVF1ZXJ5VGFyZ2V0KGRiVGFyZ2V0LnF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUYXJnZXREYXRhKHRhcmdldCwgZGJUYXJnZXQudGFyZ2V0SWQsIFwiVGFyZ2V0UHVycG9zZUxpc3RlblwiIC8qIFRhcmdldFB1cnBvc2UuTGlzdGVuICovLCBkYlRhcmdldC5sYXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIsIHZlcnNpb24sIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIEJ5dGVTdHJpbmcuZnJvbUJhc2U2NFN0cmluZyhkYlRhcmdldC5yZXN1bWVUb2tlbikpO1xufVxuLyoqIEVuY29kZXMgVGFyZ2V0RGF0YSBpbnRvIGEgRGJUYXJnZXQgZm9yIHN0b3JhZ2UgbG9jYWxseS4gKi9cbmZ1bmN0aW9uIHRvRGJUYXJnZXQobG9jYWxTZXJpYWxpemVyLCB0YXJnZXREYXRhKSB7XG4gICAgY29uc3QgZGJUaW1lc3RhbXAgPSB0b0RiVGltZXN0YW1wKHRhcmdldERhdGEuc25hcHNob3RWZXJzaW9uKTtcbiAgICBjb25zdCBkYkxhc3RMaW1ib0ZyZWVUaW1lc3RhbXAgPSB0b0RiVGltZXN0YW1wKHRhcmdldERhdGEubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbik7XG4gICAgbGV0IHF1ZXJ5UHJvdG87XG4gICAgaWYgKHRhcmdldElzRG9jdW1lbnRUYXJnZXQodGFyZ2V0RGF0YS50YXJnZXQpKSB7XG4gICAgICAgIHF1ZXJ5UHJvdG8gPSB0b0RvY3VtZW50c1RhcmdldChsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgdGFyZ2V0RGF0YS50YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcXVlcnlQcm90byA9IHRvUXVlcnlUYXJnZXQobG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIHRhcmdldERhdGEudGFyZ2V0KS5xdWVyeVRhcmdldDtcbiAgICB9XG4gICAgLy8gV2UgY2FuJ3Qgc3RvcmUgdGhlIHJlc3VtZVRva2VuIGFzIGEgQnl0ZVN0cmluZyBpbiBJbmRleGVkRGIsIHNvIHdlXG4gICAgLy8gY29udmVydCBpdCB0byBhIGJhc2U2NCBzdHJpbmcgZm9yIHN0b3JhZ2UuXG4gICAgY29uc3QgcmVzdW1lVG9rZW4gPSB0YXJnZXREYXRhLnJlc3VtZVRva2VuLnRvQmFzZTY0KCk7XG4gICAgLy8gbGFzdExpc3RlblNlcXVlbmNlTnVtYmVyIGlzIGFsd2F5cyAwIHVudGlsIHdlIGRvIHJlYWwgR0MuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0SWQ6IHRhcmdldERhdGEudGFyZ2V0SWQsXG4gICAgICAgIGNhbm9uaWNhbElkOiBjYW5vbmlmeVRhcmdldCh0YXJnZXREYXRhLnRhcmdldCksXG4gICAgICAgIHJlYWRUaW1lOiBkYlRpbWVzdGFtcCxcbiAgICAgICAgcmVzdW1lVG9rZW4sXG4gICAgICAgIGxhc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcjogdGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlcixcbiAgICAgICAgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbjogZGJMYXN0TGltYm9GcmVlVGltZXN0YW1wLFxuICAgICAgICBxdWVyeTogcXVlcnlQcm90b1xuICAgIH07XG59XG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIGZvciBmaWd1cmluZyBvdXQgd2hhdCBraW5kIG9mIHF1ZXJ5IGhhcyBiZWVuIHN0b3JlZC5cbiAqL1xuZnVuY3Rpb24gaXNEb2N1bWVudFF1ZXJ5KGRiUXVlcnkpIHtcbiAgICByZXR1cm4gZGJRdWVyeS5kb2N1bWVudHMgIT09IHVuZGVmaW5lZDtcbn1cbi8qKiBFbmNvZGVzIGEgRGJCdW5kbGUgdG8gYSBCdW5kbGVNZXRhZGF0YSBvYmplY3QuICovXG5mdW5jdGlvbiBmcm9tRGJCdW5kbGUoZGJCdW5kbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogZGJCdW5kbGUuYnVuZGxlSWQsXG4gICAgICAgIGNyZWF0ZVRpbWU6IGZyb21EYlRpbWVzdGFtcChkYkJ1bmRsZS5jcmVhdGVUaW1lKSxcbiAgICAgICAgdmVyc2lvbjogZGJCdW5kbGUudmVyc2lvblxuICAgIH07XG59XG4vKiogRW5jb2RlcyBhIEJ1bmRsZU1ldGFkYXRhIHRvIGEgRGJCdW5kbGUuICovXG5mdW5jdGlvbiB0b0RiQnVuZGxlKG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYnVuZGxlSWQ6IG1ldGFkYXRhLmlkLFxuICAgICAgICBjcmVhdGVUaW1lOiB0b0RiVGltZXN0YW1wKGZyb21WZXJzaW9uKG1ldGFkYXRhLmNyZWF0ZVRpbWUpKSxcbiAgICAgICAgdmVyc2lvbjogbWV0YWRhdGEudmVyc2lvblxuICAgIH07XG59XG4vKiogRW5jb2RlcyBhIERiTmFtZWRRdWVyeSB0byBhIE5hbWVkUXVlcnkuICovXG5mdW5jdGlvbiBmcm9tRGJOYW1lZFF1ZXJ5KGRiTmFtZWRRdWVyeSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGRiTmFtZWRRdWVyeS5uYW1lLFxuICAgICAgICBxdWVyeTogZnJvbUJ1bmRsZWRRdWVyeShkYk5hbWVkUXVlcnkuYnVuZGxlZFF1ZXJ5KSxcbiAgICAgICAgcmVhZFRpbWU6IGZyb21EYlRpbWVzdGFtcChkYk5hbWVkUXVlcnkucmVhZFRpbWUpXG4gICAgfTtcbn1cbi8qKiBFbmNvZGVzIGEgTmFtZWRRdWVyeSBmcm9tIGEgYnVuZGxlIHByb3RvIHRvIGEgRGJOYW1lZFF1ZXJ5LiAqL1xuZnVuY3Rpb24gdG9EYk5hbWVkUXVlcnkocXVlcnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBxdWVyeS5uYW1lLFxuICAgICAgICByZWFkVGltZTogdG9EYlRpbWVzdGFtcChmcm9tVmVyc2lvbihxdWVyeS5yZWFkVGltZSkpLFxuICAgICAgICBidW5kbGVkUXVlcnk6IHF1ZXJ5LmJ1bmRsZWRRdWVyeVxuICAgIH07XG59XG4vKipcbiAqIEVuY29kZXMgYSBgQnVuZGxlZFF1ZXJ5YCBmcm9tIGJ1bmRsZSBwcm90byB0byBhIFF1ZXJ5IG9iamVjdC5cbiAqXG4gKiBUaGlzIHJlY29uc3RydWN0cyB0aGUgb3JpZ2luYWwgcXVlcnkgdXNlZCB0byBidWlsZCB0aGUgYnVuZGxlIGJlaW5nIGxvYWRlZCxcbiAqIGluY2x1ZGluZyBmZWF0dXJlcyBleGlzdHMgb25seSBpbiBTREtzIChmb3IgZXhhbXBsZTogbGltaXQtdG8tbGFzdCkuXG4gKi9cbmZ1bmN0aW9uIGZyb21CdW5kbGVkUXVlcnkoYnVuZGxlZFF1ZXJ5KSB7XG4gICAgY29uc3QgcXVlcnkgPSBjb252ZXJ0UXVlcnlUYXJnZXRUb1F1ZXJ5KHtcbiAgICAgICAgcGFyZW50OiBidW5kbGVkUXVlcnkucGFyZW50LFxuICAgICAgICBzdHJ1Y3R1cmVkUXVlcnk6IGJ1bmRsZWRRdWVyeS5zdHJ1Y3R1cmVkUXVlcnlcbiAgICB9KTtcbiAgICBpZiAoYnVuZGxlZFF1ZXJ5LmxpbWl0VHlwZSA9PT0gJ0xBU1QnKSB7XG4gICAgICAgIHJldHVybiBxdWVyeVdpdGhMaW1pdChxdWVyeSwgcXVlcnkubGltaXQsIFwiTFwiIC8qIExpbWl0VHlwZS5MYXN0ICovKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5O1xufVxuLyoqIEVuY29kZXMgYSBOYW1lZFF1ZXJ5IHByb3RvIG9iamVjdCB0byBhIE5hbWVkUXVlcnkgbW9kZWwgb2JqZWN0LiAqL1xuZnVuY3Rpb24gZnJvbVByb3RvTmFtZWRRdWVyeShuYW1lZFF1ZXJ5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZWRRdWVyeS5uYW1lLFxuICAgICAgICBxdWVyeTogZnJvbUJ1bmRsZWRRdWVyeShuYW1lZFF1ZXJ5LmJ1bmRsZWRRdWVyeSksXG4gICAgICAgIHJlYWRUaW1lOiBmcm9tVmVyc2lvbihuYW1lZFF1ZXJ5LnJlYWRUaW1lKVxuICAgIH07XG59XG4vKiogRGVjb2RlcyBhIEJ1bmRsZU1ldGFkYXRhIHByb3RvIGludG8gYSBCdW5kbGVNZXRhZGF0YSBvYmplY3QuICovXG5mdW5jdGlvbiBmcm9tQnVuZGxlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogbWV0YWRhdGEuaWQsXG4gICAgICAgIHZlcnNpb246IG1ldGFkYXRhLnZlcnNpb24sXG4gICAgICAgIGNyZWF0ZVRpbWU6IGZyb21WZXJzaW9uKG1ldGFkYXRhLmNyZWF0ZVRpbWUpXG4gICAgfTtcbn1cbi8qKiBFbmNvZGVzIGEgRGJEb2N1bWVudE92ZXJsYXkgb2JqZWN0IHRvIGFuIE92ZXJsYXkgbW9kZWwgb2JqZWN0LiAqL1xuZnVuY3Rpb24gZnJvbURiRG9jdW1lbnRPdmVybGF5KGxvY2FsU2VyaWFsaXplciwgZGJEb2N1bWVudE92ZXJsYXkpIHtcbiAgICByZXR1cm4gbmV3IE92ZXJsYXkoZGJEb2N1bWVudE92ZXJsYXkubGFyZ2VzdEJhdGNoSWQsIGZyb21NdXRhdGlvbihsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgZGJEb2N1bWVudE92ZXJsYXkub3ZlcmxheU11dGF0aW9uKSk7XG59XG4vKiogRGVjb2RlcyBhbiBPdmVybGF5IG1vZGVsIG9iamVjdCBpbnRvIGEgRGJEb2N1bWVudE92ZXJsYXkgb2JqZWN0LiAqL1xuZnVuY3Rpb24gdG9EYkRvY3VtZW50T3ZlcmxheShsb2NhbFNlcmlhbGl6ZXIsIHVzZXJJZCwgb3ZlcmxheSkge1xuICAgIGNvbnN0IFtfLCBjb2xsZWN0aW9uUGF0aCwgZG9jdW1lbnRJZF0gPSB0b0RiRG9jdW1lbnRPdmVybGF5S2V5KHVzZXJJZCwgb3ZlcmxheS5tdXRhdGlvbi5rZXkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgY29sbGVjdGlvblBhdGgsXG4gICAgICAgIGRvY3VtZW50SWQsXG4gICAgICAgIGNvbGxlY3Rpb25Hcm91cDogb3ZlcmxheS5tdXRhdGlvbi5rZXkuZ2V0Q29sbGVjdGlvbkdyb3VwKCksXG4gICAgICAgIGxhcmdlc3RCYXRjaElkOiBvdmVybGF5Lmxhcmdlc3RCYXRjaElkLFxuICAgICAgICBvdmVybGF5TXV0YXRpb246IHRvTXV0YXRpb24obG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIG92ZXJsYXkubXV0YXRpb24pXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgRGJEb2N1bWVudE92ZXJsYXlLZXkgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gdXNlciBhbmRcbiAqIGRvY3VtZW50IGtleS5cbiAqL1xuZnVuY3Rpb24gdG9EYkRvY3VtZW50T3ZlcmxheUtleSh1c2VySWQsIGRvY0tleSkge1xuICAgIGNvbnN0IGRvY0lkID0gZG9jS2V5LnBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICBjb25zdCBjb2xsZWN0aW9uUGF0aCA9IGVuY29kZVJlc291cmNlUGF0aChkb2NLZXkucGF0aC5wb3BMYXN0KCkpO1xuICAgIHJldHVybiBbdXNlcklkLCBjb2xsZWN0aW9uUGF0aCwgZG9jSWRdO1xufVxuZnVuY3Rpb24gdG9EYkluZGV4Q29uZmlndXJhdGlvbihpbmRleCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4SWQ6IGluZGV4LmluZGV4SWQsXG4gICAgICAgIGNvbGxlY3Rpb25Hcm91cDogaW5kZXguY29sbGVjdGlvbkdyb3VwLFxuICAgICAgICBmaWVsZHM6IGluZGV4LmZpZWxkcy5tYXAocyA9PiBbcy5maWVsZFBhdGguY2Fub25pY2FsU3RyaW5nKCksIHMua2luZF0pXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21EYkluZGV4Q29uZmlndXJhdGlvbihpbmRleCwgc3RhdGUpIHtcbiAgICBjb25zdCBkZWNvZGVkU3RhdGUgPSBzdGF0ZVxuICAgICAgICA/IG5ldyBJbmRleFN0YXRlKHN0YXRlLnNlcXVlbmNlTnVtYmVyLCBuZXcgSW5kZXhPZmZzZXQoZnJvbURiVGltZXN0YW1wKHN0YXRlLnJlYWRUaW1lKSwgbmV3IERvY3VtZW50S2V5KGRlY29kZVJlc291cmNlUGF0aChzdGF0ZS5kb2N1bWVudEtleSkpLCBzdGF0ZS5sYXJnZXN0QmF0Y2hJZCkpXG4gICAgICAgIDogSW5kZXhTdGF0ZS5lbXB0eSgpO1xuICAgIGNvbnN0IGRlY29kZWRTZWdtZW50cyA9IGluZGV4LmZpZWxkcy5tYXAoKFtmaWVsZFBhdGgsIGtpbmRdKSA9PiBuZXcgSW5kZXhTZWdtZW50KEZpZWxkUGF0aCQxLmZyb21TZXJ2ZXJGb3JtYXQoZmllbGRQYXRoKSwga2luZCkpO1xuICAgIHJldHVybiBuZXcgRmllbGRJbmRleChpbmRleC5pbmRleElkLCBpbmRleC5jb2xsZWN0aW9uR3JvdXAsIGRlY29kZWRTZWdtZW50cywgZGVjb2RlZFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHRvRGJJbmRleFN0YXRlKGluZGV4SWQsIHVpZCwgc2VxdWVuY2VOdW1iZXIsIG9mZnNldCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4SWQsXG4gICAgICAgIHVpZCxcbiAgICAgICAgc2VxdWVuY2VOdW1iZXIsXG4gICAgICAgIHJlYWRUaW1lOiB0b0RiVGltZXN0YW1wKG9mZnNldC5yZWFkVGltZSksXG4gICAgICAgIGRvY3VtZW50S2V5OiBlbmNvZGVSZXNvdXJjZVBhdGgob2Zmc2V0LmRvY3VtZW50S2V5LnBhdGgpLFxuICAgICAgICBsYXJnZXN0QmF0Y2hJZDogb2Zmc2V0Lmxhcmdlc3RCYXRjaElkXG4gICAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEluZGV4ZWREYkJ1bmRsZUNhY2hlIHtcbiAgICBnZXRCdW5kbGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgYnVuZGxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGJ1bmRsZXNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5nZXQoYnVuZGxlSWQpXG4gICAgICAgICAgICAubmV4dChidW5kbGUgPT4ge1xuICAgICAgICAgICAgaWYgKGJ1bmRsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRGJCdW5kbGUoYnVuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzYXZlQnVuZGxlTWV0YWRhdGEodHJhbnNhY3Rpb24sIGJ1bmRsZU1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBidW5kbGVzU3RvcmUodHJhbnNhY3Rpb24pLnB1dCh0b0RiQnVuZGxlKGJ1bmRsZU1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGdldE5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5TmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZWRRdWVyaWVzU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuZ2V0KHF1ZXJ5TmFtZSlcbiAgICAgICAgICAgIC5uZXh0KHF1ZXJ5ID0+IHtcbiAgICAgICAgICAgIGlmIChxdWVyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRGJOYW1lZFF1ZXJ5KHF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzYXZlTmFtZWRRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVkUXVlcmllc1N0b3JlKHRyYW5zYWN0aW9uKS5wdXQodG9EYk5hbWVkUXVlcnkocXVlcnkpKTtcbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgYnVuZGxlcyBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIGJ1bmRsZXNTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkJ1bmRsZVN0b3JlKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBuYW1lZFF1ZXJpZXMgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBuYW1lZFF1ZXJpZXNTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYk5hbWVkUXVlcnlTdG9yZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIERvY3VtZW50T3ZlcmxheUNhY2hlIHVzaW5nIEluZGV4ZWREYi5cbiAqL1xuY2xhc3MgSW5kZXhlZERiRG9jdW1lbnRPdmVybGF5Q2FjaGUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzZXJpYWxpemVyIC0gVGhlIGRvY3VtZW50IHNlcmlhbGl6ZXIuXG4gICAgICogQHBhcmFtIHVzZXJJZCAtIFRoZSB1c2VySWQgZm9yIHdoaWNoIHdlIGFyZSBhY2Nlc3Npbmcgb3ZlcmxheXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplciwgdXNlcklkKSB7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgICAgIHRoaXMudXNlcklkID0gdXNlcklkO1xuICAgIH1cbiAgICBzdGF0aWMgZm9yVXNlcihzZXJpYWxpemVyLCB1c2VyKSB7XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHVzZXIudWlkIHx8ICcnO1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4ZWREYkRvY3VtZW50T3ZlcmxheUNhY2hlKHNlcmlhbGl6ZXIsIHVzZXJJZCk7XG4gICAgfVxuICAgIGdldE92ZXJsYXkodHJhbnNhY3Rpb24sIGtleSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRPdmVybGF5U3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuZ2V0KHRvRGJEb2N1bWVudE92ZXJsYXlLZXkodGhpcy51c2VySWQsIGtleSkpXG4gICAgICAgICAgICAubmV4dChkYk92ZXJsYXkgPT4ge1xuICAgICAgICAgICAgaWYgKGRiT3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRGJEb2N1bWVudE92ZXJsYXkodGhpcy5zZXJpYWxpemVyLCBkYk92ZXJsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRPdmVybGF5cyh0cmFuc2FjdGlvbiwga2V5cykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXdPdmVybGF5TWFwKCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChrZXlzLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPdmVybGF5KHRyYW5zYWN0aW9uLCBrZXkpLm5leHQob3ZlcmxheSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIG92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5uZXh0KCgpID0+IHJlc3VsdCk7XG4gICAgfVxuICAgIHNhdmVPdmVybGF5cyh0cmFuc2FjdGlvbiwgbGFyZ2VzdEJhdGNoSWQsIG92ZXJsYXlzKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIG92ZXJsYXlzLmZvckVhY2goKF8sIG11dGF0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gbmV3IE92ZXJsYXkobGFyZ2VzdEJhdGNoSWQsIG11dGF0aW9uKTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5zYXZlT3ZlcmxheSh0cmFuc2FjdGlvbiwgb3ZlcmxheSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcbiAgICB9XG4gICAgcmVtb3ZlT3ZlcmxheXNGb3JCYXRjaElkKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMsIGJhdGNoSWQpIHtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvblBhdGhzID0gbmV3IFNldCgpO1xuICAgICAgICAvLyBHZXQgdGhlIHNldCBvZiB1bmlxdWUgY29sbGVjdGlvbiBwYXRocy5cbiAgICAgICAgZG9jdW1lbnRLZXlzLmZvckVhY2goa2V5ID0+IGNvbGxlY3Rpb25QYXRocy5hZGQoZW5jb2RlUmVzb3VyY2VQYXRoKGtleS5nZXRDb2xsZWN0aW9uUGF0aCgpKSkpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBjb2xsZWN0aW9uUGF0aHMuZm9yRWFjaChjb2xsZWN0aW9uUGF0aCA9PiB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0aGlzLnVzZXJJZCwgY29sbGVjdGlvblBhdGgsIGJhdGNoSWRdLCBbdGhpcy51c2VySWQsIGNvbGxlY3Rpb25QYXRoLCBiYXRjaElkICsgMV0sIFxuICAgICAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxuICAgICAgICAgICAgLyp1cHBlck9wZW49Ki8gdHJ1ZSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRvY3VtZW50T3ZlcmxheVN0b3JlKHRyYW5zYWN0aW9uKS5kZWxldGVBbGwoRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleCwgcmFuZ2UpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XG4gICAgfVxuICAgIGdldE92ZXJsYXlzRm9yQ29sbGVjdGlvbih0cmFuc2FjdGlvbiwgY29sbGVjdGlvbiwgc2luY2VCYXRjaElkKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld092ZXJsYXlNYXAoKTtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvblBhdGggPSBlbmNvZGVSZXNvdXJjZVBhdGgoY29sbGVjdGlvbik7XG4gICAgICAgIC8vIFdlIHdhbnQgYmF0Y2ggSURzIGxhcmdlciB0aGFuIGBzaW5jZUJhdGNoSWRgLCBhbmQgc28gdGhlIGxvd2VyIGJvdW5kXG4gICAgICAgIC8vIGlzIG5vdCBpbmNsdXNpdmUuXG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3RoaXMudXNlcklkLCBjb2xsZWN0aW9uUGF0aCwgc2luY2VCYXRjaElkXSwgW3RoaXMudXNlcklkLCBjb2xsZWN0aW9uUGF0aCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSwgXG4gICAgICAgIC8qbG93ZXJPcGVuPSovIHRydWUpO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRPdmVybGF5U3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAubG9hZEFsbChEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4LCByYW5nZSlcbiAgICAgICAgICAgIC5uZXh0KGRiT3ZlcmxheXMgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkYk92ZXJsYXkgb2YgZGJPdmVybGF5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBmcm9tRGJEb2N1bWVudE92ZXJsYXkodGhpcy5zZXJpYWxpemVyLCBkYk92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQob3ZlcmxheS5nZXRLZXkoKSwgb3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgc2luY2VCYXRjaElkLCBjb3VudCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXdPdmVybGF5TWFwKCk7XG4gICAgICAgIGxldCBjdXJyZW50QmF0Y2hJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gV2Ugd2FudCBiYXRjaCBJRHMgbGFyZ2VyIHRoYW4gYHNpbmNlQmF0Y2hJZGAsIGFuZCBzbyB0aGUgbG93ZXIgYm91bmRcbiAgICAgICAgLy8gaXMgbm90IGluY2x1c2l2ZS5cbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGhpcy51c2VySWQsIGNvbGxlY3Rpb25Hcm91cCwgc2luY2VCYXRjaElkXSwgW3RoaXMudXNlcklkLCBjb2xsZWN0aW9uR3JvdXAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWV0sIFxuICAgICAgICAvKmxvd2VyT3Blbj0qLyB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50T3ZlcmxheVN0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoe1xuICAgICAgICAgICAgaW5kZXg6IERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvbkdyb3VwT3ZlcmxheUluZGV4LFxuICAgICAgICAgICAgcmFuZ2VcbiAgICAgICAgfSwgKF8sIGRiT3ZlcmxheSwgY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gcmV0dXJuIHBhcnRpYWwgYmF0Y2ggb3ZlcmxheXMsIGV2ZW4gaWYgdGhlIHNpemVcbiAgICAgICAgICAgIC8vIG9mIHRoZSByZXN1bHQgc2V0IGV4Y2VlZHMgdGhlIGdpdmVuIGBjb3VudGAgYXJndW1lbnQuIFRoZXJlZm9yZSwgd2VcbiAgICAgICAgICAgIC8vIGNvbnRpbnVlIHRvIGFnZ3JlZ2F0ZSByZXN1bHRzIGV2ZW4gYWZ0ZXIgdGhlIHJlc3VsdCBzaXplIGV4Y2VlZHNcbiAgICAgICAgICAgIC8vIGBjb3VudGAgaWYgdGhlcmUgYXJlIG1vcmUgb3ZlcmxheXMgZnJvbSB0aGUgYGN1cnJlbnRCYXRjaElkYC5cbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBmcm9tRGJEb2N1bWVudE92ZXJsYXkodGhpcy5zZXJpYWxpemVyLCBkYk92ZXJsYXkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zaXplKCkgPCBjb3VudCB8fFxuICAgICAgICAgICAgICAgIG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQgPT09IGN1cnJlbnRCYXRjaElkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChvdmVybGF5LmdldEtleSgpLCBvdmVybGF5KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50QmF0Y2hJZCA9IG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHJlc3VsdCk7XG4gICAgfVxuICAgIHNhdmVPdmVybGF5KHRyYW5zYWN0aW9uLCBvdmVybGF5KSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudE92ZXJsYXlTdG9yZSh0cmFuc2FjdGlvbikucHV0KHRvRGJEb2N1bWVudE92ZXJsYXkodGhpcy5zZXJpYWxpemVyLCB0aGlzLnVzZXJJZCwgb3ZlcmxheSkpO1xuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBkb2N1bWVudCBvdmVybGF5IG9iamVjdCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gZG9jdW1lbnRPdmVybGF5U3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJEb2N1bWVudE92ZXJsYXlTdG9yZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBJbmRleGVkRGJHbG9iYWxzQ2FjaGUge1xuICAgIGdsb2JhbHNTdG9yZSh0eG4pIHtcbiAgICAgICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJHbG9iYWxzU3RvcmUpO1xuICAgIH1cbiAgICBnZXRTZXNzaW9uVG9rZW4odHhuKSB7XG4gICAgICAgIGNvbnN0IGdsb2JhbHMgPSB0aGlzLmdsb2JhbHNTdG9yZSh0eG4pO1xuICAgICAgICByZXR1cm4gZ2xvYmFscy5nZXQoJ3Nlc3Npb25Ub2tlbicpLm5leHQoZ2xvYmFsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2xvYmFsPy52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgID8gQnl0ZVN0cmluZy5mcm9tVWludDhBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgICAgICA6IEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRTZXNzaW9uVG9rZW4odHhuLCBzZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgY29uc3QgZ2xvYmFscyA9IHRoaXMuZ2xvYmFsc1N0b3JlKHR4bik7XG4gICAgICAgIHJldHVybiBnbG9iYWxzLnB1dCh7XG4gICAgICAgICAgICBuYW1lOiAnc2Vzc2lvblRva2VuJyxcbiAgICAgICAgICAgIHZhbHVlOiBzZXNzaW9uVG9rZW4udG9VaW50OEFycmF5KClcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gTm90ZTogVGhpcyBjb2RlIGlzIGNvcGllZCBmcm9tIHRoZSBiYWNrZW5kLiBDb2RlIHRoYXQgaXMgbm90IHVzZWQgYnlcbi8vIEZpcmVzdG9yZSB3YXMgcmVtb3ZlZC5cbmNvbnN0IElOREVYX1RZUEVfTlVMTCA9IDU7XG5jb25zdCBJTkRFWF9UWVBFX0JPT0xFQU4gPSAxMDtcbmNvbnN0IElOREVYX1RZUEVfTkFOID0gMTM7XG5jb25zdCBJTkRFWF9UWVBFX05VTUJFUiA9IDE1O1xuY29uc3QgSU5ERVhfVFlQRV9USU1FU1RBTVAgPSAyMDtcbmNvbnN0IElOREVYX1RZUEVfU1RSSU5HID0gMjU7XG5jb25zdCBJTkRFWF9UWVBFX0JMT0IgPSAzMDtcbmNvbnN0IElOREVYX1RZUEVfUkVGRVJFTkNFID0gMzc7XG5jb25zdCBJTkRFWF9UWVBFX0dFT1BPSU5UID0gNDU7XG5jb25zdCBJTkRFWF9UWVBFX0FSUkFZID0gNTA7XG5jb25zdCBJTkRFWF9UWVBFX1ZFQ1RPUiA9IDUzO1xuY29uc3QgSU5ERVhfVFlQRV9NQVAgPSA1NTtcbmNvbnN0IElOREVYX1RZUEVfUkVGRVJFTkNFX1NFR01FTlQgPSA2MDtcbi8vIEEgdGVybWluYXRvciB0aGF0IGluZGljYXRlcyB0aGF0IGEgdHJ1bmNhdGFibGUgdmFsdWUgd2FzIG5vdCB0cnVuY2F0ZWQuXG4vLyBUaGlzIG11c3QgYmUgc21hbGxlciB0aGFuIGFsbCBvdGhlciB0eXBlIGxhYmVscy5cbmNvbnN0IE5PVF9UUlVOQ0FURUQgPSAyO1xuLyoqIEZpcmVzdG9yZSBpbmRleCB2YWx1ZSB3cml0ZXIuICAqL1xuY2xhc3MgRmlyZXN0b3JlSW5kZXhWYWx1ZVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAvLyBUaGUgd3JpdGUgbWV0aG9kcyBiZWxvdyBzaG9ydC1jaXJjdWl0IHdyaXRpbmcgdGVybWluYXRvcnMgZm9yIHZhbHVlc1xuICAgIC8vIGNvbnRhaW5pbmcgYSAodGVybWluYXRpbmcpIHRydW5jYXRlZCB2YWx1ZS5cbiAgICAvL1xuICAgIC8vIEFzIGFuIGV4YW1wbGUsIGNvbnNpZGVyIHRoZSByZXN1bHRpbmcgZW5jb2RpbmcgZm9yOlxuICAgIC8vXG4gICAgLy8gW1wiYmFyXCIsIFsyLCBcImZvb1wiXV0gLT4gKFNUUklORywgXCJiYXJcIiwgVEVSTSwgQVJSQVksIE5VTUJFUiwgMiwgU1RSSU5HLCBcImZvb1wiLCBURVJNLCBURVJNLCBURVJNKVxuICAgIC8vIFtcImJhclwiLCBbMiwgdHJ1bmNhdGVkKFwiZm9vXCIpXV0gLT4gKFNUUklORywgXCJiYXJcIiwgVEVSTSwgQVJSQVksIE5VTUJFUiwgMiwgU1RSSU5HLCBcImZvb1wiLCBUUlVOQylcbiAgICAvLyBbXCJiYXJcIiwgdHJ1bmNhdGVkKFtcImZvb1wiXSldIC0+IChTVFJJTkcsIFwiYmFyXCIsIFRFUk0sIEFSUkFZLiBTVFJJTkcsIFwiZm9vXCIsIFRFUk0sIFRSVU5DKVxuICAgIC8qKiBXcml0ZXMgYW4gaW5kZXggdmFsdWUuICAqL1xuICAgIHdyaXRlSW5kZXhWYWx1ZSh2YWx1ZSwgZW5jb2Rlcikge1xuICAgICAgICB0aGlzLndyaXRlSW5kZXhWYWx1ZUF1eCh2YWx1ZSwgZW5jb2Rlcik7XG4gICAgICAgIC8vIFdyaXRlIHNlcGFyYXRvciB0byBzcGxpdCBpbmRleCB2YWx1ZXNcbiAgICAgICAgLy8gKHNlZSBnby9maXJlc3RvcmUtc3RvcmFnZS1mb3JtYXQjZW5jb2RpbmdzKS5cbiAgICAgICAgZW5jb2Rlci53cml0ZUluZmluaXR5KCk7XG4gICAgfVxuICAgIHdyaXRlSW5kZXhWYWx1ZUF1eChpbmRleFZhbHVlLCBlbmNvZGVyKSB7XG4gICAgICAgIGlmICgnbnVsbFZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9OVUxMKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnYm9vbGVhblZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9CT09MRUFOKTtcbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoaW5kZXhWYWx1ZS5ib29sZWFuVmFsdWUgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ2ludGVnZXJWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTlVNQkVSKTtcbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIobm9ybWFsaXplTnVtYmVyKGluZGV4VmFsdWUuaW50ZWdlclZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ2RvdWJsZVZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9ybWFsaXplTnVtYmVyKGluZGV4VmFsdWUuZG91YmxlVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKG4pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTkFOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX05VTUJFUik7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmVaZXJvKG4pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC0wLjAsIDAgYW5kIDAuMCBhcmUgYWxsIGNvbnNpZGVyZWQgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcigwLjApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcihuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ3RpbWVzdGFtcFZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgdGltZXN0YW1wID0gaW5kZXhWYWx1ZS50aW1lc3RhbXBWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX1RJTUVTVEFNUCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRpbWVzdGFtcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAodGltZXN0YW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVTdHJpbmcoYCR7dGltZXN0YW1wLnNlY29uZHMgfHwgJyd9YCk7XG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlTnVtYmVyKHRpbWVzdGFtcC5uYW5vcyB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnc3RyaW5nVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleFN0cmluZyhpbmRleFZhbHVlLnN0cmluZ1ZhbHVlLCBlbmNvZGVyKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVUcnVuY2F0aW9uTWFya2VyKGVuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdieXRlc1ZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9CTE9CKTtcbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVCeXRlcyhub3JtYWxpemVCeXRlU3RyaW5nKGluZGV4VmFsdWUuYnl0ZXNWYWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy53cml0ZVRydW5jYXRpb25NYXJrZXIoZW5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ3JlZmVyZW5jZVZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhFbnRpdHlSZWYoaW5kZXhWYWx1ZS5yZWZlcmVuY2VWYWx1ZSwgZW5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ2dlb1BvaW50VmFsdWUnIGluIGluZGV4VmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGdlb1BvaW50ID0gaW5kZXhWYWx1ZS5nZW9Qb2ludFZhbHVlO1xuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfR0VPUE9JTlQpO1xuICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcihnZW9Qb2ludC5sYXRpdHVkZSB8fCAwKTtcbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoZ2VvUG9pbnQubG9uZ2l0dWRlIHx8IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdtYXBWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzTWF4VmFsdWUoaW5kZXhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNWZWN0b3JWYWx1ZShpbmRleFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleFZlY3RvcihpbmRleFZhbHVlLm1hcFZhbHVlLCBlbmNvZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleE1hcChpbmRleFZhbHVlLm1hcFZhbHVlLCBlbmNvZGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVHJ1bmNhdGlvbk1hcmtlcihlbmNvZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnYXJyYXlWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4QXJyYXkoaW5kZXhWYWx1ZS5hcnJheVZhbHVlLCBlbmNvZGVyKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVUcnVuY2F0aW9uTWFya2VyKGVuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmFpbCgweDRhNGUsIHsgaW5kZXhWYWx1ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUluZGV4U3RyaW5nKHN0cmluZ0luZGV4VmFsdWUsIGVuY29kZXIpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfU1RSSU5HKTtcbiAgICAgICAgdGhpcy53cml0ZVVubGFiZWxlZEluZGV4U3RyaW5nKHN0cmluZ0luZGV4VmFsdWUsIGVuY29kZXIpO1xuICAgIH1cbiAgICB3cml0ZVVubGFiZWxlZEluZGV4U3RyaW5nKHN0cmluZ0luZGV4VmFsdWUsIGVuY29kZXIpIHtcbiAgICAgICAgZW5jb2Rlci53cml0ZVN0cmluZyhzdHJpbmdJbmRleFZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVJbmRleE1hcChtYXBJbmRleFZhbHVlLCBlbmNvZGVyKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IG1hcEluZGV4VmFsdWUuZmllbGRzIHx8IHt9O1xuICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9NQVApO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtYXApKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhTdHJpbmcoa2V5LCBlbmNvZGVyKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleFZhbHVlQXV4KG1hcFtrZXldLCBlbmNvZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUluZGV4VmVjdG9yKG1hcEluZGV4VmFsdWUsIGVuY29kZXIpIHtcbiAgICAgICAgY29uc3QgbWFwID0gbWFwSW5kZXhWYWx1ZS5maWVsZHMgfHwge307XG4gICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX1ZFQ1RPUik7XG4gICAgICAgIC8vIFZlY3RvcnMgc29ydCBmaXJzdCBieSBsZW5ndGhcbiAgICAgICAgY29uc3Qga2V5ID0gVkVDVE9SX01BUF9WRUNUT1JTX0tFWTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gbWFwW2tleV0uYXJyYXlWYWx1ZT8udmFsdWVzPy5sZW5ndGggfHwgMDtcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTlVNQkVSKTtcbiAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcihub3JtYWxpemVOdW1iZXIobGVuZ3RoKSk7XG4gICAgICAgIC8vIFZlY3RvcnMgdGhlbiBzb3J0IGJ5IHBvc2l0aW9uIHZhbHVlXG4gICAgICAgIHRoaXMud3JpdGVJbmRleFN0cmluZyhrZXksIGVuY29kZXIpO1xuICAgICAgICB0aGlzLndyaXRlSW5kZXhWYWx1ZUF1eChtYXBba2V5XSwgZW5jb2Rlcik7XG4gICAgfVxuICAgIHdyaXRlSW5kZXhBcnJheShhcnJheUluZGV4VmFsdWUsIGVuY29kZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gYXJyYXlJbmRleFZhbHVlLnZhbHVlcyB8fCBbXTtcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfQVJSQVkpO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhWYWx1ZUF1eChlbGVtZW50LCBlbmNvZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUluZGV4RW50aXR5UmVmKHJlZmVyZW5jZVZhbHVlLCBlbmNvZGVyKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX1JFRkVSRU5DRSk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBEb2N1bWVudEtleS5mcm9tTmFtZShyZWZlcmVuY2VWYWx1ZSkucGF0aDtcbiAgICAgICAgcGF0aC5mb3JFYWNoKHNlZ21lbnQgPT4ge1xuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfUkVGRVJFTkNFX1NFR01FTlQpO1xuICAgICAgICAgICAgdGhpcy53cml0ZVVubGFiZWxlZEluZGV4U3RyaW5nKHNlZ21lbnQsIGVuY29kZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgd3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCB0eXBlT3JkZXIpIHtcbiAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcih0eXBlT3JkZXIpO1xuICAgIH1cbiAgICB3cml0ZVRydW5jYXRpb25NYXJrZXIoZW5jb2Rlcikge1xuICAgICAgICAvLyBXaGlsZSB0aGUgU0RLIGRvZXMgbm90IGltcGxlbWVudCB0cnVuY2F0aW9uLCB0aGUgdHJ1bmNhdGlvbiBtYXJrZXIgaXNcbiAgICAgICAgLy8gdXNlZCB0byB0ZXJtaW5hdGUgYWxsIHZhcmlhYmxlIGxlbmd0aCB2YWx1ZXMgKHdoaWNoIGFyZSBzdHJpbmdzLCBieXRlcyxcbiAgICAgICAgLy8gcmVmZXJlbmNlcywgYXJyYXlzIGFuZCBtYXBzKS5cbiAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcihOT1RfVFJVTkNBVEVEKTtcbiAgICB9XG59XG5GaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyLklOU1RBTkNFID0gbmV3IEZpcmVzdG9yZUluZGV4VmFsdWVXcml0ZXIoKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyB8IGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIHwgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3MgfCBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBUaGVzZSBjb25zdGFudHMgYXJlIHRha2VuIGZyb20gdGhlIGJhY2tlbmQuICovXG5jb25zdCBNSU5fU1VSUk9HQVRFID0gJ1xcdUQ4MDAnO1xuY29uc3QgTUFYX1NVUlJPR0FURSA9ICdcXHVEQkZGJztcbmNvbnN0IEVTQ0FQRTEgPSAweDAwO1xuY29uc3QgTlVMTF9CWVRFID0gMHhmZjsgLy8gQ29tYmluZWQgd2l0aCBFU0NBUEUxXG5jb25zdCBTRVBBUkFUT1IgPSAweDAxOyAvLyBDb21iaW5lZCB3aXRoIEVTQ0FQRTFcbmNvbnN0IEVTQ0FQRTIgPSAweGZmO1xuY29uc3QgSU5GSU5JVFkgPSAweGZmOyAvLyBDb21iaW5lZCB3aXRoIEVTQ0FQRTJcbmNvbnN0IEZGX0JZVEUgPSAweDAwOyAvLyBDb21iaW5lZCB3aXRoIEVTQ0FQRTJcbmNvbnN0IExPTkdfU0laRSA9IDY0O1xuY29uc3QgQllURV9TSVpFID0gODtcbi8qKlxuICogVGhlIGRlZmF1bHQgc2l6ZSBvZiB0aGUgYnVmZmVyLiBUaGlzIGlzIGFyYml0cmFyeSwgYnV0IGxpa2VseSBsYXJnZXIgdGhhblxuICogbW9zdCBpbmRleCB2YWx1ZXMgc28gdGhhdCBsZXNzIGNvcGllcyBvZiB0aGUgdW5kZXJseWluZyBidWZmZXIgd2lsbCBiZSBtYWRlLlxuICogRm9yIGxhcmdlIHZhbHVlcywgYSBzaW5nbGUgY29weSB3aWxsIG1hZGUgdG8gZG91YmxlIHRoZSBidWZmZXIgbGVuZ3RoLlxuICovXG5jb25zdCBERUZBVUxUX0JVRkZFUl9TSVpFID0gMTAyNDtcbi8qKiBDb252ZXJ0cyBhIEphdmFTY3JpcHQgbnVtYmVyIHRvIGEgYnl0ZSBhcnJheSAodXNpbmcgYmlnIGVuZGlhbiBlbmNvZGluZykuICovXG5mdW5jdGlvbiBkb3VibGVUb0xvbmdCaXRzKHZhbHVlKSB7XG4gICAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDgpKTtcbiAgICBkdi5zZXRGbG9hdDY0KDAsIHZhbHVlLCAvKiBsaXR0bGVFbmRpYW49ICovIGZhbHNlKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZHYuYnVmZmVyKTtcbn1cbi8qKlxuICogQ291bnRzIHRoZSBudW1iZXIgb2YgemVyb3MgaW4gYSBieXRlLlxuICpcbiAqIFZpc2libGUgZm9yIHRlc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIG51bWJlck9mTGVhZGluZ1plcm9zSW5CeXRlKHgpIHtcbiAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG4gICAgbGV0IHplcm9zID0gMDtcbiAgICBpZiAoeCA+PiA0ID09PSAwKSB7XG4gICAgICAgIC8vIFRlc3QgaWYgdGhlIGZpcnN0IGZvdXIgYml0cyBhcmUgemVyby5cbiAgICAgICAgemVyb3MgKz0gNDtcbiAgICAgICAgeCA9IHggPDwgNDtcbiAgICB9XG4gICAgaWYgKHggPj4gNiA9PT0gMCkge1xuICAgICAgICAvLyBUZXN0IGlmIHRoZSBmaXJzdCB0d28gKG9yIG5leHQgdHdvKSBiaXRzIGFyZSB6ZXJvLlxuICAgICAgICB6ZXJvcyArPSAyO1xuICAgICAgICB4ID0geCA8PCAyO1xuICAgIH1cbiAgICBpZiAoeCA+PiA3ID09PSAwKSB7XG4gICAgICAgIC8vIFRlc3QgaWYgdGhlIHJlbWFpbmluZyBiaXQgaXMgemVyby5cbiAgICAgICAgemVyb3MgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHplcm9zO1xufVxuLyoqIENvdW50cyB0aGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3MgaW4gdGhlIGdpdmVuIGJ5dGUgYXJyYXkuICovXG5mdW5jdGlvbiBudW1iZXJPZkxlYWRpbmdaZXJvcyhieXRlcykge1xuICAgIGxldCBsZWFkaW5nWmVyb3MgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgICAgIGNvbnN0IHplcm9zID0gbnVtYmVyT2ZMZWFkaW5nWmVyb3NJbkJ5dGUoYnl0ZXNbaV0gJiAweGZmKTtcbiAgICAgICAgbGVhZGluZ1plcm9zICs9IHplcm9zO1xuICAgICAgICBpZiAoemVyb3MgIT09IDgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWFkaW5nWmVyb3M7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBcInZhbHVlXCIuIExlYWRpbmcgemVybyBieXRlc1xuICogYXJlIHNraXBwZWQuXG4gKi9cbmZ1bmN0aW9uIHVuc2lnbmVkTnVtTGVuZ3RoKHZhbHVlKSB7XG4gICAgLy8gVGhpcyBpcyBqdXN0IHRoZSBudW1iZXIgb2YgYnl0ZXMgZm9yIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICAgIGNvbnN0IG51bUJpdHMgPSBMT05HX1NJWkUgLSBudW1iZXJPZkxlYWRpbmdaZXJvcyh2YWx1ZSk7XG4gICAgcmV0dXJuIE1hdGguY2VpbChudW1CaXRzIC8gQllURV9TSVpFKTtcbn1cbi8qKlxuICogT3JkZXJlZENvZGVXcml0ZXIgaXMgYSBtaW5pbWFsLWFsbG9jYXRpb24gaW1wbGVtZW50YXRpb24gb2YgdGhlIHdyaXRpbmdcbiAqIGJlaGF2aW9yIGRlZmluZWQgYnkgdGhlIGJhY2tlbmQuXG4gKlxuICogVGhlIGNvZGUgaXMgcG9ydGVkIGZyb20gaXRzIEphdmEgY291bnRlcnBhcnQuXG4gKi9cbmNsYXNzIE9yZGVyZWRDb2RlV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShERUZBVUxUX0JVRkZFUl9TSVpFKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgfVxuICAgIHdyaXRlQnl0ZXNBc2NlbmRpbmcodmFsdWUpIHtcbiAgICAgICAgY29uc3QgaXQgPSB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIGxldCBieXRlID0gaXQubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIWJ5dGUuZG9uZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoYnl0ZS52YWx1ZSk7XG4gICAgICAgICAgICBieXRlID0gaXQubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVTZXBhcmF0b3JBc2NlbmRpbmcoKTtcbiAgICB9XG4gICAgd3JpdGVCeXRlc0Rlc2NlbmRpbmcodmFsdWUpIHtcbiAgICAgICAgY29uc3QgaXQgPSB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIGxldCBieXRlID0gaXQubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIWJ5dGUuZG9uZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKGJ5dGUudmFsdWUpO1xuICAgICAgICAgICAgYnl0ZSA9IGl0Lm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlU2VwYXJhdG9yRGVzY2VuZGluZygpO1xuICAgIH1cbiAgICAvKiogV3JpdGVzIHV0ZjggYnl0ZXMgaW50byB0aGlzIGJ5dGUgc2VxdWVuY2UsIGFzY2VuZGluZy4gKi9cbiAgICB3cml0ZVV0ZjhBc2NlbmRpbmcoc2VxdWVuY2UpIHtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHNlcXVlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyQ29kZSA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZyhjaGFyQ29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyQ29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoKDB4MGYgPDwgNikgfCAoY2hhckNvZGUgPj4+IDYpKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygweDgwIHwgKDB4M2YgJiBjaGFyQ29kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA8IE1JTl9TVVJST0dBVEUgfHwgTUFYX1NVUlJPR0FURSA8IGMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygoMHgwZiA8PCA1KSB8IChjaGFyQ29kZSA+Pj4gMTIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY2hhckNvZGUgPj4+IDYpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY2hhckNvZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGMuY29kZVBvaW50QXQoMCk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoKDB4MGYgPDwgNCkgfCAoY29kZVBvaW50ID4+PiAxOCkpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIChjb2RlUG9pbnQgPj4+IDEyKSkpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIChjb2RlUG9pbnQgPj4+IDYpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY29kZVBvaW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZVNlcGFyYXRvckFzY2VuZGluZygpO1xuICAgIH1cbiAgICAvKiogV3JpdGVzIHV0ZjggYnl0ZXMgaW50byB0aGlzIGJ5dGUgc2VxdWVuY2UsIGRlc2NlbmRpbmcgKi9cbiAgICB3cml0ZVV0ZjhEZXNjZW5kaW5nKHNlcXVlbmNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBzZXF1ZW5jZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhckNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKGNoYXJDb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJDb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoKDB4MGYgPDwgNikgfCAoY2hhckNvZGUgPj4+IDYpKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY2hhckNvZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPCBNSU5fU1VSUk9HQVRFIHx8IE1BWF9TVVJST0dBVEUgPCBjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKCgweDBmIDw8IDUpIHwgKGNoYXJDb2RlID4+PiAxMikpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY2hhckNvZGUgPj4+IDYpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIGNoYXJDb2RlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBjLmNvZGVQb2ludEF0KDApO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygoMHgwZiA8PCA0KSB8IChjb2RlUG9pbnQgPj4+IDE4KSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIChjb2RlUG9pbnQgPj4+IDEyKSkpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY29kZVBvaW50ID4+PiA2KSkpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygweDgwIHwgKDB4M2YgJiBjb2RlUG9pbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlU2VwYXJhdG9yRGVzY2VuZGluZygpO1xuICAgIH1cbiAgICB3cml0ZU51bWJlckFzY2VuZGluZyh2YWwpIHtcbiAgICAgICAgLy8gVmFsdWVzIGFyZSBlbmNvZGVkIHdpdGggYSBzaW5nbGUgYnl0ZSBsZW5ndGggcHJlZml4LCBmb2xsb3dlZCBieSB0aGVcbiAgICAgICAgLy8gYWN0dWFsIHZhbHVlIGluIGJpZy1lbmRpYW4gZm9ybWF0IHdpdGggbGVhZGluZyAwIGJ5dGVzIGRyb3BwZWQuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy50b09yZGVyZWRCaXRzKHZhbCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHVuc2lnbmVkTnVtTGVuZ3RoKHZhbHVlKTtcbiAgICAgICAgdGhpcy5lbnN1cmVBdmFpbGFibGUoMSArIGxlbik7XG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSBsZW4gJiAweGZmOyAvLyBXcml0ZSB0aGUgbGVuZ3RoXG4gICAgICAgIGZvciAobGV0IGkgPSB2YWx1ZS5sZW5ndGggLSBsZW47IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IHZhbHVlW2ldICYgMHhmZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZU51bWJlckRlc2NlbmRpbmcodmFsKSB7XG4gICAgICAgIC8vIFZhbHVlcyBhcmUgZW5jb2RlZCB3aXRoIGEgc2luZ2xlIGJ5dGUgbGVuZ3RoIHByZWZpeCwgZm9sbG93ZWQgYnkgdGhlXG4gICAgICAgIC8vIGludmVydGVkIHZhbHVlIGluIGJpZy1lbmRpYW4gZm9ybWF0IHdpdGggbGVhZGluZyAwIGJ5dGVzIGRyb3BwZWQuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy50b09yZGVyZWRCaXRzKHZhbCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHVuc2lnbmVkTnVtTGVuZ3RoKHZhbHVlKTtcbiAgICAgICAgdGhpcy5lbnN1cmVBdmFpbGFibGUoMSArIGxlbik7XG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSB+KGxlbiAmIDB4ZmYpOyAvLyBXcml0ZSB0aGUgbGVuZ3RoXG4gICAgICAgIGZvciAobGV0IGkgPSB2YWx1ZS5sZW5ndGggLSBsZW47IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IH4odmFsdWVbaV0gJiAweGZmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgdGhlIFwiaW5maW5pdHlcIiBieXRlIHNlcXVlbmNlIHRoYXQgc29ydHMgYWZ0ZXIgYWxsIG90aGVyIGJ5dGVcbiAgICAgKiBzZXF1ZW5jZXMgd3JpdHRlbiBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAgICovXG4gICAgd3JpdGVJbmZpbml0eUFzY2VuZGluZygpIHtcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKEVTQ0FQRTIpO1xuICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoSU5GSU5JVFkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgdGhlIFwiaW5maW5pdHlcIiBieXRlIHNlcXVlbmNlIHRoYXQgc29ydHMgYmVmb3JlIGFsbCBvdGhlciBieXRlXG4gICAgICogc2VxdWVuY2VzIHdyaXR0ZW4gaW4gZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKi9cbiAgICB3cml0ZUluZmluaXR5RGVzY2VuZGluZygpIHtcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhFU0NBUEUyKTtcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhJTkZJTklUWSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgYnVmZmVyIHN1Y2ggdGhhdCBpdCBpcyB0aGUgc2FtZSBhcyB3aGVuIGl0IHdhcyBuZXdseVxuICAgICAqIGNvbnN0cnVjdGVkLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICB9XG4gICAgc2VlZChlbmNvZGVkQnl0ZXMpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVBdmFpbGFibGUoZW5jb2RlZEJ5dGVzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnNldChlbmNvZGVkQnl0ZXMsIHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGVuY29kZWRCeXRlcy5sZW5ndGg7XG4gICAgfVxuICAgIC8qKiBNYWtlcyBhIGNvcHkgb2YgdGhlIGVuY29kZWQgYnl0ZXMgaW4gdGhpcyBidWZmZXIuICAqL1xuICAgIGVuY29kZWRCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNsaWNlKDAsIHRoaXMucG9zaXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGB2YWxgIGludG8gYW4gZW5jb2Rpbmcgc28gdGhhdCB0aGUgb3JkZXIgbWF0Y2hlcyB0aGUgSUVFRSA3NTRcbiAgICAgKiBmbG9hdGluZy1wb2ludCBjb21wYXJpc29uIHJlc3VsdHMgd2l0aCB0aGUgZm9sbG93aW5nIGV4Y2VwdGlvbnM6XG4gICAgICogICAtMC4wIDwgMC4wXG4gICAgICogICBhbGwgbm9uLU5hTiA8IE5hTlxuICAgICAqICAgTmFOID0gTmFOXG4gICAgICovXG4gICAgdG9PcmRlcmVkQml0cyh2YWwpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkb3VibGVUb0xvbmdCaXRzKHZhbCk7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCBiaXQgaXMgc2V0LiBXZSB1c2UgYSBiaXQgbWFzayBzaW5jZSB2YWx1ZVswXSBpc1xuICAgICAgICAvLyBlbmNvZGVkIGFzIGEgbnVtYmVyIGZyb20gMCB0byAyNTUuXG4gICAgICAgIGNvbnN0IGlzTmVnYXRpdmUgPSAodmFsdWVbMF0gJiAweDgwKSAhPT0gMDtcbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSB0d28gY29tcGxlbWVudCB0byBnZXQgbmF0dXJhbCBvcmRlcmluZ1xuICAgICAgICB2YWx1ZVswXSBePSBpc05lZ2F0aXZlID8gMHhmZiA6IDB4ODA7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhbHVlW2ldIF49IGlzTmVnYXRpdmUgPyAweGZmIDogMHgwMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKiBXcml0ZXMgYSBzaW5nbGUgYnl0ZSBhc2NlbmRpbmcgdG8gdGhlIGJ1ZmZlci4gKi9cbiAgICB3cml0ZUJ5dGVBc2NlbmRpbmcoYikge1xuICAgICAgICBjb25zdCBtYXNrZWQgPSBiICYgMHhmZjtcbiAgICAgICAgaWYgKG1hc2tlZCA9PT0gRVNDQVBFMSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKEVTQ0FQRTEpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKE5VTExfQllURSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFza2VkID09PSBFU0NBUEUyKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoRVNDQVBFMik7XG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoRkZfQllURSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcobWFza2VkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogV3JpdGVzIGEgc2luZ2xlIGJ5dGUgZGVzY2VuZGluZyB0byB0aGUgYnVmZmVyLiAgKi9cbiAgICB3cml0ZUJ5dGVEZXNjZW5kaW5nKGIpIHtcbiAgICAgICAgY29uc3QgbWFza2VkID0gYiAmIDB4ZmY7XG4gICAgICAgIGlmIChtYXNrZWQgPT09IEVTQ0FQRTEpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoRVNDQVBFMSk7XG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVEZXNjZW5kaW5nKE5VTExfQllURSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFza2VkID09PSBFU0NBUEUyKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVEZXNjZW5kaW5nKEVTQ0FQRTIpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhGRl9CWVRFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoYik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVTZXBhcmF0b3JBc2NlbmRpbmcoKSB7XG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhFU0NBUEUxKTtcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKFNFUEFSQVRPUik7XG4gICAgfVxuICAgIHdyaXRlU2VwYXJhdG9yRGVzY2VuZGluZygpIHtcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhFU0NBUEUxKTtcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhTRVBBUkFUT1IpO1xuICAgIH1cbiAgICB3cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKGIpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVBdmFpbGFibGUoMSk7XG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSBiO1xuICAgIH1cbiAgICB3cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhiKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDEpO1xuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uKytdID0gfmI7XG4gICAgfVxuICAgIGVuc3VyZUF2YWlsYWJsZShieXRlcykge1xuICAgICAgICBjb25zdCBtaW5DYXBhY2l0eSA9IGJ5dGVzICsgdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgaWYgKG1pbkNhcGFjaXR5IDw9IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSBkb3VibGluZy5cbiAgICAgICAgbGV0IG5ld0xlbmd0aCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAqIDI7XG4gICAgICAgIC8vIFN0aWxsIG5vdCBiaWcgZW5vdWdoPyBKdXN0IGFsbG9jYXRlIHRoZSByaWdodCBzaXplLlxuICAgICAgICBpZiAobmV3TGVuZ3RoIDwgbWluQ2FwYWNpdHkpIHtcbiAgICAgICAgICAgIG5ld0xlbmd0aCA9IG1pbkNhcGFjaXR5O1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IGJ1ZmZlci5cbiAgICAgICAgY29uc3QgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgICAgICAgbmV3QnVmZmVyLnNldCh0aGlzLmJ1ZmZlcik7IC8vIGNvcHkgb2xkIGRhdGFcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XG4gICAgfVxufVxuXG5jbGFzcyBBc2NlbmRpbmdJbmRleEJ5dGVFbmNvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcmRlcmVkQ29kZSkge1xuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlID0gb3JkZXJlZENvZGU7XG4gICAgfVxuICAgIHdyaXRlQnl0ZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZUJ5dGVzQXNjZW5kaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZVV0ZjhBc2NlbmRpbmcodmFsdWUpO1xuICAgIH1cbiAgICB3cml0ZU51bWJlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLndyaXRlTnVtYmVyQXNjZW5kaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVJbmZpbml0eSgpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZUluZmluaXR5QXNjZW5kaW5nKCk7XG4gICAgfVxufVxuY2xhc3MgRGVzY2VuZGluZ0luZGV4Qnl0ZUVuY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKG9yZGVyZWRDb2RlKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUgPSBvcmRlcmVkQ29kZTtcbiAgICB9XG4gICAgd3JpdGVCeXRlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLndyaXRlQnl0ZXNEZXNjZW5kaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZVV0ZjhEZXNjZW5kaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZU51bWJlckRlc2NlbmRpbmcodmFsdWUpO1xuICAgIH1cbiAgICB3cml0ZUluZmluaXR5KCkge1xuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLndyaXRlSW5maW5pdHlEZXNjZW5kaW5nKCk7XG4gICAgfVxufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGBEaXJlY3Rpb25hbEluZGV4Qnl0ZUVuY29kZXJgIHVzaW5nIGBPcmRlcmVkQ29kZVdyaXRlcmAgZm9yIHRoZVxuICogYWN0dWFsIGVuY29kaW5nLlxuICovXG5jbGFzcyBJbmRleEJ5dGVFbmNvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZSA9IG5ldyBPcmRlcmVkQ29kZVdyaXRlcigpO1xuICAgICAgICB0aGlzLmFzY2VuZGluZyA9IG5ldyBBc2NlbmRpbmdJbmRleEJ5dGVFbmNvZGVyKHRoaXMub3JkZXJlZENvZGUpO1xuICAgICAgICB0aGlzLmRlc2NlbmRpbmcgPSBuZXcgRGVzY2VuZGluZ0luZGV4Qnl0ZUVuY29kZXIodGhpcy5vcmRlcmVkQ29kZSk7XG4gICAgfVxuICAgIHNlZWQoZW5jb2RlZEJ5dGVzKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUuc2VlZChlbmNvZGVkQnl0ZXMpO1xuICAgIH1cbiAgICBmb3JLaW5kKGtpbmQpIHtcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09IDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqLyA/IHRoaXMuYXNjZW5kaW5nIDogdGhpcy5kZXNjZW5kaW5nO1xuICAgIH1cbiAgICBlbmNvZGVkQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yZGVyZWRDb2RlLmVuY29kZWRCeXRlcygpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS5yZXNldCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBSZXByZXNlbnRzIGFuIGluZGV4IGVudHJ5IHNhdmVkIGJ5IHRoZSBTREsgaW4gcGVyc2lzdGVkIHN0b3JhZ2UuICovXG5jbGFzcyBJbmRleEVudHJ5IHtcbiAgICBjb25zdHJ1Y3RvcihfaW5kZXhJZCwgX2RvY3VtZW50S2V5LCBfYXJyYXlWYWx1ZSwgX2RpcmVjdGlvbmFsVmFsdWUpIHtcbiAgICAgICAgdGhpcy5faW5kZXhJZCA9IF9pbmRleElkO1xuICAgICAgICB0aGlzLl9kb2N1bWVudEtleSA9IF9kb2N1bWVudEtleTtcbiAgICAgICAgdGhpcy5fYXJyYXlWYWx1ZSA9IF9hcnJheVZhbHVlO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb25hbFZhbHVlID0gX2RpcmVjdGlvbmFsVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gSW5kZXhFbnRyeSBlbnRyeSB0aGF0IHNvcnRzIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjdXJyZW50XG4gICAgICogZGlyZWN0aW9uYWwgdmFsdWUuXG4gICAgICovXG4gICAgc3VjY2Vzc29yKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50TGVuZ3RoID0gdGhpcy5fZGlyZWN0aW9uYWxWYWx1ZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IGN1cnJlbnRMZW5ndGggPT09IDAgfHwgdGhpcy5fZGlyZWN0aW9uYWxWYWx1ZVtjdXJyZW50TGVuZ3RoIC0gMV0gPT09IDI1NVxuICAgICAgICAgICAgPyBjdXJyZW50TGVuZ3RoICsgMVxuICAgICAgICAgICAgOiBjdXJyZW50TGVuZ3RoO1xuICAgICAgICBjb25zdCBzdWNjZXNzb3IgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xuICAgICAgICBzdWNjZXNzb3Iuc2V0KHRoaXMuX2RpcmVjdGlvbmFsVmFsdWUsIDApO1xuICAgICAgICBpZiAobmV3TGVuZ3RoICE9PSBjdXJyZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICBzdWNjZXNzb3Iuc2V0KFswXSwgdGhpcy5fZGlyZWN0aW9uYWxWYWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKytzdWNjZXNzb3Jbc3VjY2Vzc29yLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhFbnRyeSh0aGlzLl9pbmRleElkLCB0aGlzLl9kb2N1bWVudEtleSwgdGhpcy5fYXJyYXlWYWx1ZSwgc3VjY2Vzc29yKTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIEluZGV4IEVudHJ5IGFzIGEgRGJJbmRleEVudHJ5XG4gICAgZGJJbmRleEVudHJ5KHVpZCwgb3JkZXJlZERvY3VtZW50S2V5LCBkb2N1bWVudEtleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXhJZDogdGhpcy5faW5kZXhJZCxcbiAgICAgICAgICAgIHVpZCxcbiAgICAgICAgICAgIGFycmF5VmFsdWU6IGVuY29kZUtleVNhZmVCeXRlcyh0aGlzLl9hcnJheVZhbHVlKSxcbiAgICAgICAgICAgIGRpcmVjdGlvbmFsVmFsdWU6IGVuY29kZUtleVNhZmVCeXRlcyh0aGlzLl9kaXJlY3Rpb25hbFZhbHVlKSxcbiAgICAgICAgICAgIG9yZGVyZWREb2N1bWVudEtleTogZW5jb2RlS2V5U2FmZUJ5dGVzKG9yZGVyZWREb2N1bWVudEtleSksXG4gICAgICAgICAgICBkb2N1bWVudEtleTogZG9jdW1lbnRLZXkucGF0aC50b0FycmF5KClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIEluZGV4IEVudHJ5IGFzIGEgRGJJbmRleEVudHJ5S2V5XG4gICAgZGJJbmRleEVudHJ5S2V5KHVpZCwgb3JkZXJlZERvY3VtZW50S2V5LCBkb2N1bWVudEtleSkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZGJJbmRleEVudHJ5KHVpZCwgb3JkZXJlZERvY3VtZW50S2V5LCBkb2N1bWVudEtleSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBlbnRyeS5pbmRleElkLFxuICAgICAgICAgICAgZW50cnkudWlkLFxuICAgICAgICAgICAgZW50cnkuYXJyYXlWYWx1ZSxcbiAgICAgICAgICAgIGVudHJ5LmRpcmVjdGlvbmFsVmFsdWUsXG4gICAgICAgICAgICBlbnRyeS5vcmRlcmVkRG9jdW1lbnRLZXksXG4gICAgICAgICAgICBlbnRyeS5kb2N1bWVudEtleVxuICAgICAgICBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluZGV4RW50cnlDb21wYXJhdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgbGV0IGNtcCA9IGxlZnQuX2luZGV4SWQgLSByaWdodC5faW5kZXhJZDtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIGNtcCA9IGNvbXBhcmVCeXRlQXJyYXlzKGxlZnQuX2FycmF5VmFsdWUsIHJpZ2h0Ll9hcnJheVZhbHVlKTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIGNtcCA9IGNvbXBhcmVCeXRlQXJyYXlzKGxlZnQuX2RpcmVjdGlvbmFsVmFsdWUsIHJpZ2h0Ll9kaXJlY3Rpb25hbFZhbHVlKTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIHJldHVybiBEb2N1bWVudEtleS5jb21wYXJhdG9yKGxlZnQuX2RvY3VtZW50S2V5LCByaWdodC5fZG9jdW1lbnRLZXkpO1xufVxuZnVuY3Rpb24gY29tcGFyZUJ5dGVBcnJheXMobGVmdCwgcmlnaHQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnQubGVuZ3RoICYmIGkgPCByaWdodC5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjb21wYXJlID0gbGVmdFtpXSAtIHJpZ2h0W2ldO1xuICAgICAgICBpZiAoY29tcGFyZSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlZnQubGVuZ3RoIC0gcmlnaHQubGVuZ3RoO1xufVxuLyoqXG4gKiBXb3JrYXJvdW5kIGZvciBXZWJLaXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkyNzIxXG4gKiBDcmVhdGUgYSBrZXkgc2FmZSByZXByZXNlbnRhdGlvbiBvZiBVaW50OEFycmF5IHZhbHVlcy5cbiAqIElmIHRoZSBicm93c2VyIGlzIGRldGVjdGVkIGFzIFNhZmFyaSBvciBXZWJLaXQsIHRoZW5cbiAqIHRoZSBpbnB1dCBhcnJheSB3aWxsIGJlIGNvbnZlcnRlZCB0byBcInNvcnRhYmxlIGJ5dGUgc3RyaW5nXCIuXG4gKiBPdGhlcndpc2UsIHRoZSBpbnB1dCBhcnJheSB3aWxsIGJlIHJldHVybmVkIGluIGl0cyBvcmlnaW5hbCB0eXBlLlxuICovXG5mdW5jdGlvbiBlbmNvZGVLZXlTYWZlQnl0ZXMoYXJyYXkpIHtcbiAgICBpZiAoaXNTYWZhcmlPcldlYmtpdCgpKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVaW50OEFycmF5VG9Tb3J0YWJsZVN0cmluZyhhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKlxuICogUmV2ZXJ0cyB0aGUga2V5IHNhZmUgcmVwcmVzZW50YXRpb24gb2YgVWludDhBcnJheSAoY3JlYXRlZCBieVxuICogZW5jb2RlS2V5U2FmZUJ5dGVzKSB0byBhIG5vcm1hbCBVaW50OEFycmF5LlxuICovXG5mdW5jdGlvbiBkZWNvZGVLZXlTYWZlQnl0ZXMoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVTb3J0YWJsZVN0cmluZ1RvVWludDhBcnJheShpbnB1dCk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBVaW50OEFycmF5IGludG8gYSBcInNvcnRhYmxlIGJ5dGUgc3RyaW5nXCIuXG4gKiBBIFwic29ydGFibGUgYnl0ZSBzdHJpbmdcIiBzb3J0cyBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgVWludDhBcnJheS5cbiAqIFRoaXMgd29ya3MgYmVjYXVzZSBKUyBzdHJpbmcgY29tcGFyaXNvbiBzb3J0cyBzdHJpbmdzIGJhc2VkIG9uIGNvZGUgcG9pbnRzLlxuICovXG5mdW5jdGlvbiBlbmNvZGVVaW50OEFycmF5VG9Tb3J0YWJsZVN0cmluZyhhcnJheSkge1xuICAgIGxldCBieXRlU3RyaW5nID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBieXRlU3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZVN0cmluZztcbn1cbi8qKlxuICogRGVjb2RlcyBhIFwic29ydGFibGUgYnl0ZSBzdHJpbmdcIiBiYWNrIGludG8gYSBVaW50OEFycmF5LlxuICogQSBcInNvcnRhYmxlIGJ5dGUgc3RyaW5nXCIgaXMgYXNzdW1lZCB0byBiZSBjcmVhdGVkIHdoZXJlIGVhY2ggY2hhcmFjdGVyJ3NcbiAqIFVuaWNvZGUgY29kZSBwb2ludCBkaXJlY3RseSBjb3JyZXNwb25kcyB0byBhIHNpbmdsZSBieXRlIHZhbHVlICgwLTI1NSkuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVNvcnRhYmxlU3RyaW5nVG9VaW50OEFycmF5KGJ5dGVTdHJpbmcpIHtcbiAgICBjb25zdCB1aW50OGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1aW50OGFycmF5W2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gdWludDhhcnJheTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBsaWdodCBxdWVyeSBwbGFubmVyIGZvciBGaXJlc3RvcmUuXG4gKlxuICogVGhpcyBjbGFzcyBtYXRjaGVzIGEgYEZpZWxkSW5kZXhgIGFnYWluc3QgYSBGaXJlc3RvcmUgUXVlcnkgYFRhcmdldGAuIEl0XG4gKiBkZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBpbmRleCBjYW4gYmUgdXNlZCB0byBzZXJ2ZSB0aGUgc3BlY2lmaWVkIHRhcmdldC5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIHRhYmxlIHNob3djYXNlcyBzb21lIHBvc3NpYmxlIGluZGV4IGNvbmZpZ3VyYXRpb25zOlxuICpcbiAqIFF1ZXJ5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEluZGV4XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogd2hlcmUoJ2EnLCAnPT0nLCAnYScpLndoZXJlKCdiJywgJz09JywgJ2InKSAgICAgICAgIHwgYSBBU0MsIGIgREVTQ1xuICogd2hlcmUoJ2EnLCAnPT0nLCAnYScpLndoZXJlKCdiJywgJz09JywgJ2InKSAgICAgICAgIHwgYSBBU0NcbiAqIHdoZXJlKCdhJywgJz09JywgJ2EnKS53aGVyZSgnYicsICc9PScsICdiJykgICAgICAgICB8IGIgREVTQ1xuICogd2hlcmUoJ2EnLCAnPj0nLCAnYScpLm9yZGVyQnkoJ2EnKSAgICAgICAgICAgICAgICAgIHwgYSBBU0NcbiAqIHdoZXJlKCdhJywgJz49JywgJ2EnKS5vcmRlckJ5KCdhJywgJ2Rlc2MnKSAgICAgICAgICB8IGEgREVTQ1xuICogd2hlcmUoJ2EnLCAnPj0nLCAnYScpLm9yZGVyQnkoJ2EnKS5vcmRlckJ5KCdiJykgICAgIHwgYSBBU0MsIGIgQVNDXG4gKiB3aGVyZSgnYScsICc+PScsICdhJykub3JkZXJCeSgnYScpLm9yZGVyQnkoJ2InKSAgICAgfCBhIEFTQ1xuICogd2hlcmUoJ2EnLCAnYXJyYXktY29udGFpbnMnLCAnYScpLm9yZGVyQnkoJ2InKSAgICAgIHwgYSBDT05UQUlOUywgYiBBU0NFTkRJTkdcbiAqIHdoZXJlKCdhJywgJ2FycmF5LWNvbnRhaW5zJywgJ2EnKS5vcmRlckJ5KCdiJykgICAgICB8IGEgQ09OVEFJTlNcbiAqL1xuY2xhc3MgVGFyZ2V0SW5kZXhNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICAgICAgLy8gVGhlIGluZXF1YWxpdHkgZmlsdGVycyBvZiB0aGUgdGFyZ2V0IChpZiBpdCBleGlzdHMpLlxuICAgICAgICAvLyBOb3RlOiBUaGUgc29ydCBvbiBGaWVsZEZpbHRlcnMgaXMgbm90IHJlcXVpcmVkLiBVc2luZyBTb3J0ZWRTZXQgaGVyZSBqdXN0IHRvIHV0aWxpemUgdGhlIGN1c3RvbVxuICAgICAgICAvLyBjb21wYXJhdG9yLlxuICAgICAgICB0aGlzLmluZXF1YWxpdHlGaWx0ZXJzID0gbmV3IFNvcnRlZFNldCgobGhzLCByaHMpID0+IEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IobGhzLmZpZWxkLCByaHMuZmllbGQpKTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uSWQgPVxuICAgICAgICAgICAgdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCAhPSBudWxsXG4gICAgICAgICAgICAgICAgPyB0YXJnZXQuY29sbGVjdGlvbkdyb3VwXG4gICAgICAgICAgICAgICAgOiB0YXJnZXQucGF0aC5sYXN0U2VnbWVudCgpO1xuICAgICAgICB0aGlzLm9yZGVyQnlzID0gdGFyZ2V0Lm9yZGVyQnk7XG4gICAgICAgIHRoaXMuZXF1YWxpdHlGaWx0ZXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHRhcmdldC5maWx0ZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZEZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgICAgIGlmIChmaWVsZEZpbHRlci5pc0luZXF1YWxpdHkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5lcXVhbGl0eUZpbHRlcnMgPSB0aGlzLmluZXF1YWxpdHlGaWx0ZXJzLmFkZChmaWVsZEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVxdWFsaXR5RmlsdGVycy5wdXNoKGZpZWxkRmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaGFzTXVsdGlwbGVJbmVxdWFsaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmVxdWFsaXR5RmlsdGVycy5zaXplID4gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpbmRleCBjYW4gYmUgdXNlZCB0byBzZXJ2ZSB0aGUgVGFyZ2V0SW5kZXhNYXRjaGVyJ3NcbiAgICAgKiB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBBbiBpbmRleCBpcyBjb25zaWRlcmVkIGNhcGFibGUgb2Ygc2VydmluZyB0aGUgdGFyZ2V0IHdoZW46XG4gICAgICogLSBUaGUgdGFyZ2V0IHVzZXMgYWxsIGluZGV4IHNlZ21lbnRzIGZvciBpdHMgZmlsdGVycyBhbmQgb3JkZXJCeSBjbGF1c2VzLlxuICAgICAqICAgVGhlIHRhcmdldCBjYW4gaGF2ZSBhZGRpdGlvbmFsIGZpbHRlciBhbmQgb3JkZXJCeSBjbGF1c2VzLCBidXQgbm90XG4gICAgICogICBmZXdlci5cbiAgICAgKiAtIElmIGFuIEFycmF5Q29udGFpbnMvQXJyYXlDb250YWluc0FueWZpbHRlciBpcyB1c2VkLCB0aGUgaW5kZXggbXVzdCBhbHNvXG4gICAgICogICBoYXZlIGEgY29ycmVzcG9uZGluZyBgQ09OVEFJTlNgIHNlZ21lbnQuXG4gICAgICogLSBBbGwgZGlyZWN0aW9uYWwgaW5kZXggc2VnbWVudHMgY2FuIGJlIG1hcHBlZCB0byB0aGUgdGFyZ2V0IGFzIGEgc2VyaWVzIG9mXG4gICAgICogICBlcXVhbGl0eSBmaWx0ZXJzLCBhIHNpbmdsZSBpbmVxdWFsaXR5IGZpbHRlciBhbmQgYSBzZXJpZXMgb2Ygb3JkZXJCeVxuICAgICAqICAgY2xhdXNlcy5cbiAgICAgKiAtIFRoZSBzZWdtZW50cyB0aGF0IHJlcHJlc2VudCB0aGUgZXF1YWxpdHkgZmlsdGVycyBtYXkgYXBwZWFyIG91dCBvZiBvcmRlci5cbiAgICAgKiAtIFRoZSBvcHRpb25hbCBzZWdtZW50IGZvciB0aGUgaW5lcXVhbGl0eSBmaWx0ZXIgbXVzdCBhcHBlYXIgYWZ0ZXIgYWxsXG4gICAgICogICBlcXVhbGl0eSBzZWdtZW50cy5cbiAgICAgKiAtIFRoZSBzZWdtZW50cyB0aGF0IHJlcHJlc2VudCB0aGF0IG9yZGVyQnkgY2xhdXNlIG9mIHRoZSB0YXJnZXQgbXVzdCBhcHBlYXJcbiAgICAgKiAgIGluIG9yZGVyIGFmdGVyIGFsbCBlcXVhbGl0eSBhbmQgaW5lcXVhbGl0eSBzZWdtZW50cy4gU2luZ2xlIG9yZGVyQnlcbiAgICAgKiAgIGNsYXVzZXMgY2Fubm90IGJlIHNraXBwZWQsIGJ1dCBhIGNvbnRpbnVvdXMgb3JkZXJCeSBzdWZmaXggbWF5IGJlXG4gICAgICogICBvbWl0dGVkLlxuICAgICAqL1xuICAgIHNlcnZlZEJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaGFyZEFzc2VydChpbmRleC5jb2xsZWN0aW9uR3JvdXAgPT09IHRoaXMuY29sbGVjdGlvbklkLCAweGMwN2YpO1xuICAgICAgICBpZiAodGhpcy5oYXNNdWx0aXBsZUluZXF1YWxpdHkpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgc2luZ2xlIGluZXF1YWxpdHkgaXMgc3VwcG9ydGVkIGZvciBub3cuXG4gICAgICAgICAgICAvLyBUT0RPKEFkZCBzdXBwb3J0IGZvciBtdWx0aXBsZSBpbmVxdWFsaXR5IHF1ZXJ5KTogYi8yOTg0NDEwNDNcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBhcnJheSBlbGVtZW50LCBmaW5kIGEgbWF0Y2hpbmcgZmlsdGVyLlxuICAgICAgICBjb25zdCBhcnJheVNlZ21lbnQgPSBmaWVsZEluZGV4R2V0QXJyYXlTZWdtZW50KGluZGV4KTtcbiAgICAgICAgaWYgKGFycmF5U2VnbWVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAhdGhpcy5oYXNNYXRjaGluZ0VxdWFsaXR5RmlsdGVyKGFycmF5U2VnbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWdtZW50cyA9IGZpZWxkSW5kZXhHZXREaXJlY3Rpb25hbFNlZ21lbnRzKGluZGV4KTtcbiAgICAgICAgbGV0IGVxdWFsaXR5U2VnbWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCBzZWdtZW50SW5kZXggPSAwO1xuICAgICAgICBsZXQgb3JkZXJCeXNJbmRleCA9IDA7XG4gICAgICAgIC8vIFByb2Nlc3MgYWxsIGVxdWFsaXRpZXMgZmlyc3QuIEVxdWFsaXRpZXMgY2FuIGFwcGVhciBvdXQgb2Ygb3JkZXIuXG4gICAgICAgIGZvciAoOyBzZWdtZW50SW5kZXggPCBzZWdtZW50cy5sZW5ndGg7ICsrc2VnbWVudEluZGV4KSB7XG4gICAgICAgICAgICAvLyBXZSBhdHRlbXB0IHRvIGdyZWVkaWx5IG1hdGNoIGFsbCBzZWdtZW50cyB0byBlcXVhbGl0eSBmaWx0ZXJzLiBJZiBhXG4gICAgICAgICAgICAvLyBmaWx0ZXIgbWF0Y2hlcyBhbiBpbmRleCBzZWdtZW50LCB3ZSBjYW4gbWFyayB0aGUgc2VnbWVudCBhcyB1c2VkLlxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzTWF0Y2hpbmdFcXVhbGl0eUZpbHRlcihzZWdtZW50c1tzZWdtZW50SW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGVxdWFsaXR5U2VnbWVudHMgPSBlcXVhbGl0eVNlZ21lbnRzLmFkZChzZWdtZW50c1tzZWdtZW50SW5kZXhdLmZpZWxkUGF0aC5jYW5vbmljYWxTdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBjYW5ub3QgZmluZCBhIG1hdGNoaW5nIGZpbHRlciwgd2UgbmVlZCB0byB2ZXJpZnkgd2hldGhlciB0aGVcbiAgICAgICAgICAgICAgICAvLyByZW1haW5pbmcgc2VnbWVudHMgbWFwIHRvIHRoZSB0YXJnZXQncyBpbmVxdWFsaXR5IGFuZCBpdHMgb3JkZXJCeVxuICAgICAgICAgICAgICAgIC8vIGNsYXVzZXMuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIHByb2Nlc3NlZCBhbGwgc2VnbWVudHMsIGFsbCBzZWdtZW50cyBhcmUgdXNlZCB0byBzZXJ2ZVxuICAgICAgICAvLyB0aGUgZXF1YWxpdHkgZmlsdGVycyBhbmQgd2UgZG8gbm90IG5lZWQgdG8gbWFwIGFueSBzZWdtZW50cyB0byB0aGVcbiAgICAgICAgLy8gdGFyZ2V0J3MgaW5lcXVhbGl0eSBhbmQgb3JkZXJCeSBjbGF1c2VzLlxuICAgICAgICBpZiAoc2VnbWVudEluZGV4ID09PSBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZXF1YWxpdHlGaWx0ZXJzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGEgc2luZ2xlIGluZXF1YWxpdHkgaXMgY3VycmVudGx5IHN1cHBvcnRlZC4gR2V0IHRoZSBvbmx5IGVudHJ5IGluIHRoZSBzZXQuXG4gICAgICAgICAgICBjb25zdCBpbmVxdWFsaXR5RmlsdGVyID0gdGhpcy5pbmVxdWFsaXR5RmlsdGVycy5nZXRJdGVyYXRvcigpLmdldE5leHQoKTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGluZXF1YWxpdHkgZmlsdGVyIGFuZCB0aGUgZmllbGQgd2FzIG5vdCBpbiBvbmUgb2YgdGhlXG4gICAgICAgICAgICAvLyBlcXVhbGl0eSBmaWx0ZXJzIGFib3ZlLCB0aGUgbmV4dCBzZWdtZW50IG11c3QgbWF0Y2ggYm90aCB0aGUgZmlsdGVyXG4gICAgICAgICAgICAvLyBhbmQgdGhlIGZpcnN0IG9yZGVyQnkgY2xhdXNlLlxuICAgICAgICAgICAgaWYgKCFlcXVhbGl0eVNlZ21lbnRzLmhhcyhpbmVxdWFsaXR5RmlsdGVyLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tzZWdtZW50SW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaGVzRmlsdGVyKGluZXF1YWxpdHlGaWx0ZXIsIHNlZ21lbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgICF0aGlzLm1hdGNoZXNPcmRlckJ5KHRoaXMub3JkZXJCeXNbb3JkZXJCeXNJbmRleCsrXSwgc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsrc2VnbWVudEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbCByZW1haW5pbmcgc2VnbWVudHMgbmVlZCB0byByZXByZXNlbnQgdGhlIHByZWZpeCBvZiB0aGUgdGFyZ2V0J3NcbiAgICAgICAgLy8gb3JkZXJCeS5cbiAgICAgICAgZm9yICg7IHNlZ21lbnRJbmRleCA8IHNlZ21lbnRzLmxlbmd0aDsgKytzZWdtZW50SW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tzZWdtZW50SW5kZXhdO1xuICAgICAgICAgICAgaWYgKG9yZGVyQnlzSW5kZXggPj0gdGhpcy5vcmRlckJ5cy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaGVzT3JkZXJCeSh0aGlzLm9yZGVyQnlzW29yZGVyQnlzSW5kZXgrK10sIHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVsbCBtYXRjaGVkIGZpZWxkIGluZGV4IGZvciB0aGlzIHRhcmdldC4gQ3VycmVudGx5IG11bHRpcGxlXG4gICAgICogaW5lcXVhbGl0eSBxdWVyeSBpcyBub3Qgc3VwcG9ydGVkIHNvIGZ1bmN0aW9uIHJldHVybnMgbnVsbC5cbiAgICAgKi9cbiAgICBidWlsZFRhcmdldEluZGV4KCkge1xuICAgICAgICBpZiAodGhpcy5oYXNNdWx0aXBsZUluZXF1YWxpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gbWFrZSBzdXJlIG9ubHkgb25lIHNlZ21lbnQgY3JlYXRlZCBmb3Igb25lIGZpZWxkLiBGb3IgZXhhbXBsZSxcbiAgICAgICAgLy8gaW4gY2FzZSBsaWtlIGEgPT0gMyBhbmQgYSA+IDIsIEluZGV4IHthIEFTQ0VORElOR30gd2lsbCBvbmx5IGJlIGNyZWF0ZWRcbiAgICAgICAgLy8gb25jZS5cbiAgICAgICAgbGV0IHVuaXF1ZUZpZWxkcyA9IG5ldyBTb3J0ZWRTZXQoRmllbGRQYXRoJDEuY29tcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHRoaXMuZXF1YWxpdHlGaWx0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmZpZWxkLmlzS2V5RmllbGQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNBcnJheU9wZXJhdG9yID0gZmlsdGVyLm9wID09PSBcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi8gfHxcbiAgICAgICAgICAgICAgICBmaWx0ZXIub3AgPT09IFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXlPcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEluZGV4U2VnbWVudChmaWx0ZXIuZmllbGQsIDIgLyogSW5kZXhLaW5kLkNPTlRBSU5TICovKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pcXVlRmllbGRzLmhhcyhmaWx0ZXIuZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmlxdWVGaWVsZHMgPSB1bmlxdWVGaWVsZHMuYWRkKGZpbHRlci5maWVsZCk7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChuZXcgSW5kZXhTZWdtZW50KGZpbHRlci5maWVsZCwgMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogV2UgZG8gbm90IGV4cGxpY2l0bHkgY2hlY2sgYHRoaXMuaW5lcXVhbGl0eUZpbHRlcmAgYnV0IHJhdGhlciByZWx5XG4gICAgICAgIC8vIG9uIHRoZSB0YXJnZXQgZGVmaW5pbmcgYW4gYXBwcm9wcmlhdGUgXCJvcmRlciBieVwiIHRvIGVuc3VyZSB0aGF0IHRoZVxuICAgICAgICAvLyByZXF1aXJlZCBpbmRleCBzZWdtZW50IGlzIGFkZGVkLiBUaGUgcXVlcnkgZW5naW5lIHdvdWxkIHJlamVjdCBhIHF1ZXJ5XG4gICAgICAgIC8vIHdpdGggYW4gaW5lcXVhbGl0eSBmaWx0ZXIgdGhhdCBsYWNrcyB0aGUgcmVxdWlyZWQgb3JkZXItYnkgY2xhdXNlLlxuICAgICAgICBmb3IgKGNvbnN0IG9yZGVyQnkgb2YgdGhpcy5vcmRlckJ5cykge1xuICAgICAgICAgICAgLy8gU3RvcCBhZGRpbmcgbW9yZSBzZWdtZW50cyBpZiB3ZSBzZWUgYSBvcmRlci1ieSBvbiBrZXkuIFR5cGljYWxseSB0aGlzXG4gICAgICAgICAgICAvLyBpcyB0aGUgZGVmYXVsdCBpbXBsaWNpdCBvcmRlci1ieSB3aGljaCBpcyBjb3ZlcmVkIGluIHRoZSBpbmRleF9lbnRyeVxuICAgICAgICAgICAgLy8gdGFibGUgYXMgYSBzZXBhcmF0ZSBjb2x1bW4uIElmIGl0IGlzIG5vdCB0aGUgZGVmYXVsdCBvcmRlci1ieSwgdGhlXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZWQgaW5kZXggd2lsbCBiZSBtaXNzaW5nIHNvbWUgc2VnbWVudHMgb3B0aW1pemVkIGZvciBvcmRlci1ieXMsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBwcm9iYWJseSBmaW5lLlxuICAgICAgICAgICAgaWYgKG9yZGVyQnkuZmllbGQuaXNLZXlGaWVsZCgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5pcXVlRmllbGRzLmhhcyhvcmRlckJ5LmZpZWxkKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5pcXVlRmllbGRzID0gdW5pcXVlRmllbGRzLmFkZChvcmRlckJ5LmZpZWxkKTtcbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEluZGV4U2VnbWVudChvcmRlckJ5LmZpZWxkLCBvcmRlckJ5LmRpciA9PT0gXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovXG4gICAgICAgICAgICAgICAgPyAwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi9cbiAgICAgICAgICAgICAgICA6IDEgLyogSW5kZXhLaW5kLkRFU0NFTkRJTkcgKi8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZpZWxkSW5kZXgoRmllbGRJbmRleC5VTktOT1dOX0lELCB0aGlzLmNvbGxlY3Rpb25JZCwgc2VnbWVudHMsIEluZGV4U3RhdGUuZW1wdHkoKSk7XG4gICAgfVxuICAgIGhhc01hdGNoaW5nRXF1YWxpdHlGaWx0ZXIoc2VnbWVudCkge1xuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiB0aGlzLmVxdWFsaXR5RmlsdGVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hlc0ZpbHRlcihmaWx0ZXIsIHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtYXRjaGVzRmlsdGVyKGZpbHRlciwgc2VnbWVudCkge1xuICAgICAgICBpZiAoZmlsdGVyID09PSB1bmRlZmluZWQgfHwgIWZpbHRlci5maWVsZC5pc0VxdWFsKHNlZ21lbnQuZmllbGRQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQXJyYXlPcGVyYXRvciA9IGZpbHRlci5vcCA9PT0gXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovIHx8XG4gICAgICAgICAgICBmaWx0ZXIub3AgPT09IFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovO1xuICAgICAgICByZXR1cm4gKHNlZ21lbnQua2luZCA9PT0gMiAvKiBJbmRleEtpbmQuQ09OVEFJTlMgKi8pID09PSBpc0FycmF5T3BlcmF0b3I7XG4gICAgfVxuICAgIG1hdGNoZXNPcmRlckJ5KG9yZGVyQnksIHNlZ21lbnQpIHtcbiAgICAgICAgaWYgKCFvcmRlckJ5LmZpZWxkLmlzRXF1YWwoc2VnbWVudC5maWVsZFBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgoc2VnbWVudC5raW5kID09PSAwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi8gJiZcbiAgICAgICAgICAgIG9yZGVyQnkuZGlyID09PSBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi8pIHx8XG4gICAgICAgICAgICAoc2VnbWVudC5raW5kID09PSAxIC8qIEluZGV4S2luZC5ERVNDRU5ESU5HICovICYmXG4gICAgICAgICAgICAgICAgb3JkZXJCeS5kaXIgPT09IFwiZGVzY1wiIC8qIERpcmVjdGlvbi5ERVNDRU5ESU5HICovKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IGhlbHAgd2l0aCBib29sZWFuIGxvZ2ljIHRyYW5zZm9ybWF0aW9ucyBuZWVkZWQgZm9yIGhhbmRsaW5nXG4gKiBjb21wbGV4IGZpbHRlcnMgdXNlZCBpbiBxdWVyaWVzLlxuICovXG4vKipcbiAqIFRoZSBgaW5gIGZpbHRlciBpcyBvbmx5IGEgc3ludGFjdGljIHN1Z2FyIG92ZXIgYSBkaXNqdW5jdGlvbiBvZiBlcXVhbGl0aWVzLiBGb3IgaW5zdGFuY2U6IGBhIGluXG4gKiBbMSwyLDNdYCBpcyBpbiBmYWN0IGBhPT0xIHx8IGE9PTIgfHwgYT09M2AuIFRoaXMgbWV0aG9kIGV4cGFuZHMgYW55IGBpbmAgZmlsdGVyIGluIHRoZSBnaXZlblxuICogaW5wdXQgaW50byBhIGRpc2p1bmN0aW9uIG9mIGVxdWFsaXR5IGZpbHRlcnMgYW5kIHJldHVybnMgdGhlIGV4cGFuZGVkIGZpbHRlci5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUluRXhwYW5zaW9uKGZpbHRlcikge1xuICAgIGhhcmRBc3NlcnQoZmlsdGVyIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgfHwgZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyLCAweDRlMmMpO1xuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcikge1xuICAgICAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgSW5GaWx0ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGFuZGVkRmlsdGVycyA9IGZpbHRlci52YWx1ZS5hcnJheVZhbHVlPy52YWx1ZXM/Lm1hcCh2YWx1ZSA9PiBGaWVsZEZpbHRlci5jcmVhdGUoZmlsdGVyLmZpZWxkLCBcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi8sIHZhbHVlKSkgfHwgW107XG4gICAgICAgICAgICByZXR1cm4gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShleHBhbmRlZEZpbHRlcnMsIFwib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHJlYWNoZWQgb3RoZXIga2luZHMgb2YgZmllbGQgZmlsdGVycy5cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgaGF2ZSBhIGNvbXBvc2l0ZSBmaWx0ZXIuXG4gICAgY29uc3QgZXhwYW5kZWRGaWx0ZXJzID0gZmlsdGVyLmZpbHRlcnMubWFwKHN1YmZpbHRlciA9PiBjb21wdXRlSW5FeHBhbnNpb24oc3ViZmlsdGVyKSk7XG4gICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUoZXhwYW5kZWRGaWx0ZXJzLCBmaWx0ZXIub3ApO1xufVxuLyoqXG4gKiBHaXZlbiBhIGNvbXBvc2l0ZSBmaWx0ZXIsIHJldHVybnMgdGhlIGxpc3Qgb2YgdGVybXMgaW4gaXRzIGRpc2p1bmN0aXZlIG5vcm1hbCBmb3JtLlxuICpcbiAqIDxwPkVhY2ggZWxlbWVudCBpbiB0aGUgcmV0dXJuIHZhbHVlIGlzIG9uZSB0ZXJtIG9mIHRoZSByZXN1bHRpbmcgRE5GLiBGb3IgaW5zdGFuY2U6IEZvciB0aGVcbiAqIGlucHV0OiAoQSB8fCBCKSAmJiBDLCB0aGUgRE5GIGZvcm0gaXM6IChBICYmIEMpIHx8IChCICYmIEMpLCBhbmQgdGhlIHJldHVybiB2YWx1ZSBpcyBhIGxpc3RcbiAqIHdpdGggdHdvIGVsZW1lbnRzOiBhIGNvbXBvc2l0ZSBmaWx0ZXIgdGhhdCBwZXJmb3JtcyAoQSAmJiBDKSwgYW5kIGEgY29tcG9zaXRlIGZpbHRlciB0aGF0XG4gKiBwZXJmb3JtcyAoQiAmJiBDKS5cbiAqXG4gKiBAcGFyYW0gZmlsdGVyIC0gdGhlIGNvbXBvc2l0ZSBmaWx0ZXIgdG8gY2FsY3VsYXRlIERORiB0cmFuc2Zvcm0gZm9yLlxuICogQHJldHVybnMgdGhlIHRlcm1zIGluIHRoZSBETkYgdHJhbnNmb3JtLlxuICovXG5mdW5jdGlvbiBnZXREbmZUZXJtcyhmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyLmdldEZpbHRlcnMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBjb21wdXRlRGlzdHJpYnV0ZWROb3JtYWxGb3JtKGNvbXB1dGVJbkV4cGFuc2lvbihmaWx0ZXIpKTtcbiAgICBoYXJkQXNzZXJ0KGlzRGlzanVuY3RpdmVOb3JtYWxGb3JtKHJlc3VsdCksIDB4MWNkZik7XG4gICAgaWYgKGlzU2luZ2xlRmllbGRGaWx0ZXIocmVzdWx0KSB8fCBpc0ZsYXRDb25qdW5jdGlvbihyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiBbcmVzdWx0XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5nZXRGaWx0ZXJzKCk7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmaWx0ZXIgaXMgYSBzaW5nbGUgZmllbGQgZmlsdGVyLiBlLmcuIChhID09IDEwKS4gKi9cbmZ1bmN0aW9uIGlzU2luZ2xlRmllbGRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgcmV0dXJuIGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGZpbHRlciBpcyB0aGUgY29uanVuY3Rpb24gb2Ygb25lIG9yIG1vcmUgZmllbGQgZmlsdGVycy4gZS5nLiAoYSA9PSAxMFxuICogJiYgYiA9PSAyMClcbiAqL1xuZnVuY3Rpb24gaXNGbGF0Q29uanVuY3Rpb24oZmlsdGVyKSB7XG4gICAgcmV0dXJuIChmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIgJiZcbiAgICAgICAgY29tcG9zaXRlRmlsdGVySXNGbGF0Q29uanVuY3Rpb24oZmlsdGVyKSk7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGdpdmVuIGZpbHRlciBpcyBpbiBkaXNqdW5jdGl2ZSBub3JtYWwgZm9ybSAoRE5GKS5cbiAqXG4gKiA8cD5JbiBib29sZWFuIGxvZ2ljLCBhIGRpc2p1bmN0aXZlIG5vcm1hbCBmb3JtIChETkYpIGlzIGEgY2Fub25pY2FsIG5vcm1hbCBmb3JtIG9mIGEgbG9naWNhbFxuICogZm9ybXVsYSBjb25zaXN0aW5nIG9mIGEgZGlzanVuY3Rpb24gb2YgY29uanVuY3Rpb25zOyBpdCBjYW4gYWxzbyBiZSBkZXNjcmliZWQgYXMgYW4gT1Igb2YgQU5Ecy5cbiAqXG4gKiA8cD5Gb3IgbW9yZSBpbmZvLCB2aXNpdDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzanVuY3RpdmVfbm9ybWFsX2Zvcm1cbiAqL1xuZnVuY3Rpb24gaXNEaXNqdW5jdGl2ZU5vcm1hbEZvcm0oZmlsdGVyKSB7XG4gICAgcmV0dXJuIChpc1NpbmdsZUZpZWxkRmlsdGVyKGZpbHRlcikgfHxcbiAgICAgICAgaXNGbGF0Q29uanVuY3Rpb24oZmlsdGVyKSB8fFxuICAgICAgICBpc0Rpc2p1bmN0aW9uT2ZGaWVsZEZpbHRlcnNBbmRGbGF0Q29uanVuY3Rpb25zKGZpbHRlcikpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGZpbHRlciBpcyB0aGUgZGlzanVuY3Rpb24gb2Ygb25lIG9yIG1vcmUgXCJmbGF0IGNvbmp1bmN0aW9uc1wiIGFuZFxuICogZmllbGQgZmlsdGVycy4gZS5nLiAoYSA9PSAxMCkgfHwgKGI9PTIwICYmIGM9PTMwKVxuICovXG5mdW5jdGlvbiBpc0Rpc2p1bmN0aW9uT2ZGaWVsZEZpbHRlcnNBbmRGbGF0Q29uanVuY3Rpb25zKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcbiAgICAgICAgaWYgKGNvbXBvc2l0ZUZpbHRlcklzRGlzanVuY3Rpb24oZmlsdGVyKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdWJGaWx0ZXIgb2YgZmlsdGVyLmdldEZpbHRlcnMoKSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNTaW5nbGVGaWVsZEZpbHRlcihzdWJGaWx0ZXIpICYmICFpc0ZsYXRDb25qdW5jdGlvbihzdWJGaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb21wdXRlRGlzdHJpYnV0ZWROb3JtYWxGb3JtKGZpbHRlcikge1xuICAgIGhhcmRBc3NlcnQoZmlsdGVyIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgfHwgZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyLCAweDg0ZTIpO1xuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcikge1xuICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgIH1cbiAgICBpZiAoZmlsdGVyLmZpbHRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjb21wdXRlRGlzdHJpYnV0ZWROb3JtYWxGb3JtKGZpbHRlci5maWx0ZXJzWzBdKTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSBETkYgZm9yIGVhY2ggb2YgdGhlIHN1YmZpbHRlcnMgZmlyc3RcbiAgICBjb25zdCByZXN1bHQgPSBmaWx0ZXIuZmlsdGVycy5tYXAoc3ViZmlsdGVyID0+IGNvbXB1dGVEaXN0cmlidXRlZE5vcm1hbEZvcm0oc3ViZmlsdGVyKSk7XG4gICAgbGV0IG5ld0ZpbHRlciA9IENvbXBvc2l0ZUZpbHRlci5jcmVhdGUocmVzdWx0LCBmaWx0ZXIub3ApO1xuICAgIG5ld0ZpbHRlciA9IGFwcGx5QXNzb2NpYXRpb24obmV3RmlsdGVyKTtcbiAgICBpZiAoaXNEaXNqdW5jdGl2ZU5vcm1hbEZvcm0obmV3RmlsdGVyKSkge1xuICAgICAgICByZXR1cm4gbmV3RmlsdGVyO1xuICAgIH1cbiAgICBoYXJkQXNzZXJ0KG5ld0ZpbHRlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlciwgMHhmYmYyKTtcbiAgICBoYXJkQXNzZXJ0KGNvbXBvc2l0ZUZpbHRlcklzQ29uanVuY3Rpb24obmV3RmlsdGVyKSwgMHg5ZDNiKTtcbiAgICBoYXJkQXNzZXJ0KG5ld0ZpbHRlci5maWx0ZXJzLmxlbmd0aCA+IDEsIDB4ZTI0Nyk7XG4gICAgcmV0dXJuIG5ld0ZpbHRlci5maWx0ZXJzLnJlZHVjZSgocnVubmluZ1Jlc3VsdCwgZmlsdGVyKSA9PiBhcHBseURpc3RyaWJ1dGlvbihydW5uaW5nUmVzdWx0LCBmaWx0ZXIpKTtcbn1cbmZ1bmN0aW9uIGFwcGx5RGlzdHJpYnV0aW9uKGxocywgcmhzKSB7XG4gICAgaGFyZEFzc2VydChsaHMgaW5zdGFuY2VvZiBGaWVsZEZpbHRlciB8fCBsaHMgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIsIDB4OTVmNCk7XG4gICAgaGFyZEFzc2VydChyaHMgaW5zdGFuY2VvZiBGaWVsZEZpbHRlciB8fCByaHMgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIsIDB4NjM4MSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAobGhzIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcbiAgICAgICAgaWYgKHJocyBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgICAgICAvLyBGaWVsZEZpbHRlciBGaWVsZEZpbHRlclxuICAgICAgICAgICAgcmVzdWx0ID0gYXBwbHlEaXN0cmlidXRpb25GaWVsZEZpbHRlcnMobGhzLCByaHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRmllbGRGaWx0ZXIgQ29tcG9zaXRlRmlsdGVyXG4gICAgICAgICAgICByZXN1bHQgPSBhcHBseURpc3RyaWJ1dGlvbkZpZWxkQW5kQ29tcG9zaXRlRmlsdGVycyhsaHMsIHJocyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChyaHMgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcikge1xuICAgICAgICAgICAgLy8gQ29tcG9zaXRlRmlsdGVyIEZpZWxkRmlsdGVyXG4gICAgICAgICAgICByZXN1bHQgPSBhcHBseURpc3RyaWJ1dGlvbkZpZWxkQW5kQ29tcG9zaXRlRmlsdGVycyhyaHMsIGxocyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDb21wb3NpdGVGaWx0ZXIgQ29tcG9zaXRlRmlsdGVyXG4gICAgICAgICAgICByZXN1bHQgPSBhcHBseURpc3RyaWJ1dGlvbkNvbXBvc2l0ZUZpbHRlcnMobGhzLCByaHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcHBseUFzc29jaWF0aW9uKHJlc3VsdCk7XG59XG5mdW5jdGlvbiBhcHBseURpc3RyaWJ1dGlvbkZpZWxkRmlsdGVycyhsaHMsIHJocykge1xuICAgIC8vIENvbmp1bmN0aW9uIGRpc3RyaWJ1dGlvbiBmb3IgdHdvIGZpZWxkIGZpbHRlcnMgaXMgdGhlIGNvbmp1bmN0aW9uIG9mIHRoZW0uXG4gICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUoW2xocywgcmhzXSwgXCJhbmRcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5BTkQgKi8pO1xufVxuZnVuY3Rpb24gYXBwbHlEaXN0cmlidXRpb25Db21wb3NpdGVGaWx0ZXJzKGxocywgcmhzKSB7XG4gICAgaGFyZEFzc2VydChsaHMuZmlsdGVycy5sZW5ndGggPiAwICYmIHJocy5maWx0ZXJzLmxlbmd0aCA+IDAsIDB4YmI4NSk7XG4gICAgLy8gVGhlcmUgYXJlIGZvdXIgY2FzZXM6XG4gICAgLy8gKEEgJiBCKSAmIChDICYgRCkgLS0+IChBICYgQiAmIEMgJiBEKVxuICAgIC8vIChBICYgQikgJiAoQyB8IEQpIC0tPiAoQSAmIEIgJiBDKSB8IChBICYgQiAmIEQpXG4gICAgLy8gKEEgfCBCKSAmIChDICYgRCkgLS0+IChDICYgRCAmIEEpIHwgKEMgJiBEICYgQilcbiAgICAvLyAoQSB8IEIpICYgKEMgfCBEKSAtLT4gKEEgJiBDKSB8IChBICYgRCkgfCAoQiAmIEMpIHwgKEIgJiBEKVxuICAgIC8vIENhc2UgMSBpcyBhIG1lcmdlLlxuICAgIGlmIChjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKGxocykgJiYgY29tcG9zaXRlRmlsdGVySXNDb25qdW5jdGlvbihyaHMpKSB7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGVGaWx0ZXJXaXRoQWRkZWRGaWx0ZXJzKGxocywgcmhzLmdldEZpbHRlcnMoKSk7XG4gICAgfVxuICAgIC8vIENhc2UgMiwzLDQgYWxsIGhhdmUgYXQgbGVhc3Qgb25lIHNpZGUgKGxocyBvciByaHMpIHRoYXQgaXMgYSBkaXNqdW5jdGlvbi4gSW4gYWxsIHRocmVlIGNhc2VzXG4gICAgLy8gd2Ugc2hvdWxkIHRha2UgZWFjaCBlbGVtZW50IG9mIHRoZSBkaXNqdW5jdGlvbiBhbmQgZGlzdHJpYnV0ZSBpdCBvdmVyIHRoZSBvdGhlciBzaWRlLCBhbmRcbiAgICAvLyByZXR1cm4gdGhlIGRpc2p1bmN0aW9uIG9mIHRoZSBkaXN0cmlidXRpb24gcmVzdWx0cy5cbiAgICBjb25zdCBkaXNqdW5jdGlvblNpZGUgPSBjb21wb3NpdGVGaWx0ZXJJc0Rpc2p1bmN0aW9uKGxocykgPyBsaHMgOiByaHM7XG4gICAgY29uc3Qgb3RoZXJTaWRlID0gY29tcG9zaXRlRmlsdGVySXNEaXNqdW5jdGlvbihsaHMpID8gcmhzIDogbGhzO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBkaXNqdW5jdGlvblNpZGUuZmlsdGVycy5tYXAoc3ViZmlsdGVyID0+IGFwcGx5RGlzdHJpYnV0aW9uKHN1YmZpbHRlciwgb3RoZXJTaWRlKSk7XG4gICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUocmVzdWx0cywgXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovKTtcbn1cbmZ1bmN0aW9uIGFwcGx5RGlzdHJpYnV0aW9uRmllbGRBbmRDb21wb3NpdGVGaWx0ZXJzKGZpZWxkRmlsdGVyLCBjb21wb3NpdGVGaWx0ZXIpIHtcbiAgICAvLyBUaGVyZSBhcmUgdHdvIGNhc2VzOlxuICAgIC8vIEEgJiAoQiAmIEMpIC0tPiAoQSAmIEIgJiBDKVxuICAgIC8vIEEgJiAoQiB8IEMpIC0tPiAoQSAmIEIpIHwgKEEgJiBDKVxuICAgIGlmIChjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKGNvbXBvc2l0ZUZpbHRlcikpIHtcbiAgICAgICAgLy8gQ2FzZSAxXG4gICAgICAgIHJldHVybiBjb21wb3NpdGVGaWx0ZXJXaXRoQWRkZWRGaWx0ZXJzKGNvbXBvc2l0ZUZpbHRlciwgZmllbGRGaWx0ZXIuZ2V0RmlsdGVycygpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIENhc2UgMlxuICAgICAgICBjb25zdCBuZXdGaWx0ZXJzID0gY29tcG9zaXRlRmlsdGVyLmZpbHRlcnMubWFwKHN1YmZpbHRlciA9PiBhcHBseURpc3RyaWJ1dGlvbihmaWVsZEZpbHRlciwgc3ViZmlsdGVyKSk7XG4gICAgICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKG5ld0ZpbHRlcnMsIFwib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqLyk7XG4gICAgfVxufVxuLyoqXG4gKiBBcHBsaWVzIHRoZSBhc3NvY2lhdGl2aXR5IHByb3BlcnR5IHRvIHRoZSBnaXZlbiBmaWx0ZXIgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBmaWx0ZXIuXG4gKlxuICogPHVsPlxuICogICA8bGk+QSB8IChCIHwgQykgPT0gKEEgfCBCKSB8IEMgPT0gKEEgfCBCIHwgQylcbiAqICAgPGxpPkEgJiAoQiAmIEMpID09IChBICYgQikgJiBDID09IChBICYgQiAmIEMpXG4gKiA8L3VsPlxuICpcbiAqIDxwPkZvciBtb3JlIGluZm8sIHZpc2l0OiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Bc3NvY2lhdGl2ZV9wcm9wZXJ0eSNQcm9wb3NpdGlvbmFsX2xvZ2ljXG4gKi9cbmZ1bmN0aW9uIGFwcGx5QXNzb2NpYXRpb24oZmlsdGVyKSB7XG4gICAgaGFyZEFzc2VydChmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlciB8fCBmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIsIDB4MmU0YSk7XG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcnMgPSBmaWx0ZXIuZ2V0RmlsdGVycygpO1xuICAgIC8vIElmIHRoZSBjb21wb3NpdGUgZmlsdGVyIG9ubHkgY29udGFpbnMgMSBmaWx0ZXIsIGFwcGx5IGFzc29jaWF0aXZpdHkgdG8gaXQuXG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBhcHBseUFzc29jaWF0aW9uKGZpbHRlcnNbMF0pO1xuICAgIH1cbiAgICAvLyBBc3NvY2lhdGl2aXR5IGFwcGxpZWQgdG8gYSBmbGF0IGNvbXBvc2l0ZSBmaWx0ZXIgcmVzdWx0cyBpcyBpdHNlbGYuXG4gICAgaWYgKGNvbXBvc2l0ZUZpbHRlcklzRmxhdChmaWx0ZXIpKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfVxuICAgIC8vIEZpcnN0IGFwcGx5IGFzc29jaWF0aXZpdHkgdG8gYWxsIHN1YmZpbHRlcnMuIFRoaXMgd2lsbCBpbiB0dXJuIHJlY3Vyc2l2ZWx5IGFwcGx5XG4gICAgLy8gYXNzb2NpYXRpdml0eSB0byBhbGwgbmVzdGVkIGNvbXBvc2l0ZSBmaWx0ZXJzIGFuZCBmaWVsZCBmaWx0ZXJzLlxuICAgIGNvbnN0IHVwZGF0ZWRGaWx0ZXJzID0gZmlsdGVycy5tYXAoc3ViZmlsdGVyID0+IGFwcGx5QXNzb2NpYXRpb24oc3ViZmlsdGVyKSk7XG4gICAgLy8gRm9yIGNvbXBvc2l0ZSBzdWJmaWx0ZXJzIHRoYXQgcGVyZm9ybSB0aGUgc2FtZSBraW5kIG9mIGxvZ2ljYWwgb3BlcmF0aW9uIGFzIGBjb21wb3NpdGVGaWx0ZXJgXG4gICAgLy8gdGFrZSBvdXQgdGhlaXIgZmlsdGVycyBhbmQgYWRkIHRoZW0gdG8gYGNvbXBvc2l0ZUZpbHRlcmAuIEZvciBleGFtcGxlOlxuICAgIC8vIGNvbXBvc2l0ZUZpbHRlciA9IChBIHwgKEIgfCBDIHwgRCkpXG4gICAgLy8gY29tcG9zaXRlU3ViZmlsdGVyID0gKEIgfCBDIHwgRClcbiAgICAvLyBSZXN1bHQ6IChBIHwgQiB8IEMgfCBEKVxuICAgIC8vIE5vdGUgdGhhdCB0aGUgYGNvbXBvc2l0ZVN1YmZpbHRlcmAgaGFzIGJlZW4gZWxpbWluYXRlZCwgYW5kIGl0cyBmaWx0ZXJzIChCLCBDLCBEKSBoYXZlIGJlZW5cbiAgICAvLyBhZGRlZCB0byB0aGUgdG9wLWxldmVsIFwiY29tcG9zaXRlRmlsdGVyXCIuXG4gICAgY29uc3QgbmV3U3ViZmlsdGVycyA9IFtdO1xuICAgIHVwZGF0ZWRGaWx0ZXJzLmZvckVhY2goc3ViZmlsdGVyID0+IHtcbiAgICAgICAgaWYgKHN1YmZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgICAgICBuZXdTdWJmaWx0ZXJzLnB1c2goc3ViZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdWJmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmIChzdWJmaWx0ZXIub3AgPT09IGZpbHRlci5vcCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0ZUZpbHRlcjogKEEgfCAoQiB8IEMpKVxuICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0ZVN1YmZpbHRlcjogKEIgfCBDKVxuICAgICAgICAgICAgICAgIC8vIFJlc3VsdDogKEEgfCBCIHwgQylcbiAgICAgICAgICAgICAgICBuZXdTdWJmaWx0ZXJzLnB1c2goLi4uc3ViZmlsdGVyLmZpbHRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29tcG9zaXRlRmlsdGVyOiAoQSB8IChCICYgQykpXG4gICAgICAgICAgICAgICAgLy8gY29tcG9zaXRlU3ViZmlsdGVyOiAoQiAmIEMpXG4gICAgICAgICAgICAgICAgLy8gUmVzdWx0OiAoQSB8IChCICYgQykpXG4gICAgICAgICAgICAgICAgbmV3U3ViZmlsdGVycy5wdXNoKHN1YmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobmV3U3ViZmlsdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ld1N1YmZpbHRlcnNbMF07XG4gICAgfVxuICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKG5ld1N1YmZpbHRlcnMsIGZpbHRlci5vcCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGluLW1lbW9yeSBpbXBsZW1lbnRhdGlvbiBvZiBJbmRleE1hbmFnZXIuXG4gKi9cbmNsYXNzIE1lbW9yeUluZGV4TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblBhcmVudEluZGV4ID0gbmV3IE1lbW9yeUNvbGxlY3Rpb25QYXJlbnRJbmRleCgpO1xuICAgIH1cbiAgICBhZGRUb0NvbGxlY3Rpb25QYXJlbnRJbmRleCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvblBhdGgpIHtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uUGFyZW50SW5kZXguYWRkKGNvbGxlY3Rpb25QYXRoKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldENvbGxlY3Rpb25QYXJlbnRzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29sbGVjdGlvblBhcmVudEluZGV4LmdldEVudHJpZXMoY29sbGVjdGlvbklkKSk7XG4gICAgfVxuICAgIGFkZEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIGluZGV4KSB7XG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBkZWxldGVGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBpbmRleCkge1xuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZGVsZXRlQWxsRmllbGRJbmRleGVzKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjcmVhdGVUYXJnZXRJbmRleGVzKHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldERvY3VtZW50c01hdGNoaW5nVGFyZ2V0KHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBnZXRJbmRleFR5cGUodHJhbnNhY3Rpb24sIHRhcmdldCkge1xuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoMCAvKiBJbmRleFR5cGUuTk9ORSAqLyk7XG4gICAgfVxuICAgIGdldEZpZWxkSW5kZXhlcyh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwKSB7XG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIGdldE5leHRDb2xsZWN0aW9uR3JvdXBUb1VwZGF0ZSh0cmFuc2FjdGlvbikge1xuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfVxuICAgIGdldE1pbk9mZnNldCh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShJbmRleE9mZnNldC5taW4oKSk7XG4gICAgfVxuICAgIGdldE1pbk9mZnNldEZyb21Db2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoSW5kZXhPZmZzZXQubWluKCkpO1xuICAgIH1cbiAgICB1cGRhdGVDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVJbmRleEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50cykge1xuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG59XG4vKipcbiAqIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSBjb2xsZWN0aW9uLXBhcmVudCBpbmRleCBleHBvc2VkIGJ5IE1lbW9yeUluZGV4TWFuYWdlci5cbiAqIEFsc28gdXNlZCBmb3IgaW4tbWVtb3J5IGNhY2hpbmcgYnkgSW5kZXhlZERiSW5kZXhNYW5hZ2VyIGFuZCBpbml0aWFsIGluZGV4IHBvcHVsYXRpb25cbiAqIGluIGluZGV4ZWRkYl9zY2hlbWEudHNcbiAqL1xuY2xhc3MgTWVtb3J5Q29sbGVjdGlvblBhcmVudEluZGV4IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IHt9O1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGZhbHNlIGlmIHRoZSBlbnRyeSBhbHJlYWR5IGV4aXN0ZWQuXG4gICAgYWRkKGNvbGxlY3Rpb25QYXRoKSB7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IGNvbGxlY3Rpb25QYXRoLmxhc3RTZWdtZW50KCk7XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBjb2xsZWN0aW9uUGF0aC5wb3BMYXN0KCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUGFyZW50cyA9IHRoaXMuaW5kZXhbY29sbGVjdGlvbklkXSB8fFxuICAgICAgICAgICAgbmV3IFNvcnRlZFNldChSZXNvdXJjZVBhdGguY29tcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IGFkZGVkID0gIWV4aXN0aW5nUGFyZW50cy5oYXMocGFyZW50UGF0aCk7XG4gICAgICAgIHRoaXMuaW5kZXhbY29sbGVjdGlvbklkXSA9IGV4aXN0aW5nUGFyZW50cy5hZGQocGFyZW50UGF0aCk7XG4gICAgICAgIHJldHVybiBhZGRlZDtcbiAgICB9XG4gICAgaGFzKGNvbGxlY3Rpb25QYXRoKSB7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IGNvbGxlY3Rpb25QYXRoLmxhc3RTZWdtZW50KCk7XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBjb2xsZWN0aW9uUGF0aC5wb3BMYXN0KCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUGFyZW50cyA9IHRoaXMuaW5kZXhbY29sbGVjdGlvbklkXTtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUGFyZW50cyAmJiBleGlzdGluZ1BhcmVudHMuaGFzKHBhcmVudFBhdGgpO1xuICAgIH1cbiAgICBnZXRFbnRyaWVzKGNvbGxlY3Rpb25JZCkge1xuICAgICAgICBjb25zdCBwYXJlbnRQYXRocyA9IHRoaXMuaW5kZXhbY29sbGVjdGlvbklkXSB8fFxuICAgICAgICAgICAgbmV3IFNvcnRlZFNldChSZXNvdXJjZVBhdGguY29tcGFyYXRvcik7XG4gICAgICAgIHJldHVybiBwYXJlbnRQYXRocy50b0FycmF5KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyRmID0gJ0luZGV4ZWREYkluZGV4TWFuYWdlcic7XG5jb25zdCBFTVBUWV9WQUxVRSA9IG5ldyBVaW50OEFycmF5KDApO1xuLyoqXG4gKiBBIHBlcnNpc3RlZCBpbXBsZW1lbnRhdGlvbiBvZiBJbmRleE1hbmFnZXIuXG4gKlxuICogUE9SVElORyBOT1RFOiBVbmxpa2UgaU9TIGFuZCBBbmRyb2lkLCB0aGUgV2ViIFNESyBkb2VzIG5vdCBtZW1vaXplIGluZGV4XG4gKiBkYXRhIGFzIGl0IHN1cHBvcnRzIG11bHRpLXRhYiBhY2Nlc3MuXG4gKi9cbmNsYXNzIEluZGV4ZWREYkluZGV4TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IodXNlciwgZGF0YWJhc2VJZCkge1xuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBkYXRhYmFzZUlkO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW4tbWVtb3J5IGNvcHkgb2YgdGhlIGluZGV4IGVudHJpZXMgd2UndmUgYWxyZWFkeSB3cml0dGVuIHNpbmNlIHRoZSBTREtcbiAgICAgICAgICogbGF1bmNoZWQuIFVzZWQgdG8gYXZvaWQgcmUtd3JpdGluZyB0aGUgc2FtZSBlbnRyeSByZXBlYXRlZGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzICpOT1QqIGEgY29tcGxldGUgY2FjaGUgb2Ygd2hhdCdzIGluIHBlcnNpc3RlbmNlIGFuZCBzbyBjYW4gbmV2ZXIgYmVcbiAgICAgICAgICogdXNlZCB0byBzYXRpc2Z5IHJlYWRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uUGFyZW50c0NhY2hlID0gbmV3IE1lbW9yeUNvbGxlY3Rpb25QYXJlbnRJbmRleCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwcyBmcm9tIGEgdGFyZ2V0IHRvIGl0cyBlcXVpdmFsZW50IGxpc3Qgb2Ygc3ViLXRhcmdldHMuIEVhY2ggc3ViLXRhcmdldFxuICAgICAgICAgKiBjb250YWlucyBvbmx5IG9uZSB0ZXJtIGZyb20gdGhlIHRhcmdldCdzIGRpc2p1bmN0aXZlIG5vcm1hbCBmb3JtIChETkYpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YXJnZXRUb0RuZlN1YlRhcmdldHMgPSBuZXcgT2JqZWN0TWFwKHQgPT4gY2Fub25pZnlUYXJnZXQodCksIChsLCByKSA9PiB0YXJnZXRFcXVhbHMobCwgcikpO1xuICAgICAgICB0aGlzLnVpZCA9IHVzZXIudWlkIHx8ICcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGVudHJ5IHRvIHRoZSBjb2xsZWN0aW9uIHBhcmVudCBpbmRleC5cbiAgICAgKlxuICAgICAqIFJlcGVhdGVkIGNhbGxzIGZvciB0aGUgc2FtZSBjb2xsZWN0aW9uUGF0aCBzaG91bGQgYmUgYXZvaWRlZCB3aXRoaW4gYVxuICAgICAqIHRyYW5zYWN0aW9uIGFzIEluZGV4ZWREYkluZGV4TWFuYWdlciBvbmx5IGNhY2hlcyB3cml0ZXMgb25jZSBhIHRyYW5zYWN0aW9uXG4gICAgICogaGFzIGJlZW4gY29tbWl0dGVkLlxuICAgICAqL1xuICAgIGFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uUGF0aCkge1xuICAgICAgICBpZiAoIXRoaXMuY29sbGVjdGlvblBhcmVudHNDYWNoZS5oYXMoY29sbGVjdGlvblBhdGgpKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBjb2xsZWN0aW9uUGF0aC5sYXN0U2VnbWVudCgpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IGNvbGxlY3Rpb25QYXRoLnBvcExhc3QoKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZE9uQ29tbWl0dGVkTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29sbGVjdGlvbiB0byB0aGUgaW4gbWVtb3J5IGNhY2hlIG9ubHkgaWYgdGhlIHRyYW5zYWN0aW9uIHdhc1xuICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWxseSBjb21taXR0ZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uUGFyZW50c0NhY2hlLmFkZChjb2xsZWN0aW9uUGF0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25QYXJlbnQgPSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbklkLFxuICAgICAgICAgICAgICAgIHBhcmVudDogZW5jb2RlUmVzb3VyY2VQYXRoKHBhcmVudFBhdGgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25QYXJlbnRzU3RvcmUodHJhbnNhY3Rpb24pLnB1dChjb2xsZWN0aW9uUGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0Q29sbGVjdGlvblBhcmVudHModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25JZCkge1xuICAgICAgICBjb25zdCBwYXJlbnRQYXRocyA9IFtdO1xuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFtjb2xsZWN0aW9uSWQsICcnXSwgW2ltbWVkaWF0ZVN1Y2Nlc3Nvcihjb2xsZWN0aW9uSWQpLCAnJ10sIFxuICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXG4gICAgICAgIC8qdXBwZXJPcGVuPSovIHRydWUpO1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvblBhcmVudHNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5sb2FkQWxsKHJhbmdlKVxuICAgICAgICAgICAgLm5leHQoZW50cmllcyA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvbGxlY3Rpb25JZCBndWFyZCBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5IChhbmQgaXNuJ3QgYXMgbG9uZ1xuICAgICAgICAgICAgICAgIC8vIGFzIHdlJ3JlIHJ1bm5pbmcgaW4gYSByZWFsIGJyb3dzZXIpLCBidXQgdGhlcmUncyBhIGJ1ZyBpblxuICAgICAgICAgICAgICAgIC8vIGluZGV4ZWRkYnNoaW0gdGhhdCBicmVha3Mgb3VyIHJhbmdlIGluIG91ciB0ZXN0cyBydW5uaW5nIGluIG5vZGU6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F4ZW1jbGlvbi9JbmRleGVkREJTaGltL2lzc3Vlcy8zMzRcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuY29sbGVjdGlvbklkICE9PSBjb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudFBhdGhzLnB1c2goZGVjb2RlUmVzb3VyY2VQYXRoKGVudHJ5LnBhcmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFBhdGhzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgLy8gVE9ETyhpbmRleGluZyk6IFZlcmlmeSB0aGF0IHRoZSBhdXRvLWluY3JlbWVudGluZyBpbmRleCBJRCB3b3JrcyBpblxuICAgICAgICAvLyBTYWZhcmkgJiBGaXJlZm94LlxuICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhDb25maWd1cmF0aW9uU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBkYkluZGV4ID0gdG9EYkluZGV4Q29uZmlndXJhdGlvbihpbmRleCk7XG4gICAgICAgIGRlbGV0ZSBkYkluZGV4LmluZGV4SWQ7IC8vIGBpbmRleElkYCBpcyBhdXRvLXBvcHVsYXRlZCBieSBJbmRleGVkRGJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW5kZXhlcy5hZGQoZGJJbmRleCk7XG4gICAgICAgIGlmIChpbmRleC5pbmRleFN0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZXMgPSBpbmRleFN0YXRlU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5uZXh0KGluZGV4SWQgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRlcy5wdXQodG9EYkluZGV4U3RhdGUoaW5kZXhJZCwgdGhpcy51aWQsIGluZGV4LmluZGV4U3RhdGUuc2VxdWVuY2VOdW1iZXIsIGluZGV4LmluZGV4U3RhdGUub2Zmc2V0KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZUZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBpbmRleENvbmZpZ3VyYXRpb25TdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGluZGV4U3RhdGVTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBpbmRleEVudHJpZXNTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIHJldHVybiBpbmRleGVzXG4gICAgICAgICAgICAuZGVsZXRlKGluZGV4LmluZGV4SWQpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBzdGF0ZXMuZGVsZXRlKElEQktleVJhbmdlLmJvdW5kKFtpbmRleC5pbmRleElkXSwgW2luZGV4LmluZGV4SWQgKyAxXSwgXG4gICAgICAgIC8qbG93ZXJPcGVuPSovIGZhbHNlLCBcbiAgICAgICAgLyp1cHBlck9wZW49Ki8gdHJ1ZSkpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZW50cmllcy5kZWxldGUoSURCS2V5UmFuZ2UuYm91bmQoW2luZGV4LmluZGV4SWRdLCBbaW5kZXguaW5kZXhJZCArIDFdLCBcbiAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKSkpO1xuICAgIH1cbiAgICBkZWxldGVBbGxGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IGluZGV4Q29uZmlndXJhdGlvblN0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IGluZGV4RW50cmllc1N0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gaW5kZXhTdGF0ZVN0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ZXNcbiAgICAgICAgICAgIC5kZWxldGVBbGwoKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZW50cmllcy5kZWxldGVBbGwoKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHN0YXRlcy5kZWxldGVBbGwoKSk7XG4gICAgfVxuICAgIGNyZWF0ZVRhcmdldEluZGV4ZXModHJhbnNhY3Rpb24sIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godGhpcy5nZXRTdWJUYXJnZXRzKHRhcmdldCksIChzdWJUYXJnZXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEluZGV4VHlwZSh0cmFuc2FjdGlvbiwgc3ViVGFyZ2V0KS5uZXh0KHR5cGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAwIC8qIEluZGV4VHlwZS5OT05FICovIHx8IHR5cGUgPT09IDEgLyogSW5kZXhUeXBlLlBBUlRJQUwgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0SW5kZXhNYXRjaGVyID0gbmV3IFRhcmdldEluZGV4TWF0Y2hlcihzdWJUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZEluZGV4ID0gdGFyZ2V0SW5kZXhNYXRjaGVyLmJ1aWxkVGFyZ2V0SW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldERvY3VtZW50c01hdGNoaW5nVGFyZ2V0KHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgaW5kZXhFbnRyaWVzID0gaW5kZXhFbnRyaWVzU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICBsZXQgY2FuU2VydmVUYXJnZXQgPSB0cnVlO1xuICAgICAgICBjb25zdCBpbmRleGVzID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godGhpcy5nZXRTdWJUYXJnZXRzKHRhcmdldCksIChzdWJUYXJnZXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIHN1YlRhcmdldCkubmV4dChpbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgY2FuU2VydmVUYXJnZXQgJiYgKGNhblNlcnZlVGFyZ2V0ID0gISFpbmRleCk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5zZXQoc3ViVGFyZ2V0LCBpbmRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNhblNlcnZlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4aXN0aW5nS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGluZGV4ZXMsIChpbmRleCwgc3ViVGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckZiwgYFVzaW5nIGluZGV4ICR7ZmllbGRJbmRleFRvU3RyaW5nKGluZGV4KX0gdG8gZXhlY3V0ZSAke2Nhbm9uaWZ5VGFyZ2V0KHRhcmdldCl9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5VmFsdWVzID0gdGFyZ2V0R2V0QXJyYXlWYWx1ZXMoc3ViVGFyZ2V0LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdEluVmFsdWVzID0gdGFyZ2V0R2V0Tm90SW5WYWx1ZXMoc3ViVGFyZ2V0LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvd2VyQm91bmQgPSB0YXJnZXRHZXRMb3dlckJvdW5kKHN1YlRhcmdldCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gdGFyZ2V0R2V0VXBwZXJCb3VuZChzdWJUYXJnZXQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG93ZXJCb3VuZEVuY29kZWQgPSB0aGlzLmVuY29kZUJvdW5kKGluZGV4LCBzdWJUYXJnZXQsIGxvd2VyQm91bmQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kRW5jb2RlZCA9IHRoaXMuZW5jb2RlQm91bmQoaW5kZXgsIHN1YlRhcmdldCwgdXBwZXJCb3VuZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdEluRW5jb2RlZCA9IHRoaXMuZW5jb2RlVmFsdWVzKGluZGV4LCBzdWJUYXJnZXQsIG5vdEluVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXhSYW5nZXMgPSB0aGlzLmdlbmVyYXRlSW5kZXhSYW5nZXMoaW5kZXguaW5kZXhJZCwgYXJyYXlWYWx1ZXMsIGxvd2VyQm91bmRFbmNvZGVkLCBsb3dlckJvdW5kLmluY2x1c2l2ZSwgdXBwZXJCb3VuZEVuY29kZWQsIHVwcGVyQm91bmQuaW5jbHVzaXZlLCBub3RJbkVuY29kZWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goaW5kZXhSYW5nZXMsIChpbmRleFJhbmdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhFbnRyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmxvYWRGaXJzdChpbmRleFJhbmdlLCB0YXJnZXQubGltaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5leHQoZW50cmllcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRLZXkgPSBEb2N1bWVudEtleS5mcm9tU2VnbWVudHMoZW50cnkuZG9jdW1lbnRLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nS2V5cy5oYXMoZG9jdW1lbnRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0tleXMgPSBleGlzdGluZ0tleXMuYWRkKGRvY3VtZW50S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRvY3VtZW50S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFN1YlRhcmdldHModGFyZ2V0KSB7XG4gICAgICAgIGxldCBzdWJUYXJnZXRzID0gdGhpcy50YXJnZXRUb0RuZlN1YlRhcmdldHMuZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmIChzdWJUYXJnZXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ViVGFyZ2V0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0LmZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdWJUYXJnZXRzID0gW3RhcmdldF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBhbiBpbXBsaWNpdCBBTkQgb3BlcmF0aW9uIGJldHdlZW4gYWxsIHRoZSBmaWx0ZXJzIHN0b3JlZCBpbiB0aGUgdGFyZ2V0XG4gICAgICAgICAgICBjb25zdCBkbmYgPSBnZXREbmZUZXJtcyhDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKHRhcmdldC5maWx0ZXJzLCBcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLykpO1xuICAgICAgICAgICAgc3ViVGFyZ2V0cyA9IGRuZi5tYXAodGVybSA9PiBuZXdUYXJnZXQodGFyZ2V0LnBhdGgsIHRhcmdldC5jb2xsZWN0aW9uR3JvdXAsIHRhcmdldC5vcmRlckJ5LCB0ZXJtLmdldEZpbHRlcnMoKSwgdGFyZ2V0LmxpbWl0LCB0YXJnZXQuc3RhcnRBdCwgdGFyZ2V0LmVuZEF0KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YXJnZXRUb0RuZlN1YlRhcmdldHMuc2V0KHRhcmdldCwgc3ViVGFyZ2V0cyk7XG4gICAgICAgIHJldHVybiBzdWJUYXJnZXRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEga2V5IHJhbmdlIHF1ZXJ5IG9uIGBEYkluZGV4RW50cnlTdG9yZWAgdGhhdCB1bmlvbnMgYWxsXG4gICAgICogYm91bmRzLlxuICAgICAqL1xuICAgIGdlbmVyYXRlSW5kZXhSYW5nZXMoaW5kZXhJZCwgYXJyYXlWYWx1ZXMsIGxvd2VyQm91bmRzLCBsb3dlckJvdW5kSW5jbHVzaXZlLCB1cHBlckJvdW5kcywgdXBwZXJCb3VuZEluY2x1c2l2ZSwgbm90SW5WYWx1ZXMpIHtcbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiB0b3RhbCBpbmRleCBzY2FucyB3ZSB1bmlvbiB0b2dldGhlci4gVGhpcyBpcyBzaW1pbGFyIHRvIGFcbiAgICAgICAgLy8gZGlzdHJpYnV0ZWQgbm9ybWFsIGZvcm0sIGJ1dCBhZGFwdGVkIGZvciBhcnJheSB2YWx1ZXMuIFdlIGNyZWF0ZSBhIHNpbmdsZVxuICAgICAgICAvLyBpbmRleCByYW5nZSBwZXIgdmFsdWUgaW4gYW4gQVJSQVlfQ09OVEFJTlMgb3IgQVJSQVlfQ09OVEFJTlNfQU5ZIGZpbHRlclxuICAgICAgICAvLyBjb21iaW5lZCB3aXRoIHRoZSB2YWx1ZXMgZnJvbSB0aGUgcXVlcnkgYm91bmRzLlxuICAgICAgICBjb25zdCB0b3RhbFNjYW5zID0gKGFycmF5VmFsdWVzICE9IG51bGwgPyBhcnJheVZhbHVlcy5sZW5ndGggOiAxKSAqXG4gICAgICAgICAgICBNYXRoLm1heChsb3dlckJvdW5kcy5sZW5ndGgsIHVwcGVyQm91bmRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHNjYW5zUGVyQXJyYXlFbGVtZW50ID0gdG90YWxTY2FucyAvIChhcnJheVZhbHVlcyAhPSBudWxsID8gYXJyYXlWYWx1ZXMubGVuZ3RoIDogMSk7XG4gICAgICAgIGNvbnN0IGluZGV4UmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxTY2FuczsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheVZhbHVlID0gYXJyYXlWYWx1ZXNcbiAgICAgICAgICAgICAgICA/IHRoaXMuZW5jb2RlU2luZ2xlRWxlbWVudChhcnJheVZhbHVlc1tpIC8gc2NhbnNQZXJBcnJheUVsZW1lbnRdKVxuICAgICAgICAgICAgICAgIDogRU1QVFlfVkFMVUU7XG4gICAgICAgICAgICBjb25zdCBsb3dlckJvdW5kID0gdGhpcy5nZW5lcmF0ZUxvd2VyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgbG93ZXJCb3VuZHNbaSAlIHNjYW5zUGVyQXJyYXlFbGVtZW50XSwgbG93ZXJCb3VuZEluY2x1c2l2ZSk7XG4gICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gdGhpcy5nZW5lcmF0ZVVwcGVyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgdXBwZXJCb3VuZHNbaSAlIHNjYW5zUGVyQXJyYXlFbGVtZW50XSwgdXBwZXJCb3VuZEluY2x1c2l2ZSk7XG4gICAgICAgICAgICBjb25zdCBub3RJbkJvdW5kID0gbm90SW5WYWx1ZXMubWFwKG5vdEluID0+IHRoaXMuZ2VuZXJhdGVMb3dlckJvdW5kKGluZGV4SWQsIGFycmF5VmFsdWUsIG5vdEluLCBcbiAgICAgICAgICAgIC8qIGluY2x1c2l2ZT0gKi8gdHJ1ZSkpO1xuICAgICAgICAgICAgaW5kZXhSYW5nZXMucHVzaCguLi50aGlzLmNyZWF0ZVJhbmdlKGxvd2VyQm91bmQsIHVwcGVyQm91bmQsIG5vdEluQm91bmQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXhSYW5nZXM7XG4gICAgfVxuICAgIC8qKiBHZW5lcmF0ZXMgdGhlIGxvd2VyIGJvdW5kIGZvciBgYXJyYXlWYWx1ZWAgYW5kIGBkaXJlY3Rpb25hbFZhbHVlYC4gKi9cbiAgICBnZW5lcmF0ZUxvd2VyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgZGlyZWN0aW9uYWxWYWx1ZSwgaW5jbHVzaXZlKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gbmV3IEluZGV4RW50cnkoaW5kZXhJZCwgRG9jdW1lbnRLZXkuZW1wdHkoKSwgYXJyYXlWYWx1ZSwgZGlyZWN0aW9uYWxWYWx1ZSk7XG4gICAgICAgIHJldHVybiBpbmNsdXNpdmUgPyBlbnRyeSA6IGVudHJ5LnN1Y2Nlc3NvcigpO1xuICAgIH1cbiAgICAvKiogR2VuZXJhdGVzIHRoZSB1cHBlciBib3VuZCBmb3IgYGFycmF5VmFsdWVgIGFuZCBgZGlyZWN0aW9uYWxWYWx1ZWAuICovXG4gICAgZ2VuZXJhdGVVcHBlckJvdW5kKGluZGV4SWQsIGFycmF5VmFsdWUsIGRpcmVjdGlvbmFsVmFsdWUsIGluY2x1c2l2ZSkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IG5ldyBJbmRleEVudHJ5KGluZGV4SWQsIERvY3VtZW50S2V5LmVtcHR5KCksIGFycmF5VmFsdWUsIGRpcmVjdGlvbmFsVmFsdWUpO1xuICAgICAgICByZXR1cm4gaW5jbHVzaXZlID8gZW50cnkuc3VjY2Vzc29yKCkgOiBlbnRyeTtcbiAgICB9XG4gICAgZ2V0RmllbGRJbmRleCh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEluZGV4TWF0Y2hlciA9IG5ldyBUYXJnZXRJbmRleE1hdGNoZXIodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbkdyb3VwID0gdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCAhPSBudWxsXG4gICAgICAgICAgICA/IHRhcmdldC5jb2xsZWN0aW9uR3JvdXBcbiAgICAgICAgICAgIDogdGFyZ2V0LnBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApLm5leHQoaW5kZXhlcyA9PiB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGluZGV4IHdpdGggdGhlIG1vc3QgbnVtYmVyIG9mIHNlZ21lbnRzLlxuICAgICAgICAgICAgbGV0IGluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdGFyZ2V0SW5kZXhNYXRjaGVyLnNlcnZlZEJ5SW5kZXgoY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyAmJlxuICAgICAgICAgICAgICAgICAgICAoIWluZGV4IHx8IGNhbmRpZGF0ZS5maWVsZHMubGVuZ3RoID4gaW5kZXguZmllbGRzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SW5kZXhUeXBlKHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IGluZGV4VHlwZSA9IDIgLyogSW5kZXhUeXBlLkZVTEwgKi87XG4gICAgICAgIGNvbnN0IHN1YlRhcmdldHMgPSB0aGlzLmdldFN1YlRhcmdldHModGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHN1YlRhcmdldHMsICh0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIHRhcmdldCkubmV4dChpbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleFR5cGUgPSAwIC8qIEluZGV4VHlwZS5OT05FICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmRleFR5cGUgIT09IDAgLyogSW5kZXhUeXBlLk5PTkUgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgaW5kZXguZmllbGRzLmxlbmd0aCA8IHRhcmdldEdldFNlZ21lbnRDb3VudCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4VHlwZSA9IDEgLyogSW5kZXhUeXBlLlBBUlRJQUwgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gT1IgcXVlcmllcyBoYXZlIG1vcmUgdGhhbiBvbmUgc3ViLXRhcmdldCAob25lIHN1Yi10YXJnZXQgcGVyIERORiB0ZXJtKS4gV2UgY3VycmVudGx5IGNvbnNpZGVyXG4gICAgICAgICAgICAvLyBPUiBxdWVyaWVzIHRoYXQgaGF2ZSBhIGBsaW1pdGAgdG8gaGF2ZSBhIHBhcnRpYWwgaW5kZXguIEZvciBzdWNoIHF1ZXJpZXMgd2UgcGVyZm9ybSBzb3J0aW5nXG4gICAgICAgICAgICAvLyBhbmQgYXBwbHkgdGhlIGxpbWl0IGluIG1lbW9yeSBhcyBhIHBvc3QtcHJvY2Vzc2luZyBzdGVwLlxuICAgICAgICAgICAgaWYgKHRhcmdldEhhc0xpbWl0KHRhcmdldCkgJiZcbiAgICAgICAgICAgICAgICBzdWJUYXJnZXRzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICBpbmRleFR5cGUgPT09IDIgLyogSW5kZXhUeXBlLkZVTEwgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBJbmRleFR5cGUuUEFSVElBTCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbmRleFR5cGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBieXRlIGVuY29kZWQgZm9ybSBvZiB0aGUgZGlyZWN0aW9uYWwgdmFsdWVzIGluIHRoZSBmaWVsZCBpbmRleC5cbiAgICAgKiBSZXR1cm5zIGBudWxsYCBpZiB0aGUgZG9jdW1lbnQgZG9lcyBub3QgaGF2ZSBhbGwgZmllbGRzIHNwZWNpZmllZCBpbiB0aGVcbiAgICAgKiBpbmRleC5cbiAgICAgKi9cbiAgICBlbmNvZGVEaXJlY3Rpb25hbEVsZW1lbnRzKGZpZWxkSW5kZXgsIGRvY3VtZW50KSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgSW5kZXhCeXRlRW5jb2RlcigpO1xuICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoZmllbGRJbmRleCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZG9jdW1lbnQuZGF0YS5maWVsZChzZWdtZW50LmZpZWxkUGF0aCk7XG4gICAgICAgICAgICBpZiAoZmllbGQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uYWxFbmNvZGVyID0gZW5jb2Rlci5mb3JLaW5kKHNlZ21lbnQua2luZCk7XG4gICAgICAgICAgICBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyLklOU1RBTkNFLndyaXRlSW5kZXhWYWx1ZShmaWVsZCwgZGlyZWN0aW9uYWxFbmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGVkQnl0ZXMoKTtcbiAgICB9XG4gICAgLyoqIEVuY29kZXMgYSBzaW5nbGUgdmFsdWUgdG8gdGhlIGFzY2VuZGluZyBpbmRleCBmb3JtYXQuICovXG4gICAgZW5jb2RlU2luZ2xlRWxlbWVudCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IEluZGV4Qnl0ZUVuY29kZXIoKTtcbiAgICAgICAgRmlyZXN0b3JlSW5kZXhWYWx1ZVdyaXRlci5JTlNUQU5DRS53cml0ZUluZGV4VmFsdWUodmFsdWUsIGVuY29kZXIuZm9yS2luZCgwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi8pKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZXIuZW5jb2RlZEJ5dGVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gZW5jb2RlZCBmb3JtIG9mIHRoZSBkb2N1bWVudCBrZXkgdGhhdCBzb3J0cyBiYXNlZCBvbiB0aGUga2V5XG4gICAgICogb3JkZXJpbmcgb2YgdGhlIGZpZWxkIGluZGV4LlxuICAgICAqL1xuICAgIGVuY29kZURpcmVjdGlvbmFsS2V5KGZpZWxkSW5kZXgsIGRvY3VtZW50S2V5KSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgSW5kZXhCeXRlRW5jb2RlcigpO1xuICAgICAgICBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyLklOU1RBTkNFLndyaXRlSW5kZXhWYWx1ZShyZWZWYWx1ZSh0aGlzLmRhdGFiYXNlSWQsIGRvY3VtZW50S2V5KSwgZW5jb2Rlci5mb3JLaW5kKGZpZWxkSW5kZXhHZXRLZXlPcmRlcihmaWVsZEluZGV4KSkpO1xuICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGVkQnl0ZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gZmllbGQgdmFsdWVzIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBpbiBgdGFyZ2V0YC5cbiAgICAgKiBGb3IgSU4gcXVlcmllcywgYSBsaXN0IG9mIHBvc3NpYmxlIHZhbHVlcyBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBlbmNvZGVWYWx1ZXMoZmllbGRJbmRleCwgdGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbmNvZGVycyA9IFtdO1xuICAgICAgICBlbmNvZGVycy5wdXNoKG5ldyBJbmRleEJ5dGVFbmNvZGVyKCkpO1xuICAgICAgICBsZXQgdmFsdWVJZHggPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoZmllbGRJbmRleCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3ZhbHVlSWR4KytdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGVyIG9mIGVuY29kZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbkZpbHRlcih0YXJnZXQsIHNlZ21lbnQuZmllbGRQYXRoKSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVycyA9IHRoaXMuZXhwYW5kSW5kZXhWYWx1ZXMoZW5jb2RlcnMsIHNlZ21lbnQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbmFsRW5jb2RlciA9IGVuY29kZXIuZm9yS2luZChzZWdtZW50LmtpbmQpO1xuICAgICAgICAgICAgICAgICAgICBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyLklOU1RBTkNFLndyaXRlSW5kZXhWYWx1ZSh2YWx1ZSwgZGlyZWN0aW9uYWxFbmNvZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5jb2RlZEJ5dGVzKGVuY29kZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gYm91bmRzIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBpbiBgdGFyZ2V0YC4gRm9yIElOXG4gICAgICogcXVlcmllcywgYSBsaXN0IG9mIHBvc3NpYmxlIHZhbHVlcyBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBlbmNvZGVCb3VuZChmaWVsZEluZGV4LCB0YXJnZXQsIGJvdW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZVZhbHVlcyhmaWVsZEluZGV4LCB0YXJnZXQsIGJvdW5kLnBvc2l0aW9uKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIGJ5dGUgcmVwcmVzZW50YXRpb24gZm9yIHRoZSBwcm92aWRlZCBlbmNvZGVycy4gKi9cbiAgICBnZXRFbmNvZGVkQnl0ZXMoZW5jb2RlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IGVuY29kZXJzW2ldLmVuY29kZWRCeXRlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzZXBhcmF0ZSBlbmNvZGVyIGZvciBlYWNoIGVsZW1lbnQgb2YgYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBUaGUgbWV0aG9kIGFwcGVuZHMgZWFjaCB2YWx1ZSB0byBhbGwgZXhpc3RpbmcgZW5jb2RlcnMgKGUuZy4gZmlsdGVyKFwiYVwiLFxuICAgICAqIFwiPT1cIiwgXCJhMVwiKS5maWx0ZXIoXCJiXCIsIFwiaW5cIiwgW1wiYjFcIiwgXCJiMlwiXSkgYmVjb21lcyBbXCJhMSxiMVwiLCBcImExLGIyXCJdKS4gQVxuICAgICAqIGxpc3Qgb2YgbmV3IGVuY29kZXJzIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGV4cGFuZEluZGV4VmFsdWVzKGVuY29kZXJzLCBzZWdtZW50LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBwcmVmaXhlcyA9IFsuLi5lbmNvZGVyc107XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBhcnJheUVsZW1lbnQgb2YgdmFsdWUuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkRW5jb2RlciA9IG5ldyBJbmRleEJ5dGVFbmNvZGVyKCk7XG4gICAgICAgICAgICAgICAgY2xvbmVkRW5jb2Rlci5zZWVkKHByZWZpeC5lbmNvZGVkQnl0ZXMoKSk7XG4gICAgICAgICAgICAgICAgRmlyZXN0b3JlSW5kZXhWYWx1ZVdyaXRlci5JTlNUQU5DRS53cml0ZUluZGV4VmFsdWUoYXJyYXlFbGVtZW50LCBjbG9uZWRFbmNvZGVyLmZvcktpbmQoc2VnbWVudC5raW5kKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNsb25lZEVuY29kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBpc0luRmlsdGVyKHRhcmdldCwgZmllbGRQYXRoKSB7XG4gICAgICAgIHJldHVybiAhIXRhcmdldC5maWx0ZXJzLmZpbmQoZiA9PiBmIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgJiZcbiAgICAgICAgICAgIGYuZmllbGQuaXNFcXVhbChmaWVsZFBhdGgpICYmXG4gICAgICAgICAgICAoZi5vcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovIHx8IGYub3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovKSk7XG4gICAgfVxuICAgIGdldEZpZWxkSW5kZXhlcyh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBpbmRleENvbmZpZ3VyYXRpb25TdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGluZGV4U3RhdGVTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIHJldHVybiAoY29sbGVjdGlvbkdyb3VwXG4gICAgICAgICAgICA/IGluZGV4ZXMubG9hZEFsbChEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4LCBJREJLZXlSYW5nZS5ib3VuZChjb2xsZWN0aW9uR3JvdXAsIGNvbGxlY3Rpb25Hcm91cCkpXG4gICAgICAgICAgICA6IGluZGV4ZXMubG9hZEFsbCgpKS5uZXh0KGluZGV4Q29uZmlncyA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChpbmRleENvbmZpZ3MsIChpbmRleENvbmZpZykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgLmdldChbaW5kZXhDb25maWcuaW5kZXhJZCwgdGhpcy51aWRdKVxuICAgICAgICAgICAgICAgICAgICAubmV4dChpbmRleFN0YXRlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbURiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4Q29uZmlnLCBpbmRleFN0YXRlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KS5uZXh0KCgpID0+IHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXROZXh0Q29sbGVjdGlvbkdyb3VwVG9VcGRhdGUodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uKS5uZXh0KGluZGV4ZXMgPT4ge1xuICAgICAgICAgICAgaWYgKGluZGV4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleGVzLnNvcnQoKGwsIHIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbXAgPSBsLmluZGV4U3RhdGUuc2VxdWVuY2VOdW1iZXIgLSByLmluZGV4U3RhdGUuc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNtcCAhPT0gMFxuICAgICAgICAgICAgICAgICAgICA/IGNtcFxuICAgICAgICAgICAgICAgICAgICA6IHByaW1pdGl2ZUNvbXBhcmF0b3IobC5jb2xsZWN0aW9uR3JvdXAsIHIuY29sbGVjdGlvbkdyb3VwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4ZXNbMF0uY29sbGVjdGlvbkdyb3VwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhDb25maWd1cmF0aW9uU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBpbmRleFN0YXRlU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROZXh0U2VxdWVuY2VOdW1iZXIodHJhbnNhY3Rpb24pLm5leHQobmV4dFNlcXVlbmNlTnVtYmVyID0+IGluZGV4ZXNcbiAgICAgICAgICAgIC5sb2FkQWxsKERiSW5kZXhDb25maWd1cmF0aW9uQ29sbGVjdGlvbkdyb3VwSW5kZXgsIElEQktleVJhbmdlLmJvdW5kKGNvbGxlY3Rpb25Hcm91cCwgY29sbGVjdGlvbkdyb3VwKSlcbiAgICAgICAgICAgIC5uZXh0KGNvbmZpZ3MgPT4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goY29uZmlncywgKGNvbmZpZykgPT4gc3RhdGVzLnB1dCh0b0RiSW5kZXhTdGF0ZShjb25maWcuaW5kZXhJZCwgdGhpcy51aWQsIG5leHRTZXF1ZW5jZU51bWJlciwgb2Zmc2V0KSkpKSk7XG4gICAgfVxuICAgIHVwZGF0ZUluZGV4RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRzKSB7XG4gICAgICAgIC8vIFBvcnRpbmcgTm90ZTogYGdldEZpZWxkSW5kZXhlcygpYCBvbiBXZWIgZG9lcyBub3QgY2FjaGUgaW5kZXggbG9va3VwcyBhc1xuICAgICAgICAvLyBpdCBjb3VsZCBiZSB1c2VkIGFjcm9zcyBkaWZmZXJlbnQgSW5kZXhlZERCIHRyYW5zYWN0aW9ucy4gQXMgYW55IGNhY2hlZFxuICAgICAgICAvLyBkYXRhIG1pZ2h0IGJlIGludmFsaWRhdGVkIGJ5IG90aGVyIG11bHRpLXRhYiBjbGllbnRzLCB3ZSBjYW4gb25seSB0cnVzdFxuICAgICAgICAvLyBkYXRhIHdpdGhpbiBhIHNpbmdsZSBJbmRleGVkREIgdHJhbnNhY3Rpb24uIFdlIHRoZXJlZm9yZSBhZGQgYSBjYWNoZVxuICAgICAgICAvLyBoZXJlLlxuICAgICAgICBjb25zdCBtZW1vaXplZEluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChkb2N1bWVudHMsIChrZXksIGRvYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVtb2l6ZWRDb2xsZWN0aW9uSW5kZXhlcyA9IG1lbW9pemVkSW5kZXhlcy5nZXQoa2V5LmNvbGxlY3Rpb25Hcm91cCk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZEluZGV4ZXMgPSBtZW1vaXplZENvbGxlY3Rpb25JbmRleGVzXG4gICAgICAgICAgICAgICAgPyBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShtZW1vaXplZENvbGxlY3Rpb25JbmRleGVzKVxuICAgICAgICAgICAgICAgIDogdGhpcy5nZXRGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24sIGtleS5jb2xsZWN0aW9uR3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkSW5kZXhlcy5uZXh0KGZpZWxkSW5kZXhlcyA9PiB7XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRJbmRleGVzLnNldChrZXkuY29sbGVjdGlvbkdyb3VwLCBmaWVsZEluZGV4ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChmaWVsZEluZGV4ZXMsIChmaWVsZEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEV4aXN0aW5nSW5kZXhFbnRyaWVzKHRyYW5zYWN0aW9uLCBrZXksIGZpZWxkSW5kZXgpLm5leHQoZXhpc3RpbmdFbnRyaWVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VudHJpZXMgPSB0aGlzLmNvbXB1dGVJbmRleEVudHJpZXMoZG9jLCBmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmdFbnRyaWVzLmlzRXF1YWwobmV3RW50cmllcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2MsIGZpZWxkSW5kZXgsIGV4aXN0aW5nRW50cmllcywgbmV3RW50cmllcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZEluZGV4RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50LCBmaWVsZEluZGV4LCBpbmRleEVudHJ5KSB7XG4gICAgICAgIGNvbnN0IGluZGV4RW50cmllcyA9IGluZGV4RW50cmllc1N0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGluZGV4RW50cmllcy5wdXQoaW5kZXhFbnRyeS5kYkluZGV4RW50cnkodGhpcy51aWQsIHRoaXMuZW5jb2RlRGlyZWN0aW9uYWxLZXkoZmllbGRJbmRleCwgZG9jdW1lbnQua2V5KSwgZG9jdW1lbnQua2V5KSk7XG4gICAgfVxuICAgIGRlbGV0ZUluZGV4RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50LCBmaWVsZEluZGV4LCBpbmRleEVudHJ5KSB7XG4gICAgICAgIGNvbnN0IGluZGV4RW50cmllcyA9IGluZGV4RW50cmllc1N0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGluZGV4RW50cmllcy5kZWxldGUoaW5kZXhFbnRyeS5kYkluZGV4RW50cnlLZXkodGhpcy51aWQsIHRoaXMuZW5jb2RlRGlyZWN0aW9uYWxLZXkoZmllbGRJbmRleCwgZG9jdW1lbnQua2V5KSwgZG9jdW1lbnQua2V5KSk7XG4gICAgfVxuICAgIGdldEV4aXN0aW5nSW5kZXhFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSwgZmllbGRJbmRleCkge1xuICAgICAgICBjb25zdCBpbmRleEVudHJpZXMgPSBpbmRleEVudHJpZXNTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGxldCByZXN1bHRzID0gbmV3IFNvcnRlZFNldChpbmRleEVudHJ5Q29tcGFyYXRvcik7XG4gICAgICAgIHJldHVybiBpbmRleEVudHJpZXNcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcbiAgICAgICAgICAgIGluZGV4OiBEYkluZGV4RW50cnlEb2N1bWVudEtleUluZGV4LFxuICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLm9ubHkoW1xuICAgICAgICAgICAgICAgIGZpZWxkSW5kZXguaW5kZXhJZCxcbiAgICAgICAgICAgICAgICB0aGlzLnVpZCxcbiAgICAgICAgICAgICAgICBlbmNvZGVLZXlTYWZlQnl0ZXModGhpcy5lbmNvZGVEaXJlY3Rpb25hbEtleShmaWVsZEluZGV4LCBkb2N1bWVudEtleSkpXG4gICAgICAgICAgICBdKVxuICAgICAgICB9LCAoXywgZW50cnkpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmFkZChuZXcgSW5kZXhFbnRyeShmaWVsZEluZGV4LmluZGV4SWQsIGRvY3VtZW50S2V5LCBkZWNvZGVLZXlTYWZlQnl0ZXMoZW50cnkuYXJyYXlWYWx1ZSksIGRlY29kZUtleVNhZmVCeXRlcyhlbnRyeS5kaXJlY3Rpb25hbFZhbHVlKSkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0cyk7XG4gICAgfVxuICAgIC8qKiBDcmVhdGVzIHRoZSBpbmRleCBlbnRyaWVzIGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQuICovXG4gICAgY29tcHV0ZUluZGV4RW50cmllcyhkb2N1bWVudCwgZmllbGRJbmRleCkge1xuICAgICAgICBsZXQgcmVzdWx0cyA9IG5ldyBTb3J0ZWRTZXQoaW5kZXhFbnRyeUNvbXBhcmF0b3IpO1xuICAgICAgICBjb25zdCBkaXJlY3Rpb25hbFZhbHVlID0gdGhpcy5lbmNvZGVEaXJlY3Rpb25hbEVsZW1lbnRzKGZpZWxkSW5kZXgsIGRvY3VtZW50KTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbmFsVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJyYXlTZWdtZW50ID0gZmllbGRJbmRleEdldEFycmF5U2VnbWVudChmaWVsZEluZGV4KTtcbiAgICAgICAgaWYgKGFycmF5U2VnbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvY3VtZW50LmRhdGEuZmllbGQoYXJyYXlTZWdtZW50LmZpZWxkUGF0aCk7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFycmF5VmFsdWUgb2YgdmFsdWUuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuYWRkKG5ldyBJbmRleEVudHJ5KGZpZWxkSW5kZXguaW5kZXhJZCwgZG9jdW1lbnQua2V5LCB0aGlzLmVuY29kZVNpbmdsZUVsZW1lbnQoYXJyYXlWYWx1ZSksIGRpcmVjdGlvbmFsVmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5hZGQobmV3IEluZGV4RW50cnkoZmllbGRJbmRleC5pbmRleElkLCBkb2N1bWVudC5rZXksIEVNUFRZX1ZBTFVFLCBkaXJlY3Rpb25hbFZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGluZGV4IGVudHJpZXMgZm9yIHRoZSBwcm92aWRlZCBkb2N1bWVudCBieSBkZWxldGluZyBlbnRyaWVzXG4gICAgICogdGhhdCBhcmUgbm8gbG9uZ2VyIHJlZmVyZW5jZWQgaW4gYG5ld0VudHJpZXNgIGFuZCBhZGRpbmcgYWxsIG5ld2x5IGFkZGVkXG4gICAgICogZW50cmllcy5cbiAgICAgKi9cbiAgICB1cGRhdGVFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudCwgZmllbGRJbmRleCwgZXhpc3RpbmdFbnRyaWVzLCBuZXdFbnRyaWVzKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckZiwgXCJVcGRhdGluZyBpbmRleCBlbnRyaWVzIGZvciBkb2N1bWVudCAnJXMnXCIsIGRvY3VtZW50LmtleSk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGRpZmZTb3J0ZWRTZXRzKGV4aXN0aW5nRW50cmllcywgbmV3RW50cmllcywgaW5kZXhFbnRyeUNvbXBhcmF0b3IsIFxuICAgICAgICAvKiBvbkFkZD0gKi8gZW50cnkgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmFkZEluZGV4RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50LCBmaWVsZEluZGV4LCBlbnRyeSkpO1xuICAgICAgICB9LCBcbiAgICAgICAgLyogb25SZW1vdmU9ICovIGVudHJ5ID0+IHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kZWxldGVJbmRleEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudCwgZmllbGRJbmRleCwgZW50cnkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XG4gICAgfVxuICAgIGdldE5leHRTZXF1ZW5jZU51bWJlcih0cmFuc2FjdGlvbikge1xuICAgICAgICBsZXQgbmV4dFNlcXVlbmNlTnVtYmVyID0gMTtcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gaW5kZXhTdGF0ZVN0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlc1xuICAgICAgICAgICAgLml0ZXJhdGUoe1xuICAgICAgICAgICAgaW5kZXg6IERiSW5kZXhTdGF0ZVNlcXVlbmNlTnVtYmVySW5kZXgsXG4gICAgICAgICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLnVwcGVyQm91bmQoW3RoaXMudWlkLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUl0pXG4gICAgICAgIH0sIChfLCBzdGF0ZSwgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5kb25lKCk7XG4gICAgICAgICAgICBuZXh0U2VxdWVuY2VOdW1iZXIgPSBzdGF0ZS5zZXF1ZW5jZU51bWJlciArIDE7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBuZXh0U2VxdWVuY2VOdW1iZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHNldCBvZiBJREIgcmFuZ2VzIHRoYXQgc3BsaXRzIHRoZSBleGlzdGluZyByYW5nZSBhbmQgZXhjbHVkZXNcbiAgICAgKiBhbnkgdmFsdWVzIHRoYXQgbWF0Y2ggdGhlIGBub3RJblZhbHVlYCBmcm9tIHRoZXNlIHJhbmdlcy4gQXMgYW4gZXhhbXBsZSxcbiAgICAgKiAnW2ZvbyA+IDIgJiYgZm9vICE9IDNdYCBiZWNvbWVzICBgW2ZvbyA+IDIgJiYgPCAzLCBmb28gPiAzXWAuXG4gICAgICovXG4gICAgY3JlYXRlUmFuZ2UobG93ZXIsIHVwcGVyLCBub3RJblZhbHVlcykge1xuICAgICAgICAvLyBUaGUgbm90SW4gdmFsdWVzIG5lZWQgdG8gYmUgc29ydGVkIGFuZCB1bmlxdWUgc28gdGhhdCB3ZSBjYW4gcmV0dXJuIGFcbiAgICAgICAgLy8gc29ydGVkIHNldCBvZiBub24tb3ZlcmxhcHBpbmcgcmFuZ2VzLlxuICAgICAgICBub3RJblZhbHVlcyA9IG5vdEluVmFsdWVzXG4gICAgICAgICAgICAuc29ydCgobCwgcikgPT4gaW5kZXhFbnRyeUNvbXBhcmF0b3IobCwgcikpXG4gICAgICAgICAgICAuZmlsdGVyKChlbCwgaSwgdmFsdWVzKSA9PiAhaSB8fCBpbmRleEVudHJ5Q29tcGFyYXRvcihlbCwgdmFsdWVzW2kgLSAxXSkgIT09IDApO1xuICAgICAgICBjb25zdCBib3VuZHMgPSBbXTtcbiAgICAgICAgYm91bmRzLnB1c2gobG93ZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vdEluVmFsdWUgb2Ygbm90SW5WYWx1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNtcFRvTG93ZXIgPSBpbmRleEVudHJ5Q29tcGFyYXRvcihub3RJblZhbHVlLCBsb3dlcik7XG4gICAgICAgICAgICBjb25zdCBjbXBUb1VwcGVyID0gaW5kZXhFbnRyeUNvbXBhcmF0b3Iobm90SW5WYWx1ZSwgdXBwZXIpO1xuICAgICAgICAgICAgaWYgKGNtcFRvTG93ZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBgbm90SW5WYWx1ZWAgaXMgdGhlIGxvd2VyIGJvdW5kLiBXZSB0aGVyZWZvcmUgbmVlZCB0byByYWlzZSB0aGUgYm91bmRcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgbmV4dCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBib3VuZHNbMF0gPSBsb3dlci5zdWNjZXNzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcFRvTG93ZXIgPiAwICYmIGNtcFRvVXBwZXIgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gYG5vdEluVmFsdWVgIGlzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgYm91bmRzLnB1c2gobm90SW5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgYm91bmRzLnB1c2gobm90SW5WYWx1ZS5zdWNjZXNzb3IoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXBUb1VwcGVyID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGBub3RJblZhbHVlYCAoYW5kIGFsbCBmb2xsb3dpbmcgdmFsdWVzKSBhcmUgb3V0IG9mIHRoZSByYW5nZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJvdW5kcy5wdXNoKHVwcGVyKTtcbiAgICAgICAgY29uc3QgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm91bmRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBlbmNvdW50ZXIgdHdvIGJvdW5kcyB0aGF0IHdpbGwgY3JlYXRlIGFuIHVubWF0Y2hhYmxlIGtleSByYW5nZSxcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgcmV0dXJuIGFuIGVtcHR5IHNldCBvZiBrZXkgcmFuZ2VzLlxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSYW5nZU1hdGNoYWJsZShib3VuZHNbaV0sIGJvdW5kc1tpICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG93ZXJCb3VuZCA9IGJvdW5kc1tpXS5kYkluZGV4RW50cnlLZXkodGhpcy51aWQsIEVNUFRZX1ZBTFVFLCBEb2N1bWVudEtleS5lbXB0eSgpKTtcbiAgICAgICAgICAgIGNvbnN0IHVwcGVyQm91bmQgPSBib3VuZHNbaSArIDFdLmRiSW5kZXhFbnRyeUtleSh0aGlzLnVpZCwgRU1QVFlfVkFMVUUsIERvY3VtZW50S2V5LmVtcHR5KCkpO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goSURCS2V5UmFuZ2UuYm91bmQobG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfVxuICAgIGlzUmFuZ2VNYXRjaGFibGUobG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICAgICAgICAvLyBJZiBsb3dlciBib3VuZCBpcyBncmVhdGVyIHRoYW4gdGhlIHVwcGVyIGJvdW5kLCB0aGVuIHRoZSBrZXlcbiAgICAgICAgLy8gcmFuZ2UgY2FuIG5ldmVyIGJlIG1hdGNoZWQuXG4gICAgICAgIHJldHVybiBpbmRleEVudHJ5Q29tcGFyYXRvcihsb3dlckJvdW5kLCB1cHBlckJvdW5kKSA+IDA7XG4gICAgfVxuICAgIGdldE1pbk9mZnNldEZyb21Db2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCkubmV4dChnZXRNaW5PZmZzZXRGcm9tRmllbGRJbmRleGVzKTtcbiAgICB9XG4gICAgZ2V0TWluT2Zmc2V0KHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5tYXBBcnJheSh0aGlzLmdldFN1YlRhcmdldHModGFyZ2V0KSwgKHN1YlRhcmdldCkgPT4gdGhpcy5nZXRGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBzdWJUYXJnZXQpLm5leHQoaW5kZXggPT4gaW5kZXggPyBpbmRleCA6IGZhaWwoMHhhZDhhKSkpLm5leHQoZ2V0TWluT2Zmc2V0RnJvbUZpZWxkSW5kZXhlcyk7XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGNvbGxlY3Rpb25QYXJlbnRzXG4gKiBkb2N1bWVudCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gY29sbGVjdGlvblBhcmVudHNTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkNvbGxlY3Rpb25QYXJlbnRTdG9yZSk7XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgaW5kZXggZW50cnkgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBpbmRleEVudHJpZXNTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkluZGV4RW50cnlTdG9yZSk7XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgaW5kZXggY29uZmlndXJhdGlvbiBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIGluZGV4Q29uZmlndXJhdGlvblN0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiSW5kZXhDb25maWd1cmF0aW9uU3RvcmUpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGluZGV4IHN0YXRlIG9iamVjdCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gaW5kZXhTdGF0ZVN0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiSW5kZXhTdGF0ZVN0b3JlKTtcbn1cbmZ1bmN0aW9uIGdldE1pbk9mZnNldEZyb21GaWVsZEluZGV4ZXMoZmllbGRJbmRleGVzKSB7XG4gICAgaGFyZEFzc2VydChmaWVsZEluZGV4ZXMubGVuZ3RoICE9PSAwLCAweDcwOTkpO1xuICAgIGxldCBtaW5PZmZzZXQgPSBmaWVsZEluZGV4ZXNbMF0uaW5kZXhTdGF0ZS5vZmZzZXQ7XG4gICAgbGV0IG1heEJhdGNoSWQgPSBtaW5PZmZzZXQubGFyZ2VzdEJhdGNoSWQ7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBmaWVsZEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmV3T2Zmc2V0ID0gZmllbGRJbmRleGVzW2ldLmluZGV4U3RhdGUub2Zmc2V0O1xuICAgICAgICBpZiAoaW5kZXhPZmZzZXRDb21wYXJhdG9yKG5ld09mZnNldCwgbWluT2Zmc2V0KSA8IDApIHtcbiAgICAgICAgICAgIG1pbk9mZnNldCA9IG5ld09mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4QmF0Y2hJZCA8IG5ld09mZnNldC5sYXJnZXN0QmF0Y2hJZCkge1xuICAgICAgICAgICAgbWF4QmF0Y2hJZCA9IG5ld09mZnNldC5sYXJnZXN0QmF0Y2hJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEluZGV4T2Zmc2V0KG1pbk9mZnNldC5yZWFkVGltZSwgbWluT2Zmc2V0LmRvY3VtZW50S2V5LCBtYXhCYXRjaElkKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRGVsZXRlIGEgbXV0YXRpb24gYmF0Y2ggYW5kIHRoZSBhc3NvY2lhdGVkIGRvY3VtZW50IG11dGF0aW9ucy5cbiAqIEByZXR1cm5zIEEgUGVyc2lzdGVuY2VQcm9taXNlIG9mIHRoZSBkb2N1bWVudCBtdXRhdGlvbnMgdGhhdCB3ZXJlIHJlbW92ZWQuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZU11dGF0aW9uQmF0Y2godHhuLCB1c2VySWQsIGJhdGNoKSB7XG4gICAgY29uc3QgbXV0YXRpb25TdG9yZSA9IHR4bi5zdG9yZShEYk11dGF0aW9uQmF0Y2hTdG9yZSk7XG4gICAgY29uc3QgaW5kZXhUeG4gPSB0eG4uc3RvcmUoRGJEb2N1bWVudE11dGF0aW9uU3RvcmUpO1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5vbmx5KGJhdGNoLmJhdGNoSWQpO1xuICAgIGxldCBudW1EZWxldGVkID0gMDtcbiAgICBjb25zdCByZW1vdmVQcm9taXNlID0gbXV0YXRpb25TdG9yZS5pdGVyYXRlKHsgcmFuZ2UgfSwgKGtleSwgdmFsdWUsIGNvbnRyb2wpID0+IHtcbiAgICAgICAgbnVtRGVsZXRlZCsrO1xuICAgICAgICByZXR1cm4gY29udHJvbC5kZWxldGUoKTtcbiAgICB9KTtcbiAgICBwcm9taXNlcy5wdXNoKHJlbW92ZVByb21pc2UubmV4dCgoKSA9PiB7XG4gICAgICAgIGhhcmRBc3NlcnQobnVtRGVsZXRlZCA9PT0gMSwgMHhiN2RlLCB7IGJhdGNoSWQ6IGJhdGNoLmJhdGNoSWQgfSk7XG4gICAgfSkpO1xuICAgIGNvbnN0IHJlbW92ZWREb2N1bWVudHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIGJhdGNoLm11dGF0aW9ucykge1xuICAgICAgICBjb25zdCBpbmRleEtleSA9IG5ld0RiRG9jdW1lbnRNdXRhdGlvbktleSh1c2VySWQsIG11dGF0aW9uLmtleS5wYXRoLCBiYXRjaC5iYXRjaElkKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChpbmRleFR4bi5kZWxldGUoaW5kZXhLZXkpKTtcbiAgICAgICAgcmVtb3ZlZERvY3VtZW50cy5wdXNoKG11dGF0aW9uLmtleSk7XG4gICAgfVxuICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykubmV4dCgoKSA9PiByZW1vdmVkRG9jdW1lbnRzKTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBhcHByb3hpbWF0ZSBzaXplIGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGRiRG9jdW1lbnRTaXplKGRvYykge1xuICAgIGlmICghZG9jKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKGRvYy5kb2N1bWVudCkge1xuICAgICAgICB2YWx1ZSA9IGRvYy5kb2N1bWVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jLnVua25vd25Eb2N1bWVudCkge1xuICAgICAgICB2YWx1ZSA9IGRvYy51bmtub3duRG9jdW1lbnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvYy5ub0RvY3VtZW50KSB7XG4gICAgICAgIHZhbHVlID0gZG9jLm5vRG9jdW1lbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBmYWlsKDB4Mzk4Yik7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkubGVuZ3RoO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIEEgbXV0YXRpb24gcXVldWUgZm9yIGEgc3BlY2lmaWMgdXNlciwgYmFja2VkIGJ5IEluZGV4ZWREQi4gKi9cbmNsYXNzIEluZGV4ZWREYk11dGF0aW9uUXVldWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBub3JtYWxpemVkIHVzZXJJZCAoZS5nLiBudWxsIFVJRCA9PiBcIlwiIHVzZXJJZCkgdXNlZCB0byBzdG9yZSAvXG4gICAgICogcmV0cmlldmUgbXV0YXRpb25zLlxuICAgICAqL1xuICAgIHVzZXJJZCwgc2VyaWFsaXplciwgaW5kZXhNYW5hZ2VyLCByZWZlcmVuY2VEZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLnVzZXJJZCA9IHVzZXJJZDtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBpbmRleE1hbmFnZXI7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUgPSByZWZlcmVuY2VEZWxlZ2F0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hlcyB0aGUgZG9jdW1lbnQga2V5cyBmb3IgcGVuZGluZyBtdXRhdGlvbiBiYXRjaGVzLiBJZiB0aGUgbXV0YXRpb25cbiAgICAgICAgICogaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIEluZGV4ZWREYiwgdGhlIGNhY2hlZCB2YWx1ZSBtYXkgY29udGludWUgdG9cbiAgICAgICAgICogYmUgdXNlZCB0byByZXRyaWV2ZSB0aGUgYmF0Y2gncyBkb2N1bWVudCBrZXlzLiBUbyByZW1vdmUgYSBjYWNoZWQgdmFsdWVcbiAgICAgICAgICogbG9jYWxseSwgYHJlbW92ZUNhY2hlZE11dGF0aW9uS2V5cygpYCBzaG91bGQgYmUgaW52b2tlZCBlaXRoZXIgZGlyZWN0bHlcbiAgICAgICAgICogb3IgdGhyb3VnaCBgcmVtb3ZlTXV0YXRpb25CYXRjaGVzKClgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaXRoIG11bHRpLXRhYiwgd2hlbiB0aGUgcHJpbWFyeSBjbGllbnQgYWNrbm93bGVkZ2VzIG9yIHJlamVjdHMgYSBtdXRhdGlvbixcbiAgICAgICAgICogdGhpcyBjYWNoZSBpcyB1c2VkIGJ5IHNlY29uZGFyeSBjbGllbnRzIHRvIGludmFsaWRhdGUgdGhlIGxvY2FsXG4gICAgICAgICAqIHZpZXcgb2YgdGhlIGRvY3VtZW50cyB0aGF0IHdlcmUgcHJldmlvdXNseSBhZmZlY3RlZCBieSB0aGUgbXV0YXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxuICAgICAgICB0aGlzLmRvY3VtZW50S2V5c0J5QmF0Y2hJZCA9IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG11dGF0aW9uIHF1ZXVlIGZvciB0aGUgZ2l2ZW4gdXNlci5cbiAgICAgKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyIGZvciB3aGljaCB0byBjcmVhdGUgYSBtdXRhdGlvbiBxdWV1ZS5cbiAgICAgKiBAcGFyYW0gc2VyaWFsaXplciAtIFRoZSBzZXJpYWxpemVyIHRvIHVzZSB3aGVuIHBlcnNpc3RpbmcgdG8gSW5kZXhlZERiLlxuICAgICAqL1xuICAgIHN0YXRpYyBmb3JVc2VyKHVzZXIsIHNlcmlhbGl6ZXIsIGluZGV4TWFuYWdlciwgcmVmZXJlbmNlRGVsZWdhdGUpIHtcbiAgICAgICAgLy8gVE9ETyhtY2cpOiBGaWd1cmUgb3V0IHdoYXQgY29uc3RyYWludHMgdGhlcmUgYXJlIG9uIHVzZXJJRHNcbiAgICAgICAgLy8gSW4gcGFydGljdWxhciwgYXJlIHRoZXJlIGFueSByZXNlcnZlZCBjaGFyYWN0ZXJzPyBhcmUgZW1wdHkgaWRzIGFsbG93ZWQ/XG4gICAgICAgIC8vIEZvciB0aGUgbW9tZW50IHN0b3JlIHRoZXNlIHRvZ2V0aGVyIGluIHRoZSBzYW1lIG11dGF0aW9ucyB0YWJsZSBhc3N1bWluZ1xuICAgICAgICAvLyB0aGF0IGVtcHR5IHVzZXJJRHMgYXJlbid0IGFsbG93ZWQuXG4gICAgICAgIGhhcmRBc3NlcnQodXNlci51aWQgIT09ICcnLCAweGZiODMpO1xuICAgICAgICBjb25zdCB1c2VySWQgPSB1c2VyLmlzQXV0aGVudGljYXRlZCgpID8gdXNlci51aWQgOiAnJztcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleGVkRGJNdXRhdGlvblF1ZXVlKHVzZXJJZCwgc2VyaWFsaXplciwgaW5kZXhNYW5hZ2VyLCByZWZlcmVuY2VEZWxlZ2F0ZSk7XG4gICAgfVxuICAgIGNoZWNrRW1wdHkodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgbGV0IGVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGhpcy51c2VySWQsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sIFt0aGlzLnVzZXJJZCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSk7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5pdGVyYXRlKHsgaW5kZXg6IERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNJbmRleCwgcmFuZ2UgfSwgKGtleSwgdmFsdWUsIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGVtcHR5KTtcbiAgICB9XG4gICAgYWRkTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbiwgbG9jYWxXcml0ZVRpbWUsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucykge1xuICAgICAgICBjb25zdCBkb2N1bWVudFN0b3JlID0gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uU3RvcmUgPSBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIC8vIFRoZSBJbmRleGVkRGIgaW1wbGVtZW50YXRpb24gaW4gQ2hyb21lIChhbmQgRmlyZWZveCkgZG9lcyBub3QgaGFuZGxlXG4gICAgICAgIC8vIGNvbXBvdW5kIGluZGljZXMgdGhhdCBpbmNsdWRlIGF1dG8tZ2VuZXJhdGVkIGtleXMgY29ycmVjdGx5LiBUbyBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB0aGUgaW5kZXggZW50cnkgaXMgYWRkZWQgY29ycmVjdGx5IGluIGFsbCBicm93c2Vycywgd2UgcGVyZm9ybSB0d29cbiAgICAgICAgLy8gd3JpdGVzOiBUaGUgZmlyc3Qgd3JpdGUgaXMgdXNlZCB0byByZXRyaWV2ZSB0aGUgbmV4dCBhdXRvLWdlbmVyYXRlZCBCYXRjaFxuICAgICAgICAvLyBJRCwgYW5kIHRoZSBzZWNvbmQgd3JpdGUgcG9wdWxhdGVzIHRoZSBpbmRleCBhbmQgc3RvcmVzIHRoZSBhY3R1YWxcbiAgICAgICAgLy8gbXV0YXRpb24gYmF0Y2guXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NzAxOTcyXG4gICAgICAgIC8vIFdlIHdyaXRlIGFuIGVtcHR5IG9iamVjdCB0byBvYnRhaW4ga2V5XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBtdXRhdGlvblN0b3JlLmFkZCh7fSkubmV4dChiYXRjaElkID0+IHtcbiAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIGJhdGNoSWQgPT09ICdudW1iZXInLCAweGJmN2IpO1xuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBuZXcgTXV0YXRpb25CYXRjaChiYXRjaElkLCBsb2NhbFdyaXRlVGltZSwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGRiQmF0Y2ggPSB0b0RiTXV0YXRpb25CYXRjaCh0aGlzLnNlcmlhbGl6ZXIsIHRoaXMudXNlcklkLCBiYXRjaCk7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgbGV0IGNvbGxlY3Rpb25QYXJlbnRzID0gbmV3IFNvcnRlZFNldCgobCwgcikgPT4gcHJpbWl0aXZlQ29tcGFyYXRvcihsLmNhbm9uaWNhbFN0cmluZygpLCByLmNhbm9uaWNhbFN0cmluZygpKSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4S2V5ID0gbmV3RGJEb2N1bWVudE11dGF0aW9uS2V5KHRoaXMudXNlcklkLCBtdXRhdGlvbi5rZXkucGF0aCwgYmF0Y2hJZCk7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvblBhcmVudHMgPSBjb2xsZWN0aW9uUGFyZW50cy5hZGQobXV0YXRpb24ua2V5LnBhdGgucG9wTGFzdCgpKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKG11dGF0aW9uU3RvcmUucHV0KGRiQmF0Y2gpKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRvY3VtZW50U3RvcmUucHV0KGluZGV4S2V5LCBEYkRvY3VtZW50TXV0YXRpb25QbGFjZWhvbGRlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sbGVjdGlvblBhcmVudHMuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5pbmRleE1hbmFnZXIuYWRkVG9Db2xsZWN0aW9uUGFyZW50SW5kZXgodHJhbnNhY3Rpb24sIHBhcmVudCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5hZGRPbkNvbW1pdHRlZExpc3RlbmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50S2V5c0J5QmF0Y2hJZFtiYXRjaElkXSA9IGJhdGNoLmtleXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKS5uZXh0KCgpID0+IGJhdGNoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvb2t1cE11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGJhdGNoSWQpIHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLmdldChiYXRjaElkKVxuICAgICAgICAgICAgLm5leHQoZGJCYXRjaCA9PiB7XG4gICAgICAgICAgICBpZiAoZGJCYXRjaCkge1xuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZGJCYXRjaC51c2VySWQgPT09IHRoaXMudXNlcklkLCAweDAwMzAsIGBVbmV4cGVjdGVkIHVzZXIgZm9yIG11dGF0aW9uIGJhdGNoYCwge1xuICAgICAgICAgICAgICAgICAgICB1c2VySWQ6IGRiQmF0Y2gudXNlcklkLFxuICAgICAgICAgICAgICAgICAgICBiYXRjaElkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCBkYkJhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZG9jdW1lbnQga2V5cyBmb3IgdGhlIG11dGF0aW9uIGJhdGNoIHdpdGggdGhlIGdpdmVuIGJhdGNoSWQuXG4gICAgICogRm9yIHByaW1hcnkgY2xpZW50cywgdGhpcyBtZXRob2QgcmV0dXJucyBgbnVsbGAgYWZ0ZXJcbiAgICAgKiBgcmVtb3ZlTXV0YXRpb25CYXRjaGVzKClgIGhhcyBiZWVuIGNhbGxlZC4gU2Vjb25kYXJ5IGNsaWVudHMgcmV0dXJuIGFcbiAgICAgKiBjYWNoZWQgcmVzdWx0IHVudGlsIGByZW1vdmVDYWNoZWRNdXRhdGlvbktleXMoKWAgaXMgaW52b2tlZC5cbiAgICAgKi9cbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxuICAgIGxvb2t1cE11dGF0aW9uS2V5cyh0cmFuc2FjdGlvbiwgYmF0Y2hJZCkge1xuICAgICAgICBpZiAodGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWRbYmF0Y2hJZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmRvY3VtZW50S2V5c0J5QmF0Y2hJZFtiYXRjaElkXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb29rdXBNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLCBiYXRjaElkKS5uZXh0KGJhdGNoID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IGJhdGNoLmtleXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWRbYmF0Y2hJZF0gPSBrZXlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE5leHRNdXRhdGlvbkJhdGNoQWZ0ZXJCYXRjaElkKHRyYW5zYWN0aW9uLCBiYXRjaElkKSB7XG4gICAgICAgIGNvbnN0IG5leHRCYXRjaElkID0gYmF0Y2hJZCArIDE7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChbdGhpcy51c2VySWQsIG5leHRCYXRjaElkXSk7XG4gICAgICAgIGxldCBmb3VuZEJhdGNoID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoeyBpbmRleDogRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0luZGV4LCByYW5nZSB9LCAoa2V5LCBkYkJhdGNoLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGJCYXRjaC51c2VySWQgPT09IHRoaXMudXNlcklkKSB7XG4gICAgICAgICAgICAgICAgaGFyZEFzc2VydChkYkJhdGNoLmJhdGNoSWQgPj0gbmV4dEJhdGNoSWQsIDB4YjlhNCwgeyBuZXh0QmF0Y2hJZCB9KTtcbiAgICAgICAgICAgICAgICBmb3VuZEJhdGNoID0gZnJvbURiTXV0YXRpb25CYXRjaCh0aGlzLnNlcmlhbGl6ZXIsIGRiQmF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBmb3VuZEJhdGNoKTtcbiAgICB9XG4gICAgZ2V0SGlnaGVzdFVuYWNrbm93bGVkZ2VkQmF0Y2hJZCh0cmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLnVwcGVyQm91bmQoW1xuICAgICAgICAgICAgdGhpcy51c2VySWQsXG4gICAgICAgICAgICBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgICAgXSk7XG4gICAgICAgIGxldCBiYXRjaElkID0gQkFUQ0hJRF9VTktOT1dOO1xuICAgICAgICByZXR1cm4gbXV0YXRpb25zU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IGluZGV4OiBEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zSW5kZXgsIHJhbmdlLCByZXZlcnNlOiB0cnVlIH0sIChrZXksIGRiQmF0Y2gsIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGJhdGNoSWQgPSBkYkJhdGNoLmJhdGNoSWQ7XG4gICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGJhdGNoSWQpO1xuICAgIH1cbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGhpcy51c2VySWQsIEJBVENISURfVU5LTk9XTl0sIFt0aGlzLnVzZXJJZCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSk7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5sb2FkQWxsKERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNJbmRleCwgcmFuZ2UpXG4gICAgICAgICAgICAubmV4dChkYkJhdGNoZXMgPT4gZGJCYXRjaGVzLm1hcChkYkJhdGNoID0+IGZyb21EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCBkYkJhdGNoKSkpO1xuICAgIH1cbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXNBZmZlY3RpbmdEb2N1bWVudEtleSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcbiAgICAgICAgLy8gU2NhbiB0aGUgZG9jdW1lbnQtbXV0YXRpb24gaW5kZXggc3RhcnRpbmcgd2l0aCBhIHByZWZpeCBzdGFydGluZyB3aXRoXG4gICAgICAgIC8vIHRoZSBnaXZlbiBkb2N1bWVudEtleS5cbiAgICAgICAgY29uc3QgaW5kZXhQcmVmaXggPSBuZXdEYkRvY3VtZW50TXV0YXRpb25QcmVmaXhGb3JQYXRoKHRoaXMudXNlcklkLCBkb2N1bWVudEtleS5wYXRoKTtcbiAgICAgICAgY29uc3QgaW5kZXhTdGFydCA9IElEQktleVJhbmdlLmxvd2VyQm91bmQoaW5kZXhQcmVmaXgpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIHJldHVybiBkb2N1bWVudE11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoeyByYW5nZTogaW5kZXhTdGFydCB9LCAoaW5kZXhLZXksIF8sIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFt1c2VySUQsIGVuY29kZWRQYXRoLCBiYXRjaElkXSA9IGluZGV4S2V5O1xuICAgICAgICAgICAgLy8gT25seSBjb25zaWRlciByb3dzIG1hdGNoaW5nIGV4YWN0bHkgdGhlIHNwZWNpZmljIGtleSBvZlxuICAgICAgICAgICAgLy8gaW50ZXJlc3QuIE5vdGUgdGhhdCBiZWNhdXNlIHdlIG9yZGVyIGJ5IHBhdGggZmlyc3QsIGFuZCB3ZVxuICAgICAgICAgICAgLy8gb3JkZXIgdGVybWluYXRvcnMgYmVmb3JlIHBhdGggc2VwYXJhdG9ycywgd2UnbGwgZW5jb3VudGVyIGFsbFxuICAgICAgICAgICAgLy8gdGhlIGluZGV4IHJvd3MgZm9yIGRvY3VtZW50S2V5IGNvbnRpZ3VvdXNseS4gSW4gcGFydGljdWxhciwgYWxsXG4gICAgICAgICAgICAvLyB0aGUgcm93cyBmb3IgZG9jdW1lbnRLZXkgd2lsbCBvY2N1ciBiZWZvcmUgYW55IHJvd3MgZm9yXG4gICAgICAgICAgICAvLyBkb2N1bWVudHMgbmVzdGVkIGluIGEgc3ViY29sbGVjdGlvbiBiZW5lYXRoIGRvY3VtZW50S2V5IHNvIHdlXG4gICAgICAgICAgICAvLyBjYW4gc3RvcCBhcyBzb29uIGFzIHdlIGhpdCBhbnkgc3VjaCByb3cuXG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZGVjb2RlUmVzb3VyY2VQYXRoKGVuY29kZWRQYXRoKTtcbiAgICAgICAgICAgIGlmICh1c2VySUQgIT09IHRoaXMudXNlcklkIHx8ICFkb2N1bWVudEtleS5wYXRoLmlzRXF1YWwocGF0aCkpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMb29rIHVwIHRoZSBtdXRhdGlvbiBiYXRjaCBpbiB0aGUgc3RvcmUuXG4gICAgICAgICAgICByZXR1cm4gbXV0YXRpb25zU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgLmdldChiYXRjaElkKVxuICAgICAgICAgICAgICAgIC5uZXh0KG11dGF0aW9uID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW11dGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwoMHhmMDI4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoSWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQobXV0YXRpb24udXNlcklkID09PSB0aGlzLnVzZXJJZCwgMHgyOTA3LCBgVW5leHBlY3RlZCB1c2VyIGZvciBtdXRhdGlvbiBiYXRjaGAsIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlcklkOiBtdXRhdGlvbi51c2VySWQsXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoSWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZnJvbURiTXV0YXRpb25CYXRjaCh0aGlzLnNlcmlhbGl6ZXIsIG11dGF0aW9uKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHJlc3VsdHMpO1xuICAgIH1cbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXNBZmZlY3RpbmdEb2N1bWVudEtleXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xuICAgICAgICBsZXQgdW5pcXVlQmF0Y2hJRHMgPSBuZXcgU29ydGVkU2V0KHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBkb2N1bWVudEtleXMuZm9yRWFjaChkb2N1bWVudEtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleFN0YXJ0ID0gbmV3RGJEb2N1bWVudE11dGF0aW9uUHJlZml4Rm9yUGF0aCh0aGlzLnVzZXJJZCwgZG9jdW1lbnRLZXkucGF0aCk7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmxvd2VyQm91bmQoaW5kZXhTdGFydCk7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbikuaXRlcmF0ZSh7IHJhbmdlIH0sIChpbmRleEtleSwgXywgY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFt1c2VySUQsIGVuY29kZWRQYXRoLCBiYXRjaElEXSA9IGluZGV4S2V5O1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgY29uc2lkZXIgcm93cyBtYXRjaGluZyBleGFjdGx5IHRoZSBzcGVjaWZpYyBrZXkgb2ZcbiAgICAgICAgICAgICAgICAvLyBpbnRlcmVzdC4gTm90ZSB0aGF0IGJlY2F1c2Ugd2Ugb3JkZXIgYnkgcGF0aCBmaXJzdCwgYW5kIHdlXG4gICAgICAgICAgICAgICAgLy8gb3JkZXIgdGVybWluYXRvcnMgYmVmb3JlIHBhdGggc2VwYXJhdG9ycywgd2UnbGwgZW5jb3VudGVyIGFsbFxuICAgICAgICAgICAgICAgIC8vIHRoZSBpbmRleCByb3dzIGZvciBkb2N1bWVudEtleSBjb250aWd1b3VzbHkuIEluIHBhcnRpY3VsYXIsIGFsbFxuICAgICAgICAgICAgICAgIC8vIHRoZSByb3dzIGZvciBkb2N1bWVudEtleSB3aWxsIG9jY3VyIGJlZm9yZSBhbnkgcm93cyBmb3JcbiAgICAgICAgICAgICAgICAvLyBkb2N1bWVudHMgbmVzdGVkIGluIGEgc3ViY29sbGVjdGlvbiBiZW5lYXRoIGRvY3VtZW50S2V5IHNvIHdlXG4gICAgICAgICAgICAgICAgLy8gY2FuIHN0b3AgYXMgc29vbiBhcyB3ZSBoaXQgYW55IHN1Y2ggcm93LlxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZWNvZGVSZXNvdXJjZVBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICh1c2VySUQgIT09IHRoaXMudXNlcklkIHx8ICFkb2N1bWVudEtleS5wYXRoLmlzRXF1YWwocGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5pcXVlQmF0Y2hJRHMgPSB1bmlxdWVCYXRjaElEcy5hZGQoYmF0Y2hJRCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpLm5leHQoKCkgPT4gdGhpcy5sb29rdXBNdXRhdGlvbkJhdGNoZXModHJhbnNhY3Rpb24sIHVuaXF1ZUJhdGNoSURzKSk7XG4gICAgfVxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSkge1xuICAgICAgICBjb25zdCBxdWVyeVBhdGggPSBxdWVyeS5wYXRoO1xuICAgICAgICBjb25zdCBpbW1lZGlhdGVDaGlsZHJlbkxlbmd0aCA9IHF1ZXJ5UGF0aC5sZW5ndGggKyAxO1xuICAgICAgICAvLyBUT0RPKG1jZyk6IEFjdHVhbGx5IGltcGxlbWVudCBhIHNpbmdsZS1jb2xsZWN0aW9uIHF1ZXJ5XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgaXMgYWN0dWFsbHkgZXhlY3V0aW5nIGFuIGFuY2VzdG9yIHF1ZXJ5LCB0cmF2ZXJzaW5nIHRoZSB3aG9sZVxuICAgICAgICAvLyBzdWJ0cmVlIGJlbG93IHRoZSBjb2xsZWN0aW9uIHdoaWNoIGNhbiBiZSBob3JyaWZpY2FsbHkgaW5lZmZpY2llbnQgZm9yXG4gICAgICAgIC8vIHNvbWUgc3RydWN0dXJlcy4gVGhlIHJpZ2h0IHdheSB0byBzb2x2ZSB0aGlzIGlzIHRvIGltcGxlbWVudCB0aGUgZnVsbFxuICAgICAgICAvLyB2YWx1ZSBpbmRleCwgYnV0IHRoYXQncyBub3QgaW4gdGhlIGNhcmRzIGluIHRoZSBuZWFyIGZ1dHVyZSBzbyB0aGlzIGlzXG4gICAgICAgIC8vIHRoZSBiZXN0IHdlIGNhbiBkbyBmb3IgdGhlIG1vbWVudC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3QgeWV0IGluZGV4IHRoZSBhY3R1YWwgcHJvcGVydGllcyBpbiB0aGUgbXV0YXRpb25zLCBvdXJcbiAgICAgICAgLy8gY3VycmVudCBhcHByb2FjaCBpcyB0byBqdXN0IHJldHVybiBhbGwgbXV0YXRpb24gYmF0Y2hlcyB0aGF0IGFmZmVjdFxuICAgICAgICAvLyBkb2N1bWVudHMgaW4gdGhlIGNvbGxlY3Rpb24gYmVpbmcgcXVlcmllZC5cbiAgICAgICAgY29uc3QgaW5kZXhQcmVmaXggPSBuZXdEYkRvY3VtZW50TXV0YXRpb25QcmVmaXhGb3JQYXRoKHRoaXMudXNlcklkLCBxdWVyeVBhdGgpO1xuICAgICAgICBjb25zdCBpbmRleFN0YXJ0ID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChpbmRleFByZWZpeCk7XG4gICAgICAgIC8vIENvbGxlY3QgdXAgdW5pcXVlIGJhdGNoSURzIGVuY291bnRlcmVkIGR1cmluZyBhIHNjYW4gb2YgdGhlIGluZGV4LiBVc2UgYVxuICAgICAgICAvLyBTb3J0ZWRTZXQgdG8gYWNjdW11bGF0ZSBiYXRjaCBJRHMgc28gdGhleSBjYW4gYmUgdHJhdmVyc2VkIGluIG9yZGVyIGluIGFcbiAgICAgICAgLy8gc2NhbiBvZiB0aGUgbWFpbiB0YWJsZS5cbiAgICAgICAgbGV0IHVuaXF1ZUJhdGNoSURzID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50TXV0YXRpb25zU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IHJhbmdlOiBpbmRleFN0YXJ0IH0sIChpbmRleEtleSwgXywgY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3VzZXJJRCwgZW5jb2RlZFBhdGgsIGJhdGNoSURdID0gaW5kZXhLZXk7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZGVjb2RlUmVzb3VyY2VQYXRoKGVuY29kZWRQYXRoKTtcbiAgICAgICAgICAgIGlmICh1c2VySUQgIT09IHRoaXMudXNlcklkIHx8ICFxdWVyeVBhdGguaXNQcmVmaXhPZihwYXRoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJvd3Mgd2l0aCBkb2N1bWVudCBrZXlzIG1vcmUgdGhhbiBvbmUgc2VnbWVudCBsb25nZXIgdGhhbiB0aGVcbiAgICAgICAgICAgIC8vIHF1ZXJ5IHBhdGggY2FuJ3QgYmUgbWF0Y2hlcy4gRm9yIGV4YW1wbGUsIGEgcXVlcnkgb24gJ3Jvb21zJ1xuICAgICAgICAgICAgLy8gY2FuJ3QgbWF0Y2ggdGhlIGRvY3VtZW50IC9yb29tcy9hYmMvbWVzc2FnZXMveHl4LlxuICAgICAgICAgICAgLy8gVE9ETyhtY2cpOiB3ZSdsbCBuZWVkIGEgZGlmZmVyZW50IHNjYW5uZXIgd2hlbiB3ZSBpbXBsZW1lbnRcbiAgICAgICAgICAgIC8vIGFuY2VzdG9yIHF1ZXJpZXMuXG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggIT09IGltbWVkaWF0ZUNoaWxkcmVuTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5pcXVlQmF0Y2hJRHMgPSB1bmlxdWVCYXRjaElEcy5hZGQoYmF0Y2hJRCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB0aGlzLmxvb2t1cE11dGF0aW9uQmF0Y2hlcyh0cmFuc2FjdGlvbiwgdW5pcXVlQmF0Y2hJRHMpKTtcbiAgICB9XG4gICAgbG9va3VwTXV0YXRpb25CYXRjaGVzKHRyYW5zYWN0aW9uLCBiYXRjaElEcykge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIC8vIFRPRE8ocm9ja3dvb2QpOiBJbXBsZW1lbnQgdGhpcyB1c2luZyBpdGVyYXRlLlxuICAgICAgICBiYXRjaElEcy5mb3JFYWNoKGJhdGNoSWQgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAuZ2V0KGJhdGNoSWQpXG4gICAgICAgICAgICAgICAgLm5leHQobXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBmYWlsKDB4ODljYSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hJZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFyZEFzc2VydChtdXRhdGlvbi51c2VySWQgPT09IHRoaXMudXNlcklkLCAweDI2MTQsIGBVbmV4cGVjdGVkIHVzZXIgZm9yIG11dGF0aW9uIGJhdGNoYCwgeyB1c2VySWQ6IG11dGF0aW9uLnVzZXJJZCwgYmF0Y2hJZCB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZnJvbURiTXV0YXRpb25CYXRjaCh0aGlzLnNlcmlhbGl6ZXIsIG11dGF0aW9uKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpLm5leHQoKCkgPT4gcmVzdWx0cyk7XG4gICAgfVxuICAgIHJlbW92ZU11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGJhdGNoKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLnNpbXBsZURiVHJhbnNhY3Rpb24sIHRoaXMudXNlcklkLCBiYXRjaCkubmV4dChyZW1vdmVkRG9jdW1lbnRzID0+IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZE9uQ29tbWl0dGVkTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2FjaGVkTXV0YXRpb25LZXlzKGJhdGNoLmJhdGNoSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2gocmVtb3ZlZERvY3VtZW50cywgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZURlbGVnYXRlLm1hcmtQb3RlbnRpYWxseU9ycGhhbmVkKHRyYW5zYWN0aW9uLCBrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGNhY2hlZCBrZXlzIGZvciBhIG11dGF0aW9uIGJhdGNoLiBUaGlzIG1ldGhvZCBzaG91bGQgYmVcbiAgICAgKiBjYWxsZWQgYnkgc2Vjb25kYXJ5IGNsaWVudHMgYWZ0ZXIgdGhleSBwcm9jZXNzIG11dGF0aW9uIHVwZGF0ZXMuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgZG9lcyBub3QgaGF2ZSB0byBiZSBjYWxsZWQgZnJvbSBwcmltYXJ5IGNsaWVudHMgYXNcbiAgICAgKiB0aGUgY29ycmVzcG9uZGluZyBjYWNoZSBlbnRyaWVzIGFyZSBjbGVhcmVkIHdoZW4gYW4gYWNrbm93bGVkZ2VkIG9yXG4gICAgICogcmVqZWN0ZWQgYmF0Y2ggaXMgcmVtb3ZlZCBmcm9tIHRoZSBtdXRhdGlvbiBxdWV1ZS5cbiAgICAgKi9cbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5XG4gICAgcmVtb3ZlQ2FjaGVkTXV0YXRpb25LZXlzKGJhdGNoSWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZG9jdW1lbnRLZXlzQnlCYXRjaElkW2JhdGNoSWRdO1xuICAgIH1cbiAgICBwZXJmb3JtQ29uc2lzdGVuY3lDaGVjayh0eG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tFbXB0eSh0eG4pLm5leHQoZW1wdHkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlbXB0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlcmUgYXJlIG5vIGVudHJpZXMgaW4gdGhlIGRvY3VtZW50TXV0YXRpb25zIGluZGV4IGlmXG4gICAgICAgICAgICAvLyB0aGUgcXVldWUgaXMgZW1wdHkuXG4gICAgICAgICAgICBjb25zdCBzdGFydFJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChuZXdEYkRvY3VtZW50TXV0YXRpb25QcmVmaXhGb3JVc2VyKHRoaXMudXNlcklkKSk7XG4gICAgICAgICAgICBjb25zdCBkYW5nbGluZ011dGF0aW9uUmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50TXV0YXRpb25zU3RvcmUodHhuKVxuICAgICAgICAgICAgICAgIC5pdGVyYXRlKHsgcmFuZ2U6IHN0YXJ0UmFuZ2UgfSwgKGtleSwgXywgY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJJRCA9IGtleVswXTtcbiAgICAgICAgICAgICAgICBpZiAodXNlcklEICE9PSB0aGlzLnVzZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRlY29kZVJlc291cmNlUGF0aChrZXlbMV0pO1xuICAgICAgICAgICAgICAgICAgICBkYW5nbGluZ011dGF0aW9uUmVmZXJlbmNlcy5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZGFuZ2xpbmdNdXRhdGlvblJlZmVyZW5jZXMubGVuZ3RoID09PSAwLCAweGRkOTAsIHtcbiAgICAgICAgICAgICAgICAgICAgZGFuZ2xpbmdLZXlzOiBkYW5nbGluZ011dGF0aW9uUmVmZXJlbmNlcy5tYXAocCA9PiBwLmNhbm9uaWNhbFN0cmluZygpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb250YWluc0tleSh0eG4sIGtleSkge1xuICAgICAgICByZXR1cm4gbXV0YXRpb25RdWV1ZUNvbnRhaW5zS2V5KHR4biwgdGhpcy51c2VySWQsIGtleSk7XG4gICAgfVxuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkgKHN0YXRlIGlzIGhlbGQgaW4gbWVtb3J5IGluIG90aGVyIGNsaWVudHMpLlxuICAgIC8qKiBSZXR1cm5zIHRoZSBtdXRhdGlvbiBxdWV1ZSdzIG1ldGFkYXRhIGZyb20gSW5kZXhlZERiLiAqL1xuICAgIGdldE11dGF0aW9uUXVldWVNZXRhZGF0YSh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gbXV0YXRpb25RdWV1ZXNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5nZXQodGhpcy51c2VySWQpXG4gICAgICAgICAgICAubmV4dCgobWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAobWV0YWRhdGEgfHwge1xuICAgICAgICAgICAgICAgIHVzZXJJZDogdGhpcy51c2VySWQsXG4gICAgICAgICAgICAgICAgbGFzdEFja25vd2xlZGdlZEJhdGNoSWQ6IEJBVENISURfVU5LTk9XTixcbiAgICAgICAgICAgICAgICBsYXN0U3RyZWFtVG9rZW46ICcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBtdXRhdGlvbiBxdWV1ZSBmb3IgdGhlIGdpdmVuIHVzZXIgY29udGFpbnMgYSBwZW5kaW5nXG4gKiAgICAgICAgIG11dGF0aW9uIGZvciB0aGUgZ2l2ZW4ga2V5LlxuICovXG5mdW5jdGlvbiBtdXRhdGlvblF1ZXVlQ29udGFpbnNLZXkodHhuLCB1c2VySWQsIGtleSkge1xuICAgIGNvbnN0IGluZGV4S2V5ID0gbmV3RGJEb2N1bWVudE11dGF0aW9uUHJlZml4Rm9yUGF0aCh1c2VySWQsIGtleS5wYXRoKTtcbiAgICBjb25zdCBlbmNvZGVkUGF0aCA9IGluZGV4S2V5WzFdO1xuICAgIGNvbnN0IHN0YXJ0UmFuZ2UgPSBJREJLZXlSYW5nZS5sb3dlckJvdW5kKGluZGV4S2V5KTtcbiAgICBsZXQgY29udGFpbnNLZXkgPSBmYWxzZTtcbiAgICByZXR1cm4gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0eG4pXG4gICAgICAgIC5pdGVyYXRlKHsgcmFuZ2U6IHN0YXJ0UmFuZ2UsIGtleXNPbmx5OiB0cnVlIH0sIChrZXksIHZhbHVlLCBjb250cm9sKSA9PiB7XG4gICAgICAgIGNvbnN0IFt1c2VySUQsIGtleVBhdGgsIC8qYmF0Y2hJRCovIF9dID0ga2V5O1xuICAgICAgICBpZiAodXNlcklEID09PSB1c2VySWQgJiYga2V5UGF0aCA9PT0gZW5jb2RlZFBhdGgpIHtcbiAgICAgICAgICAgIGNvbnRhaW5zS2V5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICB9KVxuICAgICAgICAubmV4dCgoKSA9PiBjb250YWluc0tleSk7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGFueSBtdXRhdGlvbiBxdWV1ZSBjb250YWlucyB0aGUgZ2l2ZW4gZG9jdW1lbnQuICovXG5mdW5jdGlvbiBtdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHhuLCBkb2NLZXkpIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICByZXR1cm4gbXV0YXRpb25RdWV1ZXNTdG9yZSh0eG4pXG4gICAgICAgIC5pdGVyYXRlU2VyaWFsKHVzZXJJZCA9PiB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvblF1ZXVlQ29udGFpbnNLZXkodHhuLCB1c2VySWQsIGRvY0tleSkubmV4dChjb250YWluc0tleSA9PiB7XG4gICAgICAgICAgICBpZiAoY29udGFpbnNLZXkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoIWNvbnRhaW5zS2V5KTtcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAgICAgLm5leHQoKCkgPT4gZm91bmQpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIG11dGF0aW9ucyBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIG11dGF0aW9uc1N0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiTXV0YXRpb25CYXRjaFN0b3JlKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBtdXRhdGlvblF1ZXVlcyBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIGRvY3VtZW50TXV0YXRpb25zU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJEb2N1bWVudE11dGF0aW9uU3RvcmUpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIG11dGF0aW9uUXVldWVzIG9iamVjdCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gbXV0YXRpb25RdWV1ZXNTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYk11dGF0aW9uUXVldWVTdG9yZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogT2Zmc2V0IHRvIGVuc3VyZSBub24tb3ZlcmxhcHBpbmcgdGFyZ2V0IGlkcy4gKi9cbmNvbnN0IE9GRlNFVCA9IDI7XG4vKipcbiAqIEdlbmVyYXRlcyBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgdGFyZ2V0IElEcyBmb3Igc2VuZGluZyB0YXJnZXRzIHRvIHRoZVxuICogd2F0Y2ggc3RyZWFtLlxuICpcbiAqIFRoZSBjbGllbnQgY29uc3RydWN0cyB0d28gZ2VuZXJhdG9ycywgb25lIGZvciB0aGUgdGFyZ2V0IGNhY2hlLCBhbmQgb25lIGZvclxuICogZm9yIHRoZSBzeW5jIGVuZ2luZSAodG8gZ2VuZXJhdGUgbGltYm8gZG9jdW1lbnRzIHRhcmdldHMpLiBUaGVzZVxuICogZ2VuZXJhdG9ycyBwcm9kdWNlIG5vbi1vdmVybGFwcGluZyBJRHMgKGJ5IHVzaW5nIGV2ZW4gYW5kIG9kZCBJRHNcbiAqIHJlc3BlY3RpdmVseSkuXG4gKlxuICogQnkgc2VwYXJhdGluZyB0aGUgdGFyZ2V0IElEIHNwYWNlLCB0aGUgcXVlcnkgY2FjaGUgY2FuIGdlbmVyYXRlIHRhcmdldCBJRHNcbiAqIHRoYXQgcGVyc2lzdCBhY3Jvc3MgY2xpZW50IHJlc3RhcnRzLCB3aGlsZSBzeW5jIGVuZ2luZSBjYW4gaW5kZXBlbmRlbnRseVxuICogZ2VuZXJhdGUgaW4tbWVtb3J5IHRhcmdldCBJRHMgdGhhdCBhcmUgdHJhbnNpZW50IGFuZCBjYW4gYmUgcmV1c2VkIGFmdGVyIGFcbiAqIHJlc3RhcnQuXG4gKi9cbmNsYXNzIFRhcmdldElkR2VuZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihsYXN0SWQpIHtcbiAgICAgICAgdGhpcy5sYXN0SWQgPSBsYXN0SWQ7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMubGFzdElkICs9IE9GRlNFVDtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdElkO1xuICAgIH1cbiAgICBzdGF0aWMgZm9yVGFyZ2V0Q2FjaGUoKSB7XG4gICAgICAgIC8vIFRoZSB0YXJnZXQgY2FjaGUgZ2VuZXJhdG9yIG11c3QgcmV0dXJuICcyJyBpbiBpdHMgZmlyc3QgY2FsbCB0byBgbmV4dCgpYFxuICAgICAgICAvLyBhcyB0aGVyZSBpcyBubyBkaWZmZXJlbnRpYXRpb24gaW4gdGhlIHByb3RvY29sIGxheWVyIGJldHdlZW4gYW4gdW5zZXRcbiAgICAgICAgLy8gbnVtYmVyIGFuZCB0aGUgbnVtYmVyICcwJy4gSWYgd2Ugd2VyZSB0byBzZW50IGEgdGFyZ2V0IHdpdGggdGFyZ2V0IElEXG4gICAgICAgIC8vICcwJywgdGhlIGJhY2tlbmQgd291bGQgY29uc2lkZXIgaXQgdW5zZXQgYW5kIHJlcGxhY2UgaXQgd2l0aCBpdHMgb3duIElELlxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldElkR2VuZXJhdG9yKDIgLSBPRkZTRVQpO1xuICAgIH1cbiAgICBzdGF0aWMgZm9yU3luY0VuZ2luZSgpIHtcbiAgICAgICAgLy8gU3luYyBlbmdpbmUgYXNzaWducyB0YXJnZXQgSURzIGZvciBsaW1ibyBkb2N1bWVudCBkZXRlY3Rpb24uXG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0SWRHZW5lcmF0b3IoMSAtIE9GRlNFVCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgSW5kZXhlZERiVGFyZ2V0Q2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHJlZmVyZW5jZURlbGVnYXRlLCBzZXJpYWxpemVyKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUgPSByZWZlcmVuY2VEZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICB9XG4gICAgLy8gUE9SVElORyBOT1RFOiBXZSBkb24ndCBjYWNoZSBnbG9iYWwgbWV0YWRhdGEgZm9yIHRoZSB0YXJnZXQgY2FjaGUsIHNpbmNlXG4gICAgLy8gc29tZSBvZiBpdCAoaW4gcGFydGljdWxhciBgaGlnaGVzdFRhcmdldElkYCkgY2FuIGJlIG1vZGlmaWVkIGJ5IHNlY29uZGFyeVxuICAgIC8vIHRhYnMuIFdlIGNvdWxkIHBlcmhhcHMgYmUgbW9yZSBncmFudWxhciAoYW5kIGUuZy4gc3RpbGwgY2FjaGVcbiAgICAvLyBgbGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbmAgaW4gbWVtb3J5KSBidXQgZm9yIHNpbXBsaWNpdHkgd2UgY3VycmVudGx5IGdvXG4gICAgLy8gdG8gSW5kZXhlZERiIHdoZW5ldmVyIHdlIG5lZWQgdG8gcmVhZCBtZXRhZGF0YS4gV2UgY2FuIHJldmlzaXQgaWYgaXQgdHVybnNcbiAgICAvLyBvdXQgdG8gaGF2ZSBhIG1lYW5pbmdmdWwgcGVyZm9ybWFuY2UgaW1wYWN0LlxuICAgIGFsbG9jYXRlVGFyZ2V0SWQodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJZEdlbmVyYXRvciA9IG5ldyBUYXJnZXRJZEdlbmVyYXRvcihtZXRhZGF0YS5oaWdoZXN0VGFyZ2V0SWQpO1xuICAgICAgICAgICAgbWV0YWRhdGEuaGlnaGVzdFRhcmdldElkID0gdGFyZ2V0SWRHZW5lcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBtZXRhZGF0YSkubmV4dCgoKSA9PiBtZXRhZGF0YS5oaWdoZXN0VGFyZ2V0SWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24uZnJvbVRpbWVzdGFtcChuZXcgVGltZXN0YW1wKG1ldGFkYXRhLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24uc2Vjb25kcywgbWV0YWRhdGEubGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbi5uYW5vc2Vjb25kcykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SGlnaGVzdFNlcXVlbmNlTnVtYmVyKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldHJpZXZlTWV0YWRhdGEodHJhbnNhY3Rpb24pLm5leHQodGFyZ2V0R2xvYmFsID0+IHRhcmdldEdsb2JhbC5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIpO1xuICAgIH1cbiAgICBzZXRUYXJnZXRzTWV0YWRhdGEodHJhbnNhY3Rpb24sIGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciwgbGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgIG1ldGFkYXRhLmhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciA9IGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgIGlmIChsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEubGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbiA9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24udG9UaW1lc3RhbXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPiBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPSBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlTWV0YWRhdGEodHJhbnNhY3Rpb24sIG1ldGFkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZFRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEudGFyZ2V0Q291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1ldGFkYXRhRnJvbVRhcmdldERhdGEodGFyZ2V0RGF0YSwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhdmVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKTtcbiAgICB9XG4gICAgcmVtb3ZlVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YS50YXJnZXRJZClcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHRhcmdldHNTdG9yZSh0cmFuc2FjdGlvbikuZGVsZXRlKHRhcmdldERhdGEudGFyZ2V0SWQpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gdGhpcy5yZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKSlcbiAgICAgICAgICAgIC5uZXh0KG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgIGhhcmRBc3NlcnQobWV0YWRhdGEudGFyZ2V0Q291bnQgPiAwLCAweDFmODEpO1xuICAgICAgICAgICAgbWV0YWRhdGEudGFyZ2V0Q291bnQgLT0gMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJvcHMgYW55IHRhcmdldHMgd2l0aCBzZXF1ZW5jZSBudW1iZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB1cHBlciBib3VuZCwgZXhjZXB0aW5nIHRob3NlXG4gICAgICogcHJlc2VudCBpbiBgYWN0aXZlVGFyZ2V0SWRzYC4gRG9jdW1lbnQgYXNzb2NpYXRpb25zIGZvciB0aGUgcmVtb3ZlZCB0YXJnZXRzIGFyZSBhbHNvIHJlbW92ZWQuXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRhcmdldHMgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICByZW1vdmVUYXJnZXRzKHR4biwgdXBwZXJCb3VuZCwgYWN0aXZlVGFyZ2V0SWRzKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIHJldHVybiB0YXJnZXRzU3RvcmUodHhuKVxuICAgICAgICAgICAgLml0ZXJhdGUoKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSBmcm9tRGJUYXJnZXQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIgPD0gdXBwZXJCb3VuZCAmJlxuICAgICAgICAgICAgICAgIGFjdGl2ZVRhcmdldElkcy5nZXQodGFyZ2V0RGF0YS50YXJnZXRJZCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5yZW1vdmVUYXJnZXREYXRhKHR4biwgdGFyZ2V0RGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gY291bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIHByb3ZpZGVkIGZ1bmN0aW9uIHdpdGggZWFjaCBgVGFyZ2V0RGF0YWAgdGhhdCB3ZSBoYXZlIGNhY2hlZC5cbiAgICAgKi9cbiAgICBmb3JFYWNoVGFyZ2V0KHR4biwgZikge1xuICAgICAgICByZXR1cm4gdGFyZ2V0c1N0b3JlKHR4bikuaXRlcmF0ZSgoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IGZyb21EYlRhcmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBmKHRhcmdldERhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGFyZ2V0U3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuZ2V0KERiVGFyZ2V0R2xvYmFsS2V5KVxuICAgICAgICAgICAgLm5leHQobWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgaGFyZEFzc2VydChtZXRhZGF0YSAhPT0gbnVsbCwgMHgwYjQ4KTtcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNhdmVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRhcmdldFN0b3JlKHRyYW5zYWN0aW9uKS5wdXQoRGJUYXJnZXRHbG9iYWxLZXksIG1ldGFkYXRhKTtcbiAgICB9XG4gICAgc2F2ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0cmFuc2FjdGlvbikucHV0KHRvRGJUYXJnZXQodGhpcy5zZXJpYWxpemVyLCB0YXJnZXREYXRhKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluLXBsYWNlIHVwZGF0ZXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIHRvIGFjY291bnQgZm9yIHZhbHVlcyBpbiB0aGUgZ2l2ZW5cbiAgICAgKiBUYXJnZXREYXRhLiBTYXZpbmcgaXMgZG9uZSBzZXBhcmF0ZWx5LiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgd2VyZSBhbnlcbiAgICAgKiBjaGFuZ2VzIHRvIHRoZSBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICB1cGRhdGVNZXRhZGF0YUZyb21UYXJnZXREYXRhKHRhcmdldERhdGEsIG1ldGFkYXRhKSB7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0YXJnZXREYXRhLnRhcmdldElkID4gbWV0YWRhdGEuaGlnaGVzdFRhcmdldElkKSB7XG4gICAgICAgICAgICBtZXRhZGF0YS5oaWdoZXN0VGFyZ2V0SWQgPSB0YXJnZXREYXRhLnRhcmdldElkO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIgPiBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhLmhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciA9IHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0Q291bnQodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dChtZXRhZGF0YSA9PiBtZXRhZGF0YS50YXJnZXRDb3VudCk7XG4gICAgfVxuICAgIGdldFRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldCkge1xuICAgICAgICAvLyBJdGVyYXRpbmcgYnkgdGhlIGNhbm9uaWNhbElkIG1heSB5aWVsZCBtb3JlIHRoYW4gb25lIHJlc3VsdCBiZWNhdXNlXG4gICAgICAgIC8vIGNhbm9uaWNhbElkIHZhbHVlcyBhcmUgbm90IHJlcXVpcmVkIHRvIGJlIHVuaXF1ZSBwZXIgdGFyZ2V0LiBUaGlzIHF1ZXJ5XG4gICAgICAgIC8vIGRlcGVuZHMgb24gdGhlIHF1ZXJ5VGFyZ2V0cyBpbmRleCB0byBiZSBlZmZpY2llbnQuXG4gICAgICAgIGNvbnN0IGNhbm9uaWNhbElkID0gY2Fub25pZnlUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbY2Fub25pY2FsSWQsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sIFtjYW5vbmljYWxJZCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGFyZ2V0c1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoeyByYW5nZSwgaW5kZXg6IERiVGFyZ2V0UXVlcnlUYXJnZXRzSW5kZXhOYW1lIH0sIChrZXksIHZhbHVlLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb3VuZCA9IGZyb21EYlRhcmdldCh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBBZnRlciBmaW5kaW5nIGEgcG90ZW50aWFsIG1hdGNoLCBjaGVjayB0aGF0IHRoZSB0YXJnZXQgaXNcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGVxdWFsIHRvIHRoZSByZXF1ZXN0ZWQgdGFyZ2V0LlxuICAgICAgICAgICAgaWYgKHRhcmdldEVxdWFscyh0YXJnZXQsIGZvdW5kLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmb3VuZDtcbiAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHJlc3VsdCk7XG4gICAgfVxuICAgIGFkZE1hdGNoaW5nS2V5cyh0eG4sIGtleXMsIHRhcmdldElkKSB7XG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogVGhlIHJldmVyc2UgaW5kZXggKGRvY3VtZW50c1RhcmdldHMpIGlzIG1haW50YWluZWQgYnlcbiAgICAgICAgLy8gSW5kZXhlZERiLlxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBjb25zdCBzdG9yZSA9IGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZW5jb2RlUmVzb3VyY2VQYXRoKGtleS5wYXRoKTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goc3RvcmUucHV0KHsgdGFyZ2V0SWQsIHBhdGggfSkpO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnJlZmVyZW5jZURlbGVnYXRlLmFkZFJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XG4gICAgfVxuICAgIHJlbW92ZU1hdGNoaW5nS2V5cyh0eG4sIGtleXMsIHRhcmdldElkKSB7XG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogVGhlIHJldmVyc2UgaW5kZXggKGRvY3VtZW50c1RhcmdldHMpIGlzIG1haW50YWluZWQgYnlcbiAgICAgICAgLy8gSW5kZXhlZERiLlxuICAgICAgICBjb25zdCBzdG9yZSA9IGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGtleXMsIChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBlbmNvZGVSZXNvdXJjZVBhdGgoa2V5LnBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKFtcbiAgICAgICAgICAgICAgICBzdG9yZS5kZWxldGUoW3RhcmdldElkLCBwYXRoXSksXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZS5yZW1vdmVSZWZlcmVuY2UodHhuLCB0YXJnZXRJZCwga2V5KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0eG4sIHRhcmdldElkKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pO1xuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0YXJnZXRJZF0sIFt0YXJnZXRJZCArIDFdLCBcbiAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlLmRlbGV0ZShyYW5nZSk7XG4gICAgfVxuICAgIGdldE1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0SWQpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGFyZ2V0SWRdLCBbdGFyZ2V0SWQgKyAxXSwgXG4gICAgICAgIC8qbG93ZXJPcGVuPSovIGZhbHNlLCBcbiAgICAgICAgLyp1cHBlck9wZW49Ki8gdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IHJhbmdlLCBrZXlzT25seTogdHJ1ZSB9LCAoa2V5LCBfLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZGVjb2RlUmVzb3VyY2VQYXRoKGtleVsxXSk7XG4gICAgICAgICAgICBjb25zdCBkb2NLZXkgPSBuZXcgRG9jdW1lbnRLZXkocGF0aCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGRvY0tleSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiByZXN1bHQpO1xuICAgIH1cbiAgICBjb250YWluc0tleSh0eG4sIGtleSkge1xuICAgICAgICBjb25zdCBwYXRoID0gZW5jb2RlUmVzb3VyY2VQYXRoKGtleS5wYXRoKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbcGF0aF0sIFtpbW1lZGlhdGVTdWNjZXNzb3IocGF0aCldLCBcbiAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKVxuICAgICAgICAgICAgLml0ZXJhdGUoe1xuICAgICAgICAgICAgaW5kZXg6IERiVGFyZ2V0RG9jdW1lbnREb2N1bWVudFRhcmdldHNJbmRleCxcbiAgICAgICAgICAgIGtleXNPbmx5OiB0cnVlLFxuICAgICAgICAgICAgcmFuZ2VcbiAgICAgICAgfSwgKFt0YXJnZXRJZCwgcGF0aF0sIF8sIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIC8vIEhhdmluZyBhIHNlbnRpbmVsIHJvdyBmb3IgYSBkb2N1bWVudCBkb2VzIG5vdCBjb3VudCBhcyBjb250YWluaW5nIHRoYXQgZG9jdW1lbnQ7XG4gICAgICAgICAgICAvLyBGb3IgdGhlIHRhcmdldCBjYWNoZSwgY29udGFpbmluZyB0aGUgZG9jdW1lbnQgbWVhbnMgdGhlIGRvY3VtZW50IGlzIHBhcnQgb2Ygc29tZVxuICAgICAgICAgICAgLy8gdGFyZ2V0LlxuICAgICAgICAgICAgaWYgKHRhcmdldElkICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNvdW50ID4gMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIGEgVGFyZ2V0RGF0YSBlbnRyeSBieSB0YXJnZXQgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0SWQgLSBUaGUgdGFyZ2V0IElEIG9mIHRoZSBUYXJnZXREYXRhIGVudHJ5IHRvIGxvb2sgdXAuXG4gICAgICogQHJldHVybnMgVGhlIGNhY2hlZCBUYXJnZXREYXRhIGVudHJ5LCBvciBudWxsIGlmIHRoZSBjYWNoZSBoYXMgbm8gZW50cnkgZm9yXG4gICAgICogdGhlIHRhcmdldC5cbiAgICAgKi9cbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxuICAgIGdldFRhcmdldERhdGFGb3JUYXJnZXQodHJhbnNhY3Rpb24sIHRhcmdldElkKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRzU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuZ2V0KHRhcmdldElkKVxuICAgICAgICAgICAgLm5leHQoZm91bmQgPT4ge1xuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYlRhcmdldChmb3VuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIHF1ZXJpZXMgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiB0YXJnZXRzU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJUYXJnZXRTdG9yZSk7XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgdGFyZ2V0IGdsb2JhbHMgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBnbG9iYWxUYXJnZXRTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYlRhcmdldEdsb2JhbFN0b3JlKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBkb2N1bWVudCB0YXJnZXQgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBkb2N1bWVudFRhcmdldFN0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiVGFyZ2V0RG9jdW1lbnRTdG9yZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBHQ19ESURfTk9UX1JVTiA9IHtcbiAgICBkaWRSdW46IGZhbHNlLFxuICAgIHNlcXVlbmNlTnVtYmVyc0NvbGxlY3RlZDogMCxcbiAgICB0YXJnZXRzUmVtb3ZlZDogMCxcbiAgICBkb2N1bWVudHNSZW1vdmVkOiAwXG59O1xuY29uc3QgTFJVX0NPTExFQ1RJT05fRElTQUJMRUQgPSAtMTtcbmNvbnN0IExSVV9ERUZBVUxUX0NBQ0hFX1NJWkVfQllURVMgPSA0MCAqIDEwMjQgKiAxMDI0O1xuY2xhc3MgTHJ1UGFyYW1zIHtcbiAgICBzdGF0aWMgd2l0aENhY2hlU2l6ZShjYWNoZVNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMcnVQYXJhbXMoY2FjaGVTaXplLCBMcnVQYXJhbXMuREVGQVVMVF9DT0xMRUNUSU9OX1BFUkNFTlRJTEUsIExydVBhcmFtcy5ERUZBVUxUX01BWF9TRVFVRU5DRV9OVU1CRVJTX1RPX0NPTExFQ1QpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBXaGVuIHdlIGF0dGVtcHQgdG8gY29sbGVjdCwgd2Ugd2lsbCBvbmx5IGRvIHNvIGlmIHRoZSBjYWNoZSBzaXplIGlzIGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAgLy8gdGhyZXNob2xkLiBQYXNzaW5nIGBDT0xMRUNUSU9OX0RJU0FCTEVEYCBoZXJlIHdpbGwgY2F1c2UgY29sbGVjdGlvbiB0byBhbHdheXMgYmUgc2tpcHBlZC5cbiAgICBjYWNoZVNpemVDb2xsZWN0aW9uVGhyZXNob2xkLCBcbiAgICAvLyBUaGUgcGVyY2VudGFnZSBvZiBzZXF1ZW5jZSBudW1iZXJzIHRoYXQgd2Ugd2lsbCBhdHRlbXB0IHRvIGNvbGxlY3RcbiAgICBwZXJjZW50aWxlVG9Db2xsZWN0LCBcbiAgICAvLyBBIGNhcCBvbiB0aGUgdG90YWwgbnVtYmVyIG9mIHNlcXVlbmNlIG51bWJlcnMgdGhhdCB3aWxsIGJlIGNvbGxlY3RlZC4gVGhpcyBwcmV2ZW50c1xuICAgIC8vIHVzIGZyb20gY29sbGVjdGluZyBhIGh1Z2UgbnVtYmVyIG9mIHNlcXVlbmNlIG51bWJlcnMgaWYgdGhlIGNhY2hlIGhhcyBncm93biB2ZXJ5IGxhcmdlLlxuICAgIG1heGltdW1TZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QpIHtcbiAgICAgICAgdGhpcy5jYWNoZVNpemVDb2xsZWN0aW9uVGhyZXNob2xkID0gY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZDtcbiAgICAgICAgdGhpcy5wZXJjZW50aWxlVG9Db2xsZWN0ID0gcGVyY2VudGlsZVRvQ29sbGVjdDtcbiAgICAgICAgdGhpcy5tYXhpbXVtU2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0ID0gbWF4aW11bVNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdDtcbiAgICB9XG59XG5McnVQYXJhbXMuREVGQVVMVF9DT0xMRUNUSU9OX1BFUkNFTlRJTEUgPSAxMDtcbkxydVBhcmFtcy5ERUZBVUxUX01BWF9TRVFVRU5DRV9OVU1CRVJTX1RPX0NPTExFQ1QgPSAxMDAwO1xuTHJ1UGFyYW1zLkRFRkFVTFQgPSBuZXcgTHJ1UGFyYW1zKExSVV9ERUZBVUxUX0NBQ0hFX1NJWkVfQllURVMsIExydVBhcmFtcy5ERUZBVUxUX0NPTExFQ1RJT05fUEVSQ0VOVElMRSwgTHJ1UGFyYW1zLkRFRkFVTFRfTUFYX1NFUVVFTkNFX05VTUJFUlNfVE9fQ09MTEVDVCk7XG5McnVQYXJhbXMuRElTQUJMRUQgPSBuZXcgTHJ1UGFyYW1zKExSVV9DT0xMRUNUSU9OX0RJU0FCTEVELCAwLCAwKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckZSA9ICdMcnVHYXJiYWdlQ29sbGVjdG9yJztcbmNvbnN0IExSVV9NSU5JTVVNX0NBQ0hFX1NJWkVfQllURVMgPSAxICogMTAyNCAqIDEwMjQ7XG4vKiogSG93IGxvbmcgd2Ugd2FpdCB0byB0cnkgcnVubmluZyBMUlUgR0MgYWZ0ZXIgU0RLIGluaXRpYWxpemF0aW9uLiAqL1xuY29uc3QgSU5JVElBTF9HQ19ERUxBWV9NUyA9IDEgKiA2MCAqIDEwMDA7XG4vKiogTWluaW11bSBhbW91bnQgb2YgdGltZSBiZXR3ZWVuIEdDIGNoZWNrcywgYWZ0ZXIgdGhlIGZpcnN0IG9uZS4gKi9cbmNvbnN0IFJFR1VMQVJfR0NfREVMQVlfTVMgPSA1ICogNjAgKiAxMDAwO1xuZnVuY3Rpb24gYnVmZmVyRW50cnlDb21wYXJhdG9yKFthU2VxdWVuY2UsIGFJbmRleF0sIFtiU2VxdWVuY2UsIGJJbmRleF0pIHtcbiAgICBjb25zdCBzZXFDbXAgPSBwcmltaXRpdmVDb21wYXJhdG9yKGFTZXF1ZW5jZSwgYlNlcXVlbmNlKTtcbiAgICBpZiAoc2VxQ21wID09PSAwKSB7XG4gICAgICAgIC8vIFRoaXMgb3JkZXIgZG9lc24ndCBtYXR0ZXIsIGJ1dCB3ZSBjYW4gYmlhcyBhZ2FpbnN0IGNodXJuIGJ5IHNvcnRpbmdcbiAgICAgICAgLy8gZW50cmllcyBjcmVhdGVkIGVhcmxpZXIgYXMgbGVzcyB0aGFuIG5ld2VyIGVudHJpZXMuXG4gICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGFJbmRleCwgYkluZGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzZXFDbXA7XG4gICAgfVxufVxuLyoqXG4gKiBVc2VkIHRvIGNhbGN1bGF0ZSB0aGUgbnRoIHNlcXVlbmNlIG51bWJlci4gS2VlcHMgYSByb2xsaW5nIGJ1ZmZlciBvZiB0aGVcbiAqIGxvd2VzdCBuIHZhbHVlcyBwYXNzZWQgdG8gYGFkZEVsZW1lbnRgLCBhbmQgZmluYWxseSByZXBvcnRzIHRoZSBsYXJnZXN0IG9mXG4gKiB0aGVtIGluIGBtYXhWYWx1ZWAuXG4gKi9cbmNsYXNzIFJvbGxpbmdTZXF1ZW5jZU51bWJlckJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IobWF4RWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5tYXhFbGVtZW50cyA9IG1heEVsZW1lbnRzO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBTb3J0ZWRTZXQoYnVmZmVyRW50cnlDb21wYXJhdG9yKTtcbiAgICAgICAgdGhpcy5wcmV2aW91c0luZGV4ID0gMDtcbiAgICB9XG4gICAgbmV4dEluZGV4KCkge1xuICAgICAgICByZXR1cm4gKyt0aGlzLnByZXZpb3VzSW5kZXg7XG4gICAgfVxuICAgIGFkZEVsZW1lbnQoc2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBbc2VxdWVuY2VOdW1iZXIsIHRoaXMubmV4dEluZGV4KCldO1xuICAgICAgICBpZiAodGhpcy5idWZmZXIuc2l6ZSA8IHRoaXMubWF4RWxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuYWRkKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hlc3RWYWx1ZSA9IHRoaXMuYnVmZmVyLmxhc3QoKTtcbiAgICAgICAgICAgIGlmIChidWZmZXJFbnRyeUNvbXBhcmF0b3IoZW50cnksIGhpZ2hlc3RWYWx1ZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5kZWxldGUoaGlnaGVzdFZhbHVlKS5hZGQoZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgLy8gR3VhcmFudGVlZCB0byBiZSBub24tZW1wdHkuIElmIHdlIGRlY2lkZSB3ZSBhcmUgbm90IGNvbGxlY3RpbmcgYW55XG4gICAgICAgIC8vIHNlcXVlbmNlIG51bWJlcnMsIG50aFNlcXVlbmNlTnVtYmVyIGJlbG93IHNob3J0LWNpcmN1aXRzLiBJZiB3ZSBoYXZlXG4gICAgICAgIC8vIGRlY2lkZWQgdGhhdCB3ZSBhcmUgY29sbGVjdGluZyBuIHNlcXVlbmNlIG51bWJlcnMsIGl0J3MgYmVjYXVzZSBuIGlzIHNvbWVcbiAgICAgICAgLy8gcGVyY2VudGFnZSBvZiB0aGUgZXhpc3Rpbmcgc2VxdWVuY2UgbnVtYmVycy4gVGhhdCBtZWFucyB3ZSBzaG91bGQgbmV2ZXJcbiAgICAgICAgLy8gYmUgaW4gYSBzaXR1YXRpb24gd2hlcmUgd2UgYXJlIGNvbGxlY3Rpbmcgc2VxdWVuY2UgbnVtYmVycyBidXQgZG9uJ3RcbiAgICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhbnkuXG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sYXN0KClbMF07XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgc2NoZWR1bGluZyBvZiBMUlUgZ2FyYmFnZSBjb2xsZWN0aW9uLiBJdCBoYW5kbGVzIGNoZWNraW5nXG4gKiB3aGV0aGVyIG9yIG5vdCBHQyBpcyBlbmFibGVkLCBhcyB3ZWxsIGFzIHdoaWNoIGRlbGF5IHRvIHVzZSBiZWZvcmUgdGhlIG5leHQgcnVuLlxuICovXG5jbGFzcyBMcnVTY2hlZHVsZXIge1xuICAgIGNvbnN0cnVjdG9yKGdhcmJhZ2VDb2xsZWN0b3IsIGFzeW5jUXVldWUsIGxvY2FsU3RvcmUpIHtcbiAgICAgICAgdGhpcy5nYXJiYWdlQ29sbGVjdG9yID0gZ2FyYmFnZUNvbGxlY3RvcjtcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcbiAgICAgICAgdGhpcy5sb2NhbFN0b3JlID0gbG9jYWxTdG9yZTtcbiAgICAgICAgdGhpcy5nY1Rhc2sgPSBudWxsO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2FyYmFnZUNvbGxlY3Rvci5wYXJhbXMuY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZCAhPT1cbiAgICAgICAgICAgIExSVV9DT0xMRUNUSU9OX0RJU0FCTEVEKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlR0MoSU5JVElBTF9HQ19ERUxBWV9NUyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2NUYXNrKSB7XG4gICAgICAgICAgICB0aGlzLmdjVGFzay5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuZ2NUYXNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2NUYXNrICE9PSBudWxsO1xuICAgIH1cbiAgICBzY2hlZHVsZUdDKGRlbGF5KSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckZSwgYEdhcmJhZ2UgY29sbGVjdGlvbiBzY2hlZHVsZWQgaW4gJHtkZWxheX1tc2ApO1xuICAgICAgICB0aGlzLmdjVGFzayA9IHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheShcImxydV9nYXJiYWdlX2NvbGxlY3Rpb25cIiAvKiBUaW1lcklkLkxydUdhcmJhZ2VDb2xsZWN0aW9uICovLCBkZWxheSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5nY1Rhc2sgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmxvY2FsU3RvcmUuY29sbGVjdEdhcmJhZ2UodGhpcy5nYXJiYWdlQ29sbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGUsICdJZ25vcmluZyBJbmRleGVkREIgZXJyb3IgZHVyaW5nIGdhcmJhZ2UgY29sbGVjdGlvbjogJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zY2hlZHVsZUdDKFJFR1VMQVJfR0NfREVMQVlfTVMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEltcGxlbWVudHMgdGhlIHN0ZXBzIGZvciBMUlUgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICovXG5jbGFzcyBMcnVHYXJiYWdlQ29sbGVjdG9ySW1wbCB7XG4gICAgY29uc3RydWN0b3IoZGVsZWdhdGUsIHBhcmFtcykge1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIH1cbiAgICBjYWxjdWxhdGVUYXJnZXRDb3VudCh0eG4sIHBlcmNlbnRpbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuZ2V0U2VxdWVuY2VOdW1iZXJDb3VudCh0eG4pLm5leHQodGFyZ2V0Q291bnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHBlcmNlbnRpbGUgLyAxMDAuMCkgKiB0YXJnZXRDb3VudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBudGhTZXF1ZW5jZU51bWJlcih0eG4sIG4pIHtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgUm9sbGluZ1NlcXVlbmNlTnVtYmVyQnVmZmVyKG4pO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZVxuICAgICAgICAgICAgLmZvckVhY2hUYXJnZXQodHhuLCB0YXJnZXQgPT4gYnVmZmVyLmFkZEVsZW1lbnQodGFyZ2V0LnNlcXVlbmNlTnVtYmVyKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmZvckVhY2hPcnBoYW5lZERvY3VtZW50U2VxdWVuY2VOdW1iZXIodHhuLCBzZXF1ZW5jZU51bWJlciA9PiBidWZmZXIuYWRkRWxlbWVudChzZXF1ZW5jZU51bWJlcikpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gYnVmZmVyLm1heFZhbHVlKTtcbiAgICB9XG4gICAgcmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5yZW1vdmVUYXJnZXRzKHR4biwgdXBwZXJCb3VuZCwgYWN0aXZlVGFyZ2V0SWRzKTtcbiAgICB9XG4gICAgcmVtb3ZlT3JwaGFuZWREb2N1bWVudHModHhuLCB1cHBlckJvdW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnJlbW92ZU9ycGhhbmVkRG9jdW1lbnRzKHR4biwgdXBwZXJCb3VuZCk7XG4gICAgfVxuICAgIGNvbGxlY3QodHhuLCBhY3RpdmVUYXJnZXRJZHMpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGQgPT09IExSVV9DT0xMRUNUSU9OX0RJU0FCTEVEKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZygnTHJ1R2FyYmFnZUNvbGxlY3RvcicsICdHYXJiYWdlIGNvbGxlY3Rpb24gc2tpcHBlZDsgZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShHQ19ESURfTk9UX1JVTik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FjaGVTaXplKHR4bikubmV4dChjYWNoZVNpemUgPT4ge1xuICAgICAgICAgICAgaWYgKGNhY2hlU2l6ZSA8IHRoaXMucGFyYW1zLmNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnTHJ1R2FyYmFnZUNvbGxlY3RvcicsIGBHYXJiYWdlIGNvbGxlY3Rpb24gc2tpcHBlZDsgQ2FjaGUgc2l6ZSAke2NhY2hlU2l6ZX0gYCArXG4gICAgICAgICAgICAgICAgICAgIGBpcyBsb3dlciB0aGFuIHRocmVzaG9sZCAke3RoaXMucGFyYW1zLmNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEdDX0RJRF9OT1RfUlVOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVuR2FyYmFnZUNvbGxlY3Rpb24odHhuLCBhY3RpdmVUYXJnZXRJZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q2FjaGVTaXplKHR4bikge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5nZXRDYWNoZVNpemUodHhuKTtcbiAgICB9XG4gICAgcnVuR2FyYmFnZUNvbGxlY3Rpb24odHhuLCBhY3RpdmVUYXJnZXRJZHMpIHtcbiAgICAgICAgbGV0IHVwcGVyQm91bmRTZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgbGV0IHNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCwgdGFyZ2V0c1JlbW92ZWQ7XG4gICAgICAgIC8vIFRpbWVzdGFtcHMgZm9yIHZhcmlvdXMgcGllY2VzIG9mIHRoZSBwcm9jZXNzXG4gICAgICAgIGxldCBjb3VudGVkVGFyZ2V0c1RzLCBmb3VuZFVwcGVyQm91bmRUcywgcmVtb3ZlZFRhcmdldHNUcywgcmVtb3ZlZERvY3VtZW50c1RzO1xuICAgICAgICBjb25zdCBzdGFydFRzID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlVGFyZ2V0Q291bnQodHhuLCB0aGlzLnBhcmFtcy5wZXJjZW50aWxlVG9Db2xsZWN0KVxuICAgICAgICAgICAgLm5leHQoc2VxdWVuY2VOdW1iZXJzID0+IHtcbiAgICAgICAgICAgIC8vIENhcCBhdCB0aGUgY29uZmlndXJlZCBtYXhcbiAgICAgICAgICAgIGlmIChzZXF1ZW5jZU51bWJlcnMgPiB0aGlzLnBhcmFtcy5tYXhpbXVtU2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0KSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0xydUdhcmJhZ2VDb2xsZWN0b3InLCAnQ2FwcGluZyBzZXF1ZW5jZSBudW1iZXJzIHRvIGNvbGxlY3QgZG93biAnICtcbiAgICAgICAgICAgICAgICAgICAgYHRvIHRoZSBtYXhpbXVtIG9mICR7dGhpcy5wYXJhbXMubWF4aW11bVNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdH0gYCArXG4gICAgICAgICAgICAgICAgICAgIGBmcm9tICR7c2VxdWVuY2VOdW1iZXJzfWApO1xuICAgICAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zLm1heGltdW1TZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QgPSBzZXF1ZW5jZU51bWJlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVkVGFyZ2V0c1RzID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm50aFNlcXVlbmNlTnVtYmVyKHR4biwgc2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KHVwcGVyQm91bmQgPT4ge1xuICAgICAgICAgICAgdXBwZXJCb3VuZFNlcXVlbmNlTnVtYmVyID0gdXBwZXJCb3VuZDtcbiAgICAgICAgICAgIGZvdW5kVXBwZXJCb3VuZFRzID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kU2VxdWVuY2VOdW1iZXIsIGFjdGl2ZVRhcmdldElkcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChudW1UYXJnZXRzUmVtb3ZlZCA9PiB7XG4gICAgICAgICAgICB0YXJnZXRzUmVtb3ZlZCA9IG51bVRhcmdldHNSZW1vdmVkO1xuICAgICAgICAgICAgcmVtb3ZlZFRhcmdldHNUcyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVPcnBoYW5lZERvY3VtZW50cyh0eG4sIHVwcGVyQm91bmRTZXF1ZW5jZU51bWJlcik7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudHNSZW1vdmVkID0+IHtcbiAgICAgICAgICAgIHJlbW92ZWREb2N1bWVudHNUcyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBpZiAoZ2V0TG9nTGV2ZWwoKSA8PSBMb2dMZXZlbC5ERUJVRykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2MgPSAnTFJVIEdhcmJhZ2UgQ29sbGVjdGlvblxcbicgK1xuICAgICAgICAgICAgICAgICAgICBgXFx0Q291bnRlZCB0YXJnZXRzIGluICR7Y291bnRlZFRhcmdldHNUcyAtIHN0YXJ0VHN9bXNcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYFxcdERldGVybWluZWQgbGVhc3QgcmVjZW50bHkgdXNlZCAke3NlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdH0gaW4gYCArXG4gICAgICAgICAgICAgICAgICAgIGAke2ZvdW5kVXBwZXJCb3VuZFRzIC0gY291bnRlZFRhcmdldHNUc31tc1xcbmAgK1xuICAgICAgICAgICAgICAgICAgICBgXFx0UmVtb3ZlZCAke3RhcmdldHNSZW1vdmVkfSB0YXJnZXRzIGluIGAgK1xuICAgICAgICAgICAgICAgICAgICBgJHtyZW1vdmVkVGFyZ2V0c1RzIC0gZm91bmRVcHBlckJvdW5kVHN9bXNcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYFxcdFJlbW92ZWQgJHtkb2N1bWVudHNSZW1vdmVkfSBkb2N1bWVudHMgaW4gYCArXG4gICAgICAgICAgICAgICAgICAgIGAke3JlbW92ZWREb2N1bWVudHNUcyAtIHJlbW92ZWRUYXJnZXRzVHN9bXNcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYFRvdGFsIER1cmF0aW9uOiAke3JlbW92ZWREb2N1bWVudHNUcyAtIHN0YXJ0VHN9bXNgO1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdMcnVHYXJiYWdlQ29sbGVjdG9yJywgZGVzYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgIGRpZFJ1bjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZU51bWJlcnNDb2xsZWN0ZWQ6IHNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCxcbiAgICAgICAgICAgICAgICB0YXJnZXRzUmVtb3ZlZCxcbiAgICAgICAgICAgICAgICBkb2N1bWVudHNSZW1vdmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3THJ1R2FyYmFnZUNvbGxlY3RvcihkZWxlZ2F0ZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBMcnVHYXJiYWdlQ29sbGVjdG9ySW1wbChkZWxlZ2F0ZSwgcGFyYW1zKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBQcm92aWRlcyBMUlUgZnVuY3Rpb25hbGl0eSBmb3IgSW5kZXhlZERCIHBlcnNpc3RlbmNlLiAqL1xuY2xhc3MgSW5kZXhlZERiTHJ1RGVsZWdhdGVJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihkYiwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgdGhpcy5nYXJiYWdlQ29sbGVjdG9yID0gbmV3THJ1R2FyYmFnZUNvbGxlY3Rvcih0aGlzLCBwYXJhbXMpO1xuICAgIH1cbiAgICBnZXRTZXF1ZW5jZU51bWJlckNvdW50KHR4bikge1xuICAgICAgICBjb25zdCBkb2NDb3VudFByb21pc2UgPSB0aGlzLm9ycGhhbmVkRG9jdW1lbnRDb3VudCh0eG4pO1xuICAgICAgICBjb25zdCB0YXJnZXRDb3VudFByb21pc2UgPSB0aGlzLmRiLmdldFRhcmdldENhY2hlKCkuZ2V0VGFyZ2V0Q291bnQodHhuKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldENvdW50UHJvbWlzZS5uZXh0KHRhcmdldENvdW50ID0+IGRvY0NvdW50UHJvbWlzZS5uZXh0KGRvY0NvdW50ID0+IHRhcmdldENvdW50ICsgZG9jQ291bnQpKTtcbiAgICB9XG4gICAgb3JwaGFuZWREb2N1bWVudENvdW50KHR4bikge1xuICAgICAgICBsZXQgb3JwaGFuZWRDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzLmZvckVhY2hPcnBoYW5lZERvY3VtZW50U2VxdWVuY2VOdW1iZXIodHhuLCBfID0+IHtcbiAgICAgICAgICAgIG9ycGhhbmVkQ291bnQrKztcbiAgICAgICAgfSkubmV4dCgoKSA9PiBvcnBoYW5lZENvdW50KTtcbiAgICB9XG4gICAgZm9yRWFjaFRhcmdldCh0eG4sIGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGIuZ2V0VGFyZ2V0Q2FjaGUoKS5mb3JFYWNoVGFyZ2V0KHR4biwgZik7XG4gICAgfVxuICAgIGZvckVhY2hPcnBoYW5lZERvY3VtZW50U2VxdWVuY2VOdW1iZXIodHhuLCBmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvckVhY2hPcnBoYW5lZERvY3VtZW50KHR4biwgKGRvY0tleSwgc2VxdWVuY2VOdW1iZXIpID0+IGYoc2VxdWVuY2VOdW1iZXIpKTtcbiAgICB9XG4gICAgYWRkUmVmZXJlbmNlKHR4biwgdGFyZ2V0SWQsIGtleSkge1xuICAgICAgICByZXR1cm4gd3JpdGVTZW50aW5lbEtleSh0eG4sIGtleSk7XG4gICAgfVxuICAgIHJlbW92ZVJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlU2VudGluZWxLZXkodHhuLCBrZXkpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXRzKHR4biwgdXBwZXJCb3VuZCwgYWN0aXZlVGFyZ2V0SWRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRiLmdldFRhcmdldENhY2hlKCkucmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcyk7XG4gICAgfVxuICAgIG1hcmtQb3RlbnRpYWxseU9ycGhhbmVkKHR4biwga2V5KSB7XG4gICAgICAgIHJldHVybiB3cml0ZVNlbnRpbmVsS2V5KHR4biwga2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFueXRoaW5nIHdvdWxkIHByZXZlbnQgdGhpcyBkb2N1bWVudCBmcm9tIGJlaW5nIGdhcmJhZ2VcbiAgICAgKiBjb2xsZWN0ZWQsIGdpdmVuIHRoYXQgdGhlIGRvY3VtZW50IGluIHF1ZXN0aW9uIGlzIG5vdCBwcmVzZW50IGluIGFueVxuICAgICAqIHRhcmdldHMgYW5kIGhhcyBhIHNlcXVlbmNlIG51bWJlciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHVwcGVyIGJvdW5kIGZvclxuICAgICAqIHRoZSBjb2xsZWN0aW9uIHJ1bi5cbiAgICAgKi9cbiAgICBpc1Bpbm5lZCh0eG4sIGRvY0tleSkge1xuICAgICAgICByZXR1cm4gbXV0YXRpb25RdWV1ZXNDb250YWluS2V5KHR4biwgZG9jS2V5KTtcbiAgICB9XG4gICAgcmVtb3ZlT3JwaGFuZWREb2N1bWVudHModHhuLCB1cHBlckJvdW5kKSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50Q2FjaGUgPSB0aGlzLmRiLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKTtcbiAgICAgICAgY29uc3QgY2hhbmdlQnVmZmVyID0gZG9jdW1lbnRDYWNoZS5uZXdDaGFuZ2VCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgbGV0IGRvY3VtZW50Q291bnQgPSAwO1xuICAgICAgICBjb25zdCBpdGVyYXRpb24gPSB0aGlzLmZvckVhY2hPcnBoYW5lZERvY3VtZW50KHR4biwgKGRvY0tleSwgc2VxdWVuY2VOdW1iZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChzZXF1ZW5jZU51bWJlciA8PSB1cHBlckJvdW5kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuaXNQaW5uZWQodHhuLCBkb2NLZXkpLm5leHQoaXNQaW5uZWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUGlubmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdXIgc2l6ZSBhY2NvdW50aW5nIHJlcXVpcmVzIHVzIHRvIHJlYWQgYWxsIGRvY3VtZW50cyBiZWZvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92aW5nIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlQnVmZmVyLmdldEVudHJ5KHR4biwgZG9jS2V5KS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VCdWZmZXIucmVtb3ZlRW50cnkoZG9jS2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudFRhcmdldFN0b3JlKHR4bikuZGVsZXRlKHNlbnRpbmVsS2V5JDEoZG9jS2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlcmF0aW9uXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBjaGFuZ2VCdWZmZXIuYXBwbHkodHhuKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGRvY3VtZW50Q291bnQpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXQodHhuLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWQgPSB0YXJnZXREYXRhLndpdGhTZXF1ZW5jZU51bWJlcih0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGIuZ2V0VGFyZ2V0Q2FjaGUoKS51cGRhdGVUYXJnZXREYXRhKHR4biwgdXBkYXRlZCk7XG4gICAgfVxuICAgIHVwZGF0ZUxpbWJvRG9jdW1lbnQodHhuLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlU2VudGluZWxLZXkodHhuLCBrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIHByb3ZpZGVkIGZ1bmN0aW9uIGZvciBlYWNoIGRvY3VtZW50IGluIHRoZSBjYWNoZSB0aGF0IGlzICdvcnBoYW5lZCcuIE9ycGhhbmVkXG4gICAgICogbWVhbnMgbm90IGEgcGFydCBvZiBhbnkgdGFyZ2V0LCBzbyB0aGUgb25seSBlbnRyeSBpbiB0aGUgdGFyZ2V0LWRvY3VtZW50IGluZGV4IGZvclxuICAgICAqIHRoYXQgZG9jdW1lbnQgd2lsbCBiZSB0aGUgc2VudGluZWwgcm93ICh0YXJnZXRJZCAwKSwgd2hpY2ggd2lsbCBhbHNvIGhhdmUgdGhlIHNlcXVlbmNlXG4gICAgICogbnVtYmVyIGZvciB0aGUgbGFzdCB0aW1lIHRoZSBkb2N1bWVudCB3YXMgYWNjZXNzZWQuXG4gICAgICovXG4gICAgZm9yRWFjaE9ycGhhbmVkRG9jdW1lbnQodHhuLCBmKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pO1xuICAgICAgICBsZXQgbmV4dFRvUmVwb3J0ID0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRDtcbiAgICAgICAgbGV0IG5leHRQYXRoO1xuICAgICAgICByZXR1cm4gc3RvcmVcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcbiAgICAgICAgICAgIGluZGV4OiBEYlRhcmdldERvY3VtZW50RG9jdW1lbnRUYXJnZXRzSW5kZXhcbiAgICAgICAgfSwgKFt0YXJnZXRJZCwgZG9jS2V5XSwgeyBwYXRoLCBzZXF1ZW5jZU51bWJlciB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0SWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBuZXh0VG9SZXBvcnQgaXMgdmFsaWQsIHJlcG9ydCBpdCwgdGhpcyBpcyBhIG5ldyBrZXkgc28gdGhlXG4gICAgICAgICAgICAgICAgLy8gbGFzdCBvbmUgbXVzdCBub3QgYmUgYSBtZW1iZXIgb2YgYW55IHRhcmdldHMuXG4gICAgICAgICAgICAgICAgaWYgKG5leHRUb1JlcG9ydCAhPT0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCkge1xuICAgICAgICAgICAgICAgICAgICBmKG5ldyBEb2N1bWVudEtleShkZWNvZGVSZXNvdXJjZVBhdGgobmV4dFBhdGgpKSwgbmV4dFRvUmVwb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc2V0IG5leHRUb1JlcG9ydCB0byBiZSB0aGlzIHNlcXVlbmNlIG51bWJlci4gSXQncyB0aGUgbmV4dCBvbmUgd2VcbiAgICAgICAgICAgICAgICAvLyBtaWdodCByZXBvcnQsIGlmIHdlIGRvbid0IGZpbmQgYW55IHRhcmdldHMgZm9yIHRoaXMgZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBzZXF1ZW5jZSBudW1iZXIgbXVzdCBiZSBkZWZpbmVkIHdoZW4gdGhlIHRhcmdldElkXG4gICAgICAgICAgICAgICAgLy8gaXMgMC5cbiAgICAgICAgICAgICAgICBuZXh0VG9SZXBvcnQgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgICAgICBuZXh0UGF0aCA9IHBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgbmV4dFRvUmVwb3J0IHRvIGJlIGludmFsaWQsIHdlIGtub3cgd2UgZG9uJ3QgbmVlZCB0byByZXBvcnRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIG9uZSBzaW5jZSB3ZSBmb3VuZCBhIHRhcmdldCBmb3IgaXQuXG4gICAgICAgICAgICAgICAgbmV4dFRvUmVwb3J0ID0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIHJlcG9ydCBzZXF1ZW5jZSBudW1iZXJzIGFmdGVyIGdldHRpbmcgdG8gdGhlIG5leHQga2V5LCB3ZVxuICAgICAgICAgICAgLy8gbmVlZCB0byBjaGVjayBpZiB0aGUgbGFzdCBrZXkgd2UgaXRlcmF0ZWQgb3ZlciB3YXMgYW4gb3JwaGFuZWRcbiAgICAgICAgICAgIC8vIGRvY3VtZW50IGFuZCByZXBvcnQgaXQuXG4gICAgICAgICAgICBpZiAobmV4dFRvUmVwb3J0ICE9PSBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKSB7XG4gICAgICAgICAgICAgICAgZihuZXcgRG9jdW1lbnRLZXkoZGVjb2RlUmVzb3VyY2VQYXRoKG5leHRQYXRoKSksIG5leHRUb1JlcG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDYWNoZVNpemUodHhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRiLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKS5nZXRTaXplKHR4bik7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VudGluZWxLZXkkMShrZXkpIHtcbiAgICByZXR1cm4gWzAsIGVuY29kZVJlc291cmNlUGF0aChrZXkucGF0aCldO1xufVxuLyoqXG4gKiBAcmV0dXJucyBBIHZhbHVlIHN1aXRhYmxlIGZvciB3cml0aW5nIGEgc2VudGluZWwgcm93IGluIHRoZSB0YXJnZXQtZG9jdW1lbnRcbiAqIHN0b3JlLlxuICovXG5mdW5jdGlvbiBzZW50aW5lbFJvdyhrZXksIHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgcmV0dXJuIHsgdGFyZ2V0SWQ6IDAsIHBhdGg6IGVuY29kZVJlc291cmNlUGF0aChrZXkucGF0aCksIHNlcXVlbmNlTnVtYmVyIH07XG59XG5mdW5jdGlvbiB3cml0ZVNlbnRpbmVsS2V5KHR4biwga2V5KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKS5wdXQoc2VudGluZWxSb3coa2V5LCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGluLW1lbW9yeSBidWZmZXIgb2YgZW50cmllcyB0byBiZSB3cml0dGVuIHRvIGEgUmVtb3RlRG9jdW1lbnRDYWNoZS5cbiAqIEl0IGNhbiBiZSB1c2VkIHRvIGJhdGNoIHVwIGEgc2V0IG9mIGNoYW5nZXMgdG8gYmUgd3JpdHRlbiB0byB0aGUgY2FjaGUsIGJ1dFxuICogYWRkaXRpb25hbGx5IHN1cHBvcnRzIHJlYWRpbmcgZW50cmllcyBiYWNrIHdpdGggdGhlIGBnZXRFbnRyeSgpYCBtZXRob2QsXG4gKiBmYWxsaW5nIGJhY2sgdG8gdGhlIHVuZGVybHlpbmcgUmVtb3RlRG9jdW1lbnRDYWNoZSBpZiBubyBlbnRyeSBpc1xuICogYnVmZmVyZWQuXG4gKlxuICogRW50cmllcyBhZGRlZCB0byB0aGUgY2FjaGUgKm11c3QqIGJlIHJlYWQgZmlyc3QuIFRoaXMgaXMgdG8gZmFjaWxpdGF0ZVxuICogY2FsY3VsYXRpbmcgdGhlIHNpemUgZGVsdGEgb2YgdGhlIHBlbmRpbmcgY2hhbmdlcy5cbiAqXG4gKiBQT1JUSU5HIE5PVEU6IFRoaXMgY2xhc3Mgd2FzIGltcGxlbWVudGVkIHRoZW4gcmVtb3ZlZCBmcm9tIG90aGVyIHBsYXRmb3Jtcy5cbiAqIElmIGJ5dGUtY291bnRpbmcgZW5kcyB1cCBiZWluZyBuZWVkZWQgb24gdGhlIG90aGVyIHBsYXRmb3JtcywgY29uc2lkZXJcbiAqIHBvcnRpbmcgdGhpcyBjbGFzcyBhcyBwYXJ0IG9mIHRoYXQgaW1wbGVtZW50YXRpb24gd29yay5cbiAqL1xuY2xhc3MgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBBIG1hcHBpbmcgb2YgZG9jdW1lbnQga2V5IHRvIHRoZSBuZXcgY2FjaGUgZW50cnkgdGhhdCBzaG91bGQgYmUgd3JpdHRlbi5cbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IE9iamVjdE1hcChrZXkgPT4ga2V5LnRvU3RyaW5nKCksIChsLCByKSA9PiBsLmlzRXF1YWwocikpO1xuICAgICAgICB0aGlzLmNoYW5nZXNBcHBsaWVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1ZmZlcnMgYSBgUmVtb3RlRG9jdW1lbnRDYWNoZS5hZGRFbnRyeSgpYCBjYWxsLlxuICAgICAqXG4gICAgICogWW91IGNhbiBvbmx5IG1vZGlmeSBkb2N1bWVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiByZXRyaWV2ZWQgdmlhXG4gICAgICogYGdldEVudHJ5KCkvZ2V0RW50cmllcygpYCAoZW5mb3JjZWQgdmlhIEluZGV4ZWREYnMgYGFwcGx5KClgKS5cbiAgICAgKi9cbiAgICBhZGRFbnRyeShkb2N1bWVudCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLnNldChkb2N1bWVudC5rZXksIGRvY3VtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVmZmVycyBhIGBSZW1vdGVEb2N1bWVudENhY2hlLnJlbW92ZUVudHJ5KClgIGNhbGwuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG9ubHkgcmVtb3ZlIGRvY3VtZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHJldHJpZXZlZCB2aWFcbiAgICAgKiBgZ2V0RW50cnkoKS9nZXRFbnRyaWVzKClgIChlbmZvcmNlZCB2aWEgSW5kZXhlZERicyBgYXBwbHkoKWApLlxuICAgICAqL1xuICAgIHJlbW92ZUVudHJ5KGtleSwgcmVhZFRpbWUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RBcHBsaWVkKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5zZXQoa2V5LCBNdXRhYmxlRG9jdW1lbnQubmV3SW52YWxpZERvY3VtZW50KGtleSkuc2V0UmVhZFRpbWUocmVhZFRpbWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3MgdXAgYW4gZW50cnkgaW4gdGhlIGNhY2hlLiBUaGUgYnVmZmVyZWQgY2hhbmdlcyB3aWxsIGZpcnN0IGJlIGNoZWNrZWQsXG4gICAgICogYW5kIGlmIG5vIGJ1ZmZlcmVkIGNoYW5nZSBhcHBsaWVzLCB0aGlzIHdpbGwgZm9yd2FyZCB0b1xuICAgICAqIGBSZW1vdGVEb2N1bWVudENhY2hlLmdldEVudHJ5KClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIGluIHdoaWNoIHRvIHBlcmZvcm0gYW55IHBlcnNpc3RlbmNlXG4gICAgICogICAgIG9wZXJhdGlvbnMuXG4gICAgICogQHBhcmFtIGRvY3VtZW50S2V5IC0gVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gbG9vayB1cC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2FjaGVkIGRvY3VtZW50IG9yIGFuIGludmFsaWQgZG9jdW1lbnQgaWYgd2UgaGF2ZSBub3RoaW5nXG4gICAgICogY2FjaGVkLlxuICAgICAqL1xuICAgIGdldEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcbiAgICAgICAgY29uc3QgYnVmZmVyZWRFbnRyeSA9IHRoaXMuY2hhbmdlcy5nZXQoZG9jdW1lbnRLZXkpO1xuICAgICAgICBpZiAoYnVmZmVyZWRFbnRyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoYnVmZmVyZWRFbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rcyB1cCBzZXZlcmFsIGVudHJpZXMgaW4gdGhlIGNhY2hlLCBmb3J3YXJkaW5nIHRvXG4gICAgICogYFJlbW90ZURvY3VtZW50Q2FjaGUuZ2V0RW50cnkoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gaW4gd2hpY2ggdG8gcGVyZm9ybSBhbnkgcGVyc2lzdGVuY2VcbiAgICAgKiAgICAgb3BlcmF0aW9ucy5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRLZXlzIC0gVGhlIGtleXMgb2YgdGhlIGVudHJpZXMgdG8gbG9vayB1cC5cbiAgICAgKiBAcmV0dXJucyBBIG1hcCBvZiBjYWNoZWQgZG9jdW1lbnRzLCBpbmRleGVkIGJ5IGtleS4gSWYgYW4gZW50cnkgY2Fubm90IGJlXG4gICAgICogICAgIGZvdW5kLCB0aGUgY29ycmVzcG9uZGluZyBrZXkgd2lsbCBiZSBtYXBwZWQgdG8gYW4gaW52YWxpZCBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBnZXRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsRnJvbUNhY2hlKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGJ1ZmZlcmVkIGNoYW5nZXMgdG8gdGhlIHVuZGVybHlpbmcgUmVtb3RlRG9jdW1lbnRDYWNoZSwgdXNpbmdcbiAgICAgKiB0aGUgcHJvdmlkZWQgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgYXBwbHkodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RBcHBsaWVkKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlc0FwcGxpZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseUNoYW5nZXModHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICAvKiogSGVscGVyIHRvIGFzc2VydCB0aGlzLmNoYW5nZXMgaXMgbm90IG51bGwgICovXG4gICAgYXNzZXJ0Tm90QXBwbGllZCgpIHtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBSZW1vdGVEb2N1bWVudENhY2hlIGZvciBJbmRleGVkRGIuIFRvIGNvbnN0cnVjdCwgaW52b2tlXG4gKiBgbmV3SW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZSgpYC5cbiAqL1xuY2xhc3MgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICB9XG4gICAgc2V0SW5kZXhNYW5hZ2VyKGluZGV4TWFuYWdlcikge1xuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IGluZGV4TWFuYWdlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgc3VwcGxpZWQgZW50cmllcyB0byB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBBbGwgY2FsbHMgb2YgYGFkZEVudHJ5YCBhcmUgcmVxdWlyZWQgdG8gZ28gdGhyb3VnaCB0aGUgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgIHRvIGVuc3VyZSBwcm9wZXIgYWNjb3VudGluZyBvZiBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICBhZGRFbnRyeSh0cmFuc2FjdGlvbiwga2V5LCBkb2MpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRTdG9yZSA9IHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50U3RvcmUucHV0KGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBkb2N1bWVudCBmcm9tIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEFsbCBjYWxscyBvZiBgcmVtb3ZlRW50cnlgICBhcmUgcmVxdWlyZWQgdG8gZ28gdGhyb3VnaCB0aGUgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgIHRvIGVuc3VyZSBwcm9wZXIgYWNjb3VudGluZyBvZiBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICByZW1vdmVFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXksIHJlYWRUaW1lKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gc3RvcmUuZGVsZXRlKGRiUmVhZFRpbWVLZXkoZG9jdW1lbnRLZXksIHJlYWRUaW1lKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgY2FjaGUgc2l6ZS5cbiAgICAgKlxuICAgICAqIENhbGxlcnMgdG8gYGFkZEVudHJ5KClgIGFuZCBgcmVtb3ZlRW50cnkoKWAgKm11c3QqIGNhbGwgdGhpcyBhZnRlcndhcmRzIHRvIHVwZGF0ZSB0aGVcbiAgICAgKiBjYWNoZSdzIG1ldGFkYXRhLlxuICAgICAqL1xuICAgIHVwZGF0ZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBzaXplRGVsdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWV0YWRhdGEodHJhbnNhY3Rpb24pLm5leHQobWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgbWV0YWRhdGEuYnl0ZVNpemUgKz0gc2l6ZURlbHRhO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TWV0YWRhdGEodHJhbnNhY3Rpb24sIG1ldGFkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSkge1xuICAgICAgICBsZXQgZG9jID0gTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSk7XG4gICAgICAgIHJldHVybiByZW1vdGVEb2N1bWVudHNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcbiAgICAgICAgICAgIGluZGV4OiBEYlJlbW90ZURvY3VtZW50RG9jdW1lbnRLZXlJbmRleCxcbiAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KGRiS2V5KGRvY3VtZW50S2V5KSlcbiAgICAgICAgfSwgKF8sIGRiUmVtb3RlRG9jKSA9PiB7XG4gICAgICAgICAgICBkb2MgPSB0aGlzLm1heWJlRGVjb2RlRG9jdW1lbnQoZG9jdW1lbnRLZXksIGRiUmVtb3RlRG9jKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIGFuIGVudHJ5IGluIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb2N1bWVudEtleSAtIFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGxvb2sgdXAuXG4gICAgICogQHJldHVybnMgVGhlIGNhY2hlZCBkb2N1bWVudCBlbnRyeSBhbmQgaXRzIHNpemUuXG4gICAgICovXG4gICAgZ2V0U2l6ZWRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgICBkb2N1bWVudDogTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoe1xuICAgICAgICAgICAgaW5kZXg6IERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4LFxuICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLm9ubHkoZGJLZXkoZG9jdW1lbnRLZXkpKVxuICAgICAgICB9LCAoXywgZGJSZW1vdGVEb2MpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudDogdGhpcy5tYXliZURlY29kZURvY3VtZW50KGRvY3VtZW50S2V5LCBkYlJlbW90ZURvYyksXG4gICAgICAgICAgICAgICAgc2l6ZTogZGJEb2N1bWVudFNpemUoZGJSZW1vdGVEb2MpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZvckVhY2hEYkVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMsIChrZXksIGRiUmVtb3RlRG9jKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSB0aGlzLm1heWJlRGVjb2RlRG9jdW1lbnQoa2V5LCBkYlJlbW90ZURvYyk7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoa2V5LCBkb2MpO1xuICAgICAgICB9KS5uZXh0KCgpID0+IHJlc3VsdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rcyB1cCBzZXZlcmFsIGVudHJpZXMgaW4gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50S2V5cyAtIFRoZSBzZXQgb2Yga2V5cyBlbnRyaWVzIHRvIGxvb2sgdXAuXG4gICAgICogQHJldHVybnMgQSBtYXAgb2YgZG9jdW1lbnRzIGluZGV4ZWQgYnkga2V5IGFuZCBhIG1hcCBvZiBzaXplcyBpbmRleGVkIGJ5XG4gICAgICogICAgIGtleSAoemVybyBpZiB0aGUgZG9jdW1lbnQgZG9lcyBub3QgZXhpc3QpLlxuICAgICAqL1xuICAgIGdldFNpemVkRW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIGxldCBzaXplTWFwID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaERiRW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cywgKGtleSwgZGJSZW1vdGVEb2MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IHRoaXMubWF5YmVEZWNvZGVEb2N1bWVudChrZXksIGRiUmVtb3RlRG9jKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChrZXksIGRvYyk7XG4gICAgICAgICAgICBzaXplTWFwID0gc2l6ZU1hcC5pbnNlcnQoa2V5LCBkYkRvY3VtZW50U2l6ZShkYlJlbW90ZURvYykpO1xuICAgICAgICB9KS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGRvY3VtZW50czogcmVzdWx0cywgc2l6ZU1hcCB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yRWFjaERiRW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGRvY3VtZW50S2V5cy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzb3J0ZWRLZXlzID0gbmV3IFNvcnRlZFNldChkYktleUNvbXBhcmF0b3IpO1xuICAgICAgICBkb2N1bWVudEtleXMuZm9yRWFjaChlID0+IChzb3J0ZWRLZXlzID0gc29ydGVkS2V5cy5hZGQoZSkpKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChkYktleShzb3J0ZWRLZXlzLmZpcnN0KCkpLCBkYktleShzb3J0ZWRLZXlzLmxhc3QoKSkpO1xuICAgICAgICBjb25zdCBrZXlJdGVyID0gc29ydGVkS2V5cy5nZXRJdGVyYXRvcigpO1xuICAgICAgICBsZXQgbmV4dEtleSA9IGtleUl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICByZXR1cm4gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IGluZGV4OiBEYlJlbW90ZURvY3VtZW50RG9jdW1lbnRLZXlJbmRleCwgcmFuZ2UgfSwgKF8sIGRiUmVtb3RlRG9jLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3RlbnRpYWxLZXkgPSBEb2N1bWVudEtleS5mcm9tU2VnbWVudHMoW1xuICAgICAgICAgICAgICAgIC4uLmRiUmVtb3RlRG9jLnByZWZpeFBhdGgsXG4gICAgICAgICAgICAgICAgZGJSZW1vdGVEb2MuY29sbGVjdGlvbkdyb3VwLFxuICAgICAgICAgICAgICAgIGRiUmVtb3RlRG9jLmRvY3VtZW50SWRcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBrZXlzIG5vdCBmb3VuZCBpbiBjYWNoZS5cbiAgICAgICAgICAgIHdoaWxlIChuZXh0S2V5ICYmIGRiS2V5Q29tcGFyYXRvcihuZXh0S2V5LCBwb3RlbnRpYWxLZXkpIDwgMCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5leHRLZXksIG51bGwpO1xuICAgICAgICAgICAgICAgIG5leHRLZXkgPSBrZXlJdGVyLmdldE5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0S2V5ICYmIG5leHRLZXkuaXNFcXVhbChwb3RlbnRpYWxLZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gS2V5IGZvdW5kIGluIGNhY2hlLlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5leHRLZXksIGRiUmVtb3RlRG9jKTtcbiAgICAgICAgICAgICAgICBuZXh0S2V5ID0ga2V5SXRlci5oYXNOZXh0KCkgPyBrZXlJdGVyLmdldE5leHQoKSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTa2lwIHRvIHRoZSBuZXh0IGtleSAoaWYgdGhlcmUgaXMgb25lKS5cbiAgICAgICAgICAgIGlmIChuZXh0S2V5KSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5za2lwKGRiS2V5KG5leHRLZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gVGhlIHJlc3Qgb2YgdGhlIGtleXMgYXJlIG5vdCBpbiB0aGUgY2FjaGUuIE9uZSBjYXNlIHdoZXJlIGBpdGVyYXRlYFxuICAgICAgICAgICAgLy8gYWJvdmUgd29uJ3QgZ28gdGhyb3VnaCB0aGVtIGlzIHdoZW4gdGhlIGNhY2hlIGlzIGVtcHR5LlxuICAgICAgICAgICAgd2hpbGUgKG5leHRLZXkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXh0S2V5LCBudWxsKTtcbiAgICAgICAgICAgICAgICBuZXh0S2V5ID0ga2V5SXRlci5oYXNOZXh0KCkgPyBrZXlJdGVyLmdldE5leHQoKSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBtdXRhdGVkRG9jcywgY29udGV4dCkge1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uID0gcXVlcnkucGF0aDtcbiAgICAgICAgY29uc3Qgc3RhcnRLZXkgPSBbXG4gICAgICAgICAgICBjb2xsZWN0aW9uLnBvcExhc3QoKS50b0FycmF5KCksXG4gICAgICAgICAgICBjb2xsZWN0aW9uLmxhc3RTZWdtZW50KCksXG4gICAgICAgICAgICB0b0RiVGltZXN0YW1wS2V5KG9mZnNldC5yZWFkVGltZSksXG4gICAgICAgICAgICBvZmZzZXQuZG9jdW1lbnRLZXkucGF0aC5pc0VtcHR5KClcbiAgICAgICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICAgICAgOiBvZmZzZXQuZG9jdW1lbnRLZXkucGF0aC5sYXN0U2VnbWVudCgpXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGVuZEtleSA9IFtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ucG9wTGFzdCgpLnRvQXJyYXkoKSxcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ubGFzdFNlZ21lbnQoKSxcbiAgICAgICAgICAgIFtOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJdLFxuICAgICAgICAgICAgJydcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLmxvYWRBbGwoSURCS2V5UmFuZ2UuYm91bmQoc3RhcnRLZXksIGVuZEtleSwgdHJ1ZSkpXG4gICAgICAgICAgICAubmV4dChkYlJlbW90ZURvY3MgPT4ge1xuICAgICAgICAgICAgY29udGV4dD8uaW5jcmVtZW50RG9jdW1lbnRSZWFkQ291bnQoZGJSZW1vdGVEb2NzLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0cyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBkYlJlbW90ZURvYyBvZiBkYlJlbW90ZURvY3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IHRoaXMubWF5YmVEZWNvZGVEb2N1bWVudChEb2N1bWVudEtleS5mcm9tU2VnbWVudHMoZGJSZW1vdGVEb2MucHJlZml4UGF0aC5jb25jYXQoZGJSZW1vdGVEb2MuY29sbGVjdGlvbkdyb3VwLCBkYlJlbW90ZURvYy5kb2N1bWVudElkKSksIGRiUmVtb3RlRG9jKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZG9jdW1lbnQpIHx8IG11dGF0ZWREb2NzLmhhcyhkb2N1bWVudC5rZXkpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFaXRoZXIgdGhlIGRvY3VtZW50IG1hdGNoZXMgdGhlIGdpdmVuIHF1ZXJ5LCBvciBpdCBpcyBtdXRhdGVkLlxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoZG9jdW1lbnQua2V5LCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRBbGxGcm9tQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIG9mZnNldCwgbGltaXQpIHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgY29uc3Qgc3RhcnRLZXkgPSBkYkNvbGxlY3Rpb25Hcm91cEtleShjb2xsZWN0aW9uR3JvdXAsIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGVuZEtleSA9IGRiQ29sbGVjdGlvbkdyb3VwS2V5KGNvbGxlY3Rpb25Hcm91cCwgSW5kZXhPZmZzZXQubWF4KCkpO1xuICAgICAgICByZXR1cm4gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuaXRlcmF0ZSh7XG4gICAgICAgICAgICBpbmRleDogRGJSZW1vdGVEb2N1bWVudENvbGxlY3Rpb25Hcm91cEluZGV4LFxuICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLmJvdW5kKHN0YXJ0S2V5LCBlbmRLZXksIHRydWUpXG4gICAgICAgIH0sIChfLCBkYlJlbW90ZURvYywgY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSB0aGlzLm1heWJlRGVjb2RlRG9jdW1lbnQoRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKGRiUmVtb3RlRG9jLnByZWZpeFBhdGguY29uY2F0KGRiUmVtb3RlRG9jLmNvbGxlY3Rpb25Hcm91cCwgZGJSZW1vdGVEb2MuZG9jdW1lbnRJZCkpLCBkYlJlbW90ZURvYyk7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoZG9jdW1lbnQua2V5LCBkb2N1bWVudCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0cy5zaXplID09PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0cyk7XG4gICAgfVxuICAgIG5ld0NoYW5nZUJ1ZmZlcihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIodGhpcywgISFvcHRpb25zICYmIG9wdGlvbnMudHJhY2tSZW1vdmFscyk7XG4gICAgfVxuICAgIGdldFNpemUodHhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1ldGFkYXRhKHR4bikubmV4dChtZXRhZGF0YSA9PiBtZXRhZGF0YS5ieXRlU2l6ZSk7XG4gICAgfVxuICAgIGdldE1ldGFkYXRhKHR4bikge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRHbG9iYWxTdG9yZSh0eG4pXG4gICAgICAgICAgICAuZ2V0KERiUmVtb3RlRG9jdW1lbnRHbG9iYWxLZXkpXG4gICAgICAgICAgICAubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICBoYXJkQXNzZXJ0KCEhbWV0YWRhdGEsIDB4NGUzNSk7XG4gICAgICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRNZXRhZGF0YSh0eG4sIG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudEdsb2JhbFN0b3JlKHR4bikucHV0KERiUmVtb3RlRG9jdW1lbnRHbG9iYWxLZXksIG1ldGFkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBgZGJSZW1vdGVEb2NgIGFuZCByZXR1cm5zIHRoZSBkb2N1bWVudCAob3IgYW4gaW52YWxpZCBkb2N1bWVudCBpZlxuICAgICAqIHRoZSBkb2N1bWVudCBjb3JyZXNwb25kcyB0byB0aGUgZm9ybWF0IHVzZWQgZm9yIHNlbnRpbmVsIGRlbGV0ZXMpLlxuICAgICAqL1xuICAgIG1heWJlRGVjb2RlRG9jdW1lbnQoZG9jdW1lbnRLZXksIGRiUmVtb3RlRG9jKSB7XG4gICAgICAgIGlmIChkYlJlbW90ZURvYykge1xuICAgICAgICAgICAgY29uc3QgZG9jID0gZnJvbURiUmVtb3RlRG9jdW1lbnQodGhpcy5zZXJpYWxpemVyLCBkYlJlbW90ZURvYyk7XG4gICAgICAgICAgICAvLyBXaGV0aGVyIHRoZSBkb2N1bWVudCBpcyBhIHNlbnRpbmVsIHJlbW92YWwgYW5kIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gdGhlXG4gICAgICAgICAgICAvLyBgZ2V0TmV3RG9jdW1lbnRDaGFuZ2VzKClgXG4gICAgICAgICAgICBjb25zdCBpc1NlbnRpbmVsUmVtb3ZhbCA9IGRvYy5pc05vRG9jdW1lbnQoKSAmJiBkb2MudmVyc2lvbi5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSk7XG4gICAgICAgICAgICBpZiAoIWlzU2VudGluZWxSZW1vdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSk7XG4gICAgfVxufVxuLyoqIENyZWF0ZXMgYSBuZXcgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZS4gKi9cbmZ1bmN0aW9uIG5ld0luZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGUoc2VyaWFsaXplcikge1xuICAgIHJldHVybiBuZXcgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZUltcGwoc2VyaWFsaXplcik7XG59XG4vKipcbiAqIEhhbmRsZXMgdGhlIGRldGFpbHMgb2YgYWRkaW5nIGFuZCB1cGRhdGluZyBkb2N1bWVudHMgaW4gdGhlIEluZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGUuXG4gKlxuICogVW5saWtlIHRoZSBNZW1vcnlSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlciwgdGhlIEluZGV4ZWREYiBpbXBsZW1lbnRhdGlvbiBjb21wdXRlcyB0aGUgc2l6ZVxuICogZGVsdGEgZm9yIGFsbCBzdWJtaXR0ZWQgY2hhbmdlcy4gVGhpcyBhdm9pZHMgaGF2aW5nIHRvIHJlLXJlYWQgYWxsIGRvY3VtZW50cyBmcm9tIEluZGV4ZWREYlxuICogd2hlbiB3ZSBhcHBseSB0aGUgY2hhbmdlcy5cbiAqL1xuY2xhc3MgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIgZXh0ZW5kcyBSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRvY3VtZW50Q2FjaGUgLSBUaGUgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZSB0byBhcHBseSB0aGUgY2hhbmdlcyB0by5cbiAgICAgKiBAcGFyYW0gdHJhY2tSZW1vdmFscyAtIFdoZXRoZXIgdG8gY3JlYXRlIHNlbnRpbmVsIGRlbGV0ZXMgdGhhdCBjYW4gYmUgdHJhY2tlZCBieVxuICAgICAqIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWAuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnRDYWNoZSwgdHJhY2tSZW1vdmFscykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRvY3VtZW50Q2FjaGUgPSBkb2N1bWVudENhY2hlO1xuICAgICAgICB0aGlzLnRyYWNrUmVtb3ZhbHMgPSB0cmFja1JlbW92YWxzO1xuICAgICAgICAvLyBBIG1hcCBvZiBkb2N1bWVudCBzaXplcyBhbmQgcmVhZCB0aW1lcyBwcmlvciB0byBhcHBseWluZyB0aGUgY2hhbmdlcyBpblxuICAgICAgICAvLyB0aGlzIGJ1ZmZlci5cbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlcyA9IG5ldyBPYmplY3RNYXAoa2V5ID0+IGtleS50b1N0cmluZygpLCAobCwgcikgPT4gbC5pc0VxdWFsKHIpKTtcbiAgICB9XG4gICAgYXBwbHlDaGFuZ2VzKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGxldCBzaXplRGVsdGEgPSAwO1xuICAgICAgICBsZXQgY29sbGVjdGlvblBhcmVudHMgPSBuZXcgU29ydGVkU2V0KChsLCByKSA9PiBwcmltaXRpdmVDb21wYXJhdG9yKGwuY2Fub25pY2FsU3RyaW5nKCksIHIuY2Fub25pY2FsU3RyaW5nKCkpKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmZvckVhY2goKGtleSwgZG9jdW1lbnRDaGFuZ2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRG9jID0gdGhpcy5kb2N1bWVudFN0YXRlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudENhY2hlLnJlbW92ZUVudHJ5KHRyYW5zYWN0aW9uLCBrZXksIHByZXZpb3VzRG9jLnJlYWRUaW1lKSk7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnRDaGFuZ2UuaXNWYWxpZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2MgPSB0b0RiUmVtb3RlRG9jdW1lbnQodGhpcy5kb2N1bWVudENhY2hlLnNlcmlhbGl6ZXIsIGRvY3VtZW50Q2hhbmdlKTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uUGFyZW50cyA9IGNvbGxlY3Rpb25QYXJlbnRzLmFkZChrZXkucGF0aC5wb3BMYXN0KCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBkYkRvY3VtZW50U2l6ZShkb2MpO1xuICAgICAgICAgICAgICAgIHNpemVEZWx0YSArPSBzaXplIC0gcHJldmlvdXNEb2Muc2l6ZTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZG9jdW1lbnRDYWNoZS5hZGRFbnRyeSh0cmFuc2FjdGlvbiwga2V5LCBkb2MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpemVEZWx0YSAtPSBwcmV2aW91c0RvYy5zaXplO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrUmVtb3ZhbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gb3JkZXIgdG8gdHJhY2sgcmVtb3ZhbHMsIHdlIHN0b3JlIGEgXCJzZW50aW5lbCBkZWxldGVcIiBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3RlRG9jdW1lbnRDYWNoZS4gVGhpcyBlbnRyeSBpcyByZXByZXNlbnRlZCBieSBhIE5vRG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCBhIHZlcnNpb24gb2YgMCBhbmQgaWdub3JlZCBieSBgbWF5YmVEZWNvZGVEb2N1bWVudCgpYCBidXRcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJlc2VydmVkIGluIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWAuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGV0ZWREb2MgPSB0b0RiUmVtb3RlRG9jdW1lbnQodGhpcy5kb2N1bWVudENhY2hlLnNlcmlhbGl6ZXIsIGRvY3VtZW50Q2hhbmdlLmNvbnZlcnRUb05vRG9jdW1lbnQoU25hcHNob3RWZXJzaW9uLm1pbigpKSk7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudENhY2hlLmFkZEVudHJ5KHRyYW5zYWN0aW9uLCBrZXksIGRlbGV0ZWREb2MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb2xsZWN0aW9uUGFyZW50cy5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZG9jdW1lbnRDYWNoZS5pbmRleE1hbmFnZXIuYWRkVG9Db2xsZWN0aW9uUGFyZW50SW5kZXgodHJhbnNhY3Rpb24sIHBhcmVudCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvY3VtZW50Q2FjaGUudXBkYXRlTWV0YWRhdGEodHJhbnNhY3Rpb24sIHNpemVEZWx0YSkpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xuICAgIH1cbiAgICBnZXRGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XG4gICAgICAgIC8vIFJlY29yZCB0aGUgc2l6ZSBvZiBldmVyeXRoaW5nIHdlIGxvYWQgZnJvbSB0aGUgY2FjaGUgc28gd2UgY2FuIGNvbXB1dGUgYSBkZWx0YSBsYXRlci5cbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRDYWNoZVxuICAgICAgICAgICAgLmdldFNpemVkRW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KVxuICAgICAgICAgICAgLm5leHQoZ2V0UmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZXMuc2V0KGRvY3VtZW50S2V5LCB7XG4gICAgICAgICAgICAgICAgc2l6ZTogZ2V0UmVzdWx0LnNpemUsXG4gICAgICAgICAgICAgICAgcmVhZFRpbWU6IGdldFJlc3VsdC5kb2N1bWVudC5yZWFkVGltZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UmVzdWx0LmRvY3VtZW50O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QWxsRnJvbUNhY2hlKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcbiAgICAgICAgLy8gUmVjb3JkIHRoZSBzaXplIG9mIGV2ZXJ5dGhpbmcgd2UgbG9hZCBmcm9tIHRoZSBjYWNoZSBzbyB3ZSBjYW4gY29tcHV0ZVxuICAgICAgICAvLyBhIGRlbHRhIGxhdGVyLlxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudENhY2hlXG4gICAgICAgICAgICAuZ2V0U2l6ZWRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpXG4gICAgICAgICAgICAubmV4dCgoeyBkb2N1bWVudHMsIHNpemVNYXAgfSkgPT4ge1xuICAgICAgICAgICAgLy8gTm90ZTogYGdldEFsbEZyb21DYWNoZWAgcmV0dXJucyB0d28gbWFwcyBpbnN0ZWFkIG9mIGEgc2luZ2xlIG1hcCBmcm9tXG4gICAgICAgICAgICAvLyBrZXlzIHRvIGBEb2N1bWVudFNpemVFbnRyeWBzLiBUaGlzIGlzIHRvIGFsbG93IHJldHVybmluZyB0aGVcbiAgICAgICAgICAgIC8vIGBNdXRhYmxlRG9jdW1lbnRNYXBgIGRpcmVjdGx5LCB3aXRob3V0IGEgY29udmVyc2lvbi5cbiAgICAgICAgICAgIHNpemVNYXAuZm9yRWFjaCgoZG9jdW1lbnRLZXksIHNpemUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGVzLnNldChkb2N1bWVudEtleSwge1xuICAgICAgICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICAgICAgICByZWFkVGltZTogZG9jdW1lbnRzLmdldChkb2N1bWVudEtleSkucmVhZFRpbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50cztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZG9jdW1lbnRHbG9iYWxTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYlJlbW90ZURvY3VtZW50R2xvYmFsU3RvcmUpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIHJlbW90ZURvY3VtZW50cyBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIHJlbW90ZURvY3VtZW50c1N0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiUmVtb3RlRG9jdW1lbnRTdG9yZSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBrZXkgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZG9jdW1lbnQgbG9va3VwcyBvbiB0aGVcbiAqIGBEYlJlbW90ZURvY3VtZW50RG9jdW1lbnRLZXlJbmRleGAgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGRiS2V5KGRvY3VtZW50S2V5KSB7XG4gICAgY29uc3QgcGF0aCA9IGRvY3VtZW50S2V5LnBhdGgudG9BcnJheSgpO1xuICAgIHJldHVybiBbXG4gICAgICAgIC8qIHByZWZpeCBwYXRoICovIHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAyKSxcbiAgICAgICAgLyogY29sbGVjdGlvbiBpZCAqLyBwYXRoW3BhdGgubGVuZ3RoIC0gMl0sXG4gICAgICAgIC8qIGRvY3VtZW50IGlkICovIHBhdGhbcGF0aC5sZW5ndGggLSAxXVxuICAgIF07XG59XG4vKipcbiAqIFJldHVybnMgYSBrZXkgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZG9jdW1lbnQgbG9va3VwcyB2aWEgdGhlIHByaW1hcnkga2V5IG9mXG4gKiB0aGUgRGJSZW1vdGVEb2N1bWVudCBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIGRiUmVhZFRpbWVLZXkoZG9jdW1lbnRLZXksIHJlYWRUaW1lKSB7XG4gICAgY29uc3QgcGF0aCA9IGRvY3VtZW50S2V5LnBhdGgudG9BcnJheSgpO1xuICAgIHJldHVybiBbXG4gICAgICAgIC8qIHByZWZpeCBwYXRoICovIHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAyKSxcbiAgICAgICAgLyogY29sbGVjdGlvbiBpZCAqLyBwYXRoW3BhdGgubGVuZ3RoIC0gMl0sXG4gICAgICAgIHRvRGJUaW1lc3RhbXBLZXkocmVhZFRpbWUpLFxuICAgICAgICAvKiBkb2N1bWVudCBpZCAqLyBwYXRoW3BhdGgubGVuZ3RoIC0gMV1cbiAgICBdO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEga2V5IHRoYXQgY2FuIGJlIHVzZWQgZm9yIGRvY3VtZW50IGxvb2t1cHMgb24gdGhlXG4gKiBgRGJSZW1vdGVEb2N1bWVudERvY3VtZW50Q29sbGVjdGlvbkdyb3VwSW5kZXhgIGluZGV4LlxuICovXG5mdW5jdGlvbiBkYkNvbGxlY3Rpb25Hcm91cEtleShjb2xsZWN0aW9uR3JvdXAsIG9mZnNldCkge1xuICAgIGNvbnN0IHBhdGggPSBvZmZzZXQuZG9jdW1lbnRLZXkucGF0aC50b0FycmF5KCk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgLyogY29sbGVjdGlvbiBpZCAqLyBjb2xsZWN0aW9uR3JvdXAsXG4gICAgICAgIHRvRGJUaW1lc3RhbXBLZXkob2Zmc2V0LnJlYWRUaW1lKSxcbiAgICAgICAgLyogcHJlZml4IHBhdGggKi8gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDIpLFxuICAgICAgICAvKiBkb2N1bWVudCBpZCAqLyBwYXRoLmxlbmd0aCA+IDAgPyBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gOiAnJ1xuICAgIF07XG59XG4vKipcbiAqIENvbXBhcmF0b3IgdGhhdCBjb21wYXJlcyBkb2N1bWVudCBrZXlzIGFjY29yZGluZyB0byB0aGUgcHJpbWFyeSBrZXkgc29ydGluZ1xuICogdXNlZCBieSB0aGUgYERiUmVtb3RlRG9jdW1lbnREb2N1bWVudGAgc3RvcmUgKGJ5IHByZWZpeCBwYXRoLCBjb2xsZWN0aW9uIGlkXG4gKiBhbmQgdGhlbiBkb2N1bWVudCBJRCkuXG4gKlxuICogVmlzaWJsZSBmb3IgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gZGJLZXlDb21wYXJhdG9yKGwsIHIpIHtcbiAgICBjb25zdCBsZWZ0ID0gbC5wYXRoLnRvQXJyYXkoKTtcbiAgICBjb25zdCByaWdodCA9IHIucGF0aC50b0FycmF5KCk7XG4gICAgLy8gVGhlIG9yZGVyaW5nIGlzIGJhc2VkIG9uIGh0dHBzOi8vY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9ibGluay8rL2ZlNWMyMWZlZjk0ZGFlNzFjMWMzMzQ0Nzc1YjhkOGE3ZjdlNmQ5ZWMvU291cmNlL21vZHVsZXMvaW5kZXhlZGRiL0lEQktleS5jcHAjNzRcbiAgICBsZXQgY21wID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnQubGVuZ3RoIC0gMiAmJiBpIDwgcmlnaHQubGVuZ3RoIC0gMjsgKytpKSB7XG4gICAgICAgIGNtcCA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFtpXSwgcmlnaHRbaV0pO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNtcCA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC5sZW5ndGgsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICBjbXAgPSBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRbbGVmdC5sZW5ndGggLSAyXSwgcmlnaHRbcmlnaHQubGVuZ3RoIC0gMl0pO1xuICAgIGlmIChjbXApIHtcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG4gICAgLy8gVE9ETyhiLzMyOTQ0MTcwMik6IERvY3VtZW50IElEcyBzaG91bGQgYmUgc29ydGVkIGJ5IFVURi04IGVuY29kZWQgYnl0ZVxuICAgIC8vIG9yZGVyLCBidXQgSW5kZXhlZERCIHNvcnRzIHN0cmluZ3MgbGV4aWNvZ3JhcGhpY2FsbHkuIERvY3VtZW50IElEXG4gICAgLy8gY29tcGFyaXNvbiBoZXJlIHN0aWxsIHJlbGllcyBvbiBwcmltaXRpdmUgY29tcGFyaXNvbiB0byBhdm9pZCBtaXNtYXRjaGVzXG4gICAgLy8gb2JzZXJ2ZWQgaW4gc25hcHNob3QgbGlzdGVuZXJzIHdpdGggVW5pY29kZSBjaGFyYWN0ZXJzIGluIGRvY3VtZW50SWRzXG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFtsZWZ0Lmxlbmd0aCAtIDFdLCByaWdodFtyaWdodC5sZW5ndGggLSAxXSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFNjaGVtYSBWZXJzaW9uIGZvciB0aGUgV2ViIGNsaWVudDpcbiAqIDEuICBJbml0aWFsIHZlcnNpb24gaW5jbHVkaW5nIE11dGF0aW9uIFF1ZXVlLCBRdWVyeSBDYWNoZSwgYW5kIFJlbW90ZVxuICogICAgIERvY3VtZW50IENhY2hlXG4gKiAyLiAgVXNlZCB0byBlbnN1cmUgYSB0YXJnZXRHbG9iYWwgb2JqZWN0IGV4aXN0cyBhbmQgYWRkIHRhcmdldENvdW50IHRvIGl0LiBOb1xuICogICAgIGxvbmdlciByZXF1aXJlZCBiZWNhdXNlIG1pZ3JhdGlvbiAzIHVuY29uZGl0aW9uYWxseSBjbGVhcnMgaXQuXG4gKiAzLiAgRHJvcHBlZCBhbmQgcmUtY3JlYXRlZCBRdWVyeSBDYWNoZSB0byBkZWFsIHdpdGggY2FjaGUgY29ycnVwdGlvbiByZWxhdGVkXG4gKiAgICAgdG8gbGltYm8gcmVzb2x1dGlvbi4gQWRkcmVzc2VzXG4gKiAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWlvcy1zZGsvaXNzdWVzLzE1NDhcbiAqIDQuICBNdWx0aS1UYWIgU3VwcG9ydC5cbiAqIDUuICBSZW1vdmFsIG9mIGhlbGQgd3JpdGUgYWNrcy5cbiAqIDYuICBDcmVhdGUgZG9jdW1lbnQgZ2xvYmFsIGZvciB0cmFja2luZyBkb2N1bWVudCBjYWNoZSBzaXplLlxuICogNy4gIEVuc3VyZSBldmVyeSBjYWNoZWQgZG9jdW1lbnQgaGFzIGEgc2VudGluZWwgcm93IHdpdGggYSBzZXF1ZW5jZSBudW1iZXIuXG4gKiA4LiAgQWRkIGNvbGxlY3Rpb24tcGFyZW50IGluZGV4IGZvciBDb2xsZWN0aW9uIEdyb3VwIHF1ZXJpZXMuXG4gKiA5LiAgQ2hhbmdlIFJlbW90ZURvY3VtZW50Q2hhbmdlcyBzdG9yZSB0byBiZSBrZXllZCBieSByZWFkVGltZSByYXRoZXIgdGhhblxuICogICAgIGFuIGF1dG8taW5jcmVtZW50aW5nIElELiBUaGlzIGlzIHJlcXVpcmVkIGZvciBJbmRleC1GcmVlIHF1ZXJpZXMuXG4gKiAxMC4gUmV3cml0ZSB0aGUgY2Fub25pY2FsIElEcyB0byB0aGUgZXhwbGljaXQgUHJvdG9idWYtYmFzZWQgZm9ybWF0LlxuICogMTEuIEFkZCBidW5kbGVzIGFuZCBuYW1lZF9xdWVyaWVzIGZvciBidW5kbGUgc3VwcG9ydC5cbiAqIDEyLiBBZGQgZG9jdW1lbnQgb3ZlcmxheXMuXG4gKiAxMy4gUmV3cml0ZSB0aGUga2V5cyBvZiB0aGUgcmVtb3RlIGRvY3VtZW50IGNhY2hlIHRvIGFsbG93IGZvciBlZmZpY2llbnRcbiAqICAgICBkb2N1bWVudCBsb29rdXAgdmlhIGBnZXRBbGwoKWAuXG4gKiAxNC4gQWRkIG92ZXJsYXlzLlxuICogMTUuIEFkZCBpbmRleGluZyBzdXBwb3J0LlxuICogMTYuIFBhcnNlIHRpbWVzdGFtcCBzdHJpbmdzIGJlZm9yZSBjcmVhdGluZyBpbmRleCBlbnRyaWVzLlxuICogMTcuIFRPRE8odG9tYW5kZXJzZW4pXG4gKiAxOC4gRW5jb2RlIGtleSBzYWZlIHJlcHJlc2VudGF0aW9ucyBvZiBJbmRleEVudHJ5IGluIERiSW5kZXhFbnRyeVN0b3JlLlxuICovXG5jb25zdCBTQ0hFTUFfVkVSU0lPTiA9IDE4O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgbG9jYWwgdmlldyAob3ZlcmxheSkgb2YgYSBkb2N1bWVudCwgYW5kIHRoZSBmaWVsZHMgdGhhdCBhcmVcbiAqIGxvY2FsbHkgbXV0YXRlZC5cbiAqL1xuY2xhc3MgT3ZlcmxheWVkRG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG92ZXJsYXllZERvY3VtZW50LCBcbiAgICAvKipcbiAgICAgKiBUaGUgZmllbGRzIHRoYXQgYXJlIGxvY2FsbHkgbXV0YXRlZCBieSBwYXRjaCBtdXRhdGlvbnMuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgb3ZlcmxheWVkXHRkb2N1bWVudCBpcyBmcm9tIHNldCBvciBkZWxldGUgbXV0YXRpb25zLCB0aGlzIGlzIGBudWxsYC5cbiAgICAgKiBJZiB0aGVyZSBpcyBubyBvdmVybGF5IChtdXRhdGlvbikgZm9yIHRoZSBkb2N1bWVudCwgdGhpcyBpcyBhbiBlbXB0eSBgRmllbGRNYXNrYC5cbiAgICAgKi9cbiAgICBtdXRhdGVkRmllbGRzKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheWVkRG9jdW1lbnQgPSBvdmVybGF5ZWREb2N1bWVudDtcbiAgICAgICAgdGhpcy5tdXRhdGVkRmllbGRzID0gbXV0YXRlZEZpZWxkcztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgcmVhZG9ubHkgdmlldyBvZiB0aGUgbG9jYWwgc3RhdGUgb2YgYWxsIGRvY3VtZW50cyB3ZSdyZSB0cmFja2luZyAoaS5lLiB3ZVxuICogaGF2ZSBhIGNhY2hlZCB2ZXJzaW9uIGluIHJlbW90ZURvY3VtZW50Q2FjaGUgb3IgbG9jYWwgbXV0YXRpb25zIGZvciB0aGVcbiAqIGRvY3VtZW50KS4gVGhlIHZpZXcgaXMgY29tcHV0ZWQgYnkgYXBwbHlpbmcgdGhlIG11dGF0aW9ucyBpbiB0aGVcbiAqIE11dGF0aW9uUXVldWUgdG8gdGhlIFJlbW90ZURvY3VtZW50Q2FjaGUuXG4gKi9cbmNsYXNzIExvY2FsRG9jdW1lbnRzVmlldyB7XG4gICAgY29uc3RydWN0b3IocmVtb3RlRG9jdW1lbnRDYWNoZSwgbXV0YXRpb25RdWV1ZSwgZG9jdW1lbnRPdmVybGF5Q2FjaGUsIGluZGV4TWFuYWdlcikge1xuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGUgPSByZW1vdGVEb2N1bWVudENhY2hlO1xuICAgICAgICB0aGlzLm11dGF0aW9uUXVldWUgPSBtdXRhdGlvblF1ZXVlO1xuICAgICAgICB0aGlzLmRvY3VtZW50T3ZlcmxheUNhY2hlID0gZG9jdW1lbnRPdmVybGF5Q2FjaGU7XG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gaW5kZXhNYW5hZ2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxvY2FsIHZpZXcgb2YgdGhlIGRvY3VtZW50IGlkZW50aWZpZWQgYnkgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBMb2NhbCB2aWV3IG9mIHRoZSBkb2N1bWVudCBvciBudWxsIGlmIHdlIGRvbid0IGhhdmUgYW55IGNhY2hlZFxuICAgICAqIHN0YXRlIGZvciBpdC5cbiAgICAgKi9cbiAgICBnZXREb2N1bWVudCh0cmFuc2FjdGlvbiwga2V5KSB7XG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGVcbiAgICAgICAgICAgIC5nZXRPdmVybGF5KHRyYW5zYWN0aW9uLCBrZXkpXG4gICAgICAgICAgICAubmV4dCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICBvdmVybGF5ID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlLmdldEVudHJ5KHRyYW5zYWN0aW9uLCBrZXkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoZG9jdW1lbnQgPT4ge1xuICAgICAgICAgICAgaWYgKG92ZXJsYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcob3ZlcmxheS5tdXRhdGlvbiwgZG9jdW1lbnQsIEZpZWxkTWFzay5lbXB0eSgpLCBUaW1lc3RhbXAubm93KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbG9jYWwgdmlldyBvZiB0aGUgZG9jdW1lbnRzIGlkZW50aWZpZWQgYnkgYGtleXNgLlxuICAgICAqXG4gICAgICogSWYgd2UgZG9uJ3QgaGF2ZSBjYWNoZWQgc3RhdGUgZm9yIGEgZG9jdW1lbnQgaW4gYGtleXNgLCBhIE5vRG9jdW1lbnQgd2lsbFxuICAgICAqIGJlIHN0b3JlZCBmb3IgdGhhdCBrZXkgaW4gdGhlIHJlc3VsdGluZyBzZXQuXG4gICAgICovXG4gICAgZ2V0RG9jdW1lbnRzKHRyYW5zYWN0aW9uLCBrZXlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGVcbiAgICAgICAgICAgIC5nZXRFbnRyaWVzKHRyYW5zYWN0aW9uLCBrZXlzKVxuICAgICAgICAgICAgLm5leHQoZG9jcyA9PiB0aGlzLmdldExvY2FsVmlld09mRG9jdW1lbnRzKHRyYW5zYWN0aW9uLCBkb2NzLCBkb2N1bWVudEtleVNldCgpKS5uZXh0KCgpID0+IGRvY3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byBgZ2V0RG9jdW1lbnRzYCwgYnV0IGNyZWF0ZXMgdGhlIGxvY2FsIHZpZXcgZnJvbSB0aGUgZ2l2ZW5cbiAgICAgKiBgYmFzZURvY3NgIHdpdGhvdXQgcmV0cmlldmluZyBkb2N1bWVudHMgZnJvbSB0aGUgbG9jYWwgc3RvcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gdGhpcyBvcGVyYXRpb24gaXMgc2NvcGVkIHRvLlxuICAgICAqIEBwYXJhbSBkb2NzIC0gVGhlIGRvY3VtZW50cyB0byBhcHBseSBsb2NhbCBtdXRhdGlvbnMgdG8gZ2V0IHRoZSBsb2NhbCB2aWV3cy5cbiAgICAgKiBAcGFyYW0gZXhpc3RlbmNlU3RhdGVDaGFuZ2VkIC0gVGhlIHNldCBvZiBkb2N1bWVudCBrZXlzIHdob3NlIGV4aXN0ZW5jZSBzdGF0ZVxuICAgICAqICAgaXMgY2hhbmdlZC4gVGhpcyBpcyB1c2VmdWwgdG8gZGV0ZXJtaW5lIGlmIHNvbWUgZG9jdW1lbnRzIG92ZXJsYXkgbmVlZHNcbiAgICAgKiAgIHRvIGJlIHJlY2FsY3VsYXRlZC5cbiAgICAgKi9cbiAgICBnZXRMb2NhbFZpZXdPZkRvY3VtZW50cyh0cmFuc2FjdGlvbiwgZG9jcywgZXhpc3RlbmNlU3RhdGVDaGFuZ2VkID0gZG9jdW1lbnRLZXlTZXQoKSkge1xuICAgICAgICBjb25zdCBvdmVybGF5cyA9IG5ld092ZXJsYXlNYXAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9wdWxhdGVPdmVybGF5cyh0cmFuc2FjdGlvbiwgb3ZlcmxheXMsIGRvY3MpLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZVZpZXdzKHRyYW5zYWN0aW9uLCBkb2NzLCBvdmVybGF5cywgZXhpc3RlbmNlU3RhdGVDaGFuZ2VkKS5uZXh0KGNvbXB1dGVWaWV3c1Jlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGRvY3VtZW50TWFwKCk7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVZpZXdzUmVzdWx0LmZvckVhY2goKGRvY3VtZW50S2V5LCBvdmVybGF5ZWREb2N1bWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuaW5zZXJ0KGRvY3VtZW50S2V5LCBvdmVybGF5ZWREb2N1bWVudC5vdmVybGF5ZWREb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgb3ZlcmxheWVkIGRvY3VtZW50cyBmb3IgdGhlIGdpdmVuIGRvY3VtZW50IG1hcCwgd2hpY2ggd2lsbCBpbmNsdWRlXG4gICAgICogdGhlIGxvY2FsIHZpZXcgb2YgdGhvc2UgZG9jdW1lbnRzIGFuZCBhIGBGaWVsZE1hc2tgIGluZGljYXRpbmcgd2hpY2ggZmllbGRzXG4gICAgICogYXJlIG11dGF0ZWQgbG9jYWxseSwgYG51bGxgIGlmIG92ZXJsYXkgaXMgYSBTZXQgb3IgRGVsZXRlIG11dGF0aW9uLlxuICAgICAqL1xuICAgIGdldE92ZXJsYXllZERvY3VtZW50cyh0cmFuc2FjdGlvbiwgZG9jcykge1xuICAgICAgICBjb25zdCBvdmVybGF5cyA9IG5ld092ZXJsYXlNYXAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9wdWxhdGVPdmVybGF5cyh0cmFuc2FjdGlvbiwgb3ZlcmxheXMsIGRvY3MpLm5leHQoKCkgPT4gdGhpcy5jb21wdXRlVmlld3ModHJhbnNhY3Rpb24sIGRvY3MsIG92ZXJsYXlzLCBkb2N1bWVudEtleVNldCgpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIG92ZXJsYXlzIGZvciB7QGNvZGUgZG9jc30gYW5kIGFkZHMgdGhlbSB0byBwcm92aWRlZCBvdmVybGF5IG1hcFxuICAgICAqIGlmIHRoZSBtYXAgZG9lcyBub3QgYWxyZWFkeSBjb250YWluIGFuIGVudHJ5IGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQga2V5LlxuICAgICAqL1xuICAgIHBvcHVsYXRlT3ZlcmxheXModHJhbnNhY3Rpb24sIG92ZXJsYXlzLCBkb2NzKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdPdmVybGF5cyA9IFtdO1xuICAgICAgICBkb2NzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmICghb3ZlcmxheXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nT3ZlcmxheXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGVcbiAgICAgICAgICAgIC5nZXRPdmVybGF5cyh0cmFuc2FjdGlvbiwgbWlzc2luZ092ZXJsYXlzKVxuICAgICAgICAgICAgLm5leHQocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKChrZXksIHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIG92ZXJsYXlzLnNldChrZXksIHZhbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBsb2NhbCB2aWV3IGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3MgLSBUaGUgZG9jdW1lbnRzIHRvIGNvbXB1dGUgdmlld3MgZm9yLiBJdCBhbHNvIGhhcyB0aGUgYmFzZVxuICAgICAqICAgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnRzLlxuICAgICAqIEBwYXJhbSBvdmVybGF5cyAtIFRoZSBvdmVybGF5cyB0aGF0IG5lZWQgdG8gYmUgYXBwbGllZCB0byB0aGUgZ2l2ZW4gYmFzZVxuICAgICAqICAgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnRzLlxuICAgICAqIEBwYXJhbSBleGlzdGVuY2VTdGF0ZUNoYW5nZWQgLSBBIHNldCBvZiBkb2N1bWVudHMgd2hvc2UgZXhpc3RlbmNlIHN0YXRlc1xuICAgICAqICAgbWlnaHQgaGF2ZSBjaGFuZ2VkLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gcmUtY2FsY3VsYXRlXG4gICAgICogICBvdmVybGF5cyBmcm9tIG11dGF0aW9uIHF1ZXVlcy5cbiAgICAgKiBAcmV0dXJucyBBIG1hcCByZXByZXNlbnRzIHRoZSBsb2NhbCBkb2N1bWVudHMgdmlldy5cbiAgICAgKi9cbiAgICBjb21wdXRlVmlld3ModHJhbnNhY3Rpb24sIGRvY3MsIG92ZXJsYXlzLCBleGlzdGVuY2VTdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgbGV0IHJlY2FsY3VsYXRlRG9jdW1lbnRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIGNvbnN0IG11dGF0ZWRGaWVsZHMgPSBuZXdEb2N1bWVudEtleU1hcCgpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gbmV3T3ZlcmxheWVkRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgZG9jcy5mb3JFYWNoKChfLCBkb2MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBvdmVybGF5cy5nZXQoZG9jLmtleSk7XG4gICAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSBhbiBvdmVybGF5IGlmIHRoZSBkb2N1bWVudCdzIGV4aXN0ZW5jZSBzdGF0ZSBjaGFuZ2VkIGR1ZSB0b1xuICAgICAgICAgICAgLy8gYSByZW1vdGUgZXZlbnQgKmFuZCogdGhlIG92ZXJsYXkgaXMgYSBQYXRjaE11dGF0aW9uLiBUaGlzIGlzIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIGRvY3VtZW50IGV4aXN0ZW5jZSBzdGF0ZSBjYW4gY2hhbmdlIGlmIHNvbWUgcGF0Y2ggbXV0YXRpb24nc1xuICAgICAgICAgICAgLy8gcHJlY29uZGl0aW9ucyBhcmUgbWV0LlxuICAgICAgICAgICAgLy8gTk9URTogd2UgcmVjYWxjdWxhdGUgd2hlbiBgb3ZlcmxheWAgaXMgdW5kZWZpbmVkIGFzIHdlbGwsIGJlY2F1c2UgdGhlcmVcbiAgICAgICAgICAgIC8vIG1pZ2h0IGJlIGEgcGF0Y2ggbXV0YXRpb24gd2hvc2UgcHJlY29uZGl0aW9uIGRvZXMgbm90IG1hdGNoIGJlZm9yZSB0aGVcbiAgICAgICAgICAgIC8vIGNoYW5nZSAoaGVuY2Ugb3ZlcmxheSBpcyB1bmRlZmluZWQpLCBidXQgd291bGQgbm93IG1hdGNoLlxuICAgICAgICAgICAgaWYgKGV4aXN0ZW5jZVN0YXRlQ2hhbmdlZC5oYXMoZG9jLmtleSkgJiZcbiAgICAgICAgICAgICAgICAob3ZlcmxheSA9PT0gdW5kZWZpbmVkIHx8IG92ZXJsYXkubXV0YXRpb24gaW5zdGFuY2VvZiBQYXRjaE11dGF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJlY2FsY3VsYXRlRG9jdW1lbnRzID0gcmVjYWxjdWxhdGVEb2N1bWVudHMuaW5zZXJ0KGRvYy5rZXksIGRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdmVybGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtdXRhdGVkRmllbGRzLnNldChkb2Mua2V5LCBvdmVybGF5Lm11dGF0aW9uLmdldEZpZWxkTWFzaygpKTtcbiAgICAgICAgICAgICAgICBtdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcob3ZlcmxheS5tdXRhdGlvbiwgZG9jLCBvdmVybGF5Lm11dGF0aW9uLmdldEZpZWxkTWFzaygpLCBUaW1lc3RhbXAubm93KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gb3ZlcmxheSBleGlzdHNcbiAgICAgICAgICAgICAgICAvLyBVc2luZyBFTVBUWSB0byBpbmRpY2F0ZSB0aGVyZSBpcyBubyBvdmVybGF5IGZvciB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgbXV0YXRlZEZpZWxkcy5zZXQoZG9jLmtleSwgRmllbGRNYXNrLmVtcHR5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIHJlY2FsY3VsYXRlRG9jdW1lbnRzKS5uZXh0KHJlY2FsY3VsYXRlZEZpZWxkcyA9PiB7XG4gICAgICAgICAgICByZWNhbGN1bGF0ZWRGaWVsZHMuZm9yRWFjaCgoZG9jdW1lbnRLZXksIG1hc2spID0+IG11dGF0ZWRGaWVsZHMuc2V0KGRvY3VtZW50S2V5LCBtYXNrKSk7XG4gICAgICAgICAgICBkb2NzLmZvckVhY2goKGRvY3VtZW50S2V5LCBkb2N1bWVudCkgPT4gcmVzdWx0cy5zZXQoZG9jdW1lbnRLZXksIG5ldyBPdmVybGF5ZWREb2N1bWVudChkb2N1bWVudCwgbXV0YXRlZEZpZWxkcy5nZXQoZG9jdW1lbnRLZXkpID8/IG51bGwpKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlY2FsY3VsYXRlQW5kU2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBkb2NzKSB7XG4gICAgICAgIGNvbnN0IG1hc2tzID0gbmV3RG9jdW1lbnRLZXlNYXAoKTtcbiAgICAgICAgLy8gQSByZXZlcnNlIGxvb2t1cCBtYXAgZnJvbSBiYXRjaCBpZCB0byB0aGUgZG9jdW1lbnRzIHdpdGhpbiB0aGF0IGJhdGNoLlxuICAgICAgICBsZXQgZG9jdW1lbnRzQnlCYXRjaElkID0gbmV3IFNvcnRlZE1hcCgoa2V5MSwga2V5MikgPT4ga2V5MSAtIGtleTIpO1xuICAgICAgICBsZXQgcHJvY2Vzc2VkID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubXV0YXRpb25RdWV1ZVxuICAgICAgICAgICAgLmdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ0RvY3VtZW50S2V5cyh0cmFuc2FjdGlvbiwgZG9jcylcbiAgICAgICAgICAgIC5uZXh0KGJhdGNoZXMgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiBiYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2gua2V5cygpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZURvYyA9IGRvY3MuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlRG9jID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hc2sgPSBtYXNrcy5nZXQoa2V5KSB8fCBGaWVsZE1hc2suZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgbWFzayA9IGJhdGNoLmFwcGx5VG9Mb2NhbFZpZXcoYmFzZURvYywgbWFzayk7XG4gICAgICAgICAgICAgICAgICAgIG1hc2tzLnNldChrZXksIG1hc2spO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdTZXQgPSAoZG9jdW1lbnRzQnlCYXRjaElkLmdldChiYXRjaC5iYXRjaElkKSB8fCBkb2N1bWVudEtleVNldCgpKS5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRzQnlCYXRjaElkID0gZG9jdW1lbnRzQnlCYXRjaElkLmluc2VydChiYXRjaC5iYXRjaElkLCBuZXdTZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgaW4gZGVzY2VuZGluZyBvcmRlciBvZiBiYXRjaCBJRHMsIGFuZCBza2lwIGRvY3VtZW50cyB0aGF0IGFyZVxuICAgICAgICAgICAgLy8gYWxyZWFkeSBzYXZlZC5cbiAgICAgICAgICAgIGNvbnN0IGl0ZXIgPSBkb2N1bWVudHNCeUJhdGNoSWQuZ2V0UmV2ZXJzZUl0ZXJhdG9yKCk7XG4gICAgICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoSWQgPSBlbnRyeS5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IGVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlzID0gbmV3TXV0YXRpb25NYXAoKTtcbiAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9jZXNzZWQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlNdXRhdGlvbiA9IGNhbGN1bGF0ZU92ZXJsYXlNdXRhdGlvbihkb2NzLmdldChrZXkpLCBtYXNrcy5nZXQoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxheU11dGF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheXMuc2V0KGtleSwgb3ZlcmxheU11dGF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZCA9IHByb2Nlc3NlZC5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZS5zYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIGJhdGNoSWQsIG92ZXJsYXlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbWFza3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgb3ZlcmxheXMgYnkgcmVhZGluZyB0aGUgZG9jdW1lbnRzIGZyb20gcmVtb3RlIGRvY3VtZW50IGNhY2hlXG4gICAgICogZmlyc3QsIGFuZCBzYXZlcyB0aGVtIGFmdGVyIHRoZXkgYXJlIGNhbGN1bGF0ZWQuXG4gICAgICovXG4gICAgcmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXNGb3JEb2N1bWVudEtleXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlXG4gICAgICAgICAgICAuZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKVxuICAgICAgICAgICAgLm5leHQoZG9jcyA9PiB0aGlzLnJlY2FsY3VsYXRlQW5kU2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBkb2NzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcXVlcnkgYWdhaW5zdCB0aGUgbG9jYWwgdmlldyBvZiBhbGwgZG9jdW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHBlcnNpc3RlbmNlIHRyYW5zYWN0aW9uLlxuICAgICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0byBtYXRjaCBkb2N1bWVudHMgYWdhaW5zdC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IC0gUmVhZCB0aW1lIGFuZCBrZXkgdG8gc3RhcnQgc2Nhbm5pbmcgYnkgKGV4Y2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBBIG9wdGlvbmFsIHRyYWNrZXIgdG8ga2VlcCBhIHJlY29yZCBvZiBpbXBvcnRhbnQgZGV0YWlsc1xuICAgICAqICAgZHVyaW5nIGRhdGFiYXNlIGxvY2FsIHF1ZXJ5IGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChpc0RvY3VtZW50UXVlcnkkMShxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERvY3VtZW50c01hdGNoaW5nRG9jdW1lbnRRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDb2xsZWN0aW9uR3JvdXBRdWVyeShxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERvY3VtZW50c01hdGNoaW5nQ29sbGVjdGlvbkdyb3VwUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdDb2xsZWN0aW9uUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgY29sbGVjdGlvbiBncm91cCwgcmV0dXJucyB0aGUgbmV4dCBkb2N1bWVudHMgdGhhdCBmb2xsb3cgdGhlIHByb3ZpZGVkIG9mZnNldCwgYWxvbmdcbiAgICAgKiB3aXRoIGFuIHVwZGF0ZWQgYmF0Y2ggSUQuXG4gICAgICpcbiAgICAgKiA8cD5UaGUgZG9jdW1lbnRzIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kIGFyZSBvcmRlcmVkIGJ5IHJlbW90ZSB2ZXJzaW9uIGZyb20gdGhlIHByb3ZpZGVkXG4gICAgICogb2Zmc2V0LiBJZiB0aGVyZSBhcmUgbm8gbW9yZSByZW1vdGUgZG9jdW1lbnRzIGFmdGVyIHRoZSBwcm92aWRlZCBvZmZzZXQsIGRvY3VtZW50cyB3aXRoXG4gICAgICogbXV0YXRpb25zIGluIG9yZGVyIG9mIGJhdGNoIGlkIGZyb20gdGhlIG9mZnNldCBhcmUgcmV0dXJuZWQuIFNpbmNlIGFsbCBkb2N1bWVudHMgaW4gYSBiYXRjaCBhcmVcbiAgICAgKiByZXR1cm5lZCB0b2dldGhlciwgdGhlIHRvdGFsIG51bWJlciBvZiBkb2N1bWVudHMgcmV0dXJuZWQgY2FuIGV4Y2VlZCB7QGNvZGUgY291bnR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25Hcm91cCAtIFRoZSBjb2xsZWN0aW9uIGdyb3VwIGZvciB0aGUgZG9jdW1lbnRzLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHRvIGluZGV4IGludG8uXG4gICAgICogQHBhcmFtIGNvdW50IC0gVGhlIG51bWJlciBvZiBkb2N1bWVudHMgdG8gcmV0dXJuXG4gICAgICogQHJldHVybnMgQSBMb2NhbFdyaXRlUmVzdWx0IHdpdGggdGhlIGRvY3VtZW50cyB0aGF0IGZvbGxvdyB0aGUgcHJvdmlkZWQgb2Zmc2V0IGFuZCB0aGUgbGFzdCBwcm9jZXNzZWQgYmF0Y2ggaWQuXG4gICAgICovXG4gICAgZ2V0TmV4dERvY3VtZW50cyh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQsIGNvdW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGVcbiAgICAgICAgICAgIC5nZXRBbGxGcm9tQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIG9mZnNldCwgY291bnQpXG4gICAgICAgICAgICAubmV4dCgob3JpZ2luYWxEb2NzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5c1Byb21pc2UgPSBjb3VudCAtIG9yaWdpbmFsRG9jcy5zaXplID4gMFxuICAgICAgICAgICAgICAgID8gdGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZS5nZXRPdmVybGF5c0ZvckNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQubGFyZ2VzdEJhdGNoSWQsIGNvdW50IC0gb3JpZ2luYWxEb2NzLnNpemUpXG4gICAgICAgICAgICAgICAgOiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShuZXdPdmVybGF5TWFwKCkpO1xuICAgICAgICAgICAgLy8gVGhlIGNhbGxzaXRlIHdpbGwgdXNlIHRoZSBsYXJnZXN0IGJhdGNoIElEIHRvZ2V0aGVyIHdpdGggdGhlIGxhdGVzdCByZWFkIHRpbWUgdG8gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5ldyBpbmRleCBvZmZzZXQuIFNpbmNlIHdlIG9ubHkgcHJvY2VzcyBiYXRjaCBJRHMgaWYgYWxsIHJlbW90ZSBkb2N1bWVudHMgaGF2ZSBiZWVuIHJlYWQsXG4gICAgICAgICAgICAvLyBubyBvdmVybGF5IHdpbGwgaW5jcmVhc2UgdGhlIG92ZXJhbGwgcmVhZCB0aW1lLiBUaGlzIGlzIHdoeSB3ZSBvbmx5IG5lZWQgdG8gc3BlY2lhbCBjYXNlXG4gICAgICAgICAgICAvLyB0aGUgYmF0Y2ggaWQuXG4gICAgICAgICAgICBsZXQgbGFyZ2VzdEJhdGNoSWQgPSBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQ7XG4gICAgICAgICAgICBsZXQgbW9kaWZpZWREb2NzID0gb3JpZ2luYWxEb2NzO1xuICAgICAgICAgICAgcmV0dXJuIG92ZXJsYXlzUHJvbWlzZS5uZXh0KG92ZXJsYXlzID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2gob3ZlcmxheXMsIChrZXksIG92ZXJsYXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhcmdlc3RCYXRjaElkIDwgb3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFyZ2VzdEJhdGNoSWQgPSBvdmVybGF5Lmxhcmdlc3RCYXRjaElkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbERvY3MuZ2V0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRFbnRyeSh0cmFuc2FjdGlvbiwga2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm5leHQoZG9jID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRG9jcyA9IG1vZGlmaWVkRG9jcy5pbnNlcnQoa2V5LCBkb2MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB0aGlzLnBvcHVsYXRlT3ZlcmxheXModHJhbnNhY3Rpb24sIG92ZXJsYXlzLCBvcmlnaW5hbERvY3MpKVxuICAgICAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB0aGlzLmNvbXB1dGVWaWV3cyh0cmFuc2FjdGlvbiwgbW9kaWZpZWREb2NzLCBvdmVybGF5cywgZG9jdW1lbnRLZXlTZXQoKSkpXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KGxvY2FsRG9jcyA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBiYXRjaElkOiBsYXJnZXN0QmF0Y2hJZCxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogY29udmVydE92ZXJsYXllZERvY3VtZW50TWFwVG9Eb2N1bWVudE1hcChsb2NhbERvY3MpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ0RvY3VtZW50UXVlcnkodHJhbnNhY3Rpb24sIGRvY1BhdGgpIHtcbiAgICAgICAgLy8gSnVzdCBkbyBhIHNpbXBsZSBkb2N1bWVudCBsb29rdXAuXG4gICAgICAgIHJldHVybiB0aGlzLmdldERvY3VtZW50KHRyYW5zYWN0aW9uLCBuZXcgRG9jdW1lbnRLZXkoZG9jUGF0aCkpLm5leHQoZG9jdW1lbnQgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGRvY3VtZW50TWFwKCk7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuaW5zZXJ0KGRvY3VtZW50LmtleSwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldERvY3VtZW50c01hdGNoaW5nQ29sbGVjdGlvbkdyb3VwUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gcXVlcnkuY29sbGVjdGlvbkdyb3VwO1xuICAgICAgICBsZXQgcmVzdWx0cyA9IGRvY3VtZW50TWFwKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFuYWdlclxuICAgICAgICAgICAgLmdldENvbGxlY3Rpb25QYXJlbnRzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uSWQpXG4gICAgICAgICAgICAubmV4dChwYXJlbnRzID0+IHtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gYSBjb2xsZWN0aW9uIHF1ZXJ5IGFnYWluc3QgZWFjaCBwYXJlbnQgdGhhdCBjb250YWlucyB0aGVcbiAgICAgICAgICAgIC8vIGNvbGxlY3Rpb25JZCBhbmQgYWdncmVnYXRlIHRoZSByZXN1bHRzLlxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHBhcmVudHMsIChwYXJlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uUXVlcnkgPSBhc0NvbGxlY3Rpb25RdWVyeUF0UGF0aChxdWVyeSwgcGFyZW50LmNoaWxkKGNvbGxlY3Rpb25JZCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERvY3VtZW50c01hdGNoaW5nQ29sbGVjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uUXVlcnksIG9mZnNldCwgY29udGV4dCkubmV4dChyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgci5mb3JFYWNoKChrZXksIGRvYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuaW5zZXJ0KGtleSwgZG9jKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KS5uZXh0KCgpID0+IHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdDb2xsZWN0aW9uUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gUXVlcnkgdGhlIHJlbW90ZSBkb2N1bWVudHMgYW5kIG92ZXJsYXkgbXV0YXRpb25zLlxuICAgICAgICBsZXQgb3ZlcmxheXM7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50T3ZlcmxheUNhY2hlXG4gICAgICAgICAgICAuZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uKHRyYW5zYWN0aW9uLCBxdWVyeS5wYXRoLCBvZmZzZXQubGFyZ2VzdEJhdGNoSWQpXG4gICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgb3ZlcmxheXMgPSByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlLmdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQsIG92ZXJsYXlzLCBjb250ZXh0KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KHJlbW90ZURvY3VtZW50cyA9PiB7XG4gICAgICAgICAgICAvLyBBcyBkb2N1bWVudHMgbWlnaHQgbWF0Y2ggdGhlIHF1ZXJ5IGJlY2F1c2Ugb2YgdGhlaXIgb3ZlcmxheSB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBpbmNsdWRlIGRvY3VtZW50cyBmb3IgYWxsIG92ZXJsYXlzIGluIHRoZSBpbml0aWFsIGRvY3VtZW50IHNldC5cbiAgICAgICAgICAgIG92ZXJsYXlzLmZvckVhY2goKF8sIG92ZXJsYXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBvdmVybGF5LmdldEtleSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVEb2N1bWVudHMuZ2V0KGtleSkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlRG9jdW1lbnRzID0gcmVtb3RlRG9jdW1lbnRzLmluc2VydChrZXksIE11dGFibGVEb2N1bWVudC5uZXdJbnZhbGlkRG9jdW1lbnQoa2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBcHBseSB0aGUgb3ZlcmxheXMgYW5kIG1hdGNoIGFnYWluc3QgdGhlIHF1ZXJ5LlxuICAgICAgICAgICAgbGV0IHJlc3VsdHMgPSBkb2N1bWVudE1hcCgpO1xuICAgICAgICAgICAgcmVtb3RlRG9jdW1lbnRzLmZvckVhY2goKGtleSwgZG9jdW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gb3ZlcmxheXMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcob3ZlcmxheS5tdXRhdGlvbiwgZG9jdW1lbnQsIEZpZWxkTWFzay5lbXB0eSgpLCBUaW1lc3RhbXAubm93KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCBpbnNlcnQgdGhlIGRvY3VtZW50cyB0aGF0IHN0aWxsIG1hdGNoIHRoZSBxdWVyeVxuICAgICAgICAgICAgICAgIGlmIChxdWVyeU1hdGNoZXMocXVlcnksIGRvY3VtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoa2V5LCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTWVtb3J5QnVuZGxlQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICAgICAgdGhpcy5idW5kbGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm5hbWVkUXVlcmllcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZ2V0QnVuZGxlTWV0YWRhdGEodHJhbnNhY3Rpb24sIGJ1bmRsZUlkKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmJ1bmRsZXMuZ2V0KGJ1bmRsZUlkKSk7XG4gICAgfVxuICAgIHNhdmVCdW5kbGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgYnVuZGxlTWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5idW5kbGVzLnNldChidW5kbGVNZXRhZGF0YS5pZCwgZnJvbUJ1bmRsZU1ldGFkYXRhKGJ1bmRsZU1ldGFkYXRhKSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBnZXROYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubmFtZWRRdWVyaWVzLmdldChxdWVyeU5hbWUpKTtcbiAgICB9XG4gICAgc2F2ZU5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KSB7XG4gICAgICAgIHRoaXMubmFtZWRRdWVyaWVzLnNldChxdWVyeS5uYW1lLCBmcm9tUHJvdG9OYW1lZFF1ZXJ5KHF1ZXJ5KSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQW4gaW4tbWVtb3J5IGltcGxlbWVudGF0aW9uIG9mIERvY3VtZW50T3ZlcmxheUNhY2hlLlxuICovXG5jbGFzcyBNZW1vcnlEb2N1bWVudE92ZXJsYXlDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIEEgbWFwIHNvcnRlZCBieSBEb2N1bWVudEtleSwgd2hvc2UgdmFsdWUgaXMgYSBwYWlyIG9mIHRoZSBsYXJnZXN0IGJhdGNoIGlkXG4gICAgICAgIC8vIGZvciB0aGUgb3ZlcmxheSBhbmQgdGhlIG92ZXJsYXkgaXRzZWxmLlxuICAgICAgICB0aGlzLm92ZXJsYXlzID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbiAgICAgICAgdGhpcy5vdmVybGF5QnlCYXRjaElkID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXRPdmVybGF5KHRyYW5zYWN0aW9uLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMub3ZlcmxheXMuZ2V0KGtleSkpO1xuICAgIH1cbiAgICBnZXRPdmVybGF5cyh0cmFuc2FjdGlvbiwga2V5cykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXdPdmVybGF5TWFwKCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChrZXlzLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPdmVybGF5KHRyYW5zYWN0aW9uLCBrZXkpLm5leHQob3ZlcmxheSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIG92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5uZXh0KCgpID0+IHJlc3VsdCk7XG4gICAgfVxuICAgIHNhdmVPdmVybGF5cyh0cmFuc2FjdGlvbiwgbGFyZ2VzdEJhdGNoSWQsIG92ZXJsYXlzKSB7XG4gICAgICAgIG92ZXJsYXlzLmZvckVhY2goKF8sIG11dGF0aW9uKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhdmVPdmVybGF5KHRyYW5zYWN0aW9uLCBsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJlbW92ZU92ZXJsYXlzRm9yQmF0Y2hJZCh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzLCBiYXRjaElkKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLm92ZXJsYXlCeUJhdGNoSWQuZ2V0KGJhdGNoSWQpO1xuICAgICAgICBpZiAoa2V5cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+ICh0aGlzLm92ZXJsYXlzID0gdGhpcy5vdmVybGF5cy5yZW1vdmUoa2V5KSkpO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5QnlCYXRjaElkLmRlbGV0ZShiYXRjaElkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uLCBzaW5jZUJhdGNoSWQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3T3ZlcmxheU1hcCgpO1xuICAgICAgICBjb25zdCBpbW1lZGlhdGVDaGlsZHJlblBhdGhMZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCArIDE7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG5ldyBEb2N1bWVudEtleShjb2xsZWN0aW9uLmNoaWxkKCcnKSk7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSB0aGlzLm92ZXJsYXlzLmdldEl0ZXJhdG9yRnJvbShwcmVmaXgpO1xuICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gZW50cnkudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBvdmVybGF5LmdldEtleSgpO1xuICAgICAgICAgICAgaWYgKCFjb2xsZWN0aW9uLmlzUHJlZml4T2Yoa2V5LnBhdGgpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEb2N1bWVudHMgZnJvbSBzdWItY29sbGVjdGlvbnNcbiAgICAgICAgICAgIGlmIChrZXkucGF0aC5sZW5ndGggIT09IGltbWVkaWF0ZUNoaWxkcmVuUGF0aExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQgPiBzaW5jZUJhdGNoSWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KG92ZXJsYXkuZ2V0S2V5KCksIG92ZXJsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgICBnZXRPdmVybGF5c0ZvckNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBzaW5jZUJhdGNoSWQsIGNvdW50KSB7XG4gICAgICAgIGxldCBiYXRjaElkVG9PdmVybGF5cyA9IG5ldyBTb3J0ZWRNYXAoKGtleTEsIGtleTIpID0+IGtleTEgLSBrZXkyKTtcbiAgICAgICAgY29uc3QgaXRlciA9IHRoaXMub3ZlcmxheXMuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgd2hpbGUgKGl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gb3ZlcmxheS5nZXRLZXkoKTtcbiAgICAgICAgICAgIGlmIChrZXkuZ2V0Q29sbGVjdGlvbkdyb3VwKCkgIT09IGNvbGxlY3Rpb25Hcm91cCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQgPiBzaW5jZUJhdGNoSWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgb3ZlcmxheXNGb3JCYXRjaElkID0gYmF0Y2hJZFRvT3ZlcmxheXMuZ2V0KG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQpO1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5c0ZvckJhdGNoSWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheXNGb3JCYXRjaElkID0gbmV3T3ZlcmxheU1hcCgpO1xuICAgICAgICAgICAgICAgICAgICBiYXRjaElkVG9PdmVybGF5cyA9IGJhdGNoSWRUb092ZXJsYXlzLmluc2VydChvdmVybGF5Lmxhcmdlc3RCYXRjaElkLCBvdmVybGF5c0ZvckJhdGNoSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdmVybGF5c0ZvckJhdGNoSWQuc2V0KG92ZXJsYXkuZ2V0S2V5KCksIG92ZXJsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld092ZXJsYXlNYXAoKTtcbiAgICAgICAgY29uc3QgYmF0Y2hJdGVyID0gYmF0Y2hJZFRvT3ZlcmxheXMuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgd2hpbGUgKGJhdGNoSXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gYmF0Y2hJdGVyLmdldE5leHQoKTtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlzID0gZW50cnkudmFsdWU7XG4gICAgICAgICAgICBvdmVybGF5cy5mb3JFYWNoKChrZXksIG92ZXJsYXkpID0+IHJlc3VsdC5zZXQoa2V5LCBvdmVybGF5KSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnNpemUoKSA+PSBjb3VudCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgICBzYXZlT3ZlcmxheSh0cmFuc2FjdGlvbiwgbGFyZ2VzdEJhdGNoSWQsIG11dGF0aW9uKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgYXNzb2NpYXRpb24gb2YgdGhlIG92ZXJsYXkgdG8gaXRzIGJhdGNoIGlkLlxuICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMub3ZlcmxheXMuZ2V0KG11dGF0aW9uLmtleSk7XG4gICAgICAgIGlmIChleGlzdGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbmV3U2V0ID0gdGhpcy5vdmVybGF5QnlCYXRjaElkXG4gICAgICAgICAgICAgICAgLmdldChleGlzdGluZy5sYXJnZXN0QmF0Y2hJZClcbiAgICAgICAgICAgICAgICAuZGVsZXRlKG11dGF0aW9uLmtleSk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlCeUJhdGNoSWQuc2V0KGV4aXN0aW5nLmxhcmdlc3RCYXRjaElkLCBuZXdTZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3ZlcmxheXMgPSB0aGlzLm92ZXJsYXlzLmluc2VydChtdXRhdGlvbi5rZXksIG5ldyBPdmVybGF5KGxhcmdlc3RCYXRjaElkLCBtdXRhdGlvbikpO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGFzc29jaWF0aW9uIG9mIHRoaXMgb3ZlcmxheSB0byB0aGUgZ2l2ZW4gbGFyZ2VzdEJhdGNoSWQuXG4gICAgICAgIGxldCBiYXRjaCA9IHRoaXMub3ZlcmxheUJ5QmF0Y2hJZC5nZXQobGFyZ2VzdEJhdGNoSWQpO1xuICAgICAgICBpZiAoYmF0Y2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmF0Y2ggPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5QnlCYXRjaElkLnNldChsYXJnZXN0QmF0Y2hJZCwgYmF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3ZlcmxheUJ5QmF0Y2hJZC5zZXQobGFyZ2VzdEJhdGNoSWQsIGJhdGNoLmFkZChtdXRhdGlvbi5rZXkpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBNZW1vcnlHbG9iYWxzQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNlc3Npb25Ub2tlbiA9IEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkc7XG4gICAgfVxuICAgIGdldFNlc3Npb25Ub2tlbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5zZXNzaW9uVG9rZW4pO1xuICAgIH1cbiAgICBzZXRTZXNzaW9uVG9rZW4odHJhbnNhY3Rpb24sIHNlc3Npb25Ub2tlbikge1xuICAgICAgICB0aGlzLnNlc3Npb25Ub2tlbiA9IHNlc3Npb25Ub2tlbjtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgcmVmZXJlbmNlcyB0byBhIGRvY3VtZW50IGZyb20gc29tZSBraW5kIG9mIG51bWJlcmVkIGVudGl0eVxuICogKGVpdGhlciBhIHRhcmdldCBJRCBvciBiYXRjaCBJRCkuIEFzIHJlZmVyZW5jZXMgYXJlIGFkZGVkIHRvIG9yIHJlbW92ZWQgZnJvbVxuICogdGhlIHNldCBjb3JyZXNwb25kaW5nIGV2ZW50cyBhcmUgZW1pdHRlZCB0byBhIHJlZ2lzdGVyZWQgZ2FyYmFnZSBjb2xsZWN0b3IuXG4gKlxuICogRWFjaCByZWZlcmVuY2UgaXMgcmVwcmVzZW50ZWQgYnkgYSBEb2N1bWVudFJlZmVyZW5jZSBvYmplY3QuIEVhY2ggb2YgdGhlbVxuICogY29udGFpbnMgZW5vdWdoIGluZm9ybWF0aW9uIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoZSByZWZlcmVuY2UuIFRoZXkgYXJlIGFsbFxuICogc3RvcmVkIHByaW1hcmlseSBpbiBhIHNldCBzb3J0ZWQgYnkga2V5LiBBIGRvY3VtZW50IGlzIGNvbnNpZGVyZWQgZ2FyYmFnZSBpZlxuICogdGhlcmUncyBubyByZWZlcmVuY2VzIGluIHRoYXQgc2V0ICh0aGlzIGNhbiBiZSBlZmZpY2llbnRseSBjaGVja2VkIHRoYW5rcyB0b1xuICogc29ydGluZyBieSBrZXkpLlxuICpcbiAqIFJlZmVyZW5jZVNldCBhbHNvIGtlZXBzIGEgc2Vjb25kYXJ5IHNldCB0aGF0IGNvbnRhaW5zIHJlZmVyZW5jZXMgc29ydGVkIGJ5XG4gKiBJRHMuIFRoaXMgb25lIGlzIHVzZWQgdG8gZWZmaWNpZW50bHkgaW1wbGVtZW50IHJlbW92YWwgb2YgYWxsIHJlZmVyZW5jZXMgYnlcbiAqIHNvbWUgdGFyZ2V0IElELlxuICovXG5jbGFzcyBSZWZlcmVuY2VTZXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBBIHNldCBvZiBvdXRzdGFuZGluZyByZWZlcmVuY2VzIHRvIGEgZG9jdW1lbnQgc29ydGVkIGJ5IGtleS5cbiAgICAgICAgdGhpcy5yZWZzQnlLZXkgPSBuZXcgU29ydGVkU2V0KERvY1JlZmVyZW5jZS5jb21wYXJlQnlLZXkpO1xuICAgICAgICAvLyBBIHNldCBvZiBvdXRzdGFuZGluZyByZWZlcmVuY2VzIHRvIGEgZG9jdW1lbnQgc29ydGVkIGJ5IHRhcmdldCBpZC5cbiAgICAgICAgdGhpcy5yZWZzQnlUYXJnZXQgPSBuZXcgU29ydGVkU2V0KERvY1JlZmVyZW5jZS5jb21wYXJlQnlUYXJnZXRJZCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlZmVyZW5jZSBzZXQgY29udGFpbnMgbm8gcmVmZXJlbmNlcy4gKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZzQnlLZXkuaXNFbXB0eSgpO1xuICAgIH1cbiAgICAvKiogQWRkcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2l2ZW4gZG9jdW1lbnQga2V5IGZvciB0aGUgZ2l2ZW4gSUQuICovXG4gICAgYWRkUmVmZXJlbmNlKGtleSwgaWQpIHtcbiAgICAgICAgY29uc3QgcmVmID0gbmV3IERvY1JlZmVyZW5jZShrZXksIGlkKTtcbiAgICAgICAgdGhpcy5yZWZzQnlLZXkgPSB0aGlzLnJlZnNCeUtleS5hZGQocmVmKTtcbiAgICAgICAgdGhpcy5yZWZzQnlUYXJnZXQgPSB0aGlzLnJlZnNCeVRhcmdldC5hZGQocmVmKTtcbiAgICB9XG4gICAgLyoqIEFkZCByZWZlcmVuY2VzIHRvIHRoZSBnaXZlbiBkb2N1bWVudCBrZXlzIGZvciB0aGUgZ2l2ZW4gSUQuICovXG4gICAgYWRkUmVmZXJlbmNlcyhrZXlzLCBpZCkge1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHRoaXMuYWRkUmVmZXJlbmNlKGtleSwgaWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2l2ZW4gZG9jdW1lbnQga2V5IGZvciB0aGUgZ2l2ZW5cbiAgICAgKiBJRC5cbiAgICAgKi9cbiAgICByZW1vdmVSZWZlcmVuY2Uoa2V5LCBpZCkge1xuICAgICAgICB0aGlzLnJlbW92ZVJlZihuZXcgRG9jUmVmZXJlbmNlKGtleSwgaWQpKTtcbiAgICB9XG4gICAgcmVtb3ZlUmVmZXJlbmNlcyhrZXlzLCBpZCkge1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHRoaXMucmVtb3ZlUmVmZXJlbmNlKGtleSwgaWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCByZWZlcmVuY2VzIHdpdGggYSBnaXZlbiBJRC4gQ2FsbHMgcmVtb3ZlUmVmKCkgZm9yIGVhY2gga2V5XG4gICAgICogcmVtb3ZlZC5cbiAgICAgKi9cbiAgICByZW1vdmVSZWZlcmVuY2VzRm9ySWQoaWQpIHtcbiAgICAgICAgY29uc3QgZW1wdHlLZXkgPSBuZXcgRG9jdW1lbnRLZXkobmV3IFJlc291cmNlUGF0aChbXSkpO1xuICAgICAgICBjb25zdCBzdGFydFJlZiA9IG5ldyBEb2NSZWZlcmVuY2UoZW1wdHlLZXksIGlkKTtcbiAgICAgICAgY29uc3QgZW5kUmVmID0gbmV3IERvY1JlZmVyZW5jZShlbXB0eUtleSwgaWQgKyAxKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnJlZnNCeVRhcmdldC5mb3JFYWNoSW5SYW5nZShbc3RhcnRSZWYsIGVuZFJlZl0sIHJlZiA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVJlZihyZWYpO1xuICAgICAgICAgICAga2V5cy5wdXNoKHJlZi5rZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIHJlbW92ZUFsbFJlZmVyZW5jZXMoKSB7XG4gICAgICAgIHRoaXMucmVmc0J5S2V5LmZvckVhY2gocmVmID0+IHRoaXMucmVtb3ZlUmVmKHJlZikpO1xuICAgIH1cbiAgICByZW1vdmVSZWYocmVmKSB7XG4gICAgICAgIHRoaXMucmVmc0J5S2V5ID0gdGhpcy5yZWZzQnlLZXkuZGVsZXRlKHJlZik7XG4gICAgICAgIHRoaXMucmVmc0J5VGFyZ2V0ID0gdGhpcy5yZWZzQnlUYXJnZXQuZGVsZXRlKHJlZik7XG4gICAgfVxuICAgIHJlZmVyZW5jZXNGb3JJZChpZCkge1xuICAgICAgICBjb25zdCBlbXB0eUtleSA9IG5ldyBEb2N1bWVudEtleShuZXcgUmVzb3VyY2VQYXRoKFtdKSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0UmVmID0gbmV3IERvY1JlZmVyZW5jZShlbXB0eUtleSwgaWQpO1xuICAgICAgICBjb25zdCBlbmRSZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGVtcHR5S2V5LCBpZCArIDEpO1xuICAgICAgICBsZXQga2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIHRoaXMucmVmc0J5VGFyZ2V0LmZvckVhY2hJblJhbmdlKFtzdGFydFJlZiwgZW5kUmVmXSwgcmVmID0+IHtcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmFkZChyZWYua2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBjb250YWluc0tleShrZXkpIHtcbiAgICAgICAgY29uc3QgcmVmID0gbmV3IERvY1JlZmVyZW5jZShrZXksIDApO1xuICAgICAgICBjb25zdCBmaXJzdFJlZiA9IHRoaXMucmVmc0J5S2V5LmZpcnN0QWZ0ZXJPckVxdWFsKHJlZik7XG4gICAgICAgIHJldHVybiBmaXJzdFJlZiAhPT0gbnVsbCAmJiBrZXkuaXNFcXVhbChmaXJzdFJlZi5rZXkpO1xuICAgIH1cbn1cbmNsYXNzIERvY1JlZmVyZW5jZSB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCB0YXJnZXRPckJhdGNoSWQpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudGFyZ2V0T3JCYXRjaElkID0gdGFyZ2V0T3JCYXRjaElkO1xuICAgIH1cbiAgICAvKiogQ29tcGFyZSBieSBrZXkgdGhlbiBieSBJRCAqL1xuICAgIHN0YXRpYyBjb21wYXJlQnlLZXkobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIChEb2N1bWVudEtleS5jb21wYXJhdG9yKGxlZnQua2V5LCByaWdodC5rZXkpIHx8XG4gICAgICAgICAgICBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQudGFyZ2V0T3JCYXRjaElkLCByaWdodC50YXJnZXRPckJhdGNoSWQpKTtcbiAgICB9XG4gICAgLyoqIENvbXBhcmUgYnkgSUQgdGhlbiBieSBrZXkgKi9cbiAgICBzdGF0aWMgY29tcGFyZUJ5VGFyZ2V0SWQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIChwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQudGFyZ2V0T3JCYXRjaElkLCByaWdodC50YXJnZXRPckJhdGNoSWQpIHx8XG4gICAgICAgICAgICBEb2N1bWVudEtleS5jb21wYXJhdG9yKGxlZnQua2V5LCByaWdodC5rZXkpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBNZW1vcnlNdXRhdGlvblF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcihpbmRleE1hbmFnZXIsIHJlZmVyZW5jZURlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gaW5kZXhNYW5hZ2VyO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlID0gcmVmZXJlbmNlRGVsZWdhdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2V0IG9mIGFsbCBtdXRhdGlvbnMgdGhhdCBoYXZlIGJlZW4gc2VudCBidXQgbm90IHlldCBiZWVuIGFwcGxpZWQgdG9cbiAgICAgICAgICogdGhlIGJhY2tlbmQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm11dGF0aW9uUXVldWUgPSBbXTtcbiAgICAgICAgLyoqIE5leHQgdmFsdWUgdG8gdXNlIHdoZW4gYXNzaWduaW5nIHNlcXVlbnRpYWwgSURzIHRvIGVhY2ggbXV0YXRpb24gYmF0Y2guICovXG4gICAgICAgIHRoaXMubmV4dEJhdGNoSWQgPSAxO1xuICAgICAgICAvKiogQW4gb3JkZXJlZCBtYXBwaW5nIGJldHdlZW4gZG9jdW1lbnRzIGFuZCB0aGUgbXV0YXRpb25zIGJhdGNoIElEcy4gKi9cbiAgICAgICAgdGhpcy5iYXRjaGVzQnlEb2N1bWVudEtleSA9IG5ldyBTb3J0ZWRTZXQoRG9jUmVmZXJlbmNlLmNvbXBhcmVCeUtleSk7XG4gICAgfVxuICAgIGNoZWNrRW1wdHkodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPT09IDApO1xuICAgIH1cbiAgICBhZGRNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLCBsb2NhbFdyaXRlVGltZSwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGJhdGNoSWQgPSB0aGlzLm5leHRCYXRjaElkO1xuICAgICAgICB0aGlzLm5leHRCYXRjaElkKys7XG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5tdXRhdGlvblF1ZXVlW3RoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXRjaCA9IG5ldyBNdXRhdGlvbkJhdGNoKGJhdGNoSWQsIGxvY2FsV3JpdGVUaW1lLCBiYXNlTXV0YXRpb25zLCBtdXRhdGlvbnMpO1xuICAgICAgICB0aGlzLm11dGF0aW9uUXVldWUucHVzaChiYXRjaCk7XG4gICAgICAgIC8vIFRyYWNrIHJlZmVyZW5jZXMgYnkgZG9jdW1lbnQga2V5IGFuZCBpbmRleCBjb2xsZWN0aW9uIHBhcmVudHMuXG4gICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5ID0gdGhpcy5iYXRjaGVzQnlEb2N1bWVudEtleS5hZGQobmV3IERvY1JlZmVyZW5jZShtdXRhdGlvbi5rZXksIGJhdGNoSWQpKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyLmFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBtdXRhdGlvbi5rZXkucGF0aC5wb3BMYXN0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShiYXRjaCk7XG4gICAgfVxuICAgIGxvb2t1cE11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGJhdGNoSWQpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuZmluZE11dGF0aW9uQmF0Y2goYmF0Y2hJZCkpO1xuICAgIH1cbiAgICBnZXROZXh0TXV0YXRpb25CYXRjaEFmdGVyQmF0Y2hJZCh0cmFuc2FjdGlvbiwgYmF0Y2hJZCkge1xuICAgICAgICBjb25zdCBuZXh0QmF0Y2hJZCA9IGJhdGNoSWQgKyAxO1xuICAgICAgICAvLyBUaGUgcmVxdWVzdGVkIGJhdGNoSWQgbWF5IHN0aWxsIGJlIG91dCBvZiByYW5nZSBzbyBub3JtYWxpemUgaXQgdG8gdGhlXG4gICAgICAgIC8vIHN0YXJ0IG9mIHRoZSBxdWV1ZS5cbiAgICAgICAgY29uc3QgcmF3SW5kZXggPSB0aGlzLmluZGV4T2ZCYXRjaElkKG5leHRCYXRjaElkKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSByYXdJbmRleCA8IDAgPyAwIDogcmF3SW5kZXg7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLm11dGF0aW9uUXVldWUubGVuZ3RoID4gaW5kZXggPyB0aGlzLm11dGF0aW9uUXVldWVbaW5kZXhdIDogbnVsbCk7XG4gICAgfVxuICAgIGdldEhpZ2hlc3RVbmFja25vd2xlZGdlZEJhdGNoSWQoKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLm11dGF0aW9uUXVldWUubGVuZ3RoID09PSAwID8gQkFUQ0hJRF9VTktOT1dOIDogdGhpcy5uZXh0QmF0Y2hJZCAtIDEpO1xuICAgIH1cbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubXV0YXRpb25RdWV1ZS5zbGljZSgpKTtcbiAgICB9XG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nRG9jdW1lbnRLZXkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERvY1JlZmVyZW5jZShkb2N1bWVudEtleSwgMCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IG5ldyBEb2NSZWZlcmVuY2UoZG9jdW1lbnRLZXksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5LmZvckVhY2hJblJhbmdlKFtzdGFydCwgZW5kXSwgcmVmID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5maW5kTXV0YXRpb25CYXRjaChyZWYudGFyZ2V0T3JCYXRjaElkKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJhdGNoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXNBZmZlY3RpbmdEb2N1bWVudEtleXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xuICAgICAgICBsZXQgdW5pcXVlQmF0Y2hJRHMgPSBuZXcgU29ydGVkU2V0KHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xuICAgICAgICBkb2N1bWVudEtleXMuZm9yRWFjaChkb2N1bWVudEtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEb2NSZWZlcmVuY2UoZG9jdW1lbnRLZXksIDApO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gbmV3IERvY1JlZmVyZW5jZShkb2N1bWVudEtleSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkuZm9yRWFjaEluUmFuZ2UoW3N0YXJ0LCBlbmRdLCByZWYgPT4ge1xuICAgICAgICAgICAgICAgIHVuaXF1ZUJhdGNoSURzID0gdW5pcXVlQmF0Y2hJRHMuYWRkKHJlZi50YXJnZXRPckJhdGNoSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5maW5kTXV0YXRpb25CYXRjaGVzKHVuaXF1ZUJhdGNoSURzKSk7XG4gICAgfVxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSkge1xuICAgICAgICAvLyBVc2UgdGhlIHF1ZXJ5IHBhdGggYXMgYSBwcmVmaXggZm9yIHRlc3RpbmcgaWYgYSBkb2N1bWVudCBtYXRjaGVzIHRoZVxuICAgICAgICAvLyBxdWVyeS5cbiAgICAgICAgY29uc3QgcHJlZml4ID0gcXVlcnkucGF0aDtcbiAgICAgICAgY29uc3QgaW1tZWRpYXRlQ2hpbGRyZW5QYXRoTGVuZ3RoID0gcHJlZml4Lmxlbmd0aCArIDE7XG4gICAgICAgIC8vIENvbnN0cnVjdCBhIGRvY3VtZW50IHJlZmVyZW5jZSBmb3IgYWN0dWFsbHkgc2Nhbm5pbmcgdGhlIGluZGV4LiBVbmxpa2VcbiAgICAgICAgLy8gdGhlIHByZWZpeCB0aGUgZG9jdW1lbnQga2V5IGluIHRoaXMgcmVmZXJlbmNlIG11c3QgaGF2ZSBhbiBldmVuIG51bWJlciBvZlxuICAgICAgICAvLyBzZWdtZW50cy4gVGhlIGVtcHR5IHNlZ21lbnQgY2FuIGJlIHVzZWQgYSBzdWZmaXggb2YgdGhlIHF1ZXJ5IHBhdGhcbiAgICAgICAgLy8gYmVjYXVzZSBpdCBwcmVjZWRlcyBhbGwgb3RoZXIgc2VnbWVudHMgaW4gYW4gb3JkZXJlZCB0cmF2ZXJzYWwuXG4gICAgICAgIGxldCBzdGFydFBhdGggPSBwcmVmaXg7XG4gICAgICAgIGlmICghRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShzdGFydFBhdGgpKSB7XG4gICAgICAgICAgICBzdGFydFBhdGggPSBzdGFydFBhdGguY2hpbGQoJycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERvY1JlZmVyZW5jZShuZXcgRG9jdW1lbnRLZXkoc3RhcnRQYXRoKSwgMCk7XG4gICAgICAgIC8vIEZpbmQgdW5pcXVlIGJhdGNoSURzIHJlZmVyZW5jZWQgYnkgYWxsIGRvY3VtZW50cyBwb3RlbnRpYWxseSBtYXRjaGluZyB0aGVcbiAgICAgICAgLy8gcXVlcnkuXG4gICAgICAgIGxldCB1bmlxdWVCYXRjaElEcyA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XG4gICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkuZm9yRWFjaFdoaWxlKHJlZiA9PiB7XG4gICAgICAgICAgICBjb25zdCByb3dLZXlQYXRoID0gcmVmLmtleS5wYXRoO1xuICAgICAgICAgICAgaWYgKCFwcmVmaXguaXNQcmVmaXhPZihyb3dLZXlQYXRoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJvd3Mgd2l0aCBkb2N1bWVudCBrZXlzIG1vcmUgdGhhbiBvbmUgc2VnbWVudCBsb25nZXIgdGhhbiB0aGUgcXVlcnlcbiAgICAgICAgICAgICAgICAvLyBwYXRoIGNhbid0IGJlIG1hdGNoZXMuIEZvciBleGFtcGxlLCBhIHF1ZXJ5IG9uICdyb29tcycgY2FuJ3QgbWF0Y2hcbiAgICAgICAgICAgICAgICAvLyB0aGUgZG9jdW1lbnQgL3Jvb21zL2FiYy9tZXNzYWdlcy94eXguXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhtY2cpOiB3ZSdsbCBuZWVkIGEgZGlmZmVyZW50IHNjYW5uZXIgd2hlbiB3ZSBpbXBsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBhbmNlc3RvciBxdWVyaWVzLlxuICAgICAgICAgICAgICAgIGlmIChyb3dLZXlQYXRoLmxlbmd0aCA9PT0gaW1tZWRpYXRlQ2hpbGRyZW5QYXRoTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZUJhdGNoSURzID0gdW5pcXVlQmF0Y2hJRHMuYWRkKHJlZi50YXJnZXRPckJhdGNoSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3RhcnQpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5maW5kTXV0YXRpb25CYXRjaGVzKHVuaXF1ZUJhdGNoSURzKSk7XG4gICAgfVxuICAgIGZpbmRNdXRhdGlvbkJhdGNoZXMoYmF0Y2hJRHMpIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IGFuIGFycmF5IG9mIG1hdGNoaW5nIGJhdGNoZXMsIHNvcnRlZCBieSBiYXRjaElEIHRvIGVuc3VyZSB0aGF0XG4gICAgICAgIC8vIG11bHRpcGxlIG11dGF0aW9ucyBhZmZlY3RpbmcgdGhlIHNhbWUgZG9jdW1lbnQga2V5IGFyZSBhcHBsaWVkIGluIG9yZGVyLlxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgYmF0Y2hJRHMuZm9yRWFjaChiYXRjaElkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5maW5kTXV0YXRpb25CYXRjaChiYXRjaElkKTtcbiAgICAgICAgICAgIGlmIChiYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlbW92ZU11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGJhdGNoKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBiYXRjaCBmb3IgcmVtb3ZhbC5cbiAgICAgICAgY29uc3QgYmF0Y2hJbmRleCA9IHRoaXMuaW5kZXhPZkV4aXN0aW5nQmF0Y2hJZChiYXRjaC5iYXRjaElkLCAncmVtb3ZlZCcpO1xuICAgICAgICBoYXJkQXNzZXJ0KGJhdGNoSW5kZXggPT09IDAsIDB4ZDZkYik7XG4gICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZS5zaGlmdCgpO1xuICAgICAgICBsZXQgcmVmZXJlbmNlcyA9IHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChiYXRjaC5tdXRhdGlvbnMsIChtdXRhdGlvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gbmV3IERvY1JlZmVyZW5jZShtdXRhdGlvbi5rZXksIGJhdGNoLmJhdGNoSWQpO1xuICAgICAgICAgICAgcmVmZXJlbmNlcyA9IHJlZmVyZW5jZXMuZGVsZXRlKHJlZik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZS5tYXJrUG90ZW50aWFsbHlPcnBoYW5lZCh0cmFuc2FjdGlvbiwgbXV0YXRpb24ua2V5KTtcbiAgICAgICAgfSkubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5ID0gcmVmZXJlbmNlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZUNhY2hlZE11dGF0aW9uS2V5cyhiYXRjaElkKSB7XG4gICAgICAgIC8vIE5vLW9wIHNpbmNlIHRoZSBtZW1vcnkgbXV0YXRpb24gcXVldWUgZG9lcyBub3QgbWFpbnRhaW4gYSBzZXBhcmF0ZSBjYWNoZS5cbiAgICB9XG4gICAgY29udGFpbnNLZXkodHhuLCBrZXkpIHtcbiAgICAgICAgY29uc3QgcmVmID0gbmV3IERvY1JlZmVyZW5jZShrZXksIDApO1xuICAgICAgICBjb25zdCBmaXJzdFJlZiA9IHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkuZmlyc3RBZnRlck9yRXF1YWwocmVmKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGtleS5pc0VxdWFsKGZpcnN0UmVmICYmIGZpcnN0UmVmLmtleSkpO1xuICAgIH1cbiAgICBwZXJmb3JtQ29uc2lzdGVuY3lDaGVjayh0eG4pIHtcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPT09IDApIDtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gYmF0Y2hJZCBpbiB0aGUgbXV0YXRpb24gcXVldWUgYW5kIGFzc2VydHMgdGhhdFxuICAgICAqIHRoZSByZXN1bHRpbmcgaW5kZXggaXMgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIHF1ZXVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJhdGNoSWQgLSBUaGUgYmF0Y2hJZCB0byBzZWFyY2ggZm9yXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgY2FsbGVyIGlzIGRvaW5nLCBwaHJhc2VkIGluIHBhc3NpdmVcbiAgICAgKiBmb3JtIChlLmcuIFwiYWNrbm93bGVkZ2VkXCIgaW4gYSByb3V0aW5lIHRoYXQgYWNrbm93bGVkZ2VzIGJhdGNoZXMpLlxuICAgICAqL1xuICAgIGluZGV4T2ZFeGlzdGluZ0JhdGNoSWQoYmF0Y2hJZCwgYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleE9mQmF0Y2hJZChiYXRjaElkKTtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIGJhdGNoSWQgaW4gdGhlIG11dGF0aW9uIHF1ZXVlLiBUaGlzIG9wZXJhdGlvblxuICAgICAqIGlzIE8oMSkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcHV0ZWQgaW5kZXggb2YgdGhlIGJhdGNoIHdpdGggdGhlIGdpdmVuIGJhdGNoSWQsIGJhc2VkIG9uXG4gICAgICogdGhlIHN0YXRlIG9mIHRoZSBxdWV1ZS4gTm90ZSB0aGlzIGluZGV4IGNhbiBiZSBuZWdhdGl2ZSBpZiB0aGUgcmVxdWVzdGVkXG4gICAgICogYmF0Y2hJZCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcXVldWUgb3IgcGFzdCB0aGUgZW5kIG9mIHRoZVxuICAgICAqIHF1ZXVlIGlmIHRoZSBiYXRjaElkIGlzIGxhcmdlciB0aGFuIHRoZSBsYXN0IGFkZGVkIGJhdGNoLlxuICAgICAqL1xuICAgIGluZGV4T2ZCYXRjaElkKGJhdGNoSWQpIHtcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIEFzIGFuIGluZGV4IHRoaXMgaXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhhbWluZSB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlIHRvIGZpZ3VyZSBvdXQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVcbiAgICAgICAgLy8gYmF0Y2hJZCBhbmQgaW5kZXhlcyBpbiB0aGUgYXJyYXkuIE5vdGUgdGhhdCBzaW5jZSB0aGUgcXVldWUgaXMgb3JkZXJlZFxuICAgICAgICAvLyBieSBiYXRjaElkLCBpZiB0aGUgZmlyc3QgYmF0Y2ggaGFzIGEgbGFyZ2VyIGJhdGNoSWQgdGhlbiB0aGUgcmVxdWVzdGVkXG4gICAgICAgIC8vIGJhdGNoSWQgZG9lc24ndCBleGlzdCBpbiB0aGUgcXVldWUuXG4gICAgICAgIGNvbnN0IGZpcnN0QmF0Y2hJZCA9IHRoaXMubXV0YXRpb25RdWV1ZVswXS5iYXRjaElkO1xuICAgICAgICByZXR1cm4gYmF0Y2hJZCAtIGZpcnN0QmF0Y2hJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSB2ZXJzaW9uIG9mIGxvb2t1cE11dGF0aW9uQmF0Y2ggdGhhdCBkb2Vzbid0IHJldHVybiBhIHByb21pc2UsIHRoaXMgbWFrZXNcbiAgICAgKiBvdGhlciBmdW5jdGlvbnMgdGhhdCB1c2VzIHRoaXMgY29kZSBlYXNpZXIgdG8gcmVhZCBhbmQgbW9yZSBlZmZpY2llbnQuXG4gICAgICovXG4gICAgZmluZE11dGF0aW9uQmF0Y2goYmF0Y2hJZCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXhPZkJhdGNoSWQoYmF0Y2hJZCk7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLm11dGF0aW9uUXVldWVbaW5kZXhdO1xuICAgICAgICByZXR1cm4gYmF0Y2g7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgc21hbGxlc3QgdmFsdWUgcmVwcmVzZW50YWJsZSBieSBhIDY0LWJpdCBzaWduZWQgaW50ZWdlciAobG9uZykuXG4gKi9cbmNvbnN0IE1JTl9MT05HX1ZBTFVFID0gJy05MjIzMzcyMDM2ODU0Nzc1ODA4JztcbmZ1bmN0aW9uIGRvY3VtZW50RW50cnlNYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XG59XG4vKipcbiAqIFRoZSBtZW1vcnktb25seSBSZW1vdGVEb2N1bWVudENhY2hlIGZvciBJbmRleGVkRGIuIFRvIGNvbnN0cnVjdCwgaW52b2tlXG4gKiBgbmV3TWVtb3J5UmVtb3RlRG9jdW1lbnRDYWNoZSgpYC5cbiAqL1xuY2xhc3MgTWVtb3J5UmVtb3RlRG9jdW1lbnRDYWNoZUltcGwge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzaXplciAtIFVzZWQgdG8gYXNzZXNzIHRoZSBzaXplIG9mIGEgZG9jdW1lbnQuIEZvciBlYWdlciBHQywgdGhpcyBpc1xuICAgICAqIGV4cGVjdGVkIHRvIGp1c3QgcmV0dXJuIDAgdG8gYXZvaWQgdW5uZWNlc3NhcmlseSBkb2luZyB0aGUgd29yayBvZlxuICAgICAqIGNhbGN1bGF0aW5nIHRoZSBzaXplLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNpemVyKSB7XG4gICAgICAgIHRoaXMuc2l6ZXIgPSBzaXplcjtcbiAgICAgICAgLyoqIFVuZGVybHlpbmcgY2FjaGUgb2YgZG9jdW1lbnRzIGFuZCB0aGVpciByZWFkIHRpbWVzLiAqL1xuICAgICAgICB0aGlzLmRvY3MgPSBkb2N1bWVudEVudHJ5TWFwKCk7XG4gICAgICAgIC8qKiBTaXplIG9mIGFsbCBjYWNoZWQgZG9jdW1lbnRzLiAqL1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cbiAgICBzZXRJbmRleE1hbmFnZXIoaW5kZXhNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gaW5kZXhNYW5hZ2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBzdXBwbGllZCBlbnRyeSB0byB0aGUgY2FjaGUgYW5kIHVwZGF0ZXMgdGhlIGNhY2hlIHNpemUgYXMgYXBwcm9wcmlhdGUuXG4gICAgICpcbiAgICAgKiBBbGwgY2FsbHMgb2YgYGFkZEVudHJ5YCAgYXJlIHJlcXVpcmVkIHRvIGdvIHRocm91Z2ggdGhlIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyXG4gICAgICogcmV0dXJuZWQgYnkgYG5ld0NoYW5nZUJ1ZmZlcigpYC5cbiAgICAgKi9cbiAgICBhZGRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGRvYy5rZXk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5kb2NzLmdldChrZXkpO1xuICAgICAgICBjb25zdCBwcmV2aW91c1NpemUgPSBlbnRyeSA/IGVudHJ5LnNpemUgOiAwO1xuICAgICAgICBjb25zdCBjdXJyZW50U2l6ZSA9IHRoaXMuc2l6ZXIoZG9jKTtcbiAgICAgICAgdGhpcy5kb2NzID0gdGhpcy5kb2NzLmluc2VydChrZXksIHtcbiAgICAgICAgICAgIGRvY3VtZW50OiBkb2MubXV0YWJsZUNvcHkoKSxcbiAgICAgICAgICAgIHNpemU6IGN1cnJlbnRTaXplXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNpemUgKz0gY3VycmVudFNpemUgLSBwcmV2aW91c1NpemU7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFuYWdlci5hZGRUb0NvbGxlY3Rpb25QYXJlbnRJbmRleCh0cmFuc2FjdGlvbiwga2V5LnBhdGgucG9wTGFzdCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGVudHJ5IGZyb20gdGhlIGNhY2hlIGFuZCB1cGRhdGVzIHRoZSBjYWNoZSBzaXplIGFzIGFwcHJvcHJpYXRlLlxuICAgICAqXG4gICAgICogQWxsIGNhbGxzIG9mIGByZW1vdmVFbnRyeWAgYXJlIHJlcXVpcmVkIHRvIGdvIHRocm91Z2ggdGhlIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyXG4gICAgICogcmV0dXJuZWQgYnkgYG5ld0NoYW5nZUJ1ZmZlcigpYC5cbiAgICAgKi9cbiAgICByZW1vdmVFbnRyeShkb2N1bWVudEtleSkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZG9jcy5nZXQoZG9jdW1lbnRLZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jcyA9IHRoaXMuZG9jcy5yZW1vdmUoZG9jdW1lbnRLZXkpO1xuICAgICAgICAgICAgdGhpcy5zaXplIC09IGVudHJ5LnNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5kb2NzLmdldChkb2N1bWVudEtleSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShlbnRyeVxuICAgICAgICAgICAgPyBlbnRyeS5kb2N1bWVudC5tdXRhYmxlQ29weSgpXG4gICAgICAgICAgICA6IE11dGFibGVEb2N1bWVudC5uZXdJbnZhbGlkRG9jdW1lbnQoZG9jdW1lbnRLZXkpKTtcbiAgICB9XG4gICAgZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIGRvY3VtZW50S2V5cy5mb3JFYWNoKGRvY3VtZW50S2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5kb2NzLmdldChkb2N1bWVudEtleSk7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoZG9jdW1lbnRLZXksIGVudHJ5XG4gICAgICAgICAgICAgICAgPyBlbnRyeS5kb2N1bWVudC5tdXRhYmxlQ29weSgpXG4gICAgICAgICAgICAgICAgOiBNdXRhYmxlRG9jdW1lbnQubmV3SW52YWxpZERvY3VtZW50KGRvY3VtZW50S2V5KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgfVxuICAgIGdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQsIG11dGF0ZWREb2NzKSB7XG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIC8vIERvY3VtZW50cyBhcmUgb3JkZXJlZCBieSBrZXksIHNvIHdlIGNhbiB1c2UgYSBwcmVmaXggc2NhbiB0byBuYXJyb3cgZG93blxuICAgICAgICAvLyB0aGUgZG9jdW1lbnRzIHdlIG5lZWQgdG8gbWF0Y2ggdGhlIHF1ZXJ5IGFnYWluc3QuXG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25QYXRoID0gcXVlcnkucGF0aDtcbiAgICAgICAgLy8gRG9jdW1lbnQga2V5cyBhcmUgb3JkZXJlZCBmaXJzdCBieSBudW1lcmljIHZhbHVlIChcIl9faWQ8TG9uZz5fX1wiKSxcbiAgICAgICAgLy8gdGhlbiBsZXhpY29ncmFwaGljYWxseSBieSBzdHJpbmcgdmFsdWUuIFN0YXJ0IHRoZSBpdGVyYXRvciBhdCB0aGUgbWluaW11bVxuICAgICAgICAvLyBwb3NzaWJsZSBEb2N1bWVudCBrZXkgdmFsdWUuXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG5ldyBEb2N1bWVudEtleShjb2xsZWN0aW9uUGF0aC5jaGlsZCgnX19pZCcgKyBNSU5fTE9OR19WQUxVRSArICdfXycpKTtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLmRvY3MuZ2V0SXRlcmF0b3JGcm9tKHByZWZpeCk7XG4gICAgICAgIHdoaWxlIChpdGVyYXRvci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZTogeyBkb2N1bWVudCB9IH0gPSBpdGVyYXRvci5nZXROZXh0KCk7XG4gICAgICAgICAgICBpZiAoIWNvbGxlY3Rpb25QYXRoLmlzUHJlZml4T2Yoa2V5LnBhdGgpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5LnBhdGgubGVuZ3RoID4gY29sbGVjdGlvblBhdGgubGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgZW50cmllcyBmcm9tIHN1YmNvbGxlY3Rpb25zLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4T2Zmc2V0Q29tcGFyYXRvcihuZXdJbmRleE9mZnNldEZyb21Eb2N1bWVudChkb2N1bWVudCksIG9mZnNldCkgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkb2N1bWVudCBzb3J0cyBiZWZvcmUgdGhlIG9mZnNldC5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbXV0YXRlZERvY3MuaGFzKGRvY3VtZW50LmtleSkgJiYgIXF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZG9jdW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRvY3VtZW50IGNhbm5vdCBwb3NzaWJseSBtYXRjaCB0aGUgcXVlcnkuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoZG9jdW1lbnQua2V5LCBkb2N1bWVudC5tdXRhYmxlQ29weSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgfVxuICAgIGdldEFsbEZyb21Db2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0LCBsaW1pdCkge1xuICAgICAgICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSB0aGUgSW5kZXhCYWNrZmlsbGVyIGlmIHBlcnNpc3RlbmNlXG4gICAgICAgIC8vIGlzIGVuYWJsZWQuXG4gICAgICAgIGZhaWwoMHgyNTFjKTtcbiAgICB9XG4gICAgZm9yRWFjaERvY3VtZW50S2V5KHRyYW5zYWN0aW9uLCBmKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh0aGlzLmRvY3MsIChrZXkpID0+IGYoa2V5KSk7XG4gICAgfVxuICAgIG5ld0NoYW5nZUJ1ZmZlcihvcHRpb25zKSB7XG4gICAgICAgIC8vIGB0cmFja1JlbW92YWxzYCBpcyBpZ25vcmVzIHNpbmNlIHRoZSBNZW1vcnlSZW1vdGVEb2N1bWVudENhY2hlIGtlZXBzXG4gICAgICAgIC8vIGEgc2VwYXJhdGUgY2hhbmdlbG9nIGFuZCBkb2VzIG5vdCBuZWVkIHNwZWNpYWwgaGFuZGxpbmcgZm9yIHJlbW92YWxzLlxuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHRoaXMpO1xuICAgIH1cbiAgICBnZXRTaXplKHR4bikge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5zaXplKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVtb3J5LW9ubHkgUmVtb3RlRG9jdW1lbnRDYWNoZS5cbiAqXG4gKiBAcGFyYW0gc2l6ZXIgLSBVc2VkIHRvIGFzc2VzcyB0aGUgc2l6ZSBvZiBhIGRvY3VtZW50LiBGb3IgZWFnZXIgR0MsIHRoaXMgaXNcbiAqIGV4cGVjdGVkIHRvIGp1c3QgcmV0dXJuIDAgdG8gYXZvaWQgdW5uZWNlc3NhcmlseSBkb2luZyB0aGUgd29yayBvZlxuICogY2FsY3VsYXRpbmcgdGhlIHNpemUuXG4gKi9cbmZ1bmN0aW9uIG5ld01lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGUoc2l6ZXIpIHtcbiAgICByZXR1cm4gbmV3IE1lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGVJbXBsKHNpemVyKTtcbn1cbi8qKlxuICogSGFuZGxlcyB0aGUgZGV0YWlscyBvZiBhZGRpbmcgYW5kIHVwZGF0aW5nIGRvY3VtZW50cyBpbiB0aGUgTWVtb3J5UmVtb3RlRG9jdW1lbnRDYWNoZS5cbiAqL1xuY2xhc3MgTWVtb3J5UmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIgZXh0ZW5kcyBSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnRDYWNoZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRvY3VtZW50Q2FjaGUgPSBkb2N1bWVudENhY2hlO1xuICAgIH1cbiAgICBhcHBseUNoYW5nZXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmZvckVhY2goKGtleSwgZG9jKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9jLmlzVmFsaWREb2N1bWVudCgpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvY3VtZW50Q2FjaGUuYWRkRW50cnkodHJhbnNhY3Rpb24sIGRvYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudENhY2hlLnJlbW92ZUVudHJ5KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xuICAgIH1cbiAgICBnZXRGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50Q2FjaGUuZ2V0RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KTtcbiAgICB9XG4gICAgZ2V0QWxsRnJvbUNhY2hlKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRDYWNoZS5nZXRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE1lbW9yeVRhcmdldENhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwZXJzaXN0ZW5jZSkge1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gcGVyc2lzdGVuY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXBzIGEgdGFyZ2V0IHRvIHRoZSBkYXRhIGFib3V0IHRoYXQgdGFyZ2V0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhcmdldHMgPSBuZXcgT2JqZWN0TWFwKHQgPT4gY2Fub25pZnlUYXJnZXQodCksIHRhcmdldEVxdWFscyk7XG4gICAgICAgIC8qKiBUaGUgbGFzdCByZWNlaXZlZCBzbmFwc2hvdCB2ZXJzaW9uLiAqL1xuICAgICAgICB0aGlzLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPSBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgICAgIC8qKiBUaGUgaGlnaGVzdCBudW1iZXJlZCB0YXJnZXQgSUQgZW5jb3VudGVyZWQuICovXG4gICAgICAgIHRoaXMuaGlnaGVzdFRhcmdldElkID0gMDtcbiAgICAgICAgLyoqIFRoZSBoaWdoZXN0IHNlcXVlbmNlIG51bWJlciBlbmNvdW50ZXJlZC4gKi9cbiAgICAgICAgdGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBvcmRlcmVkIGJpZGlyZWN0aW9uYWwgbWFwcGluZyBiZXR3ZWVuIGRvY3VtZW50cyBhbmQgdGhlIHJlbW90ZSB0YXJnZXRcbiAgICAgICAgICogSURzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gbmV3IFJlZmVyZW5jZVNldCgpO1xuICAgICAgICB0aGlzLnRhcmdldENvdW50ID0gMDtcbiAgICAgICAgdGhpcy50YXJnZXRJZEdlbmVyYXRvciA9IFRhcmdldElkR2VuZXJhdG9yLmZvclRhcmdldENhY2hlKCk7XG4gICAgfVxuICAgIGZvckVhY2hUYXJnZXQodHhuLCBmKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0cy5mb3JFYWNoKChfLCB0YXJnZXREYXRhKSA9PiBmKHRhcmdldERhdGEpKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbik7XG4gICAgfVxuICAgIGdldEhpZ2hlc3RTZXF1ZW5jZU51bWJlcih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIpO1xuICAgIH1cbiAgICBhbGxvY2F0ZVRhcmdldElkKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuaGlnaGVzdFRhcmdldElkID0gdGhpcy50YXJnZXRJZEdlbmVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmhpZ2hlc3RUYXJnZXRJZCk7XG4gICAgfVxuICAgIHNldFRhcmdldHNNZXRhZGF0YSh0cmFuc2FjdGlvbiwgaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyLCBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgIGlmIChsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPSBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPiB0aGlzLmhpZ2hlc3RTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICAgICAgdGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIgPSBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHNhdmVUYXJnZXREYXRhKHRhcmdldERhdGEpIHtcbiAgICAgICAgdGhpcy50YXJnZXRzLnNldCh0YXJnZXREYXRhLnRhcmdldCwgdGFyZ2V0RGF0YSk7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gdGFyZ2V0RGF0YS50YXJnZXRJZDtcbiAgICAgICAgaWYgKHRhcmdldElkID4gdGhpcy5oaWdoZXN0VGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0SWRHZW5lcmF0b3IgPSBuZXcgVGFyZ2V0SWRHZW5lcmF0b3IodGFyZ2V0SWQpO1xuICAgICAgICAgICAgdGhpcy5oaWdoZXN0VGFyZ2V0SWQgPSB0YXJnZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlciA+IHRoaXMuaGlnaGVzdFNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLmhpZ2hlc3RTZXF1ZW5jZU51bWJlciA9IHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSkge1xuICAgICAgICB0aGlzLnNhdmVUYXJnZXREYXRhKHRhcmdldERhdGEpO1xuICAgICAgICB0aGlzLnRhcmdldENvdW50ICs9IDE7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIHRoaXMuc2F2ZVRhcmdldERhdGEodGFyZ2V0RGF0YSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0cy5kZWxldGUodGFyZ2V0RGF0YS50YXJnZXQpO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMucmVtb3ZlUmVmZXJlbmNlc0ZvcklkKHRhcmdldERhdGEudGFyZ2V0SWQpO1xuICAgICAgICB0aGlzLnRhcmdldENvdW50IC09IDE7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXRzKHRyYW5zYWN0aW9uLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgY29uc3QgcmVtb3ZhbHMgPSBbXTtcbiAgICAgICAgdGhpcy50YXJnZXRzLmZvckVhY2goKGtleSwgdGFyZ2V0RGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIgPD0gdXBwZXJCb3VuZCAmJlxuICAgICAgICAgICAgICAgIGFjdGl2ZVRhcmdldElkcy5nZXQodGFyZ2V0RGF0YS50YXJnZXRJZCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgcmVtb3ZhbHMucHVzaCh0aGlzLnJlbW92ZU1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhLnRhcmdldElkKSk7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihyZW1vdmFscykubmV4dCgoKSA9PiBjb3VudCk7XG4gICAgfVxuICAgIGdldFRhcmdldENvdW50KHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLnRhcmdldENvdW50KTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSB0aGlzLnRhcmdldHMuZ2V0KHRhcmdldCkgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRhcmdldERhdGEpO1xuICAgIH1cbiAgICBhZGRNYXRjaGluZ0tleXModHhuLCBrZXlzLCB0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMuYWRkUmVmZXJlbmNlcyhrZXlzLCB0YXJnZXRJZCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZW1vdmVNYXRjaGluZ0tleXModHhuLCBrZXlzLCB0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMucmVtb3ZlUmVmZXJlbmNlcyhrZXlzLCB0YXJnZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZURlbGVnYXRlID0gdGhpcy5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgaWYgKHJlZmVyZW5jZURlbGVnYXRlKSB7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHJlZmVyZW5jZURlbGVnYXRlLm1hcmtQb3RlbnRpYWxseU9ycGhhbmVkKHR4biwga2V5KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xuICAgIH1cbiAgICByZW1vdmVNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0eG4sIHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcy5yZW1vdmVSZWZlcmVuY2VzRm9ySWQodGFyZ2V0SWQpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0TWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHhuLCB0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0tleXMgPSB0aGlzLnJlZmVyZW5jZXMucmVmZXJlbmNlc0ZvcklkKHRhcmdldElkKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG1hdGNoaW5nS2V5cyk7XG4gICAgfVxuICAgIGNvbnRhaW5zS2V5KHR4biwga2V5KSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLnJlZmVyZW5jZXMuY29udGFpbnNLZXkoa2V5KSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyRkID0gJ01lbW9yeVBlcnNpc3RlbmNlJztcbi8qKlxuICogQSBtZW1vcnktYmFja2VkIGluc3RhbmNlIG9mIFBlcnNpc3RlbmNlLiBEYXRhIGlzIHN0b3JlZCBvbmx5IGluIFJBTSBhbmRcbiAqIG5vdCBwZXJzaXN0ZWQgYWNyb3NzIHNlc3Npb25zLlxuICovXG5jbGFzcyBNZW1vcnlQZXJzaXN0ZW5jZSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIGFjY2VwdHMgYSBmYWN0b3J5IGZvciBjcmVhdGluZyBhIHJlZmVyZW5jZSBkZWxlZ2F0ZS4gVGhpc1xuICAgICAqIGFsbG93cyBib3RoIHRoZSBkZWxlZ2F0ZSBhbmQgdGhpcyBpbnN0YW5jZSB0byBoYXZlIHN0cm9uZyByZWZlcmVuY2VzIHRvXG4gICAgICogZWFjaCBvdGhlciB3aXRob3V0IGhhdmluZyBudWxsYWJsZSBmaWVsZHMgdGhhdCB3b3VsZCB0aGVuIG5lZWQgdG8gYmVcbiAgICAgKiBjaGVja2VkIG9yIGFzc2VydGVkIG9uIGV2ZXJ5IGFjY2Vzcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZWZlcmVuY2VEZWxlZ2F0ZUZhY3RvcnksIHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5tdXRhdGlvblF1ZXVlcyA9IHt9O1xuICAgICAgICB0aGlzLm92ZXJsYXlzID0ge307XG4gICAgICAgIHRoaXMubGlzdGVuU2VxdWVuY2UgPSBuZXcgTGlzdGVuU2VxdWVuY2UoMCk7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZ2xvYmFsc0NhY2hlID0gbmV3IE1lbW9yeUdsb2JhbHNDYWNoZSgpO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlID0gcmVmZXJlbmNlRGVsZWdhdGVGYWN0b3J5KHRoaXMpO1xuICAgICAgICB0aGlzLnRhcmdldENhY2hlID0gbmV3IE1lbW9yeVRhcmdldENhY2hlKHRoaXMpO1xuICAgICAgICBjb25zdCBzaXplciA9IChkb2MpID0+IHRoaXMucmVmZXJlbmNlRGVsZWdhdGUuZG9jdW1lbnRTaXplKGRvYyk7XG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gbmV3IE1lbW9yeUluZGV4TWFuYWdlcigpO1xuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGUgPSBuZXdNZW1vcnlSZW1vdGVEb2N1bWVudENhY2hlKHNpemVyKTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gbmV3IExvY2FsU2VyaWFsaXplcihzZXJpYWxpemVyKTtcbiAgICAgICAgdGhpcy5idW5kbGVDYWNoZSA9IG5ldyBNZW1vcnlCdW5kbGVDYWNoZSh0aGlzLnNlcmlhbGl6ZXIpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgLy8gTm8gZHVyYWJsZSBzdGF0ZSB0byBlbnN1cmUgaXMgY2xvc2VkIG9uIHNodXRkb3duLlxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFydGVkO1xuICAgIH1cbiAgICBzZXREYXRhYmFzZURlbGV0ZWRMaXN0ZW5lcigpIHtcbiAgICAgICAgLy8gTm8gb3AuXG4gICAgfVxuICAgIHNldE5ldHdvcmtFbmFibGVkKCkge1xuICAgICAgICAvLyBObyBvcC5cbiAgICB9XG4gICAgZ2V0SW5kZXhNYW5hZ2VyKHVzZXIpIHtcbiAgICAgICAgLy8gV2UgZG8gbm90IGN1cnJlbnRseSBzdXBwb3J0IGluZGljZXMgZm9yIG1lbW9yeSBwZXJzaXN0ZW5jZSwgc28gd2UgY2FuXG4gICAgICAgIC8vIHJldHVybiB0aGUgc2FtZSBzaGFyZWQgaW5zdGFuY2Ugb2YgdGhlIG1lbW9yeSBpbmRleCBtYW5hZ2VyLlxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXI7XG4gICAgfVxuICAgIGdldERvY3VtZW50T3ZlcmxheUNhY2hlKHVzZXIpIHtcbiAgICAgICAgbGV0IG92ZXJsYXkgPSB0aGlzLm92ZXJsYXlzW3VzZXIudG9LZXkoKV07XG4gICAgICAgIGlmICghb3ZlcmxheSkge1xuICAgICAgICAgICAgb3ZlcmxheSA9IG5ldyBNZW1vcnlEb2N1bWVudE92ZXJsYXlDYWNoZSgpO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5c1t1c2VyLnRvS2V5KCldID0gb3ZlcmxheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3ZlcmxheTtcbiAgICB9XG4gICAgZ2V0TXV0YXRpb25RdWV1ZSh1c2VyLCBpbmRleE1hbmFnZXIpIHtcbiAgICAgICAgbGV0IHF1ZXVlID0gdGhpcy5tdXRhdGlvblF1ZXVlc1t1c2VyLnRvS2V5KCldO1xuICAgICAgICBpZiAoIXF1ZXVlKSB7XG4gICAgICAgICAgICBxdWV1ZSA9IG5ldyBNZW1vcnlNdXRhdGlvblF1ZXVlKGluZGV4TWFuYWdlciwgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZSk7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uUXVldWVzW3VzZXIudG9LZXkoKV0gPSBxdWV1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVldWU7XG4gICAgfVxuICAgIGdldEdsb2JhbHNDYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsc0NhY2hlO1xuICAgIH1cbiAgICBnZXRUYXJnZXRDYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0Q2FjaGU7XG4gICAgfVxuICAgIGdldFJlbW90ZURvY3VtZW50Q2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGU7XG4gICAgfVxuICAgIGdldEJ1bmRsZUNhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idW5kbGVDYWNoZTtcbiAgICB9XG4gICAgcnVuVHJhbnNhY3Rpb24oYWN0aW9uLCBtb2RlLCB0cmFuc2FjdGlvbk9wZXJhdGlvbikge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGQsICdTdGFydGluZyB0cmFuc2FjdGlvbjonLCBhY3Rpb24pO1xuICAgICAgICBjb25zdCB0eG4gPSBuZXcgTWVtb3J5VHJhbnNhY3Rpb24odGhpcy5saXN0ZW5TZXF1ZW5jZS5uZXh0KCkpO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlLm9uVHJhbnNhY3Rpb25TdGFydGVkKCk7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbk9wZXJhdGlvbih0eG4pXG4gICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlRGVsZWdhdGVcbiAgICAgICAgICAgICAgICAub25UcmFuc2FjdGlvbkNvbW1pdHRlZCh0eG4pXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50b1Byb21pc2UoKVxuICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHR4bi5yYWlzZU9uQ29tbWl0dGVkRXZlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHJhbnNhY3Rpb24sIGtleSkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLm9yKE9iamVjdC52YWx1ZXModGhpcy5tdXRhdGlvblF1ZXVlcykubWFwKHF1ZXVlID0+ICgpID0+IHF1ZXVlLmNvbnRhaW5zS2V5KHRyYW5zYWN0aW9uLCBrZXkpKSk7XG4gICAgfVxufVxuLyoqXG4gKiBNZW1vcnkgcGVyc2lzdGVuY2UgaXMgbm90IGFjdHVhbGx5IHRyYW5zYWN0aW9uYWwsIGJ1dCBmdXR1cmUgaW1wbGVtZW50YXRpb25zXG4gKiBtYXkgaGF2ZSB0cmFuc2FjdGlvbi1zY29wZWQgc3RhdGUuXG4gKi9cbmNsYXNzIE1lbW9yeVRyYW5zYWN0aW9uIGV4dGVuZHMgUGVyc2lzdGVuY2VUcmFuc2FjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY3VycmVudFNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFNlcXVlbmNlTnVtYmVyID0gY3VycmVudFNlcXVlbmNlTnVtYmVyO1xuICAgIH1cbn1cbmNsYXNzIE1lbW9yeUVhZ2VyRGVsZWdhdGUge1xuICAgIGNvbnN0cnVjdG9yKHBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICAgICAgLyoqIFRyYWNrcyBhbGwgZG9jdW1lbnRzIHRoYXQgYXJlIGFjdGl2ZSBpbiBRdWVyeSB2aWV3cy4gKi9cbiAgICAgICAgdGhpcy5sb2NhbFZpZXdSZWZlcmVuY2VzID0gbmV3IFJlZmVyZW5jZVNldCgpO1xuICAgICAgICAvKiogVGhlIGxpc3Qgb2YgZG9jdW1lbnRzIHRoYXQgYXJlIHBvdGVudGlhbGx5IEdDZWQgYWZ0ZXIgZWFjaCB0cmFuc2FjdGlvbi4gKi9cbiAgICAgICAgdGhpcy5fb3JwaGFuZWREb2N1bWVudHMgPSBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZmFjdG9yeShwZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeUVhZ2VyRGVsZWdhdGUocGVyc2lzdGVuY2UpO1xuICAgIH1cbiAgICBnZXQgb3JwaGFuZWREb2N1bWVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3JwaGFuZWREb2N1bWVudHMpIHtcbiAgICAgICAgICAgIHRocm93IGZhaWwoMHhlZTQ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcnBoYW5lZERvY3VtZW50cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRSZWZlcmVuY2UodHhuLCB0YXJnZXRJZCwga2V5KSB7XG4gICAgICAgIHRoaXMubG9jYWxWaWV3UmVmZXJlbmNlcy5hZGRSZWZlcmVuY2Uoa2V5LCB0YXJnZXRJZCk7XG4gICAgICAgIHRoaXMub3JwaGFuZWREb2N1bWVudHMuZGVsZXRlKGtleS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJlbW92ZVJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpIHtcbiAgICAgICAgdGhpcy5sb2NhbFZpZXdSZWZlcmVuY2VzLnJlbW92ZVJlZmVyZW5jZShrZXksIHRhcmdldElkKTtcbiAgICAgICAgdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgbWFya1BvdGVudGlhbGx5T3JwaGFuZWQodHhuLCBrZXkpIHtcbiAgICAgICAgdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmVtb3ZlVGFyZ2V0KHR4biwgdGFyZ2V0RGF0YSkge1xuICAgICAgICBjb25zdCBvcnBoYW5lZCA9IHRoaXMubG9jYWxWaWV3UmVmZXJlbmNlcy5yZW1vdmVSZWZlcmVuY2VzRm9ySWQodGFyZ2V0RGF0YS50YXJnZXRJZCk7XG4gICAgICAgIG9ycGhhbmVkLmZvckVhY2goa2V5ID0+IHRoaXMub3JwaGFuZWREb2N1bWVudHMuYWRkKGtleS50b1N0cmluZygpKSk7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5wZXJzaXN0ZW5jZS5nZXRUYXJnZXRDYWNoZSgpO1xuICAgICAgICByZXR1cm4gY2FjaGVcbiAgICAgICAgICAgIC5nZXRNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0eG4sIHRhcmdldERhdGEudGFyZ2V0SWQpXG4gICAgICAgICAgICAubmV4dChrZXlzID0+IHtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNhY2hlLnJlbW92ZVRhcmdldERhdGEodHhuLCB0YXJnZXREYXRhKSk7XG4gICAgfVxuICAgIG9uVHJhbnNhY3Rpb25TdGFydGVkKCkge1xuICAgICAgICB0aGlzLl9vcnBoYW5lZERvY3VtZW50cyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgb25UcmFuc2FjdGlvbkNvbW1pdHRlZCh0eG4pIHtcbiAgICAgICAgLy8gUmVtb3ZlIG5ld2x5IG9ycGhhbmVkIGRvY3VtZW50cy5cbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnBlcnNpc3RlbmNlLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKTtcbiAgICAgICAgY29uc3QgY2hhbmdlQnVmZmVyID0gY2FjaGUubmV3Q2hhbmdlQnVmZmVyKCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh0aGlzLm9ycGhhbmVkRG9jdW1lbnRzLCAocGF0aCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gRG9jdW1lbnRLZXkuZnJvbVBhdGgocGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1JlZmVyZW5jZWQodHhuLCBrZXkpLm5leHQoaXNSZWZlcmVuY2VkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmVmZXJlbmNlZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VCdWZmZXIucmVtb3ZlRW50cnkoa2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX29ycGhhbmVkRG9jdW1lbnRzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VCdWZmZXIuYXBwbHkodHhuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZUxpbWJvRG9jdW1lbnQodHhuLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNSZWZlcmVuY2VkKHR4biwga2V5KS5uZXh0KGlzUmVmZXJlbmNlZCA9PiB7XG4gICAgICAgICAgICBpZiAoaXNSZWZlcmVuY2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcnBoYW5lZERvY3VtZW50cy5kZWxldGUoa2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZG9jdW1lbnRTaXplKGRvYykge1xuICAgICAgICAvLyBGb3IgZWFnZXIgR0MsIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIGRvY3VtZW50IHNpemUsIHRoZXJlIGFyZSBubyBzaXplIHRocmVzaG9sZHMuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpc1JlZmVyZW5jZWQodHhuLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5vcihbXG4gICAgICAgICAgICAoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmxvY2FsVmlld1JlZmVyZW5jZXMuY29udGFpbnNLZXkoa2V5KSksXG4gICAgICAgICAgICAoKSA9PiB0aGlzLnBlcnNpc3RlbmNlLmdldFRhcmdldENhY2hlKCkuY29udGFpbnNLZXkodHhuLCBrZXkpLFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5wZXJzaXN0ZW5jZS5tdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHhuLCBrZXkpXG4gICAgICAgIF0pO1xuICAgIH1cbn1cbmNsYXNzIE1lbW9yeUxydURlbGVnYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihwZXJzaXN0ZW5jZSwgbHJ1UGFyYW1zKSB7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycyA9IG5ldyBPYmplY3RNYXAoayA9PiBlbmNvZGVSZXNvdXJjZVBhdGgoay5wYXRoKSwgKGwsIHIpID0+IGwuaXNFcXVhbChyKSk7XG4gICAgICAgIHRoaXMuZ2FyYmFnZUNvbGxlY3RvciA9IG5ld0xydUdhcmJhZ2VDb2xsZWN0b3IodGhpcywgbHJ1UGFyYW1zKTtcbiAgICB9XG4gICAgc3RhdGljIGZhY3RvcnkocGVyc2lzdGVuY2UsIGxydVBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeUxydURlbGVnYXRlKHBlcnNpc3RlbmNlLCBscnVQYXJhbXMpO1xuICAgIH1cbiAgICAvLyBOby1vcHMsIHByZXNlbnQgc28gbWVtb3J5IHBlcnNpc3RlbmNlIGRvZXNuJ3QgaGF2ZSB0byBjYXJlIHdoaWNoIGRlbGVnYXRlXG4gICAgLy8gaXQgaGFzLlxuICAgIG9uVHJhbnNhY3Rpb25TdGFydGVkKCkgeyB9XG4gICAgb25UcmFuc2FjdGlvbkNvbW1pdHRlZCh0eG4pIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGZvckVhY2hUYXJnZXQodHhuLCBmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLmdldFRhcmdldENhY2hlKCkuZm9yRWFjaFRhcmdldCh0eG4sIGYpO1xuICAgIH1cbiAgICBnZXRTZXF1ZW5jZU51bWJlckNvdW50KHR4bikge1xuICAgICAgICBjb25zdCBkb2NDb3VudFByb21pc2UgPSB0aGlzLm9ycGhhbmVkRG9jdW1lbnRDb3VudCh0eG4pO1xuICAgICAgICBjb25zdCB0YXJnZXRDb3VudFByb21pc2UgPSB0aGlzLnBlcnNpc3RlbmNlXG4gICAgICAgICAgICAuZ2V0VGFyZ2V0Q2FjaGUoKVxuICAgICAgICAgICAgLmdldFRhcmdldENvdW50KHR4bik7XG4gICAgICAgIHJldHVybiB0YXJnZXRDb3VudFByb21pc2UubmV4dCh0YXJnZXRDb3VudCA9PiBkb2NDb3VudFByb21pc2UubmV4dChkb2NDb3VudCA9PiB0YXJnZXRDb3VudCArIGRvY0NvdW50KSk7XG4gICAgfVxuICAgIG9ycGhhbmVkRG9jdW1lbnRDb3VudCh0eG4pIHtcbiAgICAgICAgbGV0IG9ycGhhbmVkQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoT3JwaGFuZWREb2N1bWVudFNlcXVlbmNlTnVtYmVyKHR4biwgXyA9PiB7XG4gICAgICAgICAgICBvcnBoYW5lZENvdW50Kys7XG4gICAgICAgIH0pLm5leHQoKCkgPT4gb3JwaGFuZWRDb3VudCk7XG4gICAgfVxuICAgIGZvckVhY2hPcnBoYW5lZERvY3VtZW50U2VxdWVuY2VOdW1iZXIodHhuLCBmKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh0aGlzLm9ycGhhbmVkU2VxdWVuY2VOdW1iZXJzLCAoa2V5LCBzZXF1ZW5jZU51bWJlcikgPT4ge1xuICAgICAgICAgICAgLy8gUGFzcyBpbiB0aGUgZXhhY3Qgc2VxdWVuY2UgbnVtYmVyIGFzIHRoZSB1cHBlciBib3VuZCBzbyB3ZSBrbm93IGl0IHdvbid0IGJlIHBpbm5lZCBieVxuICAgICAgICAgICAgLy8gYmVpbmcgdG9vIHJlY2VudC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUGlubmVkKHR4biwga2V5LCBzZXF1ZW5jZU51bWJlcikubmV4dChpc1Bpbm5lZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Bpbm5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZihzZXF1ZW5jZU51bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2VcbiAgICAgICAgICAgIC5nZXRUYXJnZXRDYWNoZSgpXG4gICAgICAgICAgICAucmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcyk7XG4gICAgfVxuICAgIHJlbW92ZU9ycGhhbmVkRG9jdW1lbnRzKHR4biwgdXBwZXJCb3VuZCkge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMucGVyc2lzdGVuY2UuZ2V0UmVtb3RlRG9jdW1lbnRDYWNoZSgpO1xuICAgICAgICBjb25zdCBjaGFuZ2VCdWZmZXIgPSBjYWNoZS5uZXdDaGFuZ2VCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgcCA9IGNhY2hlLmZvckVhY2hEb2N1bWVudEtleSh0eG4sIGtleSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1Bpbm5lZCh0eG4sIGtleSwgdXBwZXJCb3VuZCkubmV4dChpc1Bpbm5lZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Bpbm5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VCdWZmZXIucmVtb3ZlRW50cnkoa2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHAubmV4dCgoKSA9PiBjaGFuZ2VCdWZmZXIuYXBwbHkodHhuKSkubmV4dCgoKSA9PiBjb3VudCk7XG4gICAgfVxuICAgIG1hcmtQb3RlbnRpYWxseU9ycGhhbmVkKHR4biwga2V5KSB7XG4gICAgICAgIHRoaXMub3JwaGFuZWRTZXF1ZW5jZU51bWJlcnMuc2V0KGtleSwgdHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlcik7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXQodHhuLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWQgPSB0YXJnZXREYXRhLndpdGhTZXF1ZW5jZU51bWJlcih0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuZ2V0VGFyZ2V0Q2FjaGUoKS51cGRhdGVUYXJnZXREYXRhKHR4biwgdXBkYXRlZCk7XG4gICAgfVxuICAgIGFkZFJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpIHtcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5zZXQoa2V5LCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJlbW92ZVJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpIHtcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5zZXQoa2V5LCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHVwZGF0ZUxpbWJvRG9jdW1lbnQodHhuLCBrZXkpIHtcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5zZXQoa2V5LCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGRvY3VtZW50U2l6ZShkb2N1bWVudCkge1xuICAgICAgICBsZXQgZG9jdW1lbnRTaXplID0gZG9jdW1lbnQua2V5LnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICBpZiAoZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgIGRvY3VtZW50U2l6ZSArPSBlc3RpbWF0ZUJ5dGVTaXplKGRvY3VtZW50LmRhdGEudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2N1bWVudFNpemU7XG4gICAgfVxuICAgIGlzUGlubmVkKHR4biwga2V5LCB1cHBlckJvdW5kKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uub3IoW1xuICAgICAgICAgICAgKCkgPT4gdGhpcy5wZXJzaXN0ZW5jZS5tdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHhuLCBrZXkpLFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5wZXJzaXN0ZW5jZS5nZXRUYXJnZXRDYWNoZSgpLmNvbnRhaW5zS2V5KHR4biwga2V5KSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcnBoYW5lZEF0ID0gdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUob3JwaGFuZWRBdCAhPT0gdW5kZWZpbmVkICYmIG9ycGhhbmVkQXQgPiB1cHBlckJvdW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGdldENhY2hlU2l6ZSh0eG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuZ2V0UmVtb3RlRG9jdW1lbnRDYWNoZSgpLmdldFNpemUodHhuKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogUGVyZm9ybXMgZGF0YWJhc2UgY3JlYXRpb24gYW5kIHNjaGVtYSB1cGdyYWRlcy4gKi9cbmNsYXNzIFNjaGVtYUNvbnZlcnRlciB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplcikge1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBkYXRhYmFzZSBjcmVhdGlvbiBhbmQgc2NoZW1hIHVwZ3JhZGVzLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGluIHByb2R1Y3Rpb24sIHRoaXMgbWV0aG9kIGlzIG9ubHkgZXZlciB1c2VkIHRvIHVwZ3JhZGUgdGhlIHNjaGVtYVxuICAgICAqIHRvIFNDSEVNQV9WRVJTSU9OLiBEaWZmZXJlbnQgdmFsdWVzIG9mIHRvVmVyc2lvbiBhcmUgb25seSB1c2VkIGZvciB0ZXN0aW5nXG4gICAgICogYW5kIGxvY2FsIGZlYXR1cmUgZGV2ZWxvcG1lbnQuXG4gICAgICovXG4gICAgY3JlYXRlT3JVcGdyYWRlKGRiLCB0eG4sIGZyb21WZXJzaW9uLCB0b1ZlcnNpb24pIHtcbiAgICAgICAgY29uc3Qgc2ltcGxlRGJUcmFuc2FjdGlvbiA9IG5ldyBTaW1wbGVEYlRyYW5zYWN0aW9uKCdjcmVhdGVPclVwZ3JhZGUnLCB0eG4pO1xuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxICYmIHRvVmVyc2lvbiA+PSAxKSB7XG4gICAgICAgICAgICBjcmVhdGVQcmltYXJ5Q2xpZW50U3RvcmUoZGIpO1xuICAgICAgICAgICAgY3JlYXRlTXV0YXRpb25RdWV1ZShkYik7XG4gICAgICAgICAgICBjcmVhdGVRdWVyeUNhY2hlKGRiKTtcbiAgICAgICAgICAgIGNyZWF0ZUxlZ2FjeVJlbW90ZURvY3VtZW50Q2FjaGUoZGIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1pZ3JhdGlvbiAyIHRvIHBvcHVsYXRlIHRoZSB0YXJnZXRHbG9iYWwgb2JqZWN0IG5vIGxvbmdlciBuZWVkZWQgc2luY2VcbiAgICAgICAgLy8gbWlncmF0aW9uIDMgdW5jb25kaXRpb25hbGx5IGNsZWFycyBpdC5cbiAgICAgICAgbGV0IHAgPSBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAzICYmIHRvVmVyc2lvbiA+PSAzKSB7XG4gICAgICAgICAgICAvLyBCcmFuZCBuZXcgY2xpZW50cyBkb24ndCBuZWVkIHRvIGRyb3AgYW5kIHJlY3JlYXRlLS1vbmx5IGNsaWVudHMgdGhhdFxuICAgICAgICAgICAgLy8gcG90ZW50aWFsbHkgaGF2ZSBjb3JydXB0IGRhdGEuXG4gICAgICAgICAgICBpZiAoZnJvbVZlcnNpb24gIT09IDApIHtcbiAgICAgICAgICAgICAgICBkcm9wUXVlcnlDYWNoZShkYik7XG4gICAgICAgICAgICAgICAgY3JlYXRlUXVlcnlDYWNoZShkYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHdyaXRlRW1wdHlUYXJnZXRHbG9iYWxFbnRyeShzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgNCAmJiB0b1ZlcnNpb24gPj0gNCkge1xuICAgICAgICAgICAgaWYgKGZyb21WZXJzaW9uICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NoZW1hIHZlcnNpb24gMyB1c2VzIGF1dG8tZ2VuZXJhdGVkIGtleXMgdG8gZ2VuZXJhdGUgZ2xvYmFsbHkgdW5pcXVlXG4gICAgICAgICAgICAgICAgLy8gbXV0YXRpb24gYmF0Y2ggSURzICh0aGlzIHdhcyBwcmV2aW91c2x5IGVuc3VyZWQgaW50ZXJuYWxseSBieSB0aGVcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQpLiBUbyBtaWdyYXRlIHRvIHRoZSBuZXcgc2NoZW1hLCB3ZSBoYXZlIHRvIHJlYWQgYWxsIG11dGF0aW9uc1xuICAgICAgICAgICAgICAgIC8vIGFuZCB3cml0ZSB0aGVtIGJhY2sgb3V0LiBXZSBwcmVzZXJ2ZSB0aGUgZXhpc3RpbmcgYmF0Y2ggSURzIHRvIGd1YXJhbnRlZVxuICAgICAgICAgICAgICAgIC8vIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgb2JqZWN0IHN0b3Jlcy4gQW55IGZ1cnRoZXIgbXV0YXRpb24gYmF0Y2ggSURzIHdpbGxcbiAgICAgICAgICAgICAgICAvLyBiZSBhdXRvLWdlbmVyYXRlZC5cbiAgICAgICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHVwZ3JhZGVNdXRhdGlvbkJhdGNoU2NoZW1hQW5kTWlncmF0ZURhdGEoZGIsIHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUNsaWVudE1ldGFkYXRhU3RvcmUoZGIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgNSAmJiB0b1ZlcnNpb24gPj0gNSkge1xuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB0aGlzLnJlbW92ZUFja25vd2xlZGdlZE11dGF0aW9ucyhzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgNiAmJiB0b1ZlcnNpb24gPj0gNikge1xuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3JlYXRlRG9jdW1lbnRHbG9iYWxTdG9yZShkYik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkRG9jdW1lbnRHbG9iYWwoc2ltcGxlRGJUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA3ICYmIHRvVmVyc2lvbiA+PSA3KSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHRoaXMuZW5zdXJlU2VxdWVuY2VOdW1iZXJzKHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA4ICYmIHRvVmVyc2lvbiA+PSA4KSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHRoaXMuY3JlYXRlQ29sbGVjdGlvblBhcmVudEluZGV4KGRiLCBzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgOSAmJiB0b1ZlcnNpb24gPj0gOSkge1xuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTXVsdGktVGFiIHVzZWQgdG8gbWFuYWdlIGl0cyBvd24gY2hhbmdlbG9nLCBidXQgdGhpcyBoYXMgYmVlbiBtb3ZlZFxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBEYlJlbW90ZURvY3VtZW50IG9iamVjdCBzdG9yZSBpdHNlbGYuIFNpbmNlIHRoZSBwcmV2aW91cyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAvLyBsb2cgb25seSBjb250YWluZWQgdHJhbnNpZW50IGRhdGEsIHdlIGNhbiBkcm9wIGl0cyBvYmplY3Qgc3RvcmUuXG4gICAgICAgICAgICAgICAgZHJvcFJlbW90ZURvY3VtZW50Q2hhbmdlc1N0b3JlKGRiKTtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBTY2hlbWEgdmVyc2lvbiA5IHVzZWQgdG8gY3JlYXRlIGEgcmVhZCB0aW1lIGluZGV4IGZvciB0aGVcbiAgICAgICAgICAgICAgICAvLyBSZW1vdGVEb2N1bWVudENhY2hlLiBUaGlzIGlzIG5vdyBkb25lIHdpdGggc2NoZW1hIHZlcnNpb24gMTMuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxMCAmJiB0b1ZlcnNpb24gPj0gMTApIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdGhpcy5yZXdyaXRlQ2Fub25pY2FsSWRzKHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxMSAmJiB0b1ZlcnNpb24gPj0gMTEpIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUJ1bmRsZXNTdG9yZShkYik7XG4gICAgICAgICAgICAgICAgY3JlYXRlTmFtZWRRdWVyaWVzU3RvcmUoZGIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgMTIgJiYgdG9WZXJzaW9uID49IDEyKSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjcmVhdGVEb2N1bWVudE92ZXJsYXlTdG9yZShkYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxMyAmJiB0b1ZlcnNpb24gPj0gMTMpIHtcbiAgICAgICAgICAgIHAgPSBwXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gY3JlYXRlUmVtb3RlRG9jdW1lbnRDYWNoZShkYikpXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gdGhpcy5yZXdyaXRlUmVtb3RlRG9jdW1lbnRDYWNoZShkYiwgc2ltcGxlRGJUcmFuc2FjdGlvbikpXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gZGIuZGVsZXRlT2JqZWN0U3RvcmUoRGJSZW1vdGVEb2N1bWVudFN0b3JlJDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxNCAmJiB0b1ZlcnNpb24gPj0gMTQpIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdGhpcy5ydW5PdmVybGF5TWlncmF0aW9uKGRiLCBzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgMTUgJiYgdG9WZXJzaW9uID49IDE1KSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IGNyZWF0ZUZpZWxkSW5kZXgoZGIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxNiAmJiB0b1ZlcnNpb24gPj0gMTYpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBvYmplY3Qgc3RvcmVzIHRvIHJlbW92ZSBwb3NzaWJseSBjb3JydXB0ZWQgaW5kZXggZW50cmllc1xuICAgICAgICAgICAgcCA9IHBcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhTdGF0ZVN0b3JlID0gdHhuLm9iamVjdFN0b3JlKERiSW5kZXhTdGF0ZVN0b3JlKTtcbiAgICAgICAgICAgICAgICBpbmRleFN0YXRlU3RvcmUuY2xlYXIoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4RW50cnlTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShEYkluZGV4RW50cnlTdG9yZSk7XG4gICAgICAgICAgICAgICAgaW5kZXhFbnRyeVN0b3JlLmNsZWFyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxNyAmJiB0b1ZlcnNpb24gPj0gMTcpIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUdsb2JhbHNTdG9yZShkYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxOCAmJiB0b1ZlcnNpb24gPj0gMTgpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBJbmRleEVudHJ5U3RvcmVzIG9uIFdlYktpdCBhbmQgU2FmYXJpIHRvIHJlbW92ZSBwb3NzaWJseVxuICAgICAgICAgICAgLy8gY29ycnVwdGVkIGluZGV4IGVudHJpZXNcbiAgICAgICAgICAgIGlmIChpc1NhZmFyaU9yV2Via2l0KCkpIHtcbiAgICAgICAgICAgICAgICBwID0gcFxuICAgICAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4U3RhdGVTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShEYkluZGV4U3RhdGVTdG9yZSk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4U3RhdGVTdG9yZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXhFbnRyeVN0b3JlID0gdHhuLm9iamVjdFN0b3JlKERiSW5kZXhFbnRyeVN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhFbnRyeVN0b3JlLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGFkZERvY3VtZW50R2xvYmFsKHR4bikge1xuICAgICAgICBsZXQgYnl0ZVNpemUgPSAwO1xuICAgICAgICByZXR1cm4gdHhuXG4gICAgICAgICAgICAuc3RvcmUoRGJSZW1vdGVEb2N1bWVudFN0b3JlJDEpXG4gICAgICAgICAgICAuaXRlcmF0ZSgoXywgZG9jKSA9PiB7XG4gICAgICAgICAgICBieXRlU2l6ZSArPSBkYkRvY3VtZW50U2l6ZShkb2MpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7IGJ5dGVTaXplIH07XG4gICAgICAgICAgICByZXR1cm4gdHhuXG4gICAgICAgICAgICAgICAgLnN0b3JlKERiUmVtb3RlRG9jdW1lbnRHbG9iYWxTdG9yZSlcbiAgICAgICAgICAgICAgICAucHV0KERiUmVtb3RlRG9jdW1lbnRHbG9iYWxLZXksIG1ldGFkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZUFja25vd2xlZGdlZE11dGF0aW9ucyh0eG4pIHtcbiAgICAgICAgY29uc3QgcXVldWVzU3RvcmUgPSB0eG4uc3RvcmUoRGJNdXRhdGlvblF1ZXVlU3RvcmUpO1xuICAgICAgICBjb25zdCBtdXRhdGlvbnNTdG9yZSA9IHR4bi5zdG9yZShEYk11dGF0aW9uQmF0Y2hTdG9yZSk7XG4gICAgICAgIHJldHVybiBxdWV1ZXNTdG9yZS5sb2FkQWxsKCkubmV4dChxdWV1ZXMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHF1ZXVlcywgKHF1ZXVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbcXVldWUudXNlcklkLCBCQVRDSElEX1VOS05PV05dLCBbcXVldWUudXNlcklkLCBxdWV1ZS5sYXN0QWNrbm93bGVkZ2VkQmF0Y2hJZF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZVxuICAgICAgICAgICAgICAgICAgICAubG9hZEFsbChEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zSW5kZXgsIHJhbmdlKVxuICAgICAgICAgICAgICAgICAgICAubmV4dChkYkJhdGNoZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goZGJCYXRjaGVzLCAoZGJCYXRjaCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFyZEFzc2VydChkYkJhdGNoLnVzZXJJZCA9PT0gcXVldWUudXNlcklkLCAweDQ4ZGEsIGBDYW5ub3QgcHJvY2VzcyBiYXRjaCBmcm9tIHVuZXhwZWN0ZWQgdXNlcmAsIHsgYmF0Y2hJZDogZGJCYXRjaC5iYXRjaElkIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgZGJCYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlTXV0YXRpb25CYXRjaCh0eG4sIHF1ZXVlLnVzZXJJZCwgYmF0Y2gpLm5leHQoKCkgPT4geyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCBldmVyeSBkb2N1bWVudCBpbiB0aGUgcmVtb3RlIGRvY3VtZW50IGNhY2hlIGhhcyBhIGNvcnJlc3BvbmRpbmcgc2VudGluZWwgcm93XG4gICAgICogd2l0aCBhIHNlcXVlbmNlIG51bWJlci4gTWlzc2luZyByb3dzIGFyZSBnaXZlbiB0aGUgbW9zdCByZWNlbnRseSB1c2VkIHNlcXVlbmNlIG51bWJlci5cbiAgICAgKi9cbiAgICBlbnN1cmVTZXF1ZW5jZU51bWJlcnModHhuKSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50VGFyZ2V0U3RvcmUgPSB0eG4uc3RvcmUoRGJUYXJnZXREb2N1bWVudFN0b3JlKTtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRzU3RvcmUgPSB0eG4uc3RvcmUoRGJSZW1vdGVEb2N1bWVudFN0b3JlJDEpO1xuICAgICAgICBjb25zdCBnbG9iYWxUYXJnZXRTdG9yZSA9IHR4bi5zdG9yZShEYlRhcmdldEdsb2JhbFN0b3JlKTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRhcmdldFN0b3JlLmdldChEYlRhcmdldEdsb2JhbEtleSkubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3cml0ZVNlbnRpbmVsS2V5ID0gKHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRUYXJnZXRTdG9yZS5wdXQoe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRJZDogMCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogZW5jb2RlUmVzb3VyY2VQYXRoKHBhdGgpLFxuICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZU51bWJlcjogbWV0YWRhdGEuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudHNTdG9yZVxuICAgICAgICAgICAgICAgIC5pdGVyYXRlKChrZXksIGRvYykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBuZXcgUmVzb3VyY2VQYXRoKGtleSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jU2VudGluZWxLZXkgPSBzZW50aW5lbEtleShwYXRoKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRvY3VtZW50VGFyZ2V0U3RvcmUuZ2V0KGRvY1NlbnRpbmVsS2V5KS5uZXh0KG1heWJlU2VudGluZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heWJlU2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZVNlbnRpbmVsS2V5KHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVDb2xsZWN0aW9uUGFyZW50SW5kZXgoZGIsIHR4bikge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGluZGV4LlxuICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkNvbGxlY3Rpb25QYXJlbnRTdG9yZSwge1xuICAgICAgICAgICAga2V5UGF0aDogRGJDb2xsZWN0aW9uUGFyZW50S2V5UGF0aFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvblBhcmVudHNTdG9yZSA9IHR4bi5zdG9yZShEYkNvbGxlY3Rpb25QYXJlbnRTdG9yZSk7XG4gICAgICAgIC8vIEhlbHBlciB0byBhZGQgYW4gaW5kZXggZW50cnkgaWZmIHdlIGhhdmVuJ3QgYWxyZWFkeSB3cml0dGVuIGl0LlxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBNZW1vcnlDb2xsZWN0aW9uUGFyZW50SW5kZXgoKTtcbiAgICAgICAgY29uc3QgYWRkRW50cnkgPSAoY29sbGVjdGlvblBhdGgpID0+IHtcbiAgICAgICAgICAgIGlmIChjYWNoZS5hZGQoY29sbGVjdGlvblBhdGgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gY29sbGVjdGlvblBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gY29sbGVjdGlvblBhdGgucG9wTGFzdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uUGFyZW50c1N0b3JlLnB1dCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBlbmNvZGVSZXNvdXJjZVBhdGgocGFyZW50UGF0aClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gSW5kZXggZXhpc3RpbmcgcmVtb3RlIGRvY3VtZW50cy5cbiAgICAgICAgcmV0dXJuIHR4blxuICAgICAgICAgICAgLnN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxKVxuICAgICAgICAgICAgLml0ZXJhdGUoeyBrZXlzT25seTogdHJ1ZSB9LCAocGF0aFNlZ21lbnRzLCBfKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gbmV3IFJlc291cmNlUGF0aChwYXRoU2VnbWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEVudHJ5KHBhdGgucG9wTGFzdCgpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIEluZGV4IGV4aXN0aW5nIG11dGF0aW9ucy5cbiAgICAgICAgICAgIHJldHVybiB0eG5cbiAgICAgICAgICAgICAgICAuc3RvcmUoRGJEb2N1bWVudE11dGF0aW9uU3RvcmUpXG4gICAgICAgICAgICAgICAgLml0ZXJhdGUoeyBrZXlzT25seTogdHJ1ZSB9LCAoW3VzZXJJRCwgZW5jb2RlZFBhdGgsIGJhdGNoSWRdLCBfKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRlY29kZVJlc291cmNlUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZEVudHJ5KHBhdGgucG9wTGFzdCgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV3cml0ZUNhbm9uaWNhbElkcyh0eG4pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0U3RvcmUgPSB0eG4uc3RvcmUoRGJUYXJnZXRTdG9yZSk7XG4gICAgICAgIHJldHVybiB0YXJnZXRTdG9yZS5pdGVyYXRlKChrZXksIG9yaWdpbmFsRGJUYXJnZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsVGFyZ2V0RGF0YSA9IGZyb21EYlRhcmdldChvcmlnaW5hbERiVGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWREYlRhcmdldCA9IHRvRGJUYXJnZXQodGhpcy5zZXJpYWxpemVyLCBvcmlnaW5hbFRhcmdldERhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFN0b3JlLnB1dCh1cGRhdGVkRGJUYXJnZXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV3cml0ZVJlbW90ZURvY3VtZW50Q2FjaGUoZGIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGxlZ2FjeVJlbW90ZURvY3VtZW50U3RvcmUgPSB0cmFuc2FjdGlvbi5zdG9yZShEYlJlbW90ZURvY3VtZW50U3RvcmUkMSk7XG4gICAgICAgIGNvbnN0IHdyaXRlcyA9IFtdO1xuICAgICAgICByZXR1cm4gbGVnYWN5UmVtb3RlRG9jdW1lbnRTdG9yZVxuICAgICAgICAgICAgLml0ZXJhdGUoKF8sIGxlZ2FjeURvY3VtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVEb2N1bWVudFN0b3JlID0gdHJhbnNhY3Rpb24uc3RvcmUoRGJSZW1vdGVEb2N1bWVudFN0b3JlKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBleHRyYWN0S2V5KGxlZ2FjeURvY3VtZW50KS5wYXRoLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIGNvbnN0IGRiUmVtb3RlRG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgcHJlZml4UGF0aDogcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDIpLFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25Hcm91cDogcGF0aFtwYXRoLmxlbmd0aCAtIDJdLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50SWQ6IHBhdGhbcGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICByZWFkVGltZTogbGVnYWN5RG9jdW1lbnQucmVhZFRpbWUgfHwgWzAsIDBdLFxuICAgICAgICAgICAgICAgIHVua25vd25Eb2N1bWVudDogbGVnYWN5RG9jdW1lbnQudW5rbm93bkRvY3VtZW50LFxuICAgICAgICAgICAgICAgIG5vRG9jdW1lbnQ6IGxlZ2FjeURvY3VtZW50Lm5vRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQ6IGxlZ2FjeURvY3VtZW50LmRvY3VtZW50LFxuICAgICAgICAgICAgICAgIGhhc0NvbW1pdHRlZE11dGF0aW9uczogISFsZWdhY3lEb2N1bWVudC5oYXNDb21taXR0ZWRNdXRhdGlvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3cml0ZXMucHVzaChyZW1vdGVEb2N1bWVudFN0b3JlLnB1dChkYlJlbW90ZURvY3VtZW50KSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcih3cml0ZXMpKTtcbiAgICB9XG4gICAgcnVuT3ZlcmxheU1pZ3JhdGlvbihkYiwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgbXV0YXRpb25zU3RvcmUgPSB0cmFuc2FjdGlvbi5zdG9yZShEYk11dGF0aW9uQmF0Y2hTdG9yZSk7XG4gICAgICAgIGNvbnN0IHJlbW90ZURvY3VtZW50Q2FjaGUgPSBuZXdJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlKHRoaXMuc2VyaWFsaXplcik7XG4gICAgICAgIGNvbnN0IG1lbW9yeVBlcnNpc3RlbmNlID0gbmV3IE1lbW9yeVBlcnNpc3RlbmNlKE1lbW9yeUVhZ2VyRGVsZWdhdGUuZmFjdG9yeSwgdGhpcy5zZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIpO1xuICAgICAgICByZXR1cm4gbXV0YXRpb25zU3RvcmUubG9hZEFsbCgpLm5leHQoZGJCYXRjaGVzID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJUb0RvY3VtZW50U2V0ID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZGJCYXRjaGVzLmZvckVhY2goZGJCYXRjaCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGRvY3VtZW50U2V0ID0gdXNlclRvRG9jdW1lbnRTZXQuZ2V0KGRiQmF0Y2gudXNlcklkKSA/PyBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gZnJvbURiTXV0YXRpb25CYXRjaCh0aGlzLnNlcmlhbGl6ZXIsIGRiQmF0Y2gpO1xuICAgICAgICAgICAgICAgIGJhdGNoLmtleXMoKS5mb3JFYWNoKGtleSA9PiAoZG9jdW1lbnRTZXQgPSBkb2N1bWVudFNldC5hZGQoa2V5KSkpO1xuICAgICAgICAgICAgICAgIHVzZXJUb0RvY3VtZW50U2V0LnNldChkYkJhdGNoLnVzZXJJZCwgZG9jdW1lbnRTZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godXNlclRvRG9jdW1lbnRTZXQsIChhbGxEb2N1bWVudEtleXNGb3JVc2VyLCB1c2VySWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyID0gbmV3IFVzZXIodXNlcklkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudE92ZXJsYXlDYWNoZSA9IEluZGV4ZWREYkRvY3VtZW50T3ZlcmxheUNhY2hlLmZvclVzZXIodGhpcy5zZXJpYWxpemVyLCB1c2VyKTtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBUaGUgaW5kZXggbWFuYWdlciBhbmQgdGhlIHJlZmVyZW5jZSBkZWxlZ2F0ZSBhcmVcbiAgICAgICAgICAgICAgICAvLyBpcnJlbGV2YW50IGZvciB0aGUgcHVycG9zZSBvZiByZWNhbGN1bGF0aW5nIGFuZCBzYXZpbmdcbiAgICAgICAgICAgICAgICAvLyBvdmVybGF5cy4gV2UgY2FuIHRoZXJlZm9yZSBzaW1wbHkgdXNlIHRoZSBtZW1vcnlcbiAgICAgICAgICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleE1hbmFnZXIgPSBtZW1vcnlQZXJzaXN0ZW5jZS5nZXRJbmRleE1hbmFnZXIodXNlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgbXV0YXRpb25RdWV1ZSA9IEluZGV4ZWREYk11dGF0aW9uUXVldWUuZm9yVXNlcih1c2VyLCB0aGlzLnNlcmlhbGl6ZXIsIGluZGV4TWFuYWdlciwgbWVtb3J5UGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsRG9jdW1lbnRzVmlldyA9IG5ldyBMb2NhbERvY3VtZW50c1ZpZXcocmVtb3RlRG9jdW1lbnRDYWNoZSwgbXV0YXRpb25RdWV1ZSwgZG9jdW1lbnRPdmVybGF5Q2FjaGUsIGluZGV4TWFuYWdlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsRG9jdW1lbnRzVmlld1xuICAgICAgICAgICAgICAgICAgICAucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXNGb3JEb2N1bWVudEtleXMobmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKSwgYWxsRG9jdW1lbnRLZXlzRm9yVXNlcilcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZW50aW5lbEtleShwYXRoKSB7XG4gICAgcmV0dXJuIFswLCBlbmNvZGVSZXNvdXJjZVBhdGgocGF0aCldO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJpbWFyeUNsaWVudFN0b3JlKGRiKSB7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJQcmltYXJ5Q2xpZW50U3RvcmUpO1xufVxuZnVuY3Rpb24gY3JlYXRlTXV0YXRpb25RdWV1ZShkYikge1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiTXV0YXRpb25RdWV1ZVN0b3JlLCB7XG4gICAgICAgIGtleVBhdGg6IERiTXV0YXRpb25RdWV1ZUtleVBhdGhcbiAgICB9KTtcbiAgICBjb25zdCBtdXRhdGlvbkJhdGNoZXNTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlLCB7XG4gICAgICAgIGtleVBhdGg6IERiTXV0YXRpb25CYXRjaEtleVBhdGgsXG4gICAgICAgIGF1dG9JbmNyZW1lbnQ6IHRydWVcbiAgICB9KTtcbiAgICBtdXRhdGlvbkJhdGNoZXNTdG9yZS5jcmVhdGVJbmRleChEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zSW5kZXgsIERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNLZXlQYXRoLCB7IHVuaXF1ZTogdHJ1ZSB9KTtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkRvY3VtZW50TXV0YXRpb25TdG9yZSk7XG59XG4vKipcbiAqIFVwZ3JhZGUgZnVuY3Rpb24gdG8gbWlncmF0ZSB0aGUgJ211dGF0aW9ucycgc3RvcmUgZnJvbSBWMSB0byBWMy4gTG9hZHNcbiAqIGFuZCByZXdyaXRlcyBhbGwgZGF0YS5cbiAqL1xuZnVuY3Rpb24gdXBncmFkZU11dGF0aW9uQmF0Y2hTY2hlbWFBbmRNaWdyYXRlRGF0YShkYiwgdHhuKSB7XG4gICAgY29uc3QgdjFNdXRhdGlvbnNTdG9yZSA9IHR4bi5zdG9yZShEYk11dGF0aW9uQmF0Y2hTdG9yZSk7XG4gICAgcmV0dXJuIHYxTXV0YXRpb25zU3RvcmUubG9hZEFsbCgpLm5leHQoZXhpc3RpbmdNdXRhdGlvbnMgPT4ge1xuICAgICAgICBkYi5kZWxldGVPYmplY3RTdG9yZShEYk11dGF0aW9uQmF0Y2hTdG9yZSk7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uc1N0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJNdXRhdGlvbkJhdGNoU3RvcmUsIHtcbiAgICAgICAgICAgIGtleVBhdGg6IERiTXV0YXRpb25CYXRjaEtleVBhdGgsXG4gICAgICAgICAgICBhdXRvSW5jcmVtZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBtdXRhdGlvbnNTdG9yZS5jcmVhdGVJbmRleChEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zSW5kZXgsIERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNLZXlQYXRoLCB7IHVuaXF1ZTogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgdjNNdXRhdGlvbnNTdG9yZSA9IHR4bi5zdG9yZShEYk11dGF0aW9uQmF0Y2hTdG9yZSk7XG4gICAgICAgIGNvbnN0IHdyaXRlQWxsID0gZXhpc3RpbmdNdXRhdGlvbnMubWFwKG11dGF0aW9uID0+IHYzTXV0YXRpb25zU3RvcmUucHV0KG11dGF0aW9uKSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcih3cml0ZUFsbCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVMZWdhY3lSZW1vdGVEb2N1bWVudENhY2hlKGRiKSB7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJSZW1vdGVEb2N1bWVudFN0b3JlJDEpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVtb3RlRG9jdW1lbnRDYWNoZShkYikge1xuICAgIGNvbnN0IHJlbW90ZURvY3VtZW50U3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYlJlbW90ZURvY3VtZW50U3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJSZW1vdGVEb2N1bWVudEtleVBhdGhcbiAgICB9KTtcbiAgICByZW1vdGVEb2N1bWVudFN0b3JlLmNyZWF0ZUluZGV4KERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4LCBEYlJlbW90ZURvY3VtZW50RG9jdW1lbnRLZXlJbmRleFBhdGgpO1xuICAgIHJlbW90ZURvY3VtZW50U3RvcmUuY3JlYXRlSW5kZXgoRGJSZW1vdGVEb2N1bWVudENvbGxlY3Rpb25Hcm91cEluZGV4LCBEYlJlbW90ZURvY3VtZW50Q29sbGVjdGlvbkdyb3VwSW5kZXhQYXRoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50R2xvYmFsU3RvcmUoZGIpIHtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYlJlbW90ZURvY3VtZW50R2xvYmFsU3RvcmUpO1xufVxuZnVuY3Rpb24gY3JlYXRlUXVlcnlDYWNoZShkYikge1xuICAgIGNvbnN0IHRhcmdldERvY3VtZW50c1N0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJUYXJnZXREb2N1bWVudFN0b3JlLCB7XG4gICAgICAgIGtleVBhdGg6IERiVGFyZ2V0RG9jdW1lbnRLZXlQYXRoXG4gICAgfSk7XG4gICAgdGFyZ2V0RG9jdW1lbnRzU3RvcmUuY3JlYXRlSW5kZXgoRGJUYXJnZXREb2N1bWVudERvY3VtZW50VGFyZ2V0c0luZGV4LCBEYlRhcmdldERvY3VtZW50RG9jdW1lbnRUYXJnZXRzS2V5UGF0aCwgeyB1bmlxdWU6IHRydWUgfSk7XG4gICAgY29uc3QgdGFyZ2V0U3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYlRhcmdldFN0b3JlLCB7XG4gICAgICAgIGtleVBhdGg6IERiVGFyZ2V0S2V5UGF0aFxuICAgIH0pO1xuICAgIC8vIE5PVEU6IFRoaXMgaXMgdW5pcXVlIG9ubHkgYmVjYXVzZSB0aGUgVGFyZ2V0SWQgaXMgdGhlIHN1ZmZpeC5cbiAgICB0YXJnZXRTdG9yZS5jcmVhdGVJbmRleChEYlRhcmdldFF1ZXJ5VGFyZ2V0c0luZGV4TmFtZSwgRGJUYXJnZXRRdWVyeVRhcmdldHNLZXlQYXRoLCB7IHVuaXF1ZTogdHJ1ZSB9KTtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYlRhcmdldEdsb2JhbFN0b3JlKTtcbn1cbmZ1bmN0aW9uIGRyb3BRdWVyeUNhY2hlKGRiKSB7XG4gICAgZGIuZGVsZXRlT2JqZWN0U3RvcmUoRGJUYXJnZXREb2N1bWVudFN0b3JlKTtcbiAgICBkYi5kZWxldGVPYmplY3RTdG9yZShEYlRhcmdldFN0b3JlKTtcbiAgICBkYi5kZWxldGVPYmplY3RTdG9yZShEYlRhcmdldEdsb2JhbFN0b3JlKTtcbn1cbmZ1bmN0aW9uIGRyb3BSZW1vdGVEb2N1bWVudENoYW5nZXNTdG9yZShkYikge1xuICAgIGlmIChkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCdyZW1vdGVEb2N1bWVudENoYW5nZXMnKSkge1xuICAgICAgICBkYi5kZWxldGVPYmplY3RTdG9yZSgncmVtb3RlRG9jdW1lbnRDaGFuZ2VzJyk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIHRoZSB0YXJnZXQgZ2xvYmFsIHNpbmdsZXRvbiByb3cuXG4gKlxuICogQHBhcmFtIHR4biAtIFRoZSB2ZXJzaW9uIHVwZ3JhZGUgdHJhbnNhY3Rpb24gZm9yIGluZGV4ZWRkYlxuICovXG5mdW5jdGlvbiB3cml0ZUVtcHR5VGFyZ2V0R2xvYmFsRW50cnkodHhuKSB7XG4gICAgY29uc3QgZ2xvYmFsU3RvcmUgPSB0eG4uc3RvcmUoRGJUYXJnZXRHbG9iYWxTdG9yZSk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgIGhpZ2hlc3RUYXJnZXRJZDogMCxcbiAgICAgICAgaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgICBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uOiBTbmFwc2hvdFZlcnNpb24ubWluKCkudG9UaW1lc3RhbXAoKSxcbiAgICAgICAgdGFyZ2V0Q291bnQ6IDBcbiAgICB9O1xuICAgIHJldHVybiBnbG9iYWxTdG9yZS5wdXQoRGJUYXJnZXRHbG9iYWxLZXksIG1ldGFkYXRhKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudE1ldGFkYXRhU3RvcmUoZGIpIHtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkNsaWVudE1ldGFkYXRhU3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJDbGllbnRNZXRhZGF0YUtleVBhdGhcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJ1bmRsZXNTdG9yZShkYikge1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiQnVuZGxlU3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJCdW5kbGVLZXlQYXRoXG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVOYW1lZFF1ZXJpZXNTdG9yZShkYikge1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiTmFtZWRRdWVyeVN0b3JlLCB7XG4gICAgICAgIGtleVBhdGg6IERiTmFtZWRRdWVyeUtleVBhdGhcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpZWxkSW5kZXgoZGIpIHtcbiAgICBjb25zdCBpbmRleENvbmZpZ3VyYXRpb25TdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiSW5kZXhDb25maWd1cmF0aW9uU3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJJbmRleENvbmZpZ3VyYXRpb25LZXlQYXRoLFxuICAgICAgICBhdXRvSW5jcmVtZW50OiB0cnVlXG4gICAgfSk7XG4gICAgaW5kZXhDb25maWd1cmF0aW9uU3RvcmUuY3JlYXRlSW5kZXgoRGJJbmRleENvbmZpZ3VyYXRpb25Db2xsZWN0aW9uR3JvdXBJbmRleCwgRGJJbmRleENvbmZpZ3VyYXRpb25Db2xsZWN0aW9uR3JvdXBJbmRleFBhdGgsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbiAgICBjb25zdCBpbmRleFN0YXRlU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkluZGV4U3RhdGVTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYkluZGV4U3RhdGVLZXlQYXRoXG4gICAgfSk7XG4gICAgaW5kZXhTdGF0ZVN0b3JlLmNyZWF0ZUluZGV4KERiSW5kZXhTdGF0ZVNlcXVlbmNlTnVtYmVySW5kZXgsIERiSW5kZXhTdGF0ZVNlcXVlbmNlTnVtYmVySW5kZXhQYXRoLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG4gICAgY29uc3QgaW5kZXhFbnRyeVN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJJbmRleEVudHJ5U3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJJbmRleEVudHJ5S2V5UGF0aFxuICAgIH0pO1xuICAgIGluZGV4RW50cnlTdG9yZS5jcmVhdGVJbmRleChEYkluZGV4RW50cnlEb2N1bWVudEtleUluZGV4LCBEYkluZGV4RW50cnlEb2N1bWVudEtleUluZGV4UGF0aCwgeyB1bmlxdWU6IGZhbHNlIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnRPdmVybGF5U3RvcmUoZGIpIHtcbiAgICBjb25zdCBkb2N1bWVudE92ZXJsYXlTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiRG9jdW1lbnRPdmVybGF5U3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJEb2N1bWVudE92ZXJsYXlLZXlQYXRoXG4gICAgfSk7XG4gICAgZG9jdW1lbnRPdmVybGF5U3RvcmUuY3JlYXRlSW5kZXgoRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleCwgRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleFBhdGgsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbiAgICBkb2N1bWVudE92ZXJsYXlTdG9yZS5jcmVhdGVJbmRleChEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25Hcm91cE92ZXJsYXlJbmRleCwgRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uR3JvdXBPdmVybGF5SW5kZXhQYXRoLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVHbG9iYWxzU3RvcmUoZGIpIHtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkdsb2JhbHNTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYkdsb2JhbHNLZXlQYXRoXG4gICAgfSk7XG59XG5mdW5jdGlvbiBleHRyYWN0S2V5KHJlbW90ZURvYykge1xuICAgIGlmIChyZW1vdGVEb2MuZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhyZW1vdGVEb2MuZG9jdW1lbnQubmFtZSkucG9wRmlyc3QoNSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZW1vdGVEb2Mubm9Eb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKHJlbW90ZURvYy5ub0RvY3VtZW50LnBhdGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZW1vdGVEb2MudW5rbm93bkRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBEb2N1bWVudEtleS5mcm9tU2VnbWVudHMocmVtb3RlRG9jLnVua25vd25Eb2N1bWVudC5wYXRoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKDB4OGZhZik7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyRjID0gJ0luZGV4ZWREYlBlcnNpc3RlbmNlJztcbi8qKlxuICogT2xkZXN0IGFjY2VwdGFibGUgYWdlIGluIG1pbGxpc2Vjb25kcyBmb3IgY2xpZW50IG1ldGFkYXRhIGJlZm9yZSB0aGUgY2xpZW50XG4gKiBpcyBjb25zaWRlcmVkIGluYWN0aXZlIGFuZCBpdHMgYXNzb2NpYXRlZCBkYXRhIGlzIGdhcmJhZ2UgY29sbGVjdGVkLlxuICovXG5jb25zdCBNQVhfQ0xJRU5UX0FHRV9NUyA9IDMwICogNjAgKiAxMDAwOyAvLyAzMCBtaW51dGVzXG4vKipcbiAqIE9sZGVzdCBhY2NlcHRhYmxlIG1ldGFkYXRhIGFnZSBmb3IgY2xpZW50cyB0aGF0IG1heSBwYXJ0aWNpcGF0ZSBpbiB0aGVcbiAqIHByaW1hcnkgbGVhc2UgZWxlY3Rpb24uIENsaWVudHMgdGhhdCBoYXZlIG5vdCB1cGRhdGVkIHRoZWlyIGNsaWVudCBtZXRhZGF0YVxuICogd2l0aGluIDUgc2Vjb25kcyBhcmUgbm90IGVsaWdpYmxlIHRvIHJlY2VpdmUgYSBwcmltYXJ5IGxlYXNlLlxuICovXG5jb25zdCBNQVhfUFJJTUFSWV9FTElHSUJMRV9BR0VfTVMgPSA1MDAwO1xuLyoqXG4gKiBUaGUgaW50ZXJ2YWwgYXQgd2hpY2ggY2xpZW50cyB3aWxsIHVwZGF0ZSB0aGVpciBtZXRhZGF0YSwgaW5jbHVkaW5nXG4gKiByZWZyZXNoaW5nIHRoZWlyIHByaW1hcnkgbGVhc2UgaWYgaGVsZCBvciBwb3RlbnRpYWxseSB0cnlpbmcgdG8gYWNxdWlyZSBpdCBpZlxuICogbm90IGhlbGQuXG4gKlxuICogUHJpbWFyeSBjbGllbnRzIG1heSBvcHBvcnR1bmlzdGljYWxseSByZWZyZXNoIHRoZWlyIG1ldGFkYXRhIGVhcmxpZXJcbiAqIGlmIHRoZXkncmUgYWxyZWFkeSBwZXJmb3JtaW5nIGFuIEluZGV4ZWREQiBvcGVyYXRpb24uXG4gKi9cbmNvbnN0IENMSUVOVF9NRVRBREFUQV9SRUZSRVNIX0lOVEVSVkFMX01TID0gNDAwMDtcbi8qKiBVc2VyLWZhY2luZyBlcnJvciB3aGVuIHRoZSBwcmltYXJ5IGxlYXNlIGlzIHJlcXVpcmVkIGJ1dCBub3QgYXZhaWxhYmxlLiAqL1xuY29uc3QgUFJJTUFSWV9MRUFTRV9FWENMVVNJVkVfRVJST1JfTVNHID0gJ0ZhaWxlZCB0byBvYnRhaW4gZXhjbHVzaXZlIGFjY2VzcyB0byB0aGUgcGVyc2lzdGVuY2UgbGF5ZXIuIFRvIGFsbG93ICcgK1xuICAgICdzaGFyZWQgYWNjZXNzLCBtdWx0aS10YWIgc3luY2hyb25pemF0aW9uIGhhcyB0byBiZSBlbmFibGVkIGluIGFsbCB0YWJzLiAnICtcbiAgICAnSWYgeW91IGFyZSB1c2luZyBgZXhwZXJpbWVudGFsRm9yY2VPd25pbmdUYWI6dHJ1ZWAsIG1ha2Ugc3VyZSB0aGF0IG9ubHkgJyArXG4gICAgJ29uZSB0YWIgaGFzIHBlcnNpc3RlbmNlIGVuYWJsZWQgYXQgYW55IGdpdmVuIHRpbWUuJztcbmNvbnN0IFVOU1VQUE9SVEVEX1BMQVRGT1JNX0VSUk9SX01TRyA9ICdUaGlzIHBsYXRmb3JtIGlzIGVpdGhlciBtaXNzaW5nIEluZGV4ZWREQiBvciBpcyBrbm93biB0byBoYXZlICcgK1xuICAgICdhbiBpbmNvbXBsZXRlIGltcGxlbWVudGF0aW9uLiBPZmZsaW5lIHBlcnNpc3RlbmNlIGhhcyBiZWVuIGRpc2FibGVkLic7XG4vLyBUaGUgZm9ybWF0IG9mIHRoZSBMb2NhbFN0b3JhZ2Uga2V5IHRoYXQgc3RvcmVzIHpvbWJpZWQgY2xpZW50IGlzOlxuLy8gICAgIGZpcmVzdG9yZV96b21iaWVfPHBlcnNpc3RlbmNlX3ByZWZpeD5fPGluc3RhbmNlX2tleT5cbmNvbnN0IFpPTUJJRURfQ0xJRU5UU19LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV96b21iaWUnO1xuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWFpbiAoYW5kIGN1cnJlbnRseSBvbmx5KSBJbmRleGVkREIgZGF0YWJhc2UuIFRoaXMgbmFtZSBpc1xuICogYXBwZW5kZWQgdG8gdGhlIHByZWZpeCBwcm92aWRlZCB0byB0aGUgSW5kZXhlZERiUGVyc2lzdGVuY2UgY29uc3RydWN0b3IuXG4gKi9cbmNvbnN0IE1BSU5fREFUQUJBU0UgPSAnbWFpbic7XG4vKipcbiAqIEFuIEluZGV4ZWREQi1iYWNrZWQgaW5zdGFuY2Ugb2YgUGVyc2lzdGVuY2UuIERhdGEgaXMgc3RvcmVkIHBlcnNpc3RlbnRseVxuICogYWNyb3NzIHNlc3Npb25zLlxuICpcbiAqIE9uIFdlYiBvbmx5LCB0aGUgRmlyZXN0b3JlIFNES3Mgc3VwcG9ydCBzaGFyZWQgYWNjZXNzIHRvIGl0cyBwZXJzaXN0ZW5jZVxuICogbGF5ZXIuIFRoaXMgYWxsb3dzIG11bHRpcGxlIGJyb3dzZXIgdGFicyB0byByZWFkIGFuZCB3cml0ZSB0byBJbmRleGVkRGIgYW5kXG4gKiB0byBzeW5jaHJvbml6ZSBzdGF0ZSBldmVuIHdpdGhvdXQgbmV0d29yayBjb25uZWN0aXZpdHkuIFNoYXJlZCBhY2Nlc3MgaXNcbiAqIGN1cnJlbnRseSBvcHRpb25hbCBhbmQgbm90IGVuYWJsZWQgdW5sZXNzIGFsbCBjbGllbnRzIGludm9rZVxuICogYGVuYWJsZVBlcnNpc3RlbmNlKClgIHdpdGggYHtzeW5jaHJvbml6ZVRhYnM6dHJ1ZX1gLlxuICpcbiAqIEluIG11bHRpLXRhYiBtb2RlLCBpZiBtdWx0aXBsZSBjbGllbnRzIGFyZSBhY3RpdmUgYXQgdGhlIHNhbWUgdGltZSwgdGhlIFNES1xuICogd2lsbCBkZXNpZ25hdGUgb25lIGNsaWVudCBhcyB0aGUgXCJwcmltYXJ5IGNsaWVudFwiLiBBbiBlZmZvcnQgaXMgbWFkZSB0byBwaWNrXG4gKiBhIHZpc2libGUsIG5ldHdvcmstY29ubmVjdGVkIGFuZCBhY3RpdmUgY2xpZW50LCBhbmQgdGhpcyBjbGllbnQgaXNcbiAqIHJlc3BvbnNpYmxlIGZvciBsZXR0aW5nIG90aGVyIGNsaWVudHMga25vdyBhYm91dCBpdHMgcHJlc2VuY2UuIFRoZSBwcmltYXJ5XG4gKiBjbGllbnQgd3JpdGVzIGEgdW5pcXVlIGNsaWVudC1nZW5lcmF0ZWQgaWRlbnRpZmllciAodGhlIGNsaWVudCBJRCkgdG9cbiAqIEluZGV4ZWREYuKAmXMgXCJvd25lclwiIHN0b3JlIGV2ZXJ5IDQgc2Vjb25kcy4gSWYgdGhlIHByaW1hcnkgY2xpZW50IGZhaWxzIHRvXG4gKiB1cGRhdGUgdGhpcyBlbnRyeSwgYW5vdGhlciBjbGllbnQgY2FuIGFjcXVpcmUgdGhlIGxlYXNlIGFuZCB0YWtlIG92ZXIgYXNcbiAqIHByaW1hcnkuXG4gKlxuICogU29tZSBwZXJzaXN0ZW5jZSBvcGVyYXRpb25zIGluIHRoZSBTREsgYXJlIGRlc2lnbmF0ZWQgYXMgcHJpbWFyeS1jbGllbnQgb25seVxuICogb3BlcmF0aW9ucy4gVGhpcyBpbmNsdWRlcyB0aGUgYWNrbm93bGVkZ21lbnQgb2YgbXV0YXRpb25zIGFuZCBhbGwgdXBkYXRlcyBvZlxuICogcmVtb3RlIGRvY3VtZW50cy4gVGhlIGVmZmVjdHMgb2YgdGhlc2Ugb3BlcmF0aW9ucyBhcmUgd3JpdHRlbiB0byBwZXJzaXN0ZW5jZVxuICogYW5kIHRoZW4gYnJvYWRjYXN0IHRvIG90aGVyIHRhYnMgdmlhIExvY2FsU3RvcmFnZSAoc2VlXG4gKiBgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlYCksIHdoaWNoIHRoZW4gcmVmcmVzaCB0aGVpciBzdGF0ZSBmcm9tXG4gKiBwZXJzaXN0ZW5jZS5cbiAqXG4gKiBTaW1pbGFybHksIHRoZSBwcmltYXJ5IGNsaWVudCBsaXN0ZW5zIHRvIG5vdGlmaWNhdGlvbnMgc2VudCBieSBzZWNvbmRhcnlcbiAqIGNsaWVudHMgdG8gZGlzY292ZXIgcGVyc2lzdGVuY2UgY2hhbmdlcyB3cml0dGVuIGJ5IHNlY29uZGFyeSBjbGllbnRzLCBzdWNoIGFzXG4gKiB0aGUgYWRkaXRpb24gb2YgbmV3IG11dGF0aW9ucyBhbmQgcXVlcnkgdGFyZ2V0cy5cbiAqXG4gKiBJZiBtdWx0aS10YWIgaXMgbm90IGVuYWJsZWQgYW5kIGFub3RoZXIgdGFiIGFscmVhZHkgb2J0YWluZWQgdGhlIHByaW1hcnlcbiAqIGxlYXNlLCBJbmRleGVkRGJQZXJzaXN0ZW5jZSBlbnRlcnMgYSBmYWlsZWQgc3RhdGUgYW5kIGFsbCBzdWJzZXF1ZW50XG4gKiBvcGVyYXRpb25zIHdpbGwgYXV0b21hdGljYWxseSBmYWlsLlxuICpcbiAqIEFkZGl0aW9uYWxseSwgdGhlcmUgaXMgYW4gb3B0aW1pemF0aW9uIHNvIHRoYXQgd2hlbiBhIHRhYiBpcyBjbG9zZWQsIHRoZVxuICogcHJpbWFyeSBsZWFzZSBpcyByZWxlYXNlZCBpbW1lZGlhdGVseSAodGhpcyBpcyBlc3BlY2lhbGx5IGltcG9ydGFudCB0byBtYWtlXG4gKiBzdXJlIHRoYXQgYSByZWZyZXNoZWQgdGFiIGlzIGFibGUgdG8gaW1tZWRpYXRlbHkgcmUtYWNxdWlyZSB0aGUgcHJpbWFyeVxuICogbGVhc2UpLiBVbmZvcnR1bmF0ZWx5LCBJbmRleGVkREIgY2Fubm90IGJlIHJlbGlhYmx5IHVzZWQgaW4gd2luZG93LnVubG9hZFxuICogc2luY2UgaXQgaXMgYW4gYXN5bmNocm9ub3VzIEFQSS4gU28gaW4gYWRkaXRpb24gdG8gYXR0ZW1wdGluZyB0byBnaXZlIHVwIHRoZVxuICogbGVhc2UsIHRoZSBsZWFzZWhvbGRlciB3cml0ZXMgaXRzIGNsaWVudCBJRCB0byBhIFwiem9tYmllZENsaWVudFwiIGVudHJ5IGluXG4gKiBMb2NhbFN0b3JhZ2Ugd2hpY2ggYWN0cyBhcyBhbiBpbmRpY2F0b3IgdGhhdCBhbm90aGVyIHRhYiBzaG91bGQgZ28gYWhlYWQgYW5kXG4gKiB0YWtlIHRoZSBwcmltYXJ5IGxlYXNlIGltbWVkaWF0ZWx5IHJlZ2FyZGxlc3Mgb2YgdGhlIGN1cnJlbnQgbGVhc2UgdGltZXN0YW1wLlxuICpcbiAqIFRPRE8oYi8xMTQyMjYyMzQpOiBSZW1vdmUgYHN5bmNocm9uaXplVGFic2Agc2VjdGlvbiB3aGVuIG11bHRpLXRhYiBpcyBub1xuICogbG9uZ2VyIG9wdGlvbmFsLlxuICovXG5jbGFzcyBJbmRleGVkRGJQZXJzaXN0ZW5jZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzeW5jaHJvbml6ZSB0aGUgaW4tbWVtb3J5IHN0YXRlIG9mIG11bHRpcGxlIHRhYnMgYW5kIHNoYXJlXG4gICAgICogYWNjZXNzIHRvIGxvY2FsIHBlcnNpc3RlbmNlLlxuICAgICAqL1xuICAgIGFsbG93VGFiU3luY2hyb25pemF0aW9uLCBwZXJzaXN0ZW5jZUtleSwgY2xpZW50SWQsIGxydVBhcmFtcywgcXVldWUsIHdpbmRvdywgZG9jdW1lbnQsIHNlcmlhbGl6ZXIsIHNlcXVlbmNlTnVtYmVyU3luY2VyLCBcbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgZm9yY2VmdWxseSBvYnRhaW5zIGRhdGFiYXNlIGFjY2Vzcy4gRXhpc3RpbmcgdGFicyB3aWxsXG4gICAgICogbm8gbG9uZ2VyIGJlIGFibGUgdG8gYWNjZXNzIEluZGV4ZWREQi5cbiAgICAgKi9cbiAgICBmb3JjZU93bmluZ1RhYiwgc2NoZW1hVmVyc2lvbiA9IFNDSEVNQV9WRVJTSU9OKSB7XG4gICAgICAgIHRoaXMuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24gPSBhbGxvd1RhYlN5bmNocm9uaXphdGlvbjtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5O1xuICAgICAgICB0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICAgICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZU51bWJlclN5bmNlciA9IHNlcXVlbmNlTnVtYmVyU3luY2VyO1xuICAgICAgICB0aGlzLmZvcmNlT3duaW5nVGFiID0gZm9yY2VPd25pbmdUYWI7XG4gICAgICAgIHRoaXMuc2NoZW1hVmVyc2lvbiA9IHNjaGVtYVZlcnNpb247XG4gICAgICAgIHRoaXMubGlzdGVuU2VxdWVuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNQcmltYXJ5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV0d29ya0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAvKiogT3VyIHdpbmRvdy51bmxvYWQgaGFuZGxlciwgaWYgcmVnaXN0ZXJlZC4gKi9cbiAgICAgICAgdGhpcy53aW5kb3dVbmxvYWRIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbkZvcmVncm91bmQgPSBmYWxzZTtcbiAgICAgICAgLyoqIE91ciAndmlzaWJpbGl0eWNoYW5nZScgbGlzdGVuZXIgaWYgcmVnaXN0ZXJlZC4gKi9cbiAgICAgICAgdGhpcy5kb2N1bWVudFZpc2liaWxpdHlIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgLyoqIFRoZSBjbGllbnQgbWV0YWRhdGEgcmVmcmVzaCB0YXNrLiAqL1xuICAgICAgICB0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyID0gbnVsbDtcbiAgICAgICAgLyoqIFRoZSBsYXN0IHRpbWUgd2UgZ2FyYmFnZSBjb2xsZWN0ZWQgdGhlIGNsaWVudCBtZXRhZGF0YSBvYmplY3Qgc3RvcmUuICovXG4gICAgICAgIHRoaXMubGFzdEdhcmJhZ2VDb2xsZWN0aW9uVGltZSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgLyoqIEEgbGlzdGVuZXIgdG8gbm90aWZ5IG9uIHByaW1hcnkgc3RhdGUgY2hhbmdlcy4gKi9cbiAgICAgICAgdGhpcy5wcmltYXJ5U3RhdGVMaXN0ZW5lciA9IF8gPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIGlmICghSW5kZXhlZERiUGVyc2lzdGVuY2UuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5JTVBMRU1FTlRFRCwgVU5TVVBQT1JURURfUExBVEZPUk1fRVJST1JfTVNHKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlID0gbmV3IEluZGV4ZWREYkxydURlbGVnYXRlSW1wbCh0aGlzLCBscnVQYXJhbXMpO1xuICAgICAgICB0aGlzLmRiTmFtZSA9IHBlcnNpc3RlbmNlS2V5ICsgTUFJTl9EQVRBQkFTRTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gbmV3IExvY2FsU2VyaWFsaXplcihzZXJpYWxpemVyKTtcbiAgICAgICAgdGhpcy5zaW1wbGVEYiA9IG5ldyBTaW1wbGVEYih0aGlzLmRiTmFtZSwgdGhpcy5zY2hlbWFWZXJzaW9uLCBuZXcgU2NoZW1hQ29udmVydGVyKHRoaXMuc2VyaWFsaXplcikpO1xuICAgICAgICB0aGlzLmdsb2JhbHNDYWNoZSA9IG5ldyBJbmRleGVkRGJHbG9iYWxzQ2FjaGUoKTtcbiAgICAgICAgdGhpcy50YXJnZXRDYWNoZSA9IG5ldyBJbmRleGVkRGJUYXJnZXRDYWNoZSh0aGlzLnJlZmVyZW5jZURlbGVnYXRlLCB0aGlzLnNlcmlhbGl6ZXIpO1xuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGUgPSBuZXdJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlKHRoaXMuc2VyaWFsaXplcik7XG4gICAgICAgIHRoaXMuYnVuZGxlQ2FjaGUgPSBuZXcgSW5kZXhlZERiQnVuZGxlQ2FjaGUoKTtcbiAgICAgICAgaWYgKHRoaXMud2luZG93ICYmIHRoaXMud2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgdGhpcy53ZWJTdG9yYWdlID0gdGhpcy53aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53ZWJTdG9yYWdlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChmb3JjZU93bmluZ1RhYiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBsb2dFcnJvcihMT0dfVEFHJGMsICdMb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGUuIEFzIGEgcmVzdWx0LCBwZXJzaXN0ZW5jZSBtYXkgbm90IHdvcmsgJyArXG4gICAgICAgICAgICAgICAgICAgICdyZWxpYWJseS4gSW4gcGFydGljdWxhciBlbmFibGVQZXJzaXN0ZW5jZSgpIGNvdWxkIGZhaWwgaW1tZWRpYXRlbHkgJyArXG4gICAgICAgICAgICAgICAgICAgICdhZnRlciByZWZyZXNoaW5nIHRoZSBwYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gc3RhcnQgSW5kZXhlZERiIHBlcnNpc3RlbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgV2hldGhlciBwZXJzaXN0ZW5jZSB3YXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBleHBlY3RlZCB0byBmYWlsIHNvbWV0aW1lcyAoaW4gdGhlIGNhc2Ugb2YgYW5vdGhlciB0YWJcbiAgICAgICAgLy8gYWxyZWFkeSBoYXZpbmcgdGhlIHBlcnNpc3RlbmNlIGxvY2spLCBzbyBpdCdzIHRoZSBmaXJzdCB0aGluZyB3ZSBzaG91bGRcbiAgICAgICAgLy8gZG8uXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeSgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNQcmltYXJ5ICYmICF0aGlzLmFsbG93VGFiU3luY2hyb25pemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gRmFpbCBgc3RhcnQoKWAgaWYgYHN5bmNocm9uaXplVGFic2AgaXMgZGlzYWJsZWQgYW5kIHdlIGNhbm5vdFxuICAgICAgICAgICAgICAgIC8vIG9idGFpbiB0aGUgcHJpbWFyeSBsZWFzZS5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCBQUklNQVJZX0xFQVNFX0VYQ0xVU0lWRV9FUlJPUl9NU0cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hdHRhY2hWaXNpYmlsaXR5SGFuZGxlcigpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hXaW5kb3dVbmxvYWRIb29rKCk7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ2xpZW50TWV0YWRhdGFBbmRQcmltYXJ5TGVhc2VSZWZyZXNoZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1blRyYW5zYWN0aW9uKCdnZXRIaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXInLCAncmVhZG9ubHknLCB0eG4gPT4gdGhpcy50YXJnZXRDYWNoZS5nZXRIaWdoZXN0U2VxdWVuY2VOdW1iZXIodHhuKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPT4ge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5TZXF1ZW5jZSA9IG5ldyBMaXN0ZW5TZXF1ZW5jZShoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIsIHRoaXMuc2VxdWVuY2VOdW1iZXJTeW5jZXIpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2ltcGxlRGIgJiYgdGhpcy5zaW1wbGVEYi5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIHByaW1hcnkgc3RhdGUgb2YgdGhlXG4gICAgICogaW5zdGFuY2UgY2hhbmdlcy4gVXBvbiByZWdpc3RlcmluZywgdGhpcyBsaXN0ZW5lciBpcyBpbnZva2VkIGltbWVkaWF0ZWx5XG4gICAgICogd2l0aCB0aGUgY3VycmVudCBwcmltYXJ5IHN0YXRlLlxuICAgICAqXG4gICAgICogUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgV2ViIG11bHRpLXRhYi5cbiAgICAgKi9cbiAgICBzZXRQcmltYXJ5U3RhdGVMaXN0ZW5lcihwcmltYXJ5U3RhdGVMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnByaW1hcnlTdGF0ZUxpc3RlbmVyID0gYXN5bmMgKHByaW1hcnlTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmltYXJ5U3RhdGVMaXN0ZW5lcihwcmltYXJ5U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJpbWFyeVN0YXRlTGlzdGVuZXIodGhpcy5pc1ByaW1hcnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIGRhdGFiYXNlIHJlY2VpdmVzIGFcbiAgICAgKiB2ZXJzaW9uIGNoYW5nZSBldmVudCBpbmRpY2F0aW5nIHRoYXQgaXQgaGFzIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBQT1JUSU5HIE5PVEU6IFRoaXMgaXMgb25seSB1c2VkIGZvciBXZWIgbXVsdGktdGFiLlxuICAgICAqL1xuICAgIHNldERhdGFiYXNlRGVsZXRlZExpc3RlbmVyKGRhdGFiYXNlRGVsZXRlZExpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc2ltcGxlRGIuc2V0VmVyc2lvbkNoYW5nZUxpc3RlbmVyKGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW4gYXR0ZW1wdCBpcyBtYWRlIHRvIGRlbGV0ZSBJbmRleGVkREIuXG4gICAgICAgICAgICBpZiAoZXZlbnQubmV3VmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGRhdGFiYXNlRGVsZXRlZExpc3RlbmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIHRoZSBjdXJyZW50IG5ldHdvcmsgc3RhdGUgaW4gdGhlIGNsaWVudCdzIG1ldGFkYXRhLCBwb3RlbnRpYWxseVxuICAgICAqIGFmZmVjdGluZyB0aGUgcHJpbWFyeSBsZWFzZS5cbiAgICAgKlxuICAgICAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgZm9yIFdlYiBtdWx0aS10YWIuXG4gICAgICovXG4gICAgc2V0TmV0d29ya0VuYWJsZWQobmV0d29ya0VuYWJsZWQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV0d29ya0VuYWJsZWQgIT09IG5ldHdvcmtFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5ldHdvcmtFbmFibGVkID0gbmV0d29ya0VuYWJsZWQ7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIHByaW1hcnkgbGVhc2UgcmVmcmVzaCBmb3IgaW1tZWRpYXRlIGV4ZWN1dGlvbi4gVGhlIGV2ZW50dWFsXG4gICAgICAgICAgICAvLyBsZWFzZSB1cGRhdGUgd2lsbCBiZSBwcm9wYWdhdGVkIHZpYSBgcHJpbWFyeVN0YXRlTGlzdGVuZXJgLlxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlQ2xpZW50TWV0YWRhdGFBbmRUcnlCZWNvbWVQcmltYXJ5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY2xpZW50IG1ldGFkYXRhIGluIEluZGV4ZWREYiBhbmQgYXR0ZW1wdHMgdG8gZWl0aGVyIG9idGFpbiBvclxuICAgICAqIGV4dGVuZCB0aGUgcHJpbWFyeSBsZWFzZSBmb3IgdGhlIGxvY2FsIGNsaWVudC4gQXN5bmNocm9ub3VzbHkgbm90aWZpZXMgdGhlXG4gICAgICogcHJpbWFyeSBzdGF0ZSBsaXN0ZW5lciBpZiB0aGUgY2xpZW50IGVpdGhlciBuZXdseSBvYnRhaW5lZCBvciByZWxlYXNlZCBpdHNcbiAgICAgKiBwcmltYXJ5IGxlYXNlLlxuICAgICAqL1xuICAgIHVwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuVHJhbnNhY3Rpb24oJ3VwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeScsICdyZWFkd3JpdGUnLCB0eG4gPT4ge1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFTdG9yZSA9IGNsaWVudE1ldGFkYXRhU3RvcmUodHhuKTtcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YVN0b3JlXG4gICAgICAgICAgICAgICAgLnB1dCh7XG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgdXBkYXRlVGltZU1zOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtFbmFibGVkOiB0aGlzLm5ldHdvcmtFbmFibGVkLFxuICAgICAgICAgICAgICAgIGluRm9yZWdyb3VuZDogdGhpcy5pbkZvcmVncm91bmRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlQcmltYXJ5TGVhc2UodHhuKS5uZXh0KHN1Y2Nlc3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gdGhpcy5wcmltYXJ5U3RhdGVMaXN0ZW5lcihmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMuY2FuQWN0QXNQcmltYXJ5KHR4bikpXG4gICAgICAgICAgICAgICAgLm5leHQoY2FuQWN0QXNQcmltYXJ5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnkgJiYgIWNhbkFjdEFzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxlYXNlUHJpbWFyeUxlYXNlSWZIZWxkKHR4bikubmV4dCgoKSA9PiBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhbkFjdEFzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3F1aXJlT3JFeHRlbmRQcmltYXJ5TGVhc2UodHhuKS5uZXh0KCgpID0+IHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8qIGNhbkFjdEFzUHJpbWFyeT0gKi8gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRjLCAnRmFpbGVkIHRvIGV4dGVuZCBvd25lciBsZWFzZTogJywgZSk7XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VlZCB3aXRoIHRoZSBleGlzdGluZyBzdGF0ZS4gQW55IHN1YnNlcXVlbnQgYWNjZXNzIHRvXG4gICAgICAgICAgICAgICAgLy8gSW5kZXhlZERCIHdpbGwgdmVyaWZ5IHRoZSBsZWFzZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ByaW1hcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRjLCAnUmVsZWFzaW5nIG93bmVyIGxlYXNlIGFmdGVyIGVycm9yIGR1cmluZyBsZWFzZSByZWZyZXNoJywgZSk7XG4gICAgICAgICAgICByZXR1cm4gLyogaXNQcmltYXJ5PSAqLyBmYWxzZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGlzUHJpbWFyeSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnkgIT09IGlzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiB0aGlzLnByaW1hcnlTdGF0ZUxpc3RlbmVyKGlzUHJpbWFyeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSBpc1ByaW1hcnk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2ZXJpZnlQcmltYXJ5TGVhc2UodHhuKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gcHJpbWFyeUNsaWVudFN0b3JlKHR4bik7XG4gICAgICAgIHJldHVybiBzdG9yZS5nZXQoRGJQcmltYXJ5Q2xpZW50S2V5KS5uZXh0KHByaW1hcnlDbGllbnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuaXNMb2NhbENsaWVudChwcmltYXJ5Q2xpZW50KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVDbGllbnRNZXRhZGF0YSh0eG4pIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGFTdG9yZSA9IGNsaWVudE1ldGFkYXRhU3RvcmUodHhuKTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhU3RvcmUuZGVsZXRlKHRoaXMuY2xpZW50SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZ2FyYmFnZSBjb2xsZWN0aW9uIHRocmVzaG9sZCBoYXMgcGFzc2VkLCBwcnVuZXMgdGhlXG4gICAgICogUmVtb3RlRG9jdW1lbnRDaGFuZ2VzIGFuZCB0aGUgQ2xpZW50TWV0YWRhdGEgc3RvcmUgYmFzZWQgb24gdGhlIGxhc3QgdXBkYXRlXG4gICAgICogdGltZSBvZiBhbGwgY2xpZW50cy5cbiAgICAgKi9cbiAgICBhc3luYyBtYXliZUdhcmJhZ2VDb2xsZWN0TXVsdGlDbGllbnRTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNQcmltYXJ5ICYmXG4gICAgICAgICAgICAhdGhpcy5pc1dpdGhpbkFnZSh0aGlzLmxhc3RHYXJiYWdlQ29sbGVjdGlvblRpbWUsIE1BWF9DTElFTlRfQUdFX01TKSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0R2FyYmFnZUNvbGxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IGluYWN0aXZlQ2xpZW50cyA9IGF3YWl0IHRoaXMucnVuVHJhbnNhY3Rpb24oJ21heWJlR2FyYmFnZUNvbGxlY3RNdWx0aUNsaWVudFN0YXRlJywgJ3JlYWR3cml0ZS1wcmltYXJ5JywgdHhuID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YVN0b3JlID0gZ2V0U3RvcmUodHhuLCBEYkNsaWVudE1ldGFkYXRhU3RvcmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YVN0b3JlLmxvYWRBbGwoKS5uZXh0KGV4aXN0aW5nQ2xpZW50cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuZmlsdGVyQWN0aXZlQ2xpZW50cyhleGlzdGluZ0NsaWVudHMsIE1BWF9DTElFTlRfQUdFX01TKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5hY3RpdmUgPSBleGlzdGluZ0NsaWVudHMuZmlsdGVyKGNsaWVudCA9PiBhY3RpdmUuaW5kZXhPZihjbGllbnQpID09PSAtMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBtZXRhZGF0YSBmb3IgY2xpZW50cyB0aGF0IGFyZSBubyBsb25nZXIgY29uc2lkZXJlZCBhY3RpdmUuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChpbmFjdGl2ZSwgKGluYWN0aXZlQ2xpZW50KSA9PiBtZXRhZGF0YVN0b3JlLmRlbGV0ZShpbmFjdGl2ZUNsaWVudC5jbGllbnRJZCkpLm5leHQoKCkgPT4gaW5hY3RpdmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBwcmltYXJ5IGxlYXNlIHZpb2xhdGlvbnMgb3IgYW55IG90aGVyIHR5cGUgb2YgZXJyb3IuIFRoZSBuZXh0XG4gICAgICAgICAgICAgICAgLy8gcHJpbWFyeSB3aWxsIHJ1biBgbWF5YmVHYXJiYWdlQ29sbGVjdE11bHRpQ2xpZW50U3RhdGUoKWAgYWdhaW4uXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXNlIGBpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MoKWAgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0byBkZXBlbmRcbiAgICAgICAgICAgICAgICAvLyBvbiBMb2NhbFN0b3JlLlxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRGVsZXRlIHBvdGVudGlhbCBsZWZ0b3ZlciBlbnRyaWVzIHRoYXQgbWF5IGNvbnRpbnVlIHRvIG1hcmsgdGhlXG4gICAgICAgICAgICAvLyBpbmFjdGl2ZSBjbGllbnRzIGFzIHpvbWJpZWQgaW4gTG9jYWxTdG9yYWdlLlxuICAgICAgICAgICAgLy8gSWRlYWxseSB3ZSdkIGRlbGV0ZSB0aGUgSW5kZXhlZERiIGFuZCBMb2NhbFN0b3JhZ2Ugem9tYmllIGVudHJpZXMgZm9yXG4gICAgICAgICAgICAvLyB0aGUgY2xpZW50IGF0b21pY2FsbHksIGJ1dCB3ZSBjYW4ndC4gU28gd2Ugb3B0IHRvIGRlbGV0ZSB0aGUgSW5kZXhlZERiXG4gICAgICAgICAgICAvLyBlbnRyaWVzIGZpcnN0IHRvIGF2b2lkIHBvdGVudGlhbGx5IHJldml2aW5nIGEgem9tYmllZCBjbGllbnQuXG4gICAgICAgICAgICBpZiAodGhpcy53ZWJTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbmFjdGl2ZUNsaWVudCBvZiBpbmFjdGl2ZUNsaWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWJTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy56b21iaWVkQ2xpZW50TG9jYWxTdG9yYWdlS2V5KGluYWN0aXZlQ2xpZW50LmNsaWVudElkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhIHJlY3VycmluZyB0aW1lciB0byB1cGRhdGUgdGhlIGNsaWVudCBtZXRhZGF0YSBhbmQgdG8gZWl0aGVyXG4gICAgICogZXh0ZW5kIG9yIGFjcXVpcmUgdGhlIHByaW1hcnkgbGVhc2UgaWYgdGhlIGNsaWVudCBpcyBlbGlnaWJsZS5cbiAgICAgKi9cbiAgICBzY2hlZHVsZUNsaWVudE1ldGFkYXRhQW5kUHJpbWFyeUxlYXNlUmVmcmVzaGVzKCkge1xuICAgICAgICB0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyID0gdGhpcy5xdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheShcImNsaWVudF9tZXRhZGF0YV9yZWZyZXNoXCIgLyogVGltZXJJZC5DbGllbnRNZXRhZGF0YVJlZnJlc2ggKi8sIENMSUVOVF9NRVRBREFUQV9SRUZSRVNIX0lOVEVSVkFMX01TLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVDbGllbnRNZXRhZGF0YUFuZFRyeUJlY29tZVByaW1hcnkoKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMubWF5YmVHYXJiYWdlQ29sbGVjdE11bHRpQ2xpZW50U3RhdGUoKSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLnNjaGVkdWxlQ2xpZW50TWV0YWRhdGFBbmRQcmltYXJ5TGVhc2VSZWZyZXNoZXMoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQ2hlY2tzIHdoZXRoZXIgYGNsaWVudGAgaXMgdGhlIGxvY2FsIGNsaWVudC4gKi9cbiAgICBpc0xvY2FsQ2xpZW50KGNsaWVudCkge1xuICAgICAgICByZXR1cm4gY2xpZW50ID8gY2xpZW50Lm93bmVySWQgPT09IHRoaXMuY2xpZW50SWQgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgdGhlIHN0YXRlIG9mIGFsbCBhY3RpdmUgY2xpZW50cyBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGxvY2FsXG4gICAgICogY2xpZW50IGlzIG9yIGNhbiBhY3QgYXMgdGhlIGhvbGRlciBvZiB0aGUgcHJpbWFyeSBsZWFzZS4gUmV0dXJucyB3aGV0aGVyXG4gICAgICogdGhlIGNsaWVudCBpcyBlbGlnaWJsZSBmb3IgdGhlIGxlYXNlLCBidXQgZG9lcyBub3QgYWN0dWFsbHkgYWNxdWlyZSBpdC5cbiAgICAgKiBNYXkgcmV0dXJuICdmYWxzZScgZXZlbiBpZiB0aGVyZSBpcyBubyBhY3RpdmUgbGVhc2Vob2xkZXIgYW5kIGFub3RoZXJcbiAgICAgKiAoZm9yZWdyb3VuZCkgY2xpZW50IHNob3VsZCBiZWNvbWUgbGVhc2Vob2xkZXIgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBjYW5BY3RBc1ByaW1hcnkodHhuKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcmNlT3duaW5nVGFiKSB7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RvcmUgPSBwcmltYXJ5Q2xpZW50U3RvcmUodHhuKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlXG4gICAgICAgICAgICAuZ2V0KERiUHJpbWFyeUNsaWVudEtleSlcbiAgICAgICAgICAgIC5uZXh0KGN1cnJlbnRQcmltYXJ5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMZWFzZUlzVmFsaWQgPSBjdXJyZW50UHJpbWFyeSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaXNXaXRoaW5BZ2UoY3VycmVudFByaW1hcnkubGVhc2VUaW1lc3RhbXBNcywgTUFYX1BSSU1BUllfRUxJR0lCTEVfQUdFX01TKSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmlzQ2xpZW50Wm9tYmllZChjdXJyZW50UHJpbWFyeS5vd25lcklkKTtcbiAgICAgICAgICAgIC8vIEEgY2xpZW50IGlzIGVsaWdpYmxlIGZvciB0aGUgcHJpbWFyeSBsZWFzZSBpZjpcbiAgICAgICAgICAgIC8vIC0gaXRzIG5ldHdvcmsgaXMgZW5hYmxlZCBhbmQgdGhlIGNsaWVudCdzIHRhYiBpcyBpbiB0aGUgZm9yZWdyb3VuZC5cbiAgICAgICAgICAgIC8vIC0gaXRzIG5ldHdvcmsgaXMgZW5hYmxlZCBhbmQgbm8gb3RoZXIgY2xpZW50J3MgdGFiIGlzIGluIHRoZVxuICAgICAgICAgICAgLy8gICBmb3JlZ3JvdW5kLlxuICAgICAgICAgICAgLy8gLSBldmVyeSBjbGllbnRzIG5ldHdvcmsgaXMgZGlzYWJsZWQgYW5kIHRoZSBjbGllbnQncyB0YWIgaXMgaW4gdGhlXG4gICAgICAgICAgICAvLyAgIGZvcmVncm91bmQuXG4gICAgICAgICAgICAvLyAtIGV2ZXJ5IGNsaWVudHMgbmV0d29yayBpcyBkaXNhYmxlZCBhbmQgbm8gb3RoZXIgY2xpZW50J3MgdGFiIGlzIGluXG4gICAgICAgICAgICAvLyAgIHRoZSBmb3JlZ3JvdW5kLlxuICAgICAgICAgICAgLy8gLSB0aGUgYGZvcmNlT3duaW5nVGFiYCBzZXR0aW5nIHdhcyBwYXNzZWQgaW4uXG4gICAgICAgICAgICBpZiAoY3VycmVudExlYXNlSXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTG9jYWxDbGllbnQoY3VycmVudFByaW1hcnkpICYmIHRoaXMubmV0d29ya0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0xvY2FsQ2xpZW50KGN1cnJlbnRQcmltYXJ5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcmltYXJ5LmFsbG93VGFiU3luY2hyb25pemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWlsIHRoZSBgY2FuQWN0QXNQcmltYXJ5YCBjaGVjayBpZiB0aGUgY3VycmVudCBsZWFzZWhvbGRlciBoYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBvcHRlZCBpbnRvIG11bHRpLXRhYiBzeW5jaHJvbml6YXRpb24uIElmIHRoaXMgaGFwcGVucyBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50IHN0YXJ0dXAsIHdlIHJlamVjdCB0aGUgUHJvbWlzZSByZXR1cm5lZCBieVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGVuYWJsZVBlcnNpc3RlbmNlKClgIGFuZCB0aGUgdXNlciBjYW4gY29udGludWUgdG8gdXNlIEZpcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCBpbi1tZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGZhaWxzIGR1cmluZyBhIGxlYXNlIHJlZnJlc2gsIHdlIHdpbGwgaW5zdGVhZCBibG9jayB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzeW5jUXVldWUgZnJvbSBleGVjdXRpbmcgZnVydGhlciBvcGVyYXRpb25zLiBOb3RlIHRoYXQgdGhpcyBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXB0YWJsZSBzaW5jZSBtaXhpbmcgJiBtYXRjaGluZyBkaWZmZXJlbnQgYHN5bmNocm9uaXplVGFic2BcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmdzIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhiLzExNDIyNjIzNCk6IFJlbW92ZSB0aGlzIGNoZWNrIHdoZW4gYHN5bmNocm9uaXplVGFic2AgY2FuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgYmUgdHVybmVkIG9mZi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sIFBSSU1BUllfTEVBU0VfRVhDTFVTSVZFX0VSUk9SX01TRyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm5ldHdvcmtFbmFibGVkICYmIHRoaXMuaW5Gb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50TWV0YWRhdGFTdG9yZSh0eG4pXG4gICAgICAgICAgICAgICAgLmxvYWRBbGwoKVxuICAgICAgICAgICAgICAgIC5uZXh0KGV4aXN0aW5nQ2xpZW50cyA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBhbGwgZXhpc3RpbmcgY2xpZW50cyBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgYXQgbGVhc3Qgb25lIG9mXG4gICAgICAgICAgICAgICAgLy8gdGhlbSBpcyBiZXR0ZXIgc3VpdGVkIHRvIG9idGFpbiB0aGUgcHJpbWFyeSBsZWFzZS5cbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmZXJyZWRDYW5kaWRhdGUgPSB0aGlzLmZpbHRlckFjdGl2ZUNsaWVudHMoZXhpc3RpbmdDbGllbnRzLCBNQVhfUFJJTUFSWV9FTElHSUJMRV9BR0VfTVMpLmZpbmQob3RoZXJDbGllbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jbGllbnRJZCAhPT0gb3RoZXJDbGllbnQuY2xpZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyQ2xpZW50SGFzQmV0dGVyTmV0d29ya1N0YXRlID0gIXRoaXMubmV0d29ya0VuYWJsZWQgJiYgb3RoZXJDbGllbnQubmV0d29ya0VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNsaWVudEhhc0JldHRlclZpc2liaWxpdHkgPSAhdGhpcy5pbkZvcmVncm91bmQgJiYgb3RoZXJDbGllbnQuaW5Gb3JlZ3JvdW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJDbGllbnRIYXNTYW1lTmV0d29ya1N0YXRlID0gdGhpcy5uZXR3b3JrRW5hYmxlZCA9PT0gb3RoZXJDbGllbnQubmV0d29ya0VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJDbGllbnRIYXNCZXR0ZXJOZXR3b3JrU3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3RoZXJDbGllbnRIYXNCZXR0ZXJWaXNpYmlsaXR5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyQ2xpZW50SGFzU2FtZU5ldHdvcmtTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZlcnJlZENhbmRpZGF0ZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChjYW5BY3RBc1ByaW1hcnkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNQcmltYXJ5ICE9PSBjYW5BY3RBc1ByaW1hcnkpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsIGBDbGllbnQgJHtjYW5BY3RBc1ByaW1hcnkgPyAnaXMnIDogJ2lzIG5vdCd9IGVsaWdpYmxlIGZvciBhIHByaW1hcnkgbGVhc2UuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FuQWN0QXNQcmltYXJ5O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2h1dGRvd24oKSB7XG4gICAgICAgIC8vIFRoZSBzaHV0ZG93bigpIG9wZXJhdGlvbnMgYXJlIGlkZW1wb3RlbnQgYW5kIGNhbiBiZSBjYWxsZWQgZXZlbiB3aGVuXG4gICAgICAgIC8vIHN0YXJ0KCkgYWJvcnRlZCAoZS5nLiBiZWNhdXNlIGl0IGNvdWxkbid0IGFjcXVpcmUgdGhlIHBlcnNpc3RlbmNlIGxlYXNlKS5cbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hcmtDbGllbnRab21iaWVkKCk7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy5jbGllbnRNZXRhZGF0YVJlZnJlc2hlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXRhY2hWaXNpYmlsaXR5SGFuZGxlcigpO1xuICAgICAgICB0aGlzLmRldGFjaFdpbmRvd1VubG9hZEhvb2soKTtcbiAgICAgICAgLy8gVXNlIGBTaW1wbGVEYi5ydW5UcmFuc2FjdGlvbmAgZGlyZWN0bHkgdG8gYXZvaWQgZmFpbGluZyBpZiBhbm90aGVyIHRhYlxuICAgICAgICAvLyBoYXMgb2J0YWluZWQgdGhlIHByaW1hcnkgbGVhc2UuXG4gICAgICAgIGF3YWl0IHRoaXMuc2ltcGxlRGIucnVuVHJhbnNhY3Rpb24oJ3NodXRkb3duJywgJ3JlYWR3cml0ZScsIFtEYlByaW1hcnlDbGllbnRTdG9yZSwgRGJDbGllbnRNZXRhZGF0YVN0b3JlXSwgc2ltcGxlRGJUeG4gPT4ge1xuICAgICAgICAgICAgY29uc3QgcGVyc2lzdGVuY2VUcmFuc2FjdGlvbiA9IG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbihzaW1wbGVEYlR4biwgTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxlYXNlUHJpbWFyeUxlYXNlSWZIZWxkKHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24pLm5leHQoKCkgPT4gdGhpcy5yZW1vdmVDbGllbnRNZXRhZGF0YShwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNpbXBsZURiLmNsb3NlKCk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZW50cnkgbWFya2luZyB0aGUgY2xpZW50IGFzIHpvbWJpZWQgZnJvbSBMb2NhbFN0b3JhZ2Ugc2luY2VcbiAgICAgICAgLy8gd2Ugc3VjY2Vzc2Z1bGx5IGRlbGV0ZWQgaXRzIG1ldGFkYXRhIGZyb20gSW5kZXhlZERiLlxuICAgICAgICB0aGlzLnJlbW92ZUNsaWVudFpvbWJpZWRFbnRyeSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNsaWVudHMgdGhhdCBhcmUgbm90IHpvbWJpZWQgYW5kIGhhdmUgYW4gdXBkYXRlVGltZSB3aXRoaW4gdGhlXG4gICAgICogcHJvdmlkZWQgdGhyZXNob2xkLlxuICAgICAqL1xuICAgIGZpbHRlckFjdGl2ZUNsaWVudHMoY2xpZW50cywgYWN0aXZpdHlUaHJlc2hvbGRNcykge1xuICAgICAgICByZXR1cm4gY2xpZW50cy5maWx0ZXIoY2xpZW50ID0+IHRoaXMuaXNXaXRoaW5BZ2UoY2xpZW50LnVwZGF0ZVRpbWVNcywgYWN0aXZpdHlUaHJlc2hvbGRNcykgJiZcbiAgICAgICAgICAgICF0aGlzLmlzQ2xpZW50Wm9tYmllZChjbGllbnQuY2xpZW50SWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSURzIG9mIHRoZSBjbGllbnRzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUuIElmIG11bHRpLXRhYlxuICAgICAqIGlzIG5vdCBzdXBwb3J0ZWQsIHJldHVybnMgYW4gYXJyYXkgdGhhdCBvbmx5IGNvbnRhaW5zIHRoZSBsb2NhbCBjbGllbnQnc1xuICAgICAqIElELlxuICAgICAqXG4gICAgICogUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgV2ViIG11bHRpLXRhYi5cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVDbGllbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5UcmFuc2FjdGlvbignZ2V0QWN0aXZlQ2xpZW50cycsICdyZWFkb25seScsIHR4biA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50TWV0YWRhdGFTdG9yZSh0eG4pXG4gICAgICAgICAgICAgICAgLmxvYWRBbGwoKVxuICAgICAgICAgICAgICAgIC5uZXh0KGNsaWVudHMgPT4gdGhpcy5maWx0ZXJBY3RpdmVDbGllbnRzKGNsaWVudHMsIE1BWF9DTElFTlRfQUdFX01TKS5tYXAoY2xpZW50TWV0YWRhdGEgPT4gY2xpZW50TWV0YWRhdGEuY2xpZW50SWQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBzdGFydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnRlZDtcbiAgICB9XG4gICAgZ2V0R2xvYmFsc0NhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxzQ2FjaGU7XG4gICAgfVxuICAgIGdldE11dGF0aW9uUXVldWUodXNlciwgaW5kZXhNYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiBJbmRleGVkRGJNdXRhdGlvblF1ZXVlLmZvclVzZXIodXNlciwgdGhpcy5zZXJpYWxpemVyLCBpbmRleE1hbmFnZXIsIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUpO1xuICAgIH1cbiAgICBnZXRUYXJnZXRDYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0Q2FjaGU7XG4gICAgfVxuICAgIGdldFJlbW90ZURvY3VtZW50Q2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGU7XG4gICAgfVxuICAgIGdldEluZGV4TWFuYWdlcih1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiSW5kZXhNYW5hZ2VyKHVzZXIsIHRoaXMuc2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLmRhdGFiYXNlSWQpO1xuICAgIH1cbiAgICBnZXREb2N1bWVudE92ZXJsYXlDYWNoZSh1c2VyKSB7XG4gICAgICAgIHJldHVybiBJbmRleGVkRGJEb2N1bWVudE92ZXJsYXlDYWNoZS5mb3JVc2VyKHRoaXMuc2VyaWFsaXplciwgdXNlcik7XG4gICAgfVxuICAgIGdldEJ1bmRsZUNhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idW5kbGVDYWNoZTtcbiAgICB9XG4gICAgcnVuVHJhbnNhY3Rpb24oYWN0aW9uLCBtb2RlLCB0cmFuc2FjdGlvbk9wZXJhdGlvbikge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsICdTdGFydGluZyB0cmFuc2FjdGlvbjonLCBhY3Rpb24pO1xuICAgICAgICBjb25zdCBzaW1wbGVEYk1vZGUgPSBtb2RlID09PSAncmVhZG9ubHknID8gJ3JlYWRvbmx5JyA6ICdyZWFkd3JpdGUnO1xuICAgICAgICBjb25zdCBvYmplY3RTdG9yZXMgPSBnZXRPYmplY3RTdG9yZXModGhpcy5zY2hlbWFWZXJzaW9uKTtcbiAgICAgICAgbGV0IHBlcnNpc3RlbmNlVHJhbnNhY3Rpb247XG4gICAgICAgIC8vIERvIGFsbCB0cmFuc2FjdGlvbnMgYXMgcmVhZHdyaXRlIGFnYWluc3QgYWxsIG9iamVjdCBzdG9yZXMsIHNpbmNlIHdlXG4gICAgICAgIC8vIGFyZSB0aGUgb25seSByZWFkZXIvd3JpdGVyLlxuICAgICAgICByZXR1cm4gdGhpcy5zaW1wbGVEYlxuICAgICAgICAgICAgLnJ1blRyYW5zYWN0aW9uKGFjdGlvbiwgc2ltcGxlRGJNb2RlLCBvYmplY3RTdG9yZXMsIHNpbXBsZURiVHhuID0+IHtcbiAgICAgICAgICAgIHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24gPSBuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb24oc2ltcGxlRGJUeG4sIHRoaXMubGlzdGVuU2VxdWVuY2VcbiAgICAgICAgICAgICAgICA/IHRoaXMubGlzdGVuU2VxdWVuY2UubmV4dCgpXG4gICAgICAgICAgICAgICAgOiBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKTtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlLXByaW1hcnknKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgd2UgbWVyZWx5IHZlcmlmeSB0aGF0IHdlIGhhdmUgKG9yIGNhbiBhY3F1aXJlKSB0aGUgbGVhc2VcbiAgICAgICAgICAgICAgICAvLyBpbW1lZGlhdGVseSwgd2Ugd2FpdCB0byBleHRlbmQgdGhlIHByaW1hcnkgbGVhc2UgdW50aWwgYWZ0ZXJcbiAgICAgICAgICAgICAgICAvLyBleGVjdXRpbmcgdHJhbnNhY3Rpb25PcGVyYXRpb24oKS4gVGhpcyBlbnN1cmVzIHRoYXQgZXZlbiBpZiB0aGVcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbk9wZXJhdGlvbiB0YWtlcyBhIGxvbmcgdGltZSwgd2UnbGwgdXNlIGEgcmVjZW50XG4gICAgICAgICAgICAgICAgLy8gbGVhc2VUaW1lc3RhbXBNcyBpbiB0aGUgZXh0ZW5kZWQgKG9yIG5ld2x5IGFjcXVpcmVkKSBsZWFzZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlQcmltYXJ5TGVhc2UocGVyc2lzdGVuY2VUcmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoaG9sZHNQcmltYXJ5TGVhc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZHNQcmltYXJ5TGVhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAvKiBob2xkc1ByaW1hcnlMZWFzZT0gKi8gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYW5BY3RBc1ByaW1hcnkocGVyc2lzdGVuY2VUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoaG9sZHNQcmltYXJ5TGVhc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhvbGRzUHJpbWFyeUxlYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFcnJvcihgRmFpbGVkIHRvIG9idGFpbiBwcmltYXJ5IGxlYXNlIGZvciBhY3Rpb24gJyR7YWN0aW9ufScuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IHRoaXMucHJpbWFyeVN0YXRlTGlzdGVuZXIoZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sIFBSSU1BUllfTEVBU0VfTE9TVF9FUlJPUl9NU0cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbk9wZXJhdGlvbihwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3F1aXJlT3JFeHRlbmRQcmltYXJ5TGVhc2UocGVyc2lzdGVuY2VUcmFuc2FjdGlvbikubmV4dCgoKSA9PiByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5QWxsb3dUYWJTeW5jaHJvbml6YXRpb24ocGVyc2lzdGVuY2VUcmFuc2FjdGlvbikubmV4dCgoKSA9PiB0cmFuc2FjdGlvbk9wZXJhdGlvbihwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcGVyc2lzdGVuY2VUcmFuc2FjdGlvbi5yYWlzZU9uQ29tbWl0dGVkRXZlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGF0IHRoZSBjdXJyZW50IHRhYiBpcyB0aGUgcHJpbWFyeSBsZWFzZWhvbGRlciBvciBhbHRlcm5hdGl2ZWx5XG4gICAgICogdGhhdCB0aGUgbGVhc2Vob2xkZXIgaGFzIG9wdGVkIGludG8gbXVsdGktdGFiIHN5bmNocm9uaXphdGlvbi5cbiAgICAgKi9cbiAgICAvLyBUT0RPKGIvMTE0MjI2MjM0KTogUmVtb3ZlIHRoaXMgY2hlY2sgd2hlbiBgc3luY2hyb25pemVUYWJzYCBjYW4gbm8gbG9uZ2VyXG4gICAgLy8gYmUgdHVybmVkIG9mZi5cbiAgICB2ZXJpZnlBbGxvd1RhYlN5bmNocm9uaXphdGlvbih0eG4pIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBwcmltYXJ5Q2xpZW50U3RvcmUodHhuKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlLmdldChEYlByaW1hcnlDbGllbnRLZXkpLm5leHQoY3VycmVudFByaW1hcnkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudExlYXNlSXNWYWxpZCA9IGN1cnJlbnRQcmltYXJ5ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5pc1dpdGhpbkFnZShjdXJyZW50UHJpbWFyeS5sZWFzZVRpbWVzdGFtcE1zLCBNQVhfUFJJTUFSWV9FTElHSUJMRV9BR0VfTVMpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaXNDbGllbnRab21iaWVkKGN1cnJlbnRQcmltYXJ5Lm93bmVySWQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZWFzZUlzVmFsaWQgJiYgIXRoaXMuaXNMb2NhbENsaWVudChjdXJyZW50UHJpbWFyeSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZm9yY2VPd25pbmdUYWIgJiZcbiAgICAgICAgICAgICAgICAgICAgKCF0aGlzLmFsbG93VGFiU3luY2hyb25pemF0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhY3VycmVudFByaW1hcnkuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sIFBSSU1BUllfTEVBU0VfRVhDTFVTSVZFX0VSUk9SX01TRyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT2J0YWlucyBvciBleHRlbmRzIHRoZSBuZXcgcHJpbWFyeSBsZWFzZSBmb3IgdGhlIGxvY2FsIGNsaWVudC4gVGhpc1xuICAgICAqIG1ldGhvZCBkb2VzIG5vdCB2ZXJpZnkgdGhhdCB0aGUgY2xpZW50IGlzIGVsaWdpYmxlIGZvciB0aGlzIGxlYXNlLlxuICAgICAqL1xuICAgIGFjcXVpcmVPckV4dGVuZFByaW1hcnlMZWFzZSh0eG4pIHtcbiAgICAgICAgY29uc3QgbmV3UHJpbWFyeSA9IHtcbiAgICAgICAgICAgIG93bmVySWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICBhbGxvd1RhYlN5bmNocm9uaXphdGlvbjogdGhpcy5hbGxvd1RhYlN5bmNocm9uaXphdGlvbixcbiAgICAgICAgICAgIGxlYXNlVGltZXN0YW1wTXM6IERhdGUubm93KClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByaW1hcnlDbGllbnRTdG9yZSh0eG4pLnB1dChEYlByaW1hcnlDbGllbnRLZXksIG5ld1ByaW1hcnkpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNBdmFpbGFibGUoKSB7XG4gICAgICAgIHJldHVybiBTaW1wbGVEYi5pc0F2YWlsYWJsZSgpO1xuICAgIH1cbiAgICAvKiogQ2hlY2tzIHRoZSBwcmltYXJ5IGxlYXNlIGFuZCByZW1vdmVzIGl0IGlmIHdlIGFyZSB0aGUgY3VycmVudCBwcmltYXJ5LiAqL1xuICAgIHJlbGVhc2VQcmltYXJ5TGVhc2VJZkhlbGQodHhuKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gcHJpbWFyeUNsaWVudFN0b3JlKHR4bik7XG4gICAgICAgIHJldHVybiBzdG9yZS5nZXQoRGJQcmltYXJ5Q2xpZW50S2V5KS5uZXh0KHByaW1hcnlDbGllbnQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2NhbENsaWVudChwcmltYXJ5Q2xpZW50KSkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckYywgJ1JlbGVhc2luZyBwcmltYXJ5IGxlYXNlLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5kZWxldGUoRGJQcmltYXJ5Q2xpZW50S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIFZlcmlmaWVzIHRoYXQgYHVwZGF0ZVRpbWVNc2AgaXMgd2l0aGluIGBtYXhBZ2VNc2AuICovXG4gICAgaXNXaXRoaW5BZ2UodXBkYXRlVGltZU1zLCBtYXhBZ2VNcykge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBtaW5BY2NlcHRhYmxlID0gbm93IC0gbWF4QWdlTXM7XG4gICAgICAgIGNvbnN0IG1heEFjY2VwdGFibGUgPSBub3c7XG4gICAgICAgIGlmICh1cGRhdGVUaW1lTXMgPCBtaW5BY2NlcHRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXBkYXRlVGltZU1zID4gbWF4QWNjZXB0YWJsZSkge1xuICAgICAgICAgICAgbG9nRXJyb3IoYERldGVjdGVkIGFuIHVwZGF0ZSB0aW1lIHRoYXQgaXMgaW4gdGhlIGZ1dHVyZTogJHt1cGRhdGVUaW1lTXN9ID4gJHttYXhBY2NlcHRhYmxlfWApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhdHRhY2hWaXNpYmlsaXR5SGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnQgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluRm9yZWdyb3VuZCA9IHRoaXMuZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZSc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5SGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLmluRm9yZWdyb3VuZCA9IHRoaXMuZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGV0YWNoVmlzaWJpbGl0eUhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50VmlzaWJpbGl0eUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5SGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50VmlzaWJpbGl0eUhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGEgd2luZG93LnVubG9hZCBoYW5kbGVyIHRoYXQgd2lsbCBzeW5jaHJvbm91c2x5IHdyaXRlIG91clxuICAgICAqIGNsaWVudElkIHRvIGEgXCJ6b21iaWUgY2xpZW50IGlkXCIgbG9jYXRpb24gaW4gTG9jYWxTdG9yYWdlLiBUaGlzIGNhbiBiZSB1c2VkXG4gICAgICogYnkgdGFicyB0cnlpbmcgdG8gYWNxdWlyZSB0aGUgcHJpbWFyeSBsZWFzZSB0byBkZXRlcm1pbmUgdGhhdCB0aGUgbGVhc2VcbiAgICAgKiBpcyBubyBsb25nZXIgdmFsaWQgZXZlbiBpZiB0aGUgdGltZXN0YW1wIGlzIHJlY2VudC4gVGhpcyBpcyBwYXJ0aWN1bGFybHlcbiAgICAgKiBpbXBvcnRhbnQgZm9yIHRoZSByZWZyZXNoIGNhc2UgKHNvIHRoZSB0YWIgY29ycmVjdGx5IHJlLWFjcXVpcmVzIHRoZVxuICAgICAqIHByaW1hcnkgbGVhc2UpLiBMb2NhbFN0b3JhZ2UgaXMgdXNlZCBmb3IgdGhpcyByYXRoZXIgdGhhbiBJbmRleGVkRGIgYmVjYXVzZVxuICAgICAqIGl0IGlzIGEgc3luY2hyb25vdXMgQVBJIGFuZCBzbyBjYW4gYmUgdXNlZCByZWxpYWJseSBmcm9tICBhbiB1bmxvYWRcbiAgICAgKiBoYW5kbGVyLlxuICAgICAqL1xuICAgIGF0dGFjaFdpbmRvd1VubG9hZEhvb2soKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy53aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMud2luZG93VW5sb2FkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBJbiB0aGVvcnksIHRoaXMgc2hvdWxkIGJlIHNjaGVkdWxlZCBvbiB0aGUgQXN5bmNRdWV1ZSBzaW5jZSBpdFxuICAgICAgICAgICAgICAgIC8vIGFjY2Vzc2VzIGludGVybmFsIHN0YXRlLiBXZSBleGVjdXRlIHRoaXMgY29kZSBkaXJlY3RseSBkdXJpbmcgc2h1dGRvd25cbiAgICAgICAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBhIGNoYW5jZSB0byBydW4uXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrQ2xpZW50Wm9tYmllZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNhZmFyaUluZGV4ZGJCdWdWZXJzaW9uUmVnZXggPSAvKD86VmVyc2lvbnxNb2JpbGUpXFwvMVs0NTZdLztcbiAgICAgICAgICAgICAgICBpZiAoaXNTYWZhcmkoKSAmJlxuICAgICAgICAgICAgICAgICAgICAobmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goc2FmYXJpSW5kZXhkYkJ1Z1ZlcnNpb25SZWdleCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goc2FmYXJpSW5kZXhkYkJ1Z1ZlcnNpb25SZWdleCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9uIFNhZmFyaSAxNCwgMTUsIGFuZCAxNiwgd2UgZG8gbm90IHJ1biBhbnkgY2xlYW51cCBhY3Rpb25zIGFzIGl0IG1pZ2h0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgYSBidWcgdGhhdCBwcmV2ZW50cyBTYWZhcmkgZnJvbSByZS1vcGVuaW5nIEluZGV4ZWREQiBkdXJpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5leHQgcGFnZSBsb2FkLlxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIyNjU0N1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVudGVyUmVzdHJpY3RlZE1vZGUoLyogcHVyZ2VFeGlzdGluZ1Rhc2tzPSAqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCBncmFjZWZ1bCBzaHV0ZG93biAoaW5jbHVkaW5nIHJlbGVhc2luZyBvdXIgcHJpbWFyeSBsZWFzZSksXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGVyZSdzIG5vIGd1YXJhbnRlZSBpdCB3aWxsIGNvbXBsZXRlLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaHV0ZG93bigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy53aW5kb3dVbmxvYWRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXRhY2hXaW5kb3dVbmxvYWRIb29rKCkge1xuICAgICAgICBpZiAodGhpcy53aW5kb3dVbmxvYWRIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMud2luZG93VW5sb2FkSGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLndpbmRvd1VubG9hZEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBhIGNsaWVudCBpcyBcInpvbWJpZWRcIiBiYXNlZCBvbiBpdHMgTG9jYWxTdG9yYWdlIGVudHJ5LlxuICAgICAqIENsaWVudHMgYmVjb21lIHpvbWJpZWQgd2hlbiB0aGVpciB0YWIgY2xvc2VzIHdpdGhvdXQgcnVubmluZyBhbGwgb2YgdGhlXG4gICAgICogY2xlYW51cCBsb2dpYyBpbiBgc2h1dGRvd24oKWAuXG4gICAgICovXG4gICAgaXNDbGllbnRab21iaWVkKGNsaWVudElkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpc1pvbWJpZWQgPSB0aGlzLndlYlN0b3JhZ2U/LmdldEl0ZW0odGhpcy56b21iaWVkQ2xpZW50TG9jYWxTdG9yYWdlS2V5KGNsaWVudElkKSkgIT09IG51bGw7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsIGBDbGllbnQgJyR7Y2xpZW50SWR9JyAke2lzWm9tYmllZCA/ICdpcycgOiAnaXMgbm90J30gem9tYmllZCBpbiBMb2NhbFN0b3JhZ2VgKTtcbiAgICAgICAgICAgIHJldHVybiBpc1pvbWJpZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIEdyYWNlZnVsbHkgaGFuZGxlIGlmIExvY2FsU3RvcmFnZSBpc24ndCB3b3JraW5nLlxuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRjLCAnRmFpbGVkIHRvIGdldCB6b21iaWVkIGNsaWVudCBpZC4nLCBlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvcmQgY2xpZW50IGFzIHpvbWJpZWQgKGEgY2xpZW50IHRoYXQgaGFkIGl0cyB0YWIgY2xvc2VkKS4gWm9tYmllZFxuICAgICAqIGNsaWVudHMgYXJlIGlnbm9yZWQgZHVyaW5nIHByaW1hcnkgdGFiIHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBtYXJrQ2xpZW50Wm9tYmllZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLndlYlN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53ZWJTdG9yYWdlLnNldEl0ZW0odGhpcy56b21iaWVkQ2xpZW50TG9jYWxTdG9yYWdlS2V5KHRoaXMuY2xpZW50SWQpLCBTdHJpbmcoRGF0ZS5ub3coKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBHcmFjZWZ1bGx5IGhhbmRsZSBpZiBMb2NhbFN0b3JhZ2UgaXNuJ3QgYXZhaWxhYmxlIC8gd29ya2luZy5cbiAgICAgICAgICAgIGxvZ0Vycm9yKCdGYWlsZWQgdG8gc2V0IHpvbWJpZSBjbGllbnQgaWQuJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJlbW92ZXMgdGhlIHpvbWJpZWQgY2xpZW50IGVudHJ5IGlmIGl0IGV4aXN0cy4gKi9cbiAgICByZW1vdmVDbGllbnRab21iaWVkRW50cnkoKSB7XG4gICAgICAgIGlmICghdGhpcy53ZWJTdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMud2ViU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuem9tYmllZENsaWVudExvY2FsU3RvcmFnZUtleSh0aGlzLmNsaWVudElkKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZVxuICAgICAgICB9XG4gICAgfVxuICAgIHpvbWJpZWRDbGllbnRMb2NhbFN0b3JhZ2VLZXkoY2xpZW50SWQpIHtcbiAgICAgICAgcmV0dXJuIGAke1pPTUJJRURfQ0xJRU5UU19LRVlfUFJFRklYfV8ke3RoaXMucGVyc2lzdGVuY2VLZXl9XyR7Y2xpZW50SWR9YDtcbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgcHJpbWFyeSBjbGllbnQgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBwcmltYXJ5Q2xpZW50U3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJQcmltYXJ5Q2xpZW50U3RvcmUpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGNsaWVudCBtZXRhZGF0YSBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIGNsaWVudE1ldGFkYXRhU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJDbGllbnRNZXRhZGF0YVN0b3JlKTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgc3RyaW5nIHVzZWQgYXMgYSBwcmVmaXggd2hlbiBzdG9yaW5nIGRhdGEgaW4gSW5kZXhlZERCIGFuZFxuICogTG9jYWxTdG9yYWdlLlxuICovXG5mdW5jdGlvbiBpbmRleGVkRGJTdG9yYWdlUHJlZml4KGRhdGFiYXNlSWQsIHBlcnNpc3RlbmNlS2V5KSB7XG4gICAgLy8gVXNlIHR3byBkaWZmZXJlbnQgcHJlZml4IGZvcm1hdHM6XG4gICAgLy9cbiAgICAvLyAgICogZmlyZXN0b3JlIC8gcGVyc2lzdGVuY2VLZXkgLyBwcm9qZWN0SUQgLiBkYXRhYmFzZUlEIC8gLi4uXG4gICAgLy8gICAqIGZpcmVzdG9yZSAvIHBlcnNpc3RlbmNlS2V5IC8gcHJvamVjdElEIC8gLi4uXG4gICAgLy9cbiAgICAvLyBwcm9qZWN0SURzIGFyZSBETlMtY29tcGF0aWJsZSBuYW1lcyBhbmQgY2Fubm90IGNvbnRhaW4gZG90c1xuICAgIC8vIHNvIHRoZXJlJ3Mgbm8gZGFuZ2VyIG9mIGNvbGxpc2lvbnMuXG4gICAgbGV0IGRhdGFiYXNlID0gZGF0YWJhc2VJZC5wcm9qZWN0SWQ7XG4gICAgaWYgKCFkYXRhYmFzZUlkLmlzRGVmYXVsdERhdGFiYXNlKSB7XG4gICAgICAgIGRhdGFiYXNlICs9ICcuJyArIGRhdGFiYXNlSWQuZGF0YWJhc2U7XG4gICAgfVxuICAgIHJldHVybiAnZmlyZXN0b3JlLycgKyBwZXJzaXN0ZW5jZUtleSArICcvJyArIGRhdGFiYXNlICsgJy8nO1xufVxuYXN5bmMgZnVuY3Rpb24gaW5kZXhlZERiQ2xlYXJQZXJzaXN0ZW5jZShwZXJzaXN0ZW5jZUtleSkge1xuICAgIGlmICghU2ltcGxlRGIuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IGRiTmFtZSA9IHBlcnNpc3RlbmNlS2V5ICsgTUFJTl9EQVRBQkFTRTtcbiAgICBhd2FpdCBTaW1wbGVEYi5kZWxldGUoZGJOYW1lKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ29tcGFyZXMgdHdvIGFycmF5IGZvciBlcXVhbGl0eSB1c2luZyBjb21wYXJhdG9yLiBUaGUgbWV0aG9kIGNvbXB1dGVzIHRoZVxuICogaW50ZXJzZWN0aW9uIGFuZCBpbnZva2VzIGBvbkFkZGAgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdCBpcyBpbiBgYWZ0ZXJgIGJ1dCBub3RcbiAqIGBiZWZvcmVgLiBgb25SZW1vdmVgIGlzIGludm9rZWQgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gYGJlZm9yZWAgYnV0IG1pc3NpbmdcbiAqIGZyb20gYGFmdGVyYC5cbiAqXG4gKiBUaGUgbWV0aG9kIGNyZWF0ZXMgYSBjb3B5IG9mIGJvdGggYGJlZm9yZWAgYW5kIGBhZnRlcmAgYW5kIHJ1bnMgaW4gTyhuIGxvZ1xuICogbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIHR3byBsaXN0cy5cbiAqXG4gKiBAcGFyYW0gYmVmb3JlIC0gVGhlIGVsZW1lbnRzIHRoYXQgZXhpc3QgaW4gdGhlIG9yaWdpbmFsIGFycmF5LlxuICogQHBhcmFtIGFmdGVyIC0gVGhlIGVsZW1lbnRzIHRvIGRpZmYgYWdhaW5zdCB0aGUgb3JpZ2luYWwgYXJyYXkuXG4gKiBAcGFyYW0gY29tcGFyYXRvciAtIFRoZSBjb21wYXJhdG9yIGZvciB0aGUgZWxlbWVudHMgaW4gYmVmb3JlIGFuZCBhZnRlci5cbiAqIEBwYXJhbSBvbkFkZCAtIEEgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBldmVyeSBlbGVtZW50IHRoYXQgaXMgcGFydCBvZiBgXG4gKiBhZnRlcmAgYnV0IG5vdCBgYmVmb3JlYC5cbiAqIEBwYXJhbSBvblJlbW92ZSAtIEEgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBldmVyeSBlbGVtZW50IHRoYXQgaXMgcGFydCBvZlxuICogYGJlZm9yZWAgYnV0IG5vdCBgYWZ0ZXJgLlxuICovXG5mdW5jdGlvbiBkaWZmQXJyYXlzKGJlZm9yZSwgYWZ0ZXIsIGNvbXBhcmF0b3IsIG9uQWRkLCBvblJlbW92ZSkge1xuICAgIGJlZm9yZSA9IFsuLi5iZWZvcmVdO1xuICAgIGFmdGVyID0gWy4uLmFmdGVyXTtcbiAgICBiZWZvcmUuc29ydChjb21wYXJhdG9yKTtcbiAgICBhZnRlci5zb3J0KGNvbXBhcmF0b3IpO1xuICAgIGNvbnN0IGJMZW4gPSBiZWZvcmUubGVuZ3RoO1xuICAgIGNvbnN0IGFMZW4gPSBhZnRlci5sZW5ndGg7XG4gICAgbGV0IGEgPSAwO1xuICAgIGxldCBiID0gMDtcbiAgICB3aGlsZSAoYSA8IGFMZW4gJiYgYiA8IGJMZW4pIHtcbiAgICAgICAgY29uc3QgY21wID0gY29tcGFyYXRvcihiZWZvcmVbYl0sIGFmdGVyW2FdKTtcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IHdhcyByZW1vdmVkIGlmIHRoZSBuZXh0IGVsZW1lbnQgaW4gb3VyIG9yZGVyZWRcbiAgICAgICAgICAgIC8vIHdhbGt0aHJvdWdoIGlzIG9ubHkgaW4gYGJlZm9yZWAuXG4gICAgICAgICAgICBvblJlbW92ZShiZWZvcmVbYisrXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgd2FzIGFkZGVkIGlmIHRoZSBuZXh0IGVsZW1lbnQgaW4gb3VyIG9yZGVyZWQgd2Fsa3Rocm91Z2hcbiAgICAgICAgICAgIC8vIGlzIG9ubHkgaW4gYGFmdGVyYC5cbiAgICAgICAgICAgIG9uQWRkKGFmdGVyW2ErK10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYSsrO1xuICAgICAgICAgICAgYisrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChhIDwgYUxlbikge1xuICAgICAgICBvbkFkZChhZnRlclthKytdKTtcbiAgICB9XG4gICAgd2hpbGUgKGIgPCBiTGVuKSB7XG4gICAgICAgIG9uUmVtb3ZlKGJlZm9yZVtiKytdKTtcbiAgICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIGVxdWFsaXR5IGZvciBhbiBhcnJheSBvZiBwcmltaXRpdmVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBsZWZ0IC0gQXJyYXkgb2YgcHJpbWl0aXZlcy5cbiAqIEBwYXJhbSByaWdodCAtIEFycmF5IG9mIHByaW1pdGl2ZXMuXG4gKiBAcmV0dXJucyBUcnVlIGlmIGFycmF5cyBhcmUgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlQXJyYXlFcXVhbChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0Lmxlbmd0aCAhPT0gcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChsZWZ0W2ldICE9PSByaWdodFtpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyRiID0gJ0xvY2FsU3RvcmUnO1xuLyoqXG4gKiBUaGUgbWF4aW11bSB0aW1lIHRvIGxlYXZlIGEgcmVzdW1lIHRva2VuIGJ1ZmZlcmVkIHdpdGhvdXQgd3JpdGluZyBpdCBvdXQuXG4gKiBUaGlzIHZhbHVlIGlzIGFyYml0cmFyeTogaXQncyBsb25nIGVub3VnaCB0byBhdm9pZCBzZXZlcmFsIHdyaXRlc1xuICogKHBvc3NpYmx5IGluZGVmaW5pdGVseSBpZiB1cGRhdGVzIGNvbWUgbW9yZSBmcmVxdWVudGx5IHRoYW4gdGhpcykgYnV0XG4gKiBzaG9ydCBlbm91Z2ggdGhhdCByZXN0YXJ0aW5nIGFmdGVyIGNyYXNoaW5nIHdpbGwgc3RpbGwgaGF2ZSBhIHByZXR0eVxuICogcmVjZW50IHJlc3VtZSB0b2tlbi5cbiAqL1xuY29uc3QgUkVTVU1FX1RPS0VOX01BWF9BR0VfTUlDUk9TID0gNSAqIDYwICogMWU2O1xuLyoqXG4gKiBJbXBsZW1lbnRzIGBMb2NhbFN0b3JlYCBpbnRlcmZhY2UuXG4gKlxuICogTm90ZTogc29tZSBmaWVsZCBkZWZpbmVkIGluIHRoaXMgY2xhc3MgbWlnaHQgaGF2ZSBwdWJsaWMgYWNjZXNzIGxldmVsLCBidXRcbiAqIHRoZSBjbGFzcyBpcyBub3QgZXhwb3J0ZWQgc28gdGhleSBhcmUgb25seSBhY2Nlc3NpYmxlIGZyb20gdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIHVzZWZ1bCB0byBpbXBsZW1lbnQgb3B0aW9uYWwgZmVhdHVyZXMgKGxpa2UgYnVuZGxlcykgaW4gZnJlZVxuICogZnVuY3Rpb25zLCBzdWNoIHRoYXQgdGhleSBhcmUgdHJlZS1zaGFrZWFibGUuXG4gKi9cbmNsYXNzIExvY2FsU3RvcmVJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogTWFuYWdlcyBvdXIgaW4tbWVtb3J5IG9yIGR1cmFibGUgcGVyc2lzdGVuY2UuICovXG4gICAgcGVyc2lzdGVuY2UsIHF1ZXJ5RW5naW5lLCBpbml0aWFsVXNlciwgc2VyaWFsaXplcikge1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gcGVyc2lzdGVuY2U7XG4gICAgICAgIHRoaXMucXVlcnlFbmdpbmUgPSBxdWVyeUVuZ2luZTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcHMgYSB0YXJnZXRJRCB0byBkYXRhIGFib3V0IGl0cyB0YXJnZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBPUlRJTkcgTk9URTogV2UgYXJlIHVzaW5nIGFuIGltbXV0YWJsZSBkYXRhIHN0cnVjdHVyZSBvbiBXZWIgdG8gbWFrZSByZS1ydW5zXG4gICAgICAgICAqIG9mIGBhcHBseVJlbW90ZUV2ZW50KClgIGlkZW1wb3RlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhcmdldERhdGFCeVRhcmdldCA9IG5ldyBTb3J0ZWRNYXAocHJpbWl0aXZlQ29tcGFyYXRvcik7XG4gICAgICAgIC8qKiBNYXBzIGEgdGFyZ2V0IHRvIGl0cyB0YXJnZXRJRC4gKi9cbiAgICAgICAgLy8gVE9ETyh3dWFuZHkpOiBFdmFsdWF0ZSBpZiBUYXJnZXRJZCBjYW4gYmUgcGFydCBvZiBUYXJnZXQuXG4gICAgICAgIHRoaXMudGFyZ2V0SWRCeVRhcmdldCA9IG5ldyBPYmplY3RNYXAodCA9PiBjYW5vbmlmeVRhcmdldCh0KSwgdGFyZ2V0RXF1YWxzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcGVyIGNvbGxlY3Rpb24gZ3JvdXAgaW5kZXggb2YgdGhlIGxhc3QgcmVhZCB0aW1lIHByb2Nlc3NlZCBieVxuICAgICAgICAgKiBgZ2V0TmV3RG9jdW1lbnRDaGFuZ2VzKClgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQT1JUSU5HIE5PVEU6IFRoaXMgaXMgb25seSB1c2VkIGZvciBtdWx0aS10YWIgc3luY2hyb25pemF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXBSZWFkVGltZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZW1vdGVEb2N1bWVudHMgPSBwZXJzaXN0ZW5jZS5nZXRSZW1vdGVEb2N1bWVudENhY2hlKCk7XG4gICAgICAgIHRoaXMudGFyZ2V0Q2FjaGUgPSBwZXJzaXN0ZW5jZS5nZXRUYXJnZXRDYWNoZSgpO1xuICAgICAgICB0aGlzLmJ1bmRsZUNhY2hlID0gcGVyc2lzdGVuY2UuZ2V0QnVuZGxlQ2FjaGUoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplVXNlckNvbXBvbmVudHMoaW5pdGlhbFVzZXIpO1xuICAgIH1cbiAgICBpbml0aWFsaXplVXNlckNvbXBvbmVudHModXNlcikge1xuICAgICAgICAvLyBUT0RPKGluZGV4aW5nKTogQWRkIHNwZWMgdGVzdHMgdGhhdCB0ZXN0IHRoZXNlIGNvbXBvbmVudHMgY2hhbmdlIGFmdGVyIGFcbiAgICAgICAgLy8gdXNlciBjaGFuZ2VcbiAgICAgICAgdGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZSA9IHRoaXMucGVyc2lzdGVuY2UuZ2V0RG9jdW1lbnRPdmVybGF5Q2FjaGUodXNlcik7XG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gdGhpcy5wZXJzaXN0ZW5jZS5nZXRJbmRleE1hbmFnZXIodXNlcik7XG4gICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZSA9IHRoaXMucGVyc2lzdGVuY2UuZ2V0TXV0YXRpb25RdWV1ZSh1c2VyLCB0aGlzLmluZGV4TWFuYWdlcik7XG4gICAgICAgIHRoaXMubG9jYWxEb2N1bWVudHMgPSBuZXcgTG9jYWxEb2N1bWVudHNWaWV3KHRoaXMucmVtb3RlRG9jdW1lbnRzLCB0aGlzLm11dGF0aW9uUXVldWUsIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGUsIHRoaXMuaW5kZXhNYW5hZ2VyKTtcbiAgICAgICAgdGhpcy5yZW1vdGVEb2N1bWVudHMuc2V0SW5kZXhNYW5hZ2VyKHRoaXMuaW5kZXhNYW5hZ2VyKTtcbiAgICAgICAgdGhpcy5xdWVyeUVuZ2luZS5pbml0aWFsaXplKHRoaXMubG9jYWxEb2N1bWVudHMsIHRoaXMuaW5kZXhNYW5hZ2VyKTtcbiAgICB9XG4gICAgY29sbGVjdEdhcmJhZ2UoZ2FyYmFnZUNvbGxlY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignQ29sbGVjdCBnYXJiYWdlJywgJ3JlYWR3cml0ZS1wcmltYXJ5JywgdHhuID0+IGdhcmJhZ2VDb2xsZWN0b3IuY29sbGVjdCh0eG4sIHRoaXMudGFyZ2V0RGF0YUJ5VGFyZ2V0KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3TG9jYWxTdG9yZShcbi8qKiBNYW5hZ2VzIG91ciBpbi1tZW1vcnkgb3IgZHVyYWJsZSBwZXJzaXN0ZW5jZS4gKi9cbnBlcnNpc3RlbmNlLCBxdWVyeUVuZ2luZSwgaW5pdGlhbFVzZXIsIHNlcmlhbGl6ZXIpIHtcbiAgICByZXR1cm4gbmV3IExvY2FsU3RvcmVJbXBsKHBlcnNpc3RlbmNlLCBxdWVyeUVuZ2luZSwgaW5pdGlhbFVzZXIsIHNlcmlhbGl6ZXIpO1xufVxuLyoqXG4gKiBUZWxscyB0aGUgTG9jYWxTdG9yZSB0aGF0IHRoZSBjdXJyZW50bHkgYXV0aGVudGljYXRlZCB1c2VyIGhhcyBjaGFuZ2VkLlxuICpcbiAqIEluIHJlc3BvbnNlIHRoZSBsb2NhbCBzdG9yZSBzd2l0Y2hlcyB0aGUgbXV0YXRpb24gcXVldWUgdG8gdGhlIG5ldyB1c2VyIGFuZFxuICogcmV0dXJucyBhbnkgcmVzdWx0aW5nIGRvY3VtZW50IGNoYW5nZXMuXG4gKi9cbi8vIFBPUlRJTkcgTk9URTogQW5kcm9pZCBhbmQgaU9TIG9ubHkgcmV0dXJuIHRoZSBkb2N1bWVudHMgYWZmZWN0ZWQgYnkgdGhlXG4vLyBjaGFuZ2UuXG5hc3luYyBmdW5jdGlvbiBsb2NhbFN0b3JlSGFuZGxlVXNlckNoYW5nZShsb2NhbFN0b3JlLCB1c2VyKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0hhbmRsZSB1c2VyIGNoYW5nZScsICdyZWFkb25seScsIHR4biA9PiB7XG4gICAgICAgIC8vIFN3YXAgb3V0IHRoZSBtdXRhdGlvbiBxdWV1ZSwgZ3JhYmJpbmcgdGhlIHBlbmRpbmcgbXV0YXRpb24gYmF0Y2hlc1xuICAgICAgICAvLyBiZWZvcmUgYW5kIGFmdGVyLlxuICAgICAgICBsZXQgb2xkQmF0Y2hlcztcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWVcbiAgICAgICAgICAgIC5nZXRBbGxNdXRhdGlvbkJhdGNoZXModHhuKVxuICAgICAgICAgICAgLm5leHQocHJvbWlzZWRPbGRCYXRjaGVzID0+IHtcbiAgICAgICAgICAgIG9sZEJhdGNoZXMgPSBwcm9taXNlZE9sZEJhdGNoZXM7XG4gICAgICAgICAgICBsb2NhbFN0b3JlSW1wbC5pbml0aWFsaXplVXNlckNvbXBvbmVudHModXNlcik7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZS5nZXRBbGxNdXRhdGlvbkJhdGNoZXModHhuKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KG5ld0JhdGNoZXMgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZEJhdGNoSWRzID0gW107XG4gICAgICAgICAgICBjb25zdCBhZGRlZEJhdGNoSWRzID0gW107XG4gICAgICAgICAgICAvLyBVbmlvbiB0aGUgb2xkL25ldyBjaGFuZ2VkIGtleXMuXG4gICAgICAgICAgICBsZXQgY2hhbmdlZEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiBvbGRCYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZEJhdGNoSWRzLnB1c2goYmF0Y2guYmF0Y2hJZCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBiYXRjaC5tdXRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEtleXMgPSBjaGFuZ2VkS2V5cy5hZGQobXV0YXRpb24ua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIG5ld0JhdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBhZGRlZEJhdGNoSWRzLnB1c2goYmF0Y2guYmF0Y2hJZCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBiYXRjaC5tdXRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEtleXMgPSBjaGFuZ2VkS2V5cy5hZGQobXV0YXRpb24ua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNldCBvZiBhbGwgKHBvdGVudGlhbGx5KSBjaGFuZ2VkIGRvY3VtZW50cyBhbmQgdGhlIGxpc3RcbiAgICAgICAgICAgIC8vIG9mIG11dGF0aW9uIGJhdGNoIElEcyB0aGF0IHdlcmUgYWZmZWN0ZWQgYnkgY2hhbmdlLlxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLmxvY2FsRG9jdW1lbnRzXG4gICAgICAgICAgICAgICAgLmdldERvY3VtZW50cyh0eG4sIGNoYW5nZWRLZXlzKVxuICAgICAgICAgICAgICAgIC5uZXh0KGFmZmVjdGVkRG9jdW1lbnRzID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZERvY3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEJhdGNoSWRzLFxuICAgICAgICAgICAgICAgICAgICBhZGRlZEJhdGNoSWRzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyogQWNjZXB0cyBsb2NhbGx5IGdlbmVyYXRlZCBNdXRhdGlvbnMgYW5kIGNvbW1pdCB0aGVtIHRvIHN0b3JhZ2UuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlV3JpdGVMb2NhbGx5KGxvY2FsU3RvcmUsIG11dGF0aW9ucykge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIGNvbnN0IGxvY2FsV3JpdGVUaW1lID0gVGltZXN0YW1wLm5vdygpO1xuICAgIGNvbnN0IGtleXMgPSBtdXRhdGlvbnMucmVkdWNlKChrZXlzLCBtKSA9PiBrZXlzLmFkZChtLmtleSksIGRvY3VtZW50S2V5U2V0KCkpO1xuICAgIGxldCBvdmVybGF5ZWREb2N1bWVudHM7XG4gICAgbGV0IG11dGF0aW9uQmF0Y2g7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlXG4gICAgICAgIC5ydW5UcmFuc2FjdGlvbignTG9jYWxseSB3cml0ZSBtdXRhdGlvbnMnLCAncmVhZHdyaXRlJywgdHhuID0+IHtcbiAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBrZXlzIGRvIG5vdCBoYXZlIGEgcmVtb3RlIHZlcnNpb24gaW4gdGhlIGNhY2hlLCB0aGlzXG4gICAgICAgIC8vIGlzIG5lZWRlZCB0byBjcmVhdGUgdGhlIHJpZ2h0IG92ZXJsYXkgbXV0YXRpb246IGlmIG5vIHJlbW90ZSB2ZXJzaW9uXG4gICAgICAgIC8vIHByZXNlbnRzLCB3ZSBkbyBub3QgbmVlZCB0byBjcmVhdGUgb3ZlcmxheXMgYXMgcGF0Y2ggbXV0YXRpb25zLlxuICAgICAgICAvLyBUT0RPKE92ZXJsYXkpOiBJcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gZGV0ZXJtaW5lIHRoaXM/IFVzaW5nIHRoZVxuICAgICAgICAvLyAgZG9jdW1lbnQgdmVyc2lvbiBkb2VzIG5vdCB3b3JrIGJlY2F1c2UgbG9jYWwgbXV0YXRpb25zIHNldCB0aGVtIGJhY2tcbiAgICAgICAgLy8gIHRvIDAuXG4gICAgICAgIGxldCByZW1vdGVEb2NzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIGxldCBkb2NzV2l0aG91dFJlbW90ZVZlcnNpb24gPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucmVtb3RlRG9jdW1lbnRzXG4gICAgICAgICAgICAuZ2V0RW50cmllcyh0eG4sIGtleXMpXG4gICAgICAgICAgICAubmV4dChkb2NzID0+IHtcbiAgICAgICAgICAgIHJlbW90ZURvY3MgPSBkb2NzO1xuICAgICAgICAgICAgcmVtb3RlRG9jcy5mb3JFYWNoKChrZXksIGRvYykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZG9jLmlzVmFsaWREb2N1bWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3NXaXRob3V0UmVtb3RlVmVyc2lvbiA9IGRvY3NXaXRob3V0UmVtb3RlVmVyc2lvbi5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIExvYWQgYW5kIGFwcGx5IGFsbCBleGlzdGluZyBtdXRhdGlvbnMuIFRoaXMgbGV0cyB1cyBjb21wdXRlIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBiYXNlIHN0YXRlIGZvciBhbGwgbm9uLWlkZW1wb3RlbnQgdHJhbnNmb3JtcyBiZWZvcmUgYXBwbHlpbmdcbiAgICAgICAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHVzZXItcHJvdmlkZWQgd3JpdGVzLlxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLmxvY2FsRG9jdW1lbnRzLmdldE92ZXJsYXllZERvY3VtZW50cyh0eG4sIHJlbW90ZURvY3MpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKGRvY3MpID0+IHtcbiAgICAgICAgICAgIG92ZXJsYXllZERvY3VtZW50cyA9IGRvY3M7XG4gICAgICAgICAgICAvLyBGb3Igbm9uLWlkZW1wb3RlbnQgbXV0YXRpb25zIChzdWNoIGFzIGBGaWVsZFZhbHVlLmluY3JlbWVudCgpYCksXG4gICAgICAgICAgICAvLyB3ZSByZWNvcmQgdGhlIGJhc2Ugc3RhdGUgaW4gYSBzZXBhcmF0ZSBwYXRjaCBtdXRhdGlvbi4gVGhpcyBpc1xuICAgICAgICAgICAgLy8gbGF0ZXIgdXNlZCB0byBndWFyYW50ZWUgY29uc2lzdGVudCB2YWx1ZXMgYW5kIHByZXZlbnRzIGZsaWNrZXJcbiAgICAgICAgICAgIC8vIGV2ZW4gaWYgdGhlIGJhY2tlbmQgc2VuZHMgdXMgYW4gdXBkYXRlIHRoYXQgYWxyZWFkeSBpbmNsdWRlcyBvdXJcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybS5cbiAgICAgICAgICAgIGNvbnN0IGJhc2VNdXRhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVZhbHVlID0gbXV0YXRpb25FeHRyYWN0QmFzZVZhbHVlKG11dGF0aW9uLCBvdmVybGF5ZWREb2N1bWVudHMuZ2V0KG11dGF0aW9uLmtleSkub3ZlcmxheWVkRG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBUaGUgYmFzZSBzdGF0ZSBzaG91bGQgb25seSBiZSBhcHBsaWVkIGlmIHRoZXJlJ3Mgc29tZVxuICAgICAgICAgICAgICAgICAgICAvLyBleGlzdGluZyBkb2N1bWVudCB0byBvdmVycmlkZSwgc28gdXNlIGEgUHJlY29uZGl0aW9uIG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4aXN0cz10cnVlXG4gICAgICAgICAgICAgICAgICAgIGJhc2VNdXRhdGlvbnMucHVzaChuZXcgUGF0Y2hNdXRhdGlvbihtdXRhdGlvbi5rZXksIGJhc2VWYWx1ZSwgZXh0cmFjdEZpZWxkTWFzayhiYXNlVmFsdWUudmFsdWUubWFwVmFsdWUpLCBQcmVjb25kaXRpb24uZXhpc3RzKHRydWUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUuYWRkTXV0YXRpb25CYXRjaCh0eG4sIGxvY2FsV3JpdGVUaW1lLCBiYXNlTXV0YXRpb25zLCBtdXRhdGlvbnMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoYmF0Y2ggPT4ge1xuICAgICAgICAgICAgbXV0YXRpb25CYXRjaCA9IGJhdGNoO1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheXMgPSBiYXRjaC5hcHBseVRvTG9jYWxEb2N1bWVudFNldChvdmVybGF5ZWREb2N1bWVudHMsIGRvY3NXaXRob3V0UmVtb3RlVmVyc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwuZG9jdW1lbnRPdmVybGF5Q2FjaGUuc2F2ZU92ZXJsYXlzKHR4biwgYmF0Y2guYmF0Y2hJZCwgb3ZlcmxheXMpO1xuICAgICAgICB9KTtcbiAgICB9KVxuICAgICAgICAudGhlbigoKSA9PiAoe1xuICAgICAgICBiYXRjaElkOiBtdXRhdGlvbkJhdGNoLmJhdGNoSWQsXG4gICAgICAgIGNoYW5nZXM6IGNvbnZlcnRPdmVybGF5ZWREb2N1bWVudE1hcFRvRG9jdW1lbnRNYXAob3ZlcmxheWVkRG9jdW1lbnRzKVxuICAgIH0pKTtcbn1cbi8qKlxuICogQWNrbm93bGVkZ2VzIHRoZSBnaXZlbiBiYXRjaC5cbiAqXG4gKiBPbiB0aGUgaGFwcHkgcGF0aCB3aGVuIGEgYmF0Y2ggaXMgYWNrbm93bGVkZ2VkLCB0aGUgbG9jYWwgc3RvcmUgd2lsbFxuICpcbiAqICArIHJlbW92ZSB0aGUgYmF0Y2ggZnJvbSB0aGUgbXV0YXRpb24gcXVldWU7XG4gKiAgKyBhcHBseSB0aGUgY2hhbmdlcyB0byB0aGUgcmVtb3RlIGRvY3VtZW50IGNhY2hlO1xuICogICsgcmVjYWxjdWxhdGUgdGhlIGxhdGVuY3kgY29tcGVuc2F0ZWQgdmlldyBpbXBsaWVkIGJ5IHRob3NlIGNoYW5nZXMgKHRoZXJlXG4gKiAgICBtYXkgYmUgbXV0YXRpb25zIGluIHRoZSBxdWV1ZSB0aGF0IGFmZmVjdCB0aGUgZG9jdW1lbnRzIGJ1dCBoYXZlbid0IGJlZW5cbiAqICAgIGFja25vd2xlZGdlZCB5ZXQpOyBhbmRcbiAqICArIGdpdmUgdGhlIGNoYW5nZWQgZG9jdW1lbnRzIGJhY2sgdGhlIHN5bmMgZW5naW5lXG4gKlxuICogQHJldHVybnMgVGhlIHJlc3VsdGluZyAobW9kaWZpZWQpIGRvY3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yZUFja25vd2xlZGdlQmF0Y2gobG9jYWxTdG9yZSwgYmF0Y2hSZXN1bHQpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0Fja25vd2xlZGdlIGJhdGNoJywgJ3JlYWR3cml0ZS1wcmltYXJ5JywgdHhuID0+IHtcbiAgICAgICAgY29uc3QgYWZmZWN0ZWQgPSBiYXRjaFJlc3VsdC5iYXRjaC5rZXlzKCk7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50QnVmZmVyID0gbG9jYWxTdG9yZUltcGwucmVtb3RlRG9jdW1lbnRzLm5ld0NoYW5nZUJ1ZmZlcih7XG4gICAgICAgICAgICB0cmFja1JlbW92YWxzOiB0cnVlIC8vIE1ha2Ugc3VyZSBkb2N1bWVudCByZW1vdmFscyBzaG93IHVwIGluIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWBcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhcHBseVdyaXRlVG9SZW1vdGVEb2N1bWVudHMobG9jYWxTdG9yZUltcGwsIHR4biwgYmF0Y2hSZXN1bHQsIGRvY3VtZW50QnVmZmVyKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jdW1lbnRCdWZmZXIuYXBwbHkodHhuKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUucGVyZm9ybUNvbnNpc3RlbmN5Q2hlY2sodHhuKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLmRvY3VtZW50T3ZlcmxheUNhY2hlLnJlbW92ZU92ZXJsYXlzRm9yQmF0Y2hJZCh0eG4sIGFmZmVjdGVkLCBiYXRjaFJlc3VsdC5iYXRjaC5iYXRjaElkKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLmxvY2FsRG9jdW1lbnRzLnJlY2FsY3VsYXRlQW5kU2F2ZU92ZXJsYXlzRm9yRG9jdW1lbnRLZXlzKHR4biwgZ2V0S2V5c1dpdGhUcmFuc2Zvcm1SZXN1bHRzKGJhdGNoUmVzdWx0KSkpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50cy5nZXREb2N1bWVudHModHhuLCBhZmZlY3RlZCkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0S2V5c1dpdGhUcmFuc2Zvcm1SZXN1bHRzKGJhdGNoUmVzdWx0KSB7XG4gICAgbGV0IHJlc3VsdCA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaFJlc3VsdC5tdXRhdGlvblJlc3VsdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgbXV0YXRpb25SZXN1bHQgPSBiYXRjaFJlc3VsdC5tdXRhdGlvblJlc3VsdHNbaV07XG4gICAgICAgIGlmIChtdXRhdGlvblJlc3VsdC50cmFuc2Zvcm1SZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoYmF0Y2hSZXN1bHQuYmF0Y2gubXV0YXRpb25zW2ldLmtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUmVtb3ZlcyBtdXRhdGlvbnMgZnJvbSB0aGUgTXV0YXRpb25RdWV1ZSBmb3IgdGhlIHNwZWNpZmllZCBiYXRjaDtcbiAqIExvY2FsRG9jdW1lbnRzIHdpbGwgYmUgcmVjYWxjdWxhdGVkLlxuICpcbiAqIEByZXR1cm5zIFRoZSByZXN1bHRpbmcgbW9kaWZpZWQgZG9jdW1lbnRzLlxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlUmVqZWN0QmF0Y2gobG9jYWxTdG9yZSwgYmF0Y2hJZCkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignUmVqZWN0IGJhdGNoJywgJ3JlYWR3cml0ZS1wcmltYXJ5JywgdHhuID0+IHtcbiAgICAgICAgbGV0IGFmZmVjdGVkS2V5cztcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWVcbiAgICAgICAgICAgIC5sb29rdXBNdXRhdGlvbkJhdGNoKHR4biwgYmF0Y2hJZClcbiAgICAgICAgICAgIC5uZXh0KChiYXRjaCkgPT4ge1xuICAgICAgICAgICAgaGFyZEFzc2VydChiYXRjaCAhPT0gbnVsbCwgMHg5MGY5KTtcbiAgICAgICAgICAgIGFmZmVjdGVkS2V5cyA9IGJhdGNoLmtleXMoKTtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLnJlbW92ZU11dGF0aW9uQmF0Y2godHhuLCBiYXRjaCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLnBlcmZvcm1Db25zaXN0ZW5jeUNoZWNrKHR4bikpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5kb2N1bWVudE92ZXJsYXlDYWNoZS5yZW1vdmVPdmVybGF5c0ZvckJhdGNoSWQodHhuLCBhZmZlY3RlZEtleXMsIGJhdGNoSWQpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXNGb3JEb2N1bWVudEtleXModHhuLCBhZmZlY3RlZEtleXMpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0RG9jdW1lbnRzKHR4biwgYWZmZWN0ZWRLZXlzKSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGxhcmdlc3QgKGxhdGVzdCkgYmF0Y2ggaWQgaW4gbXV0YXRpb24gcXVldWUgdGhhdCBpcyBwZW5kaW5nXG4gKiBzZXJ2ZXIgcmVzcG9uc2UuXG4gKlxuICogUmV0dXJucyBgQkFUQ0hJRF9VTktOT1dOYCBpZiB0aGUgcXVldWUgaXMgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXRIaWdoZXN0VW5hY2tub3dsZWRnZWRCYXRjaElkKGxvY2FsU3RvcmUpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCBoaWdoZXN0IHVuYWNrbm93bGVkZ2VkIGJhdGNoIGlkJywgJ3JlYWRvbmx5JywgdHhuID0+IGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUuZ2V0SGlnaGVzdFVuYWNrbm93bGVkZ2VkQmF0Y2hJZCh0eG4pKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBjb25zaXN0ZW50IHNuYXBzaG90IHByb2Nlc3NlZCAodXNlZCBieSB0aGUgUmVtb3RlU3RvcmUgdG9cbiAqIGRldGVybWluZSB3aGV0aGVyIHRvIGJ1ZmZlciBpbmNvbWluZyBzbmFwc2hvdHMgZnJvbSB0aGUgYmFja2VuZCkuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKGxvY2FsU3RvcmUpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCBsYXN0IHJlbW90ZSBzbmFwc2hvdCB2ZXJzaW9uJywgJ3JlYWRvbmx5JywgdHhuID0+IGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlLmdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24odHhuKSk7XG59XG4vKipcbiAqIFVwZGF0ZXMgdGhlIFwiZ3JvdW5kLXN0YXRlXCIgKHJlbW90ZSkgZG9jdW1lbnRzLiBXZSBhc3N1bWUgdGhhdCB0aGUgcmVtb3RlXG4gKiBldmVudCByZWZsZWN0cyBhbnkgd3JpdGUgYmF0Y2hlcyB0aGF0IGhhdmUgYmVlbiBhY2tub3dsZWRnZWQgb3IgcmVqZWN0ZWRcbiAqIChpLmUuIHdlIGRvIG5vdCByZS1hcHBseSBsb2NhbCBtdXRhdGlvbnMgdG8gdXBkYXRlcyBmcm9tIHRoaXMgZXZlbnQpLlxuICpcbiAqIExvY2FsRG9jdW1lbnRzIGFyZSByZS1jYWxjdWxhdGVkIGlmIHRoZXJlIGFyZSByZW1haW5pbmcgbXV0YXRpb25zIGluIHRoZVxuICogcXVldWUuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVBcHBseVJlbW90ZUV2ZW50VG9Mb2NhbENhY2hlKGxvY2FsU3RvcmUsIHJlbW90ZUV2ZW50KSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgcmVtb3RlVmVyc2lvbiA9IHJlbW90ZUV2ZW50LnNuYXBzaG90VmVyc2lvbjtcbiAgICBsZXQgbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0O1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZVxuICAgICAgICAucnVuVHJhbnNhY3Rpb24oJ0FwcGx5IHJlbW90ZSBldmVudCcsICdyZWFkd3JpdGUtcHJpbWFyeScsIHR4biA9PiB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50QnVmZmVyID0gbG9jYWxTdG9yZUltcGwucmVtb3RlRG9jdW1lbnRzLm5ld0NoYW5nZUJ1ZmZlcih7XG4gICAgICAgICAgICB0cmFja1JlbW92YWxzOiB0cnVlIC8vIE1ha2Ugc3VyZSBkb2N1bWVudCByZW1vdmFscyBzaG93IHVwIGluIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlc2V0IG5ld1RhcmdldERhdGFCeVRhcmdldE1hcCBpbiBjYXNlIHRoaXMgdHJhbnNhY3Rpb24gZ2V0cyByZS1ydW4uXG4gICAgICAgIG5ld1RhcmdldERhdGFCeVRhcmdldE1hcCA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldDtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgcmVtb3RlRXZlbnQudGFyZ2V0Q2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UsIHRhcmdldElkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRUYXJnZXREYXRhID0gbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwLmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICBpZiAoIW9sZFRhcmdldERhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgcmVtb3RlIGtleXMgaWYgdGhlIHRhcmdldCBpcyBzdGlsbCBhY3RpdmUuIFRoaXNcbiAgICAgICAgICAgIC8vIGVuc3VyZXMgdGhhdCB3ZSBjYW4gcGVyc2lzdCB0aGUgdXBkYXRlZCB0YXJnZXQgZGF0YSBhbG9uZyB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgdXBkYXRlZCBhc3NpZ25tZW50LlxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxuICAgICAgICAgICAgICAgIC5yZW1vdmVNYXRjaGluZ0tleXModHhuLCBjaGFuZ2UucmVtb3ZlZERvY3VtZW50cywgdGFyZ2V0SWQpXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5hZGRNYXRjaGluZ0tleXModHhuLCBjaGFuZ2UuYWRkZWREb2N1bWVudHMsIHRhcmdldElkKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGxldCBuZXdUYXJnZXREYXRhID0gb2xkVGFyZ2V0RGF0YS53aXRoU2VxdWVuY2VOdW1iZXIodHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlcik7XG4gICAgICAgICAgICBpZiAocmVtb3RlRXZlbnQudGFyZ2V0TWlzbWF0Y2hlcy5nZXQodGFyZ2V0SWQpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3VGFyZ2V0RGF0YSA9IG5ld1RhcmdldERhdGFcbiAgICAgICAgICAgICAgICAgICAgLndpdGhSZXN1bWVUb2tlbihCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HLCBTbmFwc2hvdFZlcnNpb24ubWluKCkpXG4gICAgICAgICAgICAgICAgICAgIC53aXRoTGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbihTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnJlc3VtZVRva2VuLmFwcHJveGltYXRlQnl0ZVNpemUoKSA+IDApIHtcbiAgICAgICAgICAgICAgICBuZXdUYXJnZXREYXRhID0gbmV3VGFyZ2V0RGF0YS53aXRoUmVzdW1lVG9rZW4oY2hhbmdlLnJlc3VtZVRva2VuLCByZW1vdGVWZXJzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1RhcmdldERhdGFCeVRhcmdldE1hcCA9IG5ld1RhcmdldERhdGFCeVRhcmdldE1hcC5pbnNlcnQodGFyZ2V0SWQsIG5ld1RhcmdldERhdGEpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0YXJnZXQgZGF0YSBpZiB0aGVyZSBhcmUgdGFyZ2V0IGNoYW5nZXMgKG9yIGlmXG4gICAgICAgICAgICAvLyBzdWZmaWNpZW50IHRpbWUgaGFzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGUpLlxuICAgICAgICAgICAgaWYgKHNob3VsZFBlcnNpc3RUYXJnZXREYXRhKG9sZFRhcmdldERhdGEsIG5ld1RhcmdldERhdGEsIGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlLnVwZGF0ZVRhcmdldERhdGEodHhuLCBuZXdUYXJnZXREYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgY2hhbmdlZERvY3MgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgbGV0IGV4aXN0ZW5jZUNoYW5nZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgcmVtb3RlRXZlbnQuZG9jdW1lbnRVcGRhdGVzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChyZW1vdGVFdmVudC5yZXNvbHZlZExpbWJvRG9jdW1lbnRzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZS51cGRhdGVMaW1ib0RvY3VtZW50KHR4biwga2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBFYWNoIGxvb3AgaXRlcmF0aW9uIG9ubHkgYWZmZWN0cyBpdHMgXCJvd25cIiBkb2MsIHNvIGl0J3Mgc2FmZSB0byBnZXQgYWxsXG4gICAgICAgIC8vIHRoZSByZW1vdGUgZG9jdW1lbnRzIGluIGFkdmFuY2UgaW4gYSBzaW5nbGUgY2FsbC5cbiAgICAgICAgcHJvbWlzZXMucHVzaChwb3B1bGF0ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHR4biwgZG9jdW1lbnRCdWZmZXIsIHJlbW90ZUV2ZW50LmRvY3VtZW50VXBkYXRlcykubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgY2hhbmdlZERvY3MgPSByZXN1bHQuY2hhbmdlZERvY3VtZW50cztcbiAgICAgICAgICAgIGV4aXN0ZW5jZUNoYW5nZWRLZXlzID0gcmVzdWx0LmV4aXN0ZW5jZUNoYW5nZWRLZXlzO1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIEhBQ0s6IFRoZSBvbmx5IHJlYXNvbiB3ZSBhbGxvdyBhIG51bGwgc25hcHNob3QgdmVyc2lvbiBpcyBzbyB0aGF0IHdlXG4gICAgICAgIC8vIGNhbiBzeW50aGVzaXplIHJlbW90ZSBldmVudHMgd2hlbiB3ZSBnZXQgcGVybWlzc2lvbiBkZW5pZWQgZXJyb3JzIHdoaWxlXG4gICAgICAgIC8vIHRyeWluZyB0byByZXNvbHZlIHRoZSBzdGF0ZSBvZiBhIGxvY2FsbHkgY2FjaGVkIGRvY3VtZW50IHRoYXQgaXMgaW5cbiAgICAgICAgLy8gbGltYm8uXG4gICAgICAgIGlmICghcmVtb3RlVmVyc2lvbi5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVJlbW90ZVZlcnNpb24gPSBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxuICAgICAgICAgICAgICAgIC5nZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKHR4bilcbiAgICAgICAgICAgICAgICAubmV4dChsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuc2V0VGFyZ2V0c01ldGFkYXRhKHR4biwgdHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlciwgcmVtb3RlVmVyc2lvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godXBkYXRlUmVtb3RlVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jdW1lbnRCdWZmZXIuYXBwbHkodHhuKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLmxvY2FsRG9jdW1lbnRzLmdldExvY2FsVmlld09mRG9jdW1lbnRzKHR4biwgY2hhbmdlZERvY3MsIGV4aXN0ZW5jZUNoYW5nZWRLZXlzKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNoYW5nZWREb2NzKTtcbiAgICB9KVxuICAgICAgICAudGhlbihjaGFuZ2VkRG9jcyA9PiB7XG4gICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9IG5ld1RhcmdldERhdGFCeVRhcmdldE1hcDtcbiAgICAgICAgcmV0dXJuIGNoYW5nZWREb2NzO1xuICAgIH0pO1xufVxuLyoqXG4gKiBQb3B1bGF0ZXMgZG9jdW1lbnQgY2hhbmdlIGJ1ZmZlciB3aXRoIGRvY3VtZW50cyBmcm9tIGJhY2tlbmQgb3IgYSBidW5kbGUuXG4gKiBSZXR1cm5zIHRoZSBkb2N1bWVudCBjaGFuZ2VzIHJlc3VsdGluZyBmcm9tIGFwcGx5aW5nIHRob3NlIGRvY3VtZW50cywgYW5kXG4gKiBhbHNvIGEgc2V0IG9mIGRvY3VtZW50cyB3aG9zZSBleGlzdGVuY2Ugc3RhdGUgYXJlIGNoYW5nZWQgYXMgYSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHR4biAtIFRyYW5zYWN0aW9uIHRvIHVzZSB0byByZWFkIGV4aXN0aW5nIGRvY3VtZW50cyBmcm9tIHN0b3JhZ2UuXG4gKiBAcGFyYW0gZG9jdW1lbnRCdWZmZXIgLSBEb2N1bWVudCBidWZmZXIgdG8gY29sbGVjdCB0aGUgcmVzdWx0ZWQgY2hhbmdlcyB0byBiZVxuICogICAgICAgIGFwcGxpZWQgdG8gc3RvcmFnZS5cbiAqIEBwYXJhbSBkb2N1bWVudHMgLSBEb2N1bWVudHMgdG8gYmUgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gcG9wdWxhdGVEb2N1bWVudENoYW5nZUJ1ZmZlcih0eG4sIGRvY3VtZW50QnVmZmVyLCBkb2N1bWVudHMpIHtcbiAgICBsZXQgdXBkYXRlZEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgIGxldCBleGlzdGVuY2VDaGFuZ2VkS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgZG9jdW1lbnRzLmZvckVhY2goayA9PiAodXBkYXRlZEtleXMgPSB1cGRhdGVkS2V5cy5hZGQoaykpKTtcbiAgICByZXR1cm4gZG9jdW1lbnRCdWZmZXIuZ2V0RW50cmllcyh0eG4sIHVwZGF0ZWRLZXlzKS5uZXh0KGV4aXN0aW5nRG9jcyA9PiB7XG4gICAgICAgIGxldCBjaGFuZ2VkRG9jdW1lbnRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIGRvY3VtZW50cy5mb3JFYWNoKChrZXksIGRvYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdEb2MgPSBleGlzdGluZ0RvY3MuZ2V0KGtleSk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBzZWUgaWYgdGhlcmUgaXMgYSBleGlzdGVuY2Ugc3RhdGUgY2hhbmdlIGZvciB0aGlzIGRvY3VtZW50LlxuICAgICAgICAgICAgaWYgKGRvYy5pc0ZvdW5kRG9jdW1lbnQoKSAhPT0gZXhpc3RpbmdEb2MuaXNGb3VuZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgICAgICBleGlzdGVuY2VDaGFuZ2VkS2V5cyA9IGV4aXN0ZW5jZUNoYW5nZWRLZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm90ZTogVGhlIG9yZGVyIG9mIHRoZSBzdGVwcyBiZWxvdyBpcyBpbXBvcnRhbnQsIHNpbmNlIHdlIHdhbnRcbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSB0aGF0IHJlamVjdGVkIGxpbWJvIHJlc29sdXRpb25zICh3aGljaCBmYWJyaWNhdGVcbiAgICAgICAgICAgIC8vIE5vRG9jdW1lbnRzIHdpdGggU25hcHNob3RWZXJzaW9uLm1pbigpKSBuZXZlciBhZGQgZG9jdW1lbnRzIHRvXG4gICAgICAgICAgICAvLyBjYWNoZS5cbiAgICAgICAgICAgIGlmIChkb2MuaXNOb0RvY3VtZW50KCkgJiYgZG9jLnZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XG4gICAgICAgICAgICAgICAgLy8gTm9Eb2N1bWVudHMgd2l0aCBTbmFwc2hvdFZlcnNpb24ubWluKCkgYXJlIHVzZWQgaW4gbWFudWZhY3R1cmVkXG4gICAgICAgICAgICAgICAgLy8gZXZlbnRzLiBXZSByZW1vdmUgdGhlc2UgZG9jdW1lbnRzIGZyb20gY2FjaGUgc2luY2Ugd2UgbG9zdFxuICAgICAgICAgICAgICAgIC8vIGFjY2Vzcy5cbiAgICAgICAgICAgICAgICBkb2N1bWVudEJ1ZmZlci5yZW1vdmVFbnRyeShrZXksIGRvYy5yZWFkVGltZSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZERvY3VtZW50cyA9IGNoYW5nZWREb2N1bWVudHMuaW5zZXJ0KGtleSwgZG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFleGlzdGluZ0RvYy5pc1ZhbGlkRG9jdW1lbnQoKSB8fFxuICAgICAgICAgICAgICAgIGRvYy52ZXJzaW9uLmNvbXBhcmVUbyhleGlzdGluZ0RvYy52ZXJzaW9uKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAoZG9jLnZlcnNpb24uY29tcGFyZVRvKGV4aXN0aW5nRG9jLnZlcnNpb24pID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nRG9jLmhhc1BlbmRpbmdXcml0ZXMpKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRCdWZmZXIuYWRkRW50cnkoZG9jKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkRG9jdW1lbnRzID0gY2hhbmdlZERvY3VtZW50cy5pbnNlcnQoa2V5LCBkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRiLCAnSWdub3Jpbmcgb3V0ZGF0ZWQgd2F0Y2ggdXBkYXRlIGZvciAnLCBrZXksICcuIEN1cnJlbnQgdmVyc2lvbjonLCBleGlzdGluZ0RvYy52ZXJzaW9uLCAnIFdhdGNoIHZlcnNpb246JywgZG9jLnZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlZERvY3VtZW50cywgZXhpc3RlbmNlQ2hhbmdlZEtleXMgfTtcbiAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBuZXdUYXJnZXREYXRhIHNob3VsZCBiZSBwZXJzaXN0ZWQgZHVyaW5nIGFuIHVwZGF0ZSBvZlxuICogYW4gYWN0aXZlIHRhcmdldC4gVGFyZ2V0RGF0YSBzaG91bGQgYWx3YXlzIGJlIHBlcnNpc3RlZCB3aGVuIGEgdGFyZ2V0IGlzXG4gKiBiZWluZyByZWxlYXNlZCBhbmQgc2hvdWxkIG5vdCBjYWxsIHRoaXMgZnVuY3Rpb24uXG4gKlxuICogV2hpbGUgdGhlIHRhcmdldCBpcyBhY3RpdmUsIFRhcmdldERhdGEgdXBkYXRlcyBjYW4gYmUgb21pdHRlZCB3aGVuIG5vdGhpbmdcbiAqIGFib3V0IHRoZSB0YXJnZXQgaGFzIGNoYW5nZWQgZXhjZXB0IG1ldGFkYXRhIGxpa2UgdGhlIHJlc3VtZSB0b2tlbiBvclxuICogc25hcHNob3QgdmVyc2lvbi4gT2NjYXNpb25hbGx5IGl0J3Mgd29ydGggdGhlIGV4dHJhIHdyaXRlIHRvIHByZXZlbnQgdGhlc2VcbiAqIHZhbHVlcyBmcm9tIGdldHRpbmcgdG9vIHN0YWxlIGFmdGVyIGEgY3Jhc2gsIGJ1dCB0aGlzIGRvZXNuJ3QgaGF2ZSB0byBiZVxuICogdG9vIGZyZXF1ZW50LlxuICovXG5mdW5jdGlvbiBzaG91bGRQZXJzaXN0VGFyZ2V0RGF0YShvbGRUYXJnZXREYXRhLCBuZXdUYXJnZXREYXRhLCBjaGFuZ2UpIHtcbiAgICAvLyBBbHdheXMgcGVyc2lzdCB0YXJnZXQgZGF0YSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYSByZXN1bWUgdG9rZW4uXG4gICAgaWYgKG9sZFRhcmdldERhdGEucmVzdW1lVG9rZW4uYXBwcm94aW1hdGVCeXRlU2l6ZSgpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBEb24ndCBhbGxvdyByZXN1bWUgdG9rZW4gY2hhbmdlcyB0byBiZSBidWZmZXJlZCBpbmRlZmluaXRlbHkuIFRoaXNcbiAgICAvLyBhbGxvd3MgdXMgdG8gYmUgcmVhc29uYWJseSB1cC10by1kYXRlIGFmdGVyIGEgY3Jhc2ggYW5kIGF2b2lkcyBuZWVkaW5nXG4gICAgLy8gdG8gbG9vcCBvdmVyIGFsbCBhY3RpdmUgcXVlcmllcyBvbiBzaHV0ZG93bi4gRXNwZWNpYWxseSBpbiB0aGUgYnJvd3NlclxuICAgIC8vIHdlIG1heSBub3QgZ2V0IHRpbWUgdG8gZG8gYW55dGhpbmcgaW50ZXJlc3Rpbmcgd2hpbGUgdGhlIGN1cnJlbnQgdGFiIGlzXG4gICAgLy8gY2xvc2luZy5cbiAgICBjb25zdCB0aW1lRGVsdGEgPSBuZXdUYXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbi50b01pY3Jvc2Vjb25kcygpIC1cbiAgICAgICAgb2xkVGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24udG9NaWNyb3NlY29uZHMoKTtcbiAgICBpZiAodGltZURlbHRhID49IFJFU1VNRV9UT0tFTl9NQVhfQUdFX01JQ1JPUykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlIGlmIHRoZSBvbmx5IHRoaW5nIHRoYXQgaGFzIGNoYW5nZWQgYWJvdXQgYSB0YXJnZXQgaXMgaXRzIHJlc3VtZVxuICAgIC8vIHRva2VuIGl0J3Mgbm90IHdvcnRoIHBlcnNpc3RpbmcuIE5vdGUgdGhhdCB0aGUgUmVtb3RlU3RvcmUga2VlcHMgYW5cbiAgICAvLyBpbi1tZW1vcnkgdmlldyBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSB0YXJnZXRzIHdoaWNoIGluY2x1ZGVzIHRoZSBjdXJyZW50XG4gICAgLy8gcmVzdW1lIHRva2VuLCBzbyBzdHJlYW0gZmFpbHVyZSBvciB1c2VyIGNoYW5nZXMgd2lsbCBzdGlsbCB1c2UgYW5cbiAgICAvLyB1cC10by1kYXRlIHJlc3VtZSB0b2tlbiByZWdhcmRsZXNzIG9mIHdoYXQgd2UgZG8gaGVyZS5cbiAgICBjb25zdCBjaGFuZ2VzID0gY2hhbmdlLmFkZGVkRG9jdW1lbnRzLnNpemUgK1xuICAgICAgICBjaGFuZ2UubW9kaWZpZWREb2N1bWVudHMuc2l6ZSArXG4gICAgICAgIGNoYW5nZS5yZW1vdmVkRG9jdW1lbnRzLnNpemU7XG4gICAgcmV0dXJuIGNoYW5nZXMgPiAwO1xufVxuLyoqXG4gKiBOb3RpZmllcyBsb2NhbCBzdG9yZSBvZiB0aGUgY2hhbmdlZCB2aWV3cyB0byBsb2NhbGx5IHBpbiBkb2N1bWVudHMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvY2FsU3RvcmVOb3RpZnlMb2NhbFZpZXdDaGFuZ2VzKGxvY2FsU3RvcmUsIHZpZXdDaGFuZ2VzKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ25vdGlmeUxvY2FsVmlld0NoYW5nZXMnLCAncmVhZHdyaXRlJywgdHhuID0+IHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh2aWV3Q2hhbmdlcywgKHZpZXdDaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godmlld0NoYW5nZS5hZGRlZEtleXMsIChrZXkpID0+IGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlLmFkZFJlZmVyZW5jZSh0eG4sIHZpZXdDaGFuZ2UudGFyZ2V0SWQsIGtleSkpLm5leHQoKCkgPT4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godmlld0NoYW5nZS5yZW1vdmVkS2V5cywgKGtleSkgPT4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGUucmVtb3ZlUmVmZXJlbmNlKHR4biwgdmlld0NoYW5nZS50YXJnZXRJZCwga2V5KSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XG4gICAgICAgICAgICAvLyBJZiBgbm90aWZ5TG9jYWxWaWV3Q2hhbmdlc2AgZmFpbHMsIHdlIGRpZCBub3QgYWR2YW5jZSB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIC8vIG51bWJlciBmb3IgdGhlIGRvY3VtZW50cyB0aGF0IHdlcmUgaW5jbHVkZWQgaW4gdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgIC8vIFRoaXMgbWlnaHQgdHJpZ2dlciB0aGVtIHRvIGJlIGRlbGV0ZWQgZWFybGllciB0aGFuIHRoZXkgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyB3b3VsZCBoYXZlLCBidXQgaXQgc2hvdWxkIG5vdCBpbnZhbGlkYXRlIHRoZSBpbnRlZ3JpdHkgb2YgdGhlIGRhdGEuXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGIsICdGYWlsZWQgdG8gdXBkYXRlIHNlcXVlbmNlIG51bWJlcnM6ICcgKyBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB2aWV3Q2hhbmdlIG9mIHZpZXdDaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gdmlld0NoYW5nZS50YXJnZXRJZDtcbiAgICAgICAgaWYgKCF2aWV3Q2hhbmdlLmZyb21DYWNoZSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgbGFzdCBsaW1ibyBmcmVlIHNuYXBzaG90IHZlcnNpb25cbiAgICAgICAgICAgIGNvbnN0IGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gPSB0YXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUYXJnZXREYXRhID0gdGFyZ2V0RGF0YS53aXRoTGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbihsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0Lmluc2VydCh0YXJnZXRJZCwgdXBkYXRlZFRhcmdldERhdGEpO1xuICAgICAgICAgICAgLy8gVE9ETyhiLzI3MjU2NDMxNik6IEFwcGx5IHRoZSBvcHRpbWl6YXRpb24gZG9uZSBvbiBvdGhlciBwbGF0Zm9ybXMuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgcHJvYmxlbSBmb3Igd2ViIGJlY2F1c2Ugc2F2aW5nIHRoZSB1cGRhdGVkIHRhcmdldERhdGEgZnJvbVxuICAgICAgICAgICAgLy8gbm9uLXByaW1hcnkgY2xpZW50IGNvbmZsaWN0cyB3aXRoIHdoYXQgcHJpbWFyeSBjbGllbnQgc2F2ZWQuXG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEdldHMgdGhlIG11dGF0aW9uIGJhdGNoIGFmdGVyIHRoZSBwYXNzZWQgaW4gYmF0Y2hJZCBpbiB0aGUgbXV0YXRpb24gcXVldWVcbiAqIG9yIG51bGwgaWYgZW1wdHkuXG4gKiBAcGFyYW0gYWZ0ZXJCYXRjaElkIC0gSWYgcHJvdmlkZWQsIHRoZSBiYXRjaCB0byBzZWFyY2ggYWZ0ZXIuXG4gKiBAcmV0dXJucyBUaGUgbmV4dCBtdXRhdGlvbiBvciBudWxsIGlmIHRoZXJlIHdhc24ndCBvbmUuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXROZXh0TXV0YXRpb25CYXRjaChsb2NhbFN0b3JlLCBhZnRlckJhdGNoSWQpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCBuZXh0IG11dGF0aW9uIGJhdGNoJywgJ3JlYWRvbmx5JywgdHhuID0+IHtcbiAgICAgICAgaWYgKGFmdGVyQmF0Y2hJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhZnRlckJhdGNoSWQgPSBCQVRDSElEX1VOS05PV047XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUuZ2V0TmV4dE11dGF0aW9uQmF0Y2hBZnRlckJhdGNoSWQodHhuLCBhZnRlckJhdGNoSWQpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZWFkcyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIERvY3VtZW50IHdpdGggYSBnaXZlbiBrZXkgb3IgbnVsbCBpZiBub3RcbiAqIGZvdW5kIC0gdXNlZCBmb3IgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yZVJlYWREb2N1bWVudChsb2NhbFN0b3JlLCBrZXkpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ3JlYWQgZG9jdW1lbnQnLCAncmVhZG9ubHknLCB0eG4gPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0RG9jdW1lbnQodHhuLCBrZXkpKTtcbn1cbi8qKlxuICogQXNzaWducyB0aGUgZ2l2ZW4gdGFyZ2V0IGFuIGludGVybmFsIElEIHNvIHRoYXQgaXRzIHJlc3VsdHMgY2FuIGJlIHBpbm5lZCBzb1xuICogdGhleSBkb24ndCBnZXQgR0MnZC4gQSB0YXJnZXQgbXVzdCBiZSBhbGxvY2F0ZWQgaW4gdGhlIGxvY2FsIHN0b3JlIGJlZm9yZVxuICogdGhlIHN0b3JlIGNhbiBiZSB1c2VkIHRvIG1hbmFnZSBpdHMgdmlldy5cbiAqXG4gKiBBbGxvY2F0aW5nIGFuIGFscmVhZHkgYWxsb2NhdGVkIGBUYXJnZXRgIHdpbGwgcmV0dXJuIHRoZSBleGlzdGluZyBgVGFyZ2V0RGF0YWBcbiAqIGZvciB0aGF0IGBUYXJnZXRgLlxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlQWxsb2NhdGVUYXJnZXQobG9jYWxTdG9yZSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlXG4gICAgICAgIC5ydW5UcmFuc2FjdGlvbignQWxsb2NhdGUgdGFyZ2V0JywgJ3JlYWR3cml0ZScsIHR4biA9PiB7XG4gICAgICAgIGxldCB0YXJnZXREYXRhO1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcbiAgICAgICAgICAgIC5nZXRUYXJnZXREYXRhKHR4biwgdGFyZ2V0KVxuICAgICAgICAgICAgLm5leHQoKGNhY2hlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgdGFyZ2V0IGhhcyBiZWVuIGxpc3RlbmVkIHRvIHByZXZpb3VzbHksIHNvIHJldXNlIHRoZVxuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIHRhcmdldElELlxuICAgICAgICAgICAgICAgIC8vIFRPRE8obWNnKTogZnJlc2hlbiBsYXN0IGFjY2Vzc2VkIGRhdGU/XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGF0YSA9IGNhY2hlZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGFyZ2V0RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgLmFsbG9jYXRlVGFyZ2V0SWQodHhuKVxuICAgICAgICAgICAgICAgICAgICAubmV4dCh0YXJnZXRJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldERhdGEgPSBuZXcgVGFyZ2V0RGF0YSh0YXJnZXQsIHRhcmdldElkLCBcIlRhcmdldFB1cnBvc2VMaXN0ZW5cIiAvKiBUYXJnZXRQdXJwb3NlLkxpc3RlbiAqLywgdHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZFRhcmdldERhdGEodHhuLCB0YXJnZXREYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gdGFyZ2V0RGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgICAgIC50aGVuKHRhcmdldERhdGEgPT4ge1xuICAgICAgICAvLyBJZiBNdWx0aS1UYWIgaXMgZW5hYmxlZCwgdGhlIGV4aXN0aW5nIHRhcmdldCBkYXRhIG1heSBiZSBuZXdlciB0aGFuXG4gICAgICAgIC8vIHRoZSBpbi1tZW1vcnkgZGF0YVxuICAgICAgICBjb25zdCBjYWNoZWRUYXJnZXREYXRhID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0LmdldCh0YXJnZXREYXRhLnRhcmdldElkKTtcbiAgICAgICAgaWYgKGNhY2hlZFRhcmdldERhdGEgPT09IG51bGwgfHxcbiAgICAgICAgICAgIHRhcmdldERhdGEuc25hcHNob3RWZXJzaW9uLmNvbXBhcmVUbyhjYWNoZWRUYXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbikgPlxuICAgICAgICAgICAgICAgIDApIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0Lmluc2VydCh0YXJnZXREYXRhLnRhcmdldElkLCB0YXJnZXREYXRhKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldElkQnlUYXJnZXQuc2V0KHRhcmdldCwgdGFyZ2V0RGF0YS50YXJnZXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldERhdGE7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIFRhcmdldERhdGEgYXMgc2VlbiBieSB0aGUgTG9jYWxTdG9yZSwgaW5jbHVkaW5nIHVwZGF0ZXMgdGhhdCBtYXlcbiAqIGhhdmUgbm90IHlldCBiZWVuIHBlcnNpc3RlZCB0byB0aGUgVGFyZ2V0Q2FjaGUuXG4gKi9cbi8vIFZpc2libGUgZm9yIHRlc3RpbmcuXG5mdW5jdGlvbiBsb2NhbFN0b3JlR2V0VGFyZ2V0RGF0YShsb2NhbFN0b3JlLCB0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgdGFyZ2V0SWQgPSBsb2NhbFN0b3JlSW1wbC50YXJnZXRJZEJ5VGFyZ2V0LmdldCh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuZ2V0KHRhcmdldElkKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuZ2V0VGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0KTtcbiAgICB9XG59XG4vKipcbiAqIFVucGlucyBhbGwgdGhlIGRvY3VtZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHRhcmdldC4gSWZcbiAqIGBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YWAgaXMgc2V0IHRvIGZhbHNlIGFuZCBFYWdlciBHQyBlbmFibGVkLCB0aGUgbWV0aG9kXG4gKiBkaXJlY3RseSByZW1vdmVzIHRoZSBhc3NvY2lhdGVkIHRhcmdldCBkYXRhIGZyb20gdGhlIHRhcmdldCBjYWNoZS5cbiAqXG4gKiBSZWxlYXNpbmcgYSBub24tZXhpc3RpbmcgYFRhcmdldGAgaXMgYSBuby1vcC5cbiAqL1xuLy8gUE9SVElORyBOT1RFOiBga2VlcFBlcnNpc3RlZFRhcmdldERhdGFgIGlzIG11bHRpLXRhYiBvbmx5LlxuYXN5bmMgZnVuY3Rpb24gbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQobG9jYWxTdG9yZSwgdGFyZ2V0SWQsIGtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgdGFyZ2V0RGF0YSA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xuICAgIGNvbnN0IG1vZGUgPSBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YSA/ICdyZWFkd3JpdGUnIDogJ3JlYWR3cml0ZS1wcmltYXJ5JztcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhKSB7XG4gICAgICAgICAgICBhd2FpdCBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignUmVsZWFzZSB0YXJnZXQnLCBtb2RlLCB0eG4gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZS5yZW1vdmVUYXJnZXQodHhuLCB0YXJnZXREYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcbiAgICAgICAgICAgIC8vIEFsbCBgcmVsZWFzZVRhcmdldGAgZG9lcyBpcyByZWNvcmQgdGhlIGZpbmFsIG1ldGFkYXRhIHN0YXRlIGZvciB0aGVcbiAgICAgICAgICAgIC8vIHRhcmdldCwgYnV0IHdlJ3ZlIGJlZW4gcmVjb3JkaW5nIHRoaXMgcGVyaW9kaWNhbGx5IGR1cmluZyB0YXJnZXRcbiAgICAgICAgICAgIC8vIGFjdGl2aXR5LiBJZiB3ZSBsb3NlIHRoaXMgd3JpdGUgdGhpcyBjb3VsZCBjYXVzZSBhIHZlcnkgc2xpZ2h0XG4gICAgICAgICAgICAvLyBkaWZmZXJlbmNlIGluIHRoZSBvcmRlciBvZiB0YXJnZXQgZGVsZXRpb24gZHVyaW5nIEdDLCBidXQgd2VcbiAgICAgICAgICAgIC8vIGRvbid0IGRlZmluZSBleGFjdCBMUlUgc2VtYW50aWNzIHNvIHRoaXMgaXMgYWNjZXB0YWJsZS5cbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckYiwgYEZhaWxlZCB0byB1cGRhdGUgc2VxdWVuY2UgbnVtYmVycyBmb3IgdGFyZ2V0ICR7dGFyZ2V0SWR9OiAke2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9XG4gICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5yZW1vdmUodGFyZ2V0SWQpO1xuICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldElkQnlUYXJnZXQuZGVsZXRlKHRhcmdldERhdGEudGFyZ2V0KTtcbn1cbi8qKlxuICogUnVucyB0aGUgc3BlY2lmaWVkIHF1ZXJ5IGFnYWluc3QgdGhlIGxvY2FsIHN0b3JlIGFuZCByZXR1cm5zIHRoZSByZXN1bHRzLFxuICogcG90ZW50aWFsbHkgdGFraW5nIGFkdmFudGFnZSBvZiBxdWVyeSBkYXRhIGZyb20gcHJldmlvdXMgZXhlY3V0aW9ucyAoc3VjaFxuICogYXMgdGhlIHNldCBvZiByZW1vdGUga2V5cykuXG4gKlxuICogQHBhcmFtIHVzZVByZXZpb3VzUmVzdWx0cyAtIFdoZXRoZXIgcmVzdWx0cyBmcm9tIHByZXZpb3VzIGV4ZWN1dGlvbnMgY2FuXG4gKiBiZSB1c2VkIHRvIG9wdGltaXplIHRoaXMgcXVlcnkgZXhlY3V0aW9uLlxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlRXhlY3V0ZVF1ZXJ5KGxvY2FsU3RvcmUsIHF1ZXJ5LCB1c2VQcmV2aW91c1Jlc3VsdHMpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBsZXQgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiA9IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICBsZXQgcmVtb3RlS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdFeGVjdXRlIHF1ZXJ5JywgJ3JlYWR3cml0ZScsIC8vIFVzZSByZWFkd3JpdGUgaW5zdGVhZCBvZiByZWFkb25seSBzbyBpbmRleGVzIGNhbiBiZSBjcmVhdGVkXG4gICAgLy8gVXNlIHJlYWR3cml0ZSBpbnN0ZWFkIG9mIHJlYWRvbmx5IHNvIGluZGV4ZXMgY2FuIGJlIGNyZWF0ZWRcbiAgICB0eG4gPT4ge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUdldFRhcmdldERhdGEobG9jYWxTdG9yZUltcGwsIHR4biwgcXVlcnlUb1RhcmdldChxdWVyeSkpXG4gICAgICAgICAgICAubmV4dCh0YXJnZXREYXRhID0+IHtcbiAgICAgICAgICAgIGlmICh0YXJnZXREYXRhKSB7XG4gICAgICAgICAgICAgICAgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiA9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldERhdGEubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgLmdldE1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0RGF0YS50YXJnZXRJZClcbiAgICAgICAgICAgICAgICAgICAgLm5leHQocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlS2V5cyA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLnF1ZXJ5RW5naW5lLmdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHhuLCBxdWVyeSwgdXNlUHJldmlvdXNSZXN1bHRzXG4gICAgICAgICAgICA/IGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb25cbiAgICAgICAgICAgIDogU25hcHNob3RWZXJzaW9uLm1pbigpLCB1c2VQcmV2aW91c1Jlc3VsdHMgPyByZW1vdGVLZXlzIDogZG9jdW1lbnRLZXlTZXQoKSkpXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudHMgPT4ge1xuICAgICAgICAgICAgc2V0TWF4UmVhZFRpbWUobG9jYWxTdG9yZUltcGwsIHF1ZXJ5Q29sbGVjdGlvbkdyb3VwKHF1ZXJ5KSwgZG9jdW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRvY3VtZW50cywgcmVtb3RlS2V5cyB9O1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFwcGx5V3JpdGVUb1JlbW90ZURvY3VtZW50cyhsb2NhbFN0b3JlSW1wbCwgdHhuLCBiYXRjaFJlc3VsdCwgZG9jdW1lbnRCdWZmZXIpIHtcbiAgICBjb25zdCBiYXRjaCA9IGJhdGNoUmVzdWx0LmJhdGNoO1xuICAgIGNvbnN0IGRvY0tleXMgPSBiYXRjaC5rZXlzKCk7XG4gICAgbGV0IHByb21pc2VDaGFpbiA9IFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgZG9jS2V5cy5mb3JFYWNoKGRvY0tleSA9PiB7XG4gICAgICAgIHByb21pc2VDaGFpbiA9IHByb21pc2VDaGFpblxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jdW1lbnRCdWZmZXIuZ2V0RW50cnkodHhuLCBkb2NLZXkpKVxuICAgICAgICAgICAgLm5leHQoZG9jID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFja1ZlcnNpb24gPSBiYXRjaFJlc3VsdC5kb2NWZXJzaW9ucy5nZXQoZG9jS2V5KTtcbiAgICAgICAgICAgIGhhcmRBc3NlcnQoYWNrVmVyc2lvbiAhPT0gbnVsbCwgMHhiZDlkKTtcbiAgICAgICAgICAgIGlmIChkb2MudmVyc2lvbi5jb21wYXJlVG8oYWNrVmVyc2lvbikgPCAwKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2guYXBwbHlUb1JlbW90ZURvY3VtZW50KGRvYywgYmF0Y2hSZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChkb2MuaXNWYWxpZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdXNlIHRoZSBjb21taXRWZXJzaW9uIGFzIHRoZSByZWFkVGltZSByYXRoZXIgdGhhbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9jdW1lbnQncyB1cGRhdGVUaW1lIHNpbmNlIHRoZSB1cGRhdGVUaW1lIGlzIG5vdCBhZHZhbmNlZFxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdXBkYXRlcyB0aGF0IGRvIG5vdCBtb2RpZnkgdGhlIHVuZGVybHlpbmcgZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGRvYy5zZXRSZWFkVGltZShiYXRjaFJlc3VsdC5jb21taXRWZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRCdWZmZXIuYWRkRW50cnkoZG9jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlQ2hhaW4ubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLnJlbW92ZU11dGF0aW9uQmF0Y2godHhuLCBiYXRjaCkpO1xufVxuLyoqIFJldHVybnMgdGhlIGxvY2FsIHZpZXcgb2YgdGhlIGRvY3VtZW50cyBhZmZlY3RlZCBieSBhIG11dGF0aW9uIGJhdGNoLiAqL1xuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmZ1bmN0aW9uIGxvY2FsU3RvcmVMb29rdXBNdXRhdGlvbkRvY3VtZW50cyhsb2NhbFN0b3JlLCBiYXRjaElkKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgbXV0YXRpb25RdWV1ZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdMb29rdXAgbXV0YXRpb24gZG9jdW1lbnRzJywgJ3JlYWRvbmx5JywgdHhuID0+IHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uUXVldWVJbXBsLmxvb2t1cE11dGF0aW9uS2V5cyh0eG4sIGJhdGNoSWQpLm5leHQoa2V5cyA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50cy5nZXREb2N1bWVudHModHhuLCBrZXlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuZnVuY3Rpb24gbG9jYWxTdG9yZVJlbW92ZUNhY2hlZE11dGF0aW9uQmF0Y2hNZXRhZGF0YShsb2NhbFN0b3JlLCBiYXRjaElkKSB7XG4gICAgY29uc3QgbXV0YXRpb25RdWV1ZUltcGwgPSBkZWJ1Z0Nhc3QoZGVidWdDYXN0KGxvY2FsU3RvcmUsIExvY2FsU3RvcmVJbXBsKS5tdXRhdGlvblF1ZXVlKTtcbiAgICBtdXRhdGlvblF1ZXVlSW1wbC5yZW1vdmVDYWNoZWRNdXRhdGlvbktleXMoYmF0Y2hJZCk7XG59XG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuZnVuY3Rpb24gbG9jYWxTdG9yZUdldEFjdGl2ZUNsaWVudHMobG9jYWxTdG9yZSkge1xuICAgIGNvbnN0IHBlcnNpc3RlbmNlSW1wbCA9IGRlYnVnQ2FzdChkZWJ1Z0Nhc3QobG9jYWxTdG9yZSwgTG9jYWxTdG9yZUltcGwpLnBlcnNpc3RlbmNlKTtcbiAgICByZXR1cm4gcGVyc2lzdGVuY2VJbXBsLmdldEFjdGl2ZUNsaWVudHMoKTtcbn1cbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXG5mdW5jdGlvbiBsb2NhbFN0b3JlR2V0Q2FjaGVkVGFyZ2V0KGxvY2FsU3RvcmUsIHRhcmdldElkKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgdGFyZ2V0Q2FjaGVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlKTtcbiAgICBjb25zdCBjYWNoZWRUYXJnZXREYXRhID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgaWYgKGNhY2hlZFRhcmdldERhdGEpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZWRUYXJnZXREYXRhLnRhcmdldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCB0YXJnZXQgZGF0YScsICdyZWFkb25seScsIHR4biA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0Q2FjaGVJbXBsXG4gICAgICAgICAgICAgICAgLmdldFRhcmdldERhdGFGb3JUYXJnZXQodHhuLCB0YXJnZXRJZClcbiAgICAgICAgICAgICAgICAubmV4dCh0YXJnZXREYXRhID0+ICh0YXJnZXREYXRhID8gdGFyZ2V0RGF0YS50YXJnZXQgOiBudWxsKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0aGUgc2V0IG9mIGRvY3VtZW50cyB0aGF0IGhhdmUgYmVlbiB1cGRhdGVkIHNpbmNlIHRoZSBsYXN0IGNhbGwuXG4gKiBJZiB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCByZXR1cm5zIHRoZSBzZXQgb2YgY2hhbmdlcyBzaW5jZSBjbGllbnRcbiAqIGluaXRpYWxpemF0aW9uLiBGdXJ0aGVyIGludm9jYXRpb25zIHdpbGwgcmV0dXJuIGRvY3VtZW50IHRoYXQgaGF2ZSBjaGFuZ2VkXG4gKiBzaW5jZSB0aGUgcHJpb3IgY2FsbC5cbiAqL1xuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXROZXdEb2N1bWVudENoYW5nZXMobG9jYWxTdG9yZSwgY29sbGVjdGlvbkdyb3VwKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IG1heGltdW0gcmVhZCB0aW1lIGZvciB0aGUgY29sbGVjdGlvbi4gVGhpcyBzaG91bGQgYWx3YXlzXG4gICAgLy8gZXhpc3QsIGJ1dCB0byByZWR1Y2UgdGhlIGNoYW5jZSBmb3IgcmVncmVzc2lvbnMgd2UgZGVmYXVsdCB0b1xuICAgIC8vIFNuYXBzaG90VmVyc2lvbi5NaW4oKVxuICAgIC8vIFRPRE8oaW5kZXhpbmcpOiBDb25zaWRlciByZW1vdmluZyB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICBjb25zdCByZWFkVGltZSA9IGxvY2FsU3RvcmVJbXBsLmNvbGxlY3Rpb25Hcm91cFJlYWRUaW1lLmdldChjb2xsZWN0aW9uR3JvdXApIHx8XG4gICAgICAgIFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2VcbiAgICAgICAgLnJ1blRyYW5zYWN0aW9uKCdHZXQgbmV3IGRvY3VtZW50IGNoYW5nZXMnLCAncmVhZG9ubHknLCB0eG4gPT4gbG9jYWxTdG9yZUltcGwucmVtb3RlRG9jdW1lbnRzLmdldEFsbEZyb21Db2xsZWN0aW9uR3JvdXAodHhuLCBjb2xsZWN0aW9uR3JvdXAsIG5ld0luZGV4T2Zmc2V0U3VjY2Vzc29yRnJvbVJlYWRUaW1lKHJlYWRUaW1lLCBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQpLCBcbiAgICAvKiBsaW1pdD0gKi8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKVxuICAgICAgICAudGhlbihjaGFuZ2VkRG9jcyA9PiB7XG4gICAgICAgIHNldE1heFJlYWRUaW1lKGxvY2FsU3RvcmVJbXBsLCBjb2xsZWN0aW9uR3JvdXAsIGNoYW5nZWREb2NzKTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZWREb2NzO1xuICAgIH0pO1xufVxuLyoqIFNldHMgdGhlIGNvbGxlY3Rpb24gZ3JvdXAncyBtYXhpbXVtIHJlYWQgdGltZSBmcm9tIHRoZSBnaXZlbiBkb2N1bWVudHMuICovXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuZnVuY3Rpb24gc2V0TWF4UmVhZFRpbWUobG9jYWxTdG9yZUltcGwsIGNvbGxlY3Rpb25Hcm91cCwgY2hhbmdlZERvY3MpIHtcbiAgICBsZXQgcmVhZFRpbWUgPSBsb2NhbFN0b3JlSW1wbC5jb2xsZWN0aW9uR3JvdXBSZWFkVGltZS5nZXQoY29sbGVjdGlvbkdyb3VwKSB8fFxuICAgICAgICBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgY2hhbmdlZERvY3MuZm9yRWFjaCgoXywgZG9jKSA9PiB7XG4gICAgICAgIGlmIChkb2MucmVhZFRpbWUuY29tcGFyZVRvKHJlYWRUaW1lKSA+IDApIHtcbiAgICAgICAgICAgIHJlYWRUaW1lID0gZG9jLnJlYWRUaW1lO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbG9jYWxTdG9yZUltcGwuY29sbGVjdGlvbkdyb3VwUmVhZFRpbWUuc2V0KGNvbGxlY3Rpb25Hcm91cCwgcmVhZFRpbWUpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHRhcmdldCB1c2luZyB0aGUgZ2l2ZW4gYnVuZGxlIG5hbWUsIHdoaWNoIHdpbGwgYmUgdXNlZCB0b1xuICogaG9sZCB0aGUga2V5cyBvZiBhbGwgZG9jdW1lbnRzIGZyb20gdGhlIGJ1bmRsZSBpbiBxdWVyeS1kb2N1bWVudCBtYXBwaW5ncy5cbiAqIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBsb2FkZWQgZG9jdW1lbnRzIGRvIG5vdCBnZXQgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAqIHJpZ2h0IGF3YXkuXG4gKi9cbmZ1bmN0aW9uIHVtYnJlbGxhVGFyZ2V0KGJ1bmRsZU5hbWUpIHtcbiAgICAvLyBJdCBpcyBPSyB0aGF0IHRoZSBwYXRoIHVzZWQgZm9yIHRoZSBxdWVyeSBpcyBub3QgdmFsaWQsIGJlY2F1c2UgdGhpcyB3aWxsXG4gICAgLy8gbm90IGJlIHJlYWQgYW5kIHF1ZXJpZWQuXG4gICAgcmV0dXJuIHF1ZXJ5VG9UYXJnZXQobmV3UXVlcnlGb3JQYXRoKFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKGBfX2J1bmRsZV9fL2RvY3MvJHtidW5kbGVOYW1lfWApKSk7XG59XG4vKipcbiAqIEFwcGxpZXMgdGhlIGRvY3VtZW50cyBmcm9tIGEgYnVuZGxlIHRvIHRoZSBcImdyb3VuZC1zdGF0ZVwiIChyZW1vdGUpXG4gKiBkb2N1bWVudHMuXG4gKlxuICogTG9jYWxEb2N1bWVudHMgYXJlIHJlLWNhbGN1bGF0ZWQgaWYgdGhlcmUgYXJlIHJlbWFpbmluZyBtdXRhdGlvbnMgaW4gdGhlXG4gKiBxdWV1ZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9jYWxTdG9yZUFwcGx5QnVuZGxlZERvY3VtZW50cyhsb2NhbFN0b3JlLCBidW5kbGVDb252ZXJ0ZXIsIGRvY3VtZW50cywgYnVuZGxlTmFtZSkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIGxldCBkb2N1bWVudEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgIGxldCBkb2N1bWVudE1hcCA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xuICAgIGZvciAoY29uc3QgYnVuZGxlRG9jIG9mIGRvY3VtZW50cykge1xuICAgICAgICBjb25zdCBkb2N1bWVudEtleSA9IGJ1bmRsZUNvbnZlcnRlci50b0RvY3VtZW50S2V5KGJ1bmRsZURvYy5tZXRhZGF0YS5uYW1lKTtcbiAgICAgICAgaWYgKGJ1bmRsZURvYy5kb2N1bWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnRLZXlzID0gZG9jdW1lbnRLZXlzLmFkZChkb2N1bWVudEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9jID0gYnVuZGxlQ29udmVydGVyLnRvTXV0YWJsZURvY3VtZW50KGJ1bmRsZURvYyk7XG4gICAgICAgIGRvYy5zZXRSZWFkVGltZShidW5kbGVDb252ZXJ0ZXIudG9TbmFwc2hvdFZlcnNpb24oYnVuZGxlRG9jLm1ldGFkYXRhLnJlYWRUaW1lKSk7XG4gICAgICAgIGRvY3VtZW50TWFwID0gZG9jdW1lbnRNYXAuaW5zZXJ0KGRvY3VtZW50S2V5LCBkb2MpO1xuICAgIH1cbiAgICBjb25zdCBkb2N1bWVudEJ1ZmZlciA9IGxvY2FsU3RvcmVJbXBsLnJlbW90ZURvY3VtZW50cy5uZXdDaGFuZ2VCdWZmZXIoe1xuICAgICAgICB0cmFja1JlbW92YWxzOiB0cnVlIC8vIE1ha2Ugc3VyZSBkb2N1bWVudCByZW1vdmFscyBzaG93IHVwIGluIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWBcbiAgICB9KTtcbiAgICAvLyBBbGxvY2F0ZXMgYSB0YXJnZXQgdG8gaG9sZCBhbGwgZG9jdW1lbnQga2V5cyBmcm9tIHRoZSBidW5kbGUsIHN1Y2ggdGhhdFxuICAgIC8vIHRoZXkgd2lsbCBub3QgZ2V0IGdhcmJhZ2UgY29sbGVjdGVkIHJpZ2h0IGF3YXkuXG4gICAgY29uc3QgdW1icmVsbGFUYXJnZXREYXRhID0gYXdhaXQgbG9jYWxTdG9yZUFsbG9jYXRlVGFyZ2V0KGxvY2FsU3RvcmVJbXBsLCB1bWJyZWxsYVRhcmdldChidW5kbGVOYW1lKSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdBcHBseSBidW5kbGUgZG9jdW1lbnRzJywgJ3JlYWR3cml0ZScsIHR4biA9PiB7XG4gICAgICAgIHJldHVybiBwb3B1bGF0ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHR4biwgZG9jdW1lbnRCdWZmZXIsIGRvY3VtZW50TWFwKVxuICAgICAgICAgICAgLm5leHQoZG9jdW1lbnRDaGFuZ2VSZXN1bHQgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnRCdWZmZXIuYXBwbHkodHhuKTtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudENoYW5nZVJlc3VsdDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KGRvY3VtZW50Q2hhbmdlUmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxuICAgICAgICAgICAgICAgIC5yZW1vdmVNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0eG4sIHVtYnJlbGxhVGFyZ2V0RGF0YS50YXJnZXRJZClcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5hZGRNYXRjaGluZ0tleXModHhuLCBkb2N1bWVudEtleXMsIHVtYnJlbGxhVGFyZ2V0RGF0YS50YXJnZXRJZCkpXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0TG9jYWxWaWV3T2ZEb2N1bWVudHModHhuLCBkb2N1bWVudENoYW5nZVJlc3VsdC5jaGFuZ2VkRG9jdW1lbnRzLCBkb2N1bWVudENoYW5nZVJlc3VsdC5leGlzdGVuY2VDaGFuZ2VkS2V5cykpXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jdW1lbnRDaGFuZ2VSZXN1bHQuY2hhbmdlZERvY3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBvZiBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgaWYgdGhlIGdpdmVuIGJ1bmRsZSBoYXMgYWxyZWFkeVxuICogYmVlbiBsb2FkZWQgYW5kIHRoZSBjcmVhdGUgdGltZSBpcyBuZXdlciB0aGFuIHRoZSBjdXJyZW50IGxvYWRpbmcgYnVuZGxlLlxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlSGFzTmV3ZXJCdW5kbGUobG9jYWxTdG9yZSwgYnVuZGxlTWV0YWRhdGEpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBjb25zdCBjdXJyZW50UmVhZFRpbWUgPSBmcm9tVmVyc2lvbihidW5kbGVNZXRhZGF0YS5jcmVhdGVUaW1lKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2VcbiAgICAgICAgLnJ1blRyYW5zYWN0aW9uKCdoYXNOZXdlckJ1bmRsZScsICdyZWFkb25seScsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLmJ1bmRsZUNhY2hlLmdldEJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVNZXRhZGF0YS5pZCk7XG4gICAgfSlcbiAgICAgICAgLnRoZW4oY2FjaGVkID0+IHtcbiAgICAgICAgcmV0dXJuICEhY2FjaGVkICYmIGNhY2hlZC5jcmVhdGVUaW1lLmNvbXBhcmVUbyhjdXJyZW50UmVhZFRpbWUpID49IDA7XG4gICAgfSk7XG59XG4vKipcbiAqIFNhdmVzIHRoZSBnaXZlbiBgQnVuZGxlTWV0YWRhdGFgIHRvIGxvY2FsIHBlcnNpc3RlbmNlLlxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlU2F2ZUJ1bmRsZShsb2NhbFN0b3JlLCBidW5kbGVNZXRhZGF0YSkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignU2F2ZSBidW5kbGUnLCAncmVhZHdyaXRlJywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwuYnVuZGxlQ2FjaGUuc2F2ZUJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVNZXRhZGF0YSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIG9mIGEgYE5hbWVkUXVlcnlgIGFzc29jaWF0ZWQgd2l0aCBnaXZlbiBxdWVyeSBuYW1lLiBQcm9taXNlXG4gKiByZXNvbHZlcyB0byB1bmRlZmluZWQgaWYgbm8gcGVyc2lzdGVkIGRhdGEgY2FuIGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlR2V0TmFtZWRRdWVyeShsb2NhbFN0b3JlLCBxdWVyeU5hbWUpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCBuYW1lZCBxdWVyeScsICdyZWFkb25seScsIHRyYW5zYWN0aW9uID0+IGxvY2FsU3RvcmVJbXBsLmJ1bmRsZUNhY2hlLmdldE5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5TmFtZSkpO1xufVxuLyoqXG4gKiBTYXZlcyB0aGUgZ2l2ZW4gYE5hbWVkUXVlcnlgIHRvIGxvY2FsIHBlcnNpc3RlbmNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBsb2NhbFN0b3JlU2F2ZU5hbWVkUXVlcnkobG9jYWxTdG9yZSwgcXVlcnksIGRvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCkpIHtcbiAgICAvLyBBbGxvY2F0ZSBhIHRhcmdldCBmb3IgdGhlIG5hbWVkIHF1ZXJ5IHN1Y2ggdGhhdCBpdCBjYW4gYmUgcmVzdW1lZFxuICAgIC8vIGZyb20gYXNzb2NpYXRlZCByZWFkIHRpbWUgaWYgdXNlcnMgdXNlIGl0IHRvIGxpc3Rlbi5cbiAgICAvLyBOT1RFOiB0aGlzIGFsc28gbWVhbnMgaWYgbm8gY29ycmVzcG9uZGluZyB0YXJnZXQgZXhpc3RzLCB0aGUgbmV3IHRhcmdldFxuICAgIC8vIHdpbGwgcmVtYWluIGFjdGl2ZSBhbmQgd2lsbCBub3QgZ2V0IGNvbGxlY3RlZCwgdW5sZXNzIHVzZXJzIGhhcHBlbiB0b1xuICAgIC8vIHVubGlzdGVuIHRoZSBxdWVyeSBzb21laG93LlxuICAgIGNvbnN0IGFsbG9jYXRlZCA9IGF3YWl0IGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChsb2NhbFN0b3JlLCBxdWVyeVRvVGFyZ2V0KGZyb21CdW5kbGVkUXVlcnkocXVlcnkuYnVuZGxlZFF1ZXJ5KSkpO1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignU2F2ZSBuYW1lZCBxdWVyeScsICdyZWFkd3JpdGUnLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRUaW1lID0gZnJvbVZlcnNpb24ocXVlcnkucmVhZFRpbWUpO1xuICAgICAgICAvLyBTaW1wbHkgc2F2ZSB0aGUgcXVlcnkgaXRzZWxmIGlmIGl0IGlzIG9sZGVyIHRoYW4gd2hhdCB0aGUgU0RLIGFscmVhZHlcbiAgICAgICAgLy8gaGFzLlxuICAgICAgICBpZiAoYWxsb2NhdGVkLnNuYXBzaG90VmVyc2lvbi5jb21wYXJlVG8ocmVhZFRpbWUpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5idW5kbGVDYWNoZS5zYXZlTmFtZWRRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyB0YXJnZXQgZGF0YSBiZWNhdXNlIHRoZSBxdWVyeSBmcm9tIHRoZSBidW5kbGUgaXMgbmV3ZXIuXG4gICAgICAgIGNvbnN0IG5ld1RhcmdldERhdGEgPSBhbGxvY2F0ZWQud2l0aFJlc3VtZVRva2VuKEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcsIHJlYWRUaW1lKTtcbiAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0ID1cbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5pbnNlcnQobmV3VGFyZ2V0RGF0YS50YXJnZXRJZCwgbmV3VGFyZ2V0RGF0YSk7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxuICAgICAgICAgICAgLnVwZGF0ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIG5ld1RhcmdldERhdGEpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5yZW1vdmVNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0cmFuc2FjdGlvbiwgYWxsb2NhdGVkLnRhcmdldElkKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlLmFkZE1hdGNoaW5nS2V5cyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRzLCBhbGxvY2F0ZWQudGFyZ2V0SWQpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwuYnVuZGxlQ2FjaGUuc2F2ZU5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KSk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2NhbFN0b3JlQ29uZmlndXJlRmllbGRJbmRleGVzKGxvY2FsU3RvcmUsIG5ld0ZpZWxkSW5kZXhlcykge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIGNvbnN0IGluZGV4TWFuYWdlciA9IGxvY2FsU3RvcmVJbXBsLmluZGV4TWFuYWdlcjtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignQ29uZmlndXJlIGluZGV4ZXMnLCAncmVhZHdyaXRlJywgdHJhbnNhY3Rpb24gPT4gaW5kZXhNYW5hZ2VyXG4gICAgICAgIC5nZXRGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24pXG4gICAgICAgIC5uZXh0KG9sZEZpZWxkSW5kZXhlcyA9PiBkaWZmQXJyYXlzKG9sZEZpZWxkSW5kZXhlcywgbmV3RmllbGRJbmRleGVzLCBmaWVsZEluZGV4U2VtYW50aWNDb21wYXJhdG9yLCBmaWVsZEluZGV4ID0+IHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChpbmRleE1hbmFnZXIuYWRkRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgZmllbGRJbmRleCkpO1xuICAgIH0sIGZpZWxkSW5kZXggPT4ge1xuICAgICAgICBwcm9taXNlcy5wdXNoKGluZGV4TWFuYWdlci5kZWxldGVGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBmaWVsZEluZGV4KSk7XG4gICAgfSkpXG4gICAgICAgIC5uZXh0KCgpID0+IFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKSkpO1xufVxuZnVuY3Rpb24gbG9jYWxTdG9yZVNldEluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZChsb2NhbFN0b3JlLCBpc0VuYWJsZWQpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBsb2NhbFN0b3JlSW1wbC5xdWVyeUVuZ2luZS5pbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQgPSBpc0VuYWJsZWQ7XG59XG5mdW5jdGlvbiBsb2NhbFN0b3JlRGVsZXRlQWxsRmllbGRJbmRleGVzKGxvY2FsU3RvcmUpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBjb25zdCBpbmRleE1hbmFnZXIgPSBsb2NhbFN0b3JlSW1wbC5pbmRleE1hbmFnZXI7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdEZWxldGUgQWxsIEluZGV4ZXMnLCAncmVhZHdyaXRlJywgdHJhbnNhY3Rpb24gPT4gaW5kZXhNYW5hZ2VyLmRlbGV0ZUFsbEZpZWxkSW5kZXhlcyh0cmFuc2FjdGlvbikpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIHRyYWNrZXIgdG8ga2VlcCBhIHJlY29yZCBvZiBpbXBvcnRhbnQgZGV0YWlscyBkdXJpbmcgZGF0YWJhc2UgbG9jYWwgcXVlcnlcbiAqIGV4ZWN1dGlvbi5cbiAqL1xuY2xhc3MgUXVlcnlDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBwYXNzZWQgdGhyb3VnaCBkdXJpbmcgbG9jYWwgcXVlcnkgZXhlY3V0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZG9jdW1lbnRSZWFkQ291bnQgPSAwO1xuICAgIH1cbiAgICBnZXQgZG9jdW1lbnRSZWFkQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb2N1bWVudFJlYWRDb3VudDtcbiAgICB9XG4gICAgaW5jcmVtZW50RG9jdW1lbnRSZWFkQ291bnQoYW1vdW50KSB7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50UmVhZENvdW50ICs9IGFtb3VudDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBERUZBVUxUX0lOREVYX0FVVE9fQ1JFQVRJT05fTUlOX0NPTExFQ1RJT05fU0laRSA9IDEwMDtcbi8qKlxuICogVGhpcyBjb3N0IHJlcHJlc2VudHMgdGhlIGV2YWx1YXRpb24gcmVzdWx0IG9mXG4gKiAoKFtpbmRleCwgZG9jS2V5XSArIFtkb2NLZXksIGRvY0NvbnRlbnRdKSBwZXIgZG9jdW1lbnQgaW4gdGhlIHJlc3VsdCBzZXQpXG4gKiAvIChbZG9jS2V5LCBkb2NDb250ZW50XSBwZXIgZG9jdW1lbnRzIGluIGZ1bGwgY29sbGVjdGlvbiBzY2FuKSBjb21pbmcgZnJvbVxuICogZXhwZXJpbWVudCBbZW50ZXIgUFIgZXhwZXJpbWVudCBVUkwgaGVyZV0uXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRSZWxhdGl2ZUluZGV4UmVhZENvc3RQZXJEb2N1bWVudCgpIHtcbiAgICAvLyBUaGVzZSB2YWx1ZXMgd2VyZSBkZXJpdmVkIGZyb20gYW4gZXhwZXJpbWVudCB3aGVyZSBzZXZlcmFsIG1lbWJlcnMgb2YgdGhlXG4gICAgLy8gRmlyZXN0b3JlIFNESyB0ZWFtIHJhbiBhIHBlcmZvcm1hbmNlIHRlc3QgaW4gdmFyaW91cyBlbnZpcm9ubWVudHMuXG4gICAgLy8gR29vZ2xlcnMgY2FuIHNlZSBiLzI5OTI4NDI4NyBmb3IgZGV0YWlscy5cbiAgICBpZiAoaXNTYWZhcmkoKSkge1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2V0QW5kcm9pZFZlcnNpb24oZ2V0VUEoKSkgPiAwKSB7XG4gICAgICAgIHJldHVybiA2O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgRmlyZXN0b3JlIHF1ZXJ5IGVuZ2luZS5cbiAqXG4gKiBGaXJlc3RvcmUgcXVlcmllcyBjYW4gYmUgZXhlY3V0ZWQgaW4gdGhyZWUgbW9kZXMuIFRoZSBRdWVyeSBFbmdpbmUgZGV0ZXJtaW5lc1xuICogd2hhdCBtb2RlIHRvIHVzZSBiYXNlZCBvbiB3aGF0IGRhdGEgaXMgcGVyc2lzdGVkLiBUaGUgbW9kZSBvbmx5IGRldGVybWluZXNcbiAqIHRoZSBydW50aW1lIGNvbXBsZXhpdHkgb2YgdGhlIHF1ZXJ5IC0gdGhlIHJlc3VsdCBzZXQgaXMgZXF1aXZhbGVudCBhY3Jvc3MgYWxsXG4gKiBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogVGhlIFF1ZXJ5IGVuZ2luZSB3aWxsIHVzZSBpbmRleGVkLWJhc2VkIGV4ZWN1dGlvbiBpZiBhIHVzZXIgaGFzIGNvbmZpZ3VyZWRcbiAqIGFueSBpbmRleCB0aGF0IGNhbiBiZSB1c2VkIHRvIGV4ZWN1dGUgcXVlcnkgKHZpYSBgc2V0SW5kZXhDb25maWd1cmF0aW9uKClgKS5cbiAqIE90aGVyd2lzZSwgdGhlIGVuZ2luZSB3aWxsIHRyeSB0byBvcHRpbWl6ZSB0aGUgcXVlcnkgYnkgcmUtdXNpbmcgYSBwcmV2aW91c2x5XG4gKiBwZXJzaXN0ZWQgcXVlcnkgcmVzdWx0LiBJZiB0aGF0IGlzIG5vdCBwb3NzaWJsZSwgdGhlIHF1ZXJ5IHdpbGwgYmUgZXhlY3V0ZWRcbiAqIHZpYSBhIGZ1bGwgY29sbGVjdGlvbiBzY2FuLlxuICpcbiAqIEluZGV4LWJhc2VkIGV4ZWN1dGlvbiBpcyB0aGUgZGVmYXVsdCB3aGVuIGF2YWlsYWJsZS4gVGhlIHF1ZXJ5IGVuZ2luZVxuICogc3VwcG9ydHMgcGFydGlhbCBpbmRleGVkIGV4ZWN1dGlvbiBhbmQgbWVyZ2VzIHRoZSByZXN1bHQgZnJvbSB0aGUgaW5kZXhcbiAqIGxvb2t1cCB3aXRoIGRvY3VtZW50cyB0aGF0IGhhdmUgbm90IHlldCBiZWVuIGluZGV4ZWQuIFRoZSBpbmRleCBldmFsdWF0aW9uXG4gKiBtYXRjaGVzIHRoZSBiYWNrZW5kJ3MgZm9ybWF0IGFuZCBhcyBzdWNoLCB0aGUgU0RLIGNhbiB1c2UgaW5kZXhpbmcgZm9yIGFsbFxuICogcXVlcmllcyB0aGF0IHRoZSBiYWNrZW5kIHN1cHBvcnRzLlxuICpcbiAqIElmIG5vIGluZGV4IGV4aXN0cywgdGhlIHF1ZXJ5IGVuZ2luZSB0cmllcyB0byB0YWtlIGFkdmFudGFnZSBvZiB0aGUgdGFyZ2V0XG4gKiBkb2N1bWVudCBtYXBwaW5nIGluIHRoZSBUYXJnZXRDYWNoZS4gVGhlc2UgbWFwcGluZ3MgZXhpc3RzIGZvciBhbGwgcXVlcmllc1xuICogdGhhdCBoYXZlIGJlZW4gc3luY2VkIHdpdGggdGhlIGJhY2tlbmQgYXQgbGVhc3Qgb25jZSBhbmQgYWxsb3cgdGhlIHF1ZXJ5XG4gKiBlbmdpbmUgdG8gb25seSByZWFkIGRvY3VtZW50cyB0aGF0IHByZXZpb3VzbHkgbWF0Y2hlZCBhIHF1ZXJ5IHBsdXMgYW55XG4gKiBkb2N1bWVudHMgdGhhdCB3ZXJlIGVkaXRlZCBhZnRlciB0aGUgcXVlcnkgd2FzIGxhc3QgbGlzdGVuZWQgdG8uXG4gKlxuICogVGhlcmUgYXJlIHNvbWUgY2FzZXMgd2hlbiB0aGlzIG9wdGltaXphdGlvbiBpcyBub3QgZ3VhcmFudGVlZCB0byBwcm9kdWNlXG4gKiB0aGUgc2FtZSByZXN1bHRzIGFzIGZ1bGwgY29sbGVjdGlvbiBzY2Fucy4gSW4gdGhlc2UgY2FzZXMsIHF1ZXJ5XG4gKiBwcm9jZXNzaW5nIGZhbGxzIGJhY2sgdG8gZnVsbCBzY2Fucy4gVGhlc2UgY2FzZXMgYXJlOlxuICpcbiAqIC0gTGltaXQgcXVlcmllcyB3aGVyZSBhIGRvY3VtZW50IHRoYXQgbWF0Y2hlZCB0aGUgcXVlcnkgcHJldmlvdXNseSBubyBsb25nZXJcbiAqICAgbWF0Y2hlcyB0aGUgcXVlcnkuXG4gKlxuICogLSBMaW1pdCBxdWVyaWVzIHdoZXJlIGEgZG9jdW1lbnQgZWRpdCBtYXkgY2F1c2UgdGhlIGRvY3VtZW50IHRvIHNvcnQgYmVsb3dcbiAqICAgYW5vdGhlciBkb2N1bWVudCB0aGF0IGlzIGluIHRoZSBsb2NhbCBjYWNoZS5cbiAqXG4gKiAtIFF1ZXJpZXMgdGhhdCBoYXZlIG5ldmVyIGJlZW4gQ1VSUkVOVCBvciBmcmVlIG9mIGxpbWJvIGRvY3VtZW50cy5cbiAqL1xuY2xhc3MgUXVlcnlFbmdpbmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTREsgb25seSBkZWNpZGVzIHdoZXRoZXIgaXQgc2hvdWxkIGNyZWF0ZSBpbmRleCB3aGVuIGNvbGxlY3Rpb24gc2l6ZSBpc1xuICAgICAgICAgKiBsYXJnZXIgdGhhbiB0aGlzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleEF1dG9DcmVhdGlvbk1pbkNvbGxlY3Rpb25TaXplID0gREVGQVVMVF9JTkRFWF9BVVRPX0NSRUFUSU9OX01JTl9DT0xMRUNUSU9OX1NJWkU7XG4gICAgICAgIHRoaXMucmVsYXRpdmVJbmRleFJlYWRDb3N0UGVyRG9jdW1lbnQgPSBnZXREZWZhdWx0UmVsYXRpdmVJbmRleFJlYWRDb3N0UGVyRG9jdW1lbnQoKTtcbiAgICB9XG4gICAgLyoqIFNldHMgdGhlIGRvY3VtZW50IHZpZXcgdG8gcXVlcnkgYWdhaW5zdC4gKi9cbiAgICBpbml0aWFsaXplKGxvY2FsRG9jdW1lbnRzLCBpbmRleE1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5sb2NhbERvY3VtZW50c1ZpZXcgPSBsb2NhbERvY3VtZW50cztcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBpbmRleE1hbmFnZXI7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhbGwgbG9jYWwgZG9jdW1lbnRzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgcXVlcnkuICovXG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIHJlbW90ZUtleXMpIHtcbiAgICAgICAgLy8gU3RvcmVzIHRoZSByZXN1bHQgZnJvbSBleGVjdXRpbmcgdGhlIHF1ZXJ5OyB1c2luZyB0aGlzIG9iamVjdCBpcyBtb3JlXG4gICAgICAgIC8vIGNvbnZlbmllbnQgdGhhbiBwYXNzaW5nIHRoZSByZXN1bHQgYmV0d2VlbiBzdGVwcyBvZiB0aGUgcGVyc2lzdGVuY2VcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gYW5kIGltcHJvdmVzIHJlYWRhYmlsaXR5IGNvbXBhcmF0aXZlbHkuXG4gICAgICAgIGNvbnN0IHF1ZXJ5UmVzdWx0ID0geyByZXN1bHQ6IG51bGwgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVF1ZXJ5VXNpbmdJbmRleCh0cmFuc2FjdGlvbiwgcXVlcnkpXG4gICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcXVlcnlSZXN1bHQucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5UmVzdWx0LnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1RdWVyeVVzaW5nUmVtb3RlS2V5cyh0cmFuc2FjdGlvbiwgcXVlcnksIHJlbW90ZUtleXMsIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pLm5leHQocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICBxdWVyeVJlc3VsdC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChxdWVyeVJlc3VsdC5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IFF1ZXJ5Q29udGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZUZ1bGxDb2xsZWN0aW9uU2Nhbih0cmFuc2FjdGlvbiwgcXVlcnksIGNvbnRleHQpLm5leHQocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICBxdWVyeVJlc3VsdC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNhY2hlSW5kZXhlcyh0cmFuc2FjdGlvbiwgcXVlcnksIGNvbnRleHQsIHJlc3VsdC5zaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHF1ZXJ5UmVzdWx0LnJlc3VsdCk7XG4gICAgfVxuICAgIGNyZWF0ZUNhY2hlSW5kZXhlcyh0cmFuc2FjdGlvbiwgcXVlcnksIGNvbnRleHQsIHJlc3VsdFNpemUpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuZG9jdW1lbnRSZWFkQ291bnQgPCB0aGlzLmluZGV4QXV0b0NyZWF0aW9uTWluQ29sbGVjdGlvblNpemUpIHtcbiAgICAgICAgICAgIGlmIChnZXRMb2dMZXZlbCgpIDw9IExvZ0xldmVsLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1NESyB3aWxsIG5vdCBjcmVhdGUgY2FjaGUgaW5kZXhlcyBmb3IgcXVlcnk6Jywgc3RyaW5naWZ5UXVlcnkocXVlcnkpLCAnc2luY2UgaXQgb25seSBjcmVhdGVzIGNhY2hlIGluZGV4ZXMgZm9yIGNvbGxlY3Rpb24gY29udGFpbnMnLCAnbW9yZSB0aGFuIG9yIGVxdWFsIHRvJywgdGhpcy5pbmRleEF1dG9DcmVhdGlvbk1pbkNvbGxlY3Rpb25TaXplLCAnZG9jdW1lbnRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0TG9nTGV2ZWwoKSA8PSBMb2dMZXZlbC5ERUJVRykge1xuICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1F1ZXJ5OicsIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSwgJ3NjYW5zJywgY29udGV4dC5kb2N1bWVudFJlYWRDb3VudCwgJ2xvY2FsIGRvY3VtZW50cyBhbmQgcmV0dXJucycsIHJlc3VsdFNpemUsICdkb2N1bWVudHMgYXMgcmVzdWx0cy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5kb2N1bWVudFJlYWRDb3VudCA+XG4gICAgICAgICAgICB0aGlzLnJlbGF0aXZlSW5kZXhSZWFkQ29zdFBlckRvY3VtZW50ICogcmVzdWx0U2l6ZSkge1xuICAgICAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPD0gTG9nTGV2ZWwuREVCVUcpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnUXVlcnlFbmdpbmUnLCAnVGhlIFNESyBkZWNpZGVzIHRvIGNyZWF0ZSBjYWNoZSBpbmRleGVzIGZvciBxdWVyeTonLCBzdHJpbmdpZnlRdWVyeShxdWVyeSksICdhcyB1c2luZyBjYWNoZSBpbmRleGVzIG1heSBoZWxwIGltcHJvdmUgcGVyZm9ybWFuY2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXIuY3JlYXRlVGFyZ2V0SW5kZXhlcyh0cmFuc2FjdGlvbiwgcXVlcnlUb1RhcmdldChxdWVyeSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhbiBpbmRleGVkIHF1ZXJ5IHRoYXQgZXZhbHVhdGVzIHRoZSBxdWVyeSBiYXNlZCBvbiBhIGNvbGxlY3Rpb24nc1xuICAgICAqIHBlcnNpc3RlZCBpbmRleCB2YWx1ZXMuIFJldHVybnMgYG51bGxgIGlmIGFuIGluZGV4IGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICovXG4gICAgcGVyZm9ybVF1ZXJ5VXNpbmdJbmRleCh0cmFuc2FjdGlvbiwgcXVlcnkpIHtcbiAgICAgICAgaWYgKHF1ZXJ5TWF0Y2hlc0FsbERvY3VtZW50cyhxdWVyeSkpIHtcbiAgICAgICAgICAgIC8vIFF1ZXJpZXMgdGhhdCBtYXRjaCBhbGwgZG9jdW1lbnRzIGRvbid0IGJlbmVmaXQgZnJvbSB1c2luZ1xuICAgICAgICAgICAgLy8ga2V5LWJhc2VkIGxvb2t1cHMuIEl0IGlzIG1vcmUgZWZmaWNpZW50IHRvIHNjYW4gYWxsIGRvY3VtZW50cyBpbiBhXG4gICAgICAgICAgICAvLyBjb2xsZWN0aW9uLCByYXRoZXIgdGhhbiB0byBwZXJmb3JtIGluZGl2aWR1YWwgbG9va3Vwcy5cbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFyZ2V0ID0gcXVlcnlUb1RhcmdldChxdWVyeSk7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFuYWdlclxuICAgICAgICAgICAgLmdldEluZGV4VHlwZSh0cmFuc2FjdGlvbiwgdGFyZ2V0KVxuICAgICAgICAgICAgLm5leHQoaW5kZXhUeXBlID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleFR5cGUgPT09IDAgLyogSW5kZXhUeXBlLk5PTkUgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdGFyZ2V0IGNhbm5vdCBiZSBzZXJ2ZWQgZnJvbSBhbnkgaW5kZXguXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocXVlcnkubGltaXQgIT09IG51bGwgJiYgaW5kZXhUeXBlID09PSAxIC8qIEluZGV4VHlwZS5QQVJUSUFMICovKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY2Fubm90IGFwcGx5IGEgbGltaXQgZm9yIHRhcmdldHMgdGhhdCBhcmUgc2VydmVkIHVzaW5nIGEgcGFydGlhbFxuICAgICAgICAgICAgICAgIC8vIGluZGV4LiBJZiBhIHBhcnRpYWwgaW5kZXggd2lsbCBiZSB1c2VkIHRvIHNlcnZlIHRoZSB0YXJnZXQsIHRoZVxuICAgICAgICAgICAgICAgIC8vIHF1ZXJ5IG1heSByZXR1cm4gYSBzdXBlcnNldCBvZiBkb2N1bWVudHMgdGhhdCBtYXRjaCB0aGUgdGFyZ2V0XG4gICAgICAgICAgICAgICAgLy8gKGUuZy4gaWYgdGhlIGluZGV4IGRvZXNuJ3QgaW5jbHVkZSBhbGwgdGhlIHRhcmdldCdzIGZpbHRlcnMpLCBvclxuICAgICAgICAgICAgICAgIC8vIG1heSByZXR1cm4gdGhlIGNvcnJlY3Qgc2V0IG9mIGRvY3VtZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIgKGUuZy4gaWZcbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5kZXggZG9lc24ndCBpbmNsdWRlIGEgc2VnbWVudCBmb3Igb25lIG9mIHRoZSBvcmRlckJ5cykuXG4gICAgICAgICAgICAgICAgLy8gVGhlcmVmb3JlLCBhIGxpbWl0IHNob3VsZCBub3QgYmUgYXBwbGllZCBpbiBzdWNoIGNhc2VzLlxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnlXaXRoTGltaXQocXVlcnksIG51bGwsIFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqLyk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gcXVlcnlUb1RhcmdldChxdWVyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXJcbiAgICAgICAgICAgICAgICAuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdUYXJnZXQodHJhbnNhY3Rpb24sIHRhcmdldClcbiAgICAgICAgICAgICAgICAubmV4dChrZXlzID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3J0ZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoLi4ua2V5cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxEb2N1bWVudHNWaWV3XG4gICAgICAgICAgICAgICAgICAgIC5nZXREb2N1bWVudHModHJhbnNhY3Rpb24sIHNvcnRlZEtleXMpXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KGluZGV4ZWREb2N1bWVudHMgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRNaW5PZmZzZXQodHJhbnNhY3Rpb24sIHRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5uZXh0KG9mZnNldCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1Jlc3VsdHMgPSB0aGlzLmFwcGx5UXVlcnkocXVlcnksIGluZGV4ZWREb2N1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmVlZHNSZWZpbGwocXVlcnksIHByZXZpb3VzUmVzdWx0cywgc29ydGVkS2V5cywgb2Zmc2V0LnJlYWRUaW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgbGltaXQgcXVlcnkgd2hvc2UgYm91bmRhcmllcyBjaGFuZ2UgZHVlIHRvIGxvY2FsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWRpdHMgY2FuIGJlIHJlLXJ1biBhZ2FpbnN0IHRoZSBjYWNoZSBieSBleGNsdWRpbmcgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGltaXQuIFRoaXMgZW5zdXJlcyB0aGF0IGFsbCBkb2N1bWVudHMgdGhhdCBtYXRjaCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBxdWVyeSdzIGZpbHRlcnMgYXJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHQgc2V0LiBUaGUgU0RLXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIHRoZW4gYXBwbHkgdGhlIGxpbWl0IG9uY2UgYWxsIGxvY2FsIGVkaXRzIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluY29ycG9yYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJmb3JtUXVlcnlVc2luZ0luZGV4KHRyYW5zYWN0aW9uLCBxdWVyeVdpdGhMaW1pdChxdWVyeSwgbnVsbCwgXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmRSZW1haW5pbmdSZXN1bHRzKHRyYW5zYWN0aW9uLCBwcmV2aW91c1Jlc3VsdHMsIHF1ZXJ5LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBxdWVyeSBiYXNlZCBvbiB0aGUgdGFyZ2V0J3MgcGVyc2lzdGVkIHF1ZXJ5IG1hcHBpbmcuIFJldHVybnNcbiAgICAgKiBgbnVsbGAgaWYgdGhlIG1hcHBpbmcgaXMgbm90IGF2YWlsYWJsZSBvciBjYW5ub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBwZXJmb3JtUXVlcnlVc2luZ1JlbW90ZUtleXModHJhbnNhY3Rpb24sIHF1ZXJ5LCByZW1vdGVLZXlzLCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgIGlmIChxdWVyeU1hdGNoZXNBbGxEb2N1bWVudHMocXVlcnkpKSB7XG4gICAgICAgICAgICAvLyBRdWVyaWVzIHRoYXQgbWF0Y2ggYWxsIGRvY3VtZW50cyBkb24ndCBiZW5lZml0IGZyb20gdXNpbmdcbiAgICAgICAgICAgIC8vIGtleS1iYXNlZCBsb29rdXBzLiBJdCBpcyBtb3JlIGVmZmljaWVudCB0byBzY2FuIGFsbCBkb2N1bWVudHMgaW4gYVxuICAgICAgICAgICAgLy8gY29sbGVjdGlvbiwgcmF0aGVyIHRoYW4gdG8gcGVyZm9ybSBpbmRpdmlkdWFsIGxvb2t1cHMuXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUXVlcmllcyB0aGF0IGhhdmUgbmV2ZXIgc2VlbiBhIHNuYXBzaG90IHdpdGhvdXQgbGltYm8gZnJlZSBkb2N1bWVudHNcbiAgICAgICAgLy8gc2hvdWxkIGFsc28gYmUgcnVuIGFzIGEgZnVsbCBjb2xsZWN0aW9uIHNjYW4uXG4gICAgICAgIGlmIChsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKSkge1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsRG9jdW1lbnRzVmlldy5nZXREb2N1bWVudHModHJhbnNhY3Rpb24sIHJlbW90ZUtleXMpLm5leHQoZG9jdW1lbnRzID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUmVzdWx0cyA9IHRoaXMuYXBwbHlRdWVyeShxdWVyeSwgZG9jdW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRzUmVmaWxsKHF1ZXJ5LCBwcmV2aW91c1Jlc3VsdHMsIHJlbW90ZUtleXMsIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPD0gTG9nTGV2ZWwuREVCVUcpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnUXVlcnlFbmdpbmUnLCAnUmUtdXNpbmcgcHJldmlvdXMgcmVzdWx0IGZyb20gJXMgdG8gZXhlY3V0ZSBxdWVyeTogJXMnLCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLnRvU3RyaW5nKCksIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBhbGwgcmVzdWx0cyBmb3IgZG9jdW1lbnRzIHRoYXQgd2VyZSB1cGRhdGVkIHNpbmNlIHRoZSBsYXN0XG4gICAgICAgICAgICAvLyBsaW1iby1kb2N1bWVudCBmcmVlIHJlbW90ZSBzbmFwc2hvdC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGVuZFJlbWFpbmluZ1Jlc3VsdHModHJhbnNhY3Rpb24sIHByZXZpb3VzUmVzdWx0cywgcXVlcnksIG5ld0luZGV4T2Zmc2V0U3VjY2Vzc29yRnJvbVJlYWRUaW1lKGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIElOSVRJQUxfTEFSR0VTVF9CQVRDSF9JRCkpLm5leHQocmVzdWx0cyA9PiByZXN1bHRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBBcHBsaWVzIHRoZSBxdWVyeSBmaWx0ZXIgYW5kIHNvcnRpbmcgdG8gdGhlIHByb3ZpZGVkIGRvY3VtZW50cy4gICovXG4gICAgYXBwbHlRdWVyeShxdWVyeSwgZG9jdW1lbnRzKSB7XG4gICAgICAgIC8vIFNvcnQgdGhlIGRvY3VtZW50cyBhbmQgcmUtYXBwbHkgdGhlIHF1ZXJ5IGZpbHRlciBzaW5jZSBwcmV2aW91c2x5XG4gICAgICAgIC8vIG1hdGNoaW5nIGRvY3VtZW50cyBkbyBub3QgbmVjZXNzYXJpbHkgc3RpbGwgbWF0Y2ggdGhlIHF1ZXJ5LlxuICAgICAgICBsZXQgcXVlcnlSZXN1bHRzID0gbmV3IFNvcnRlZFNldChuZXdRdWVyeUNvbXBhcmF0b3IocXVlcnkpKTtcbiAgICAgICAgZG9jdW1lbnRzLmZvckVhY2goKF8sIG1heWJlRG9jKSA9PiB7XG4gICAgICAgICAgICBpZiAocXVlcnlNYXRjaGVzKHF1ZXJ5LCBtYXliZURvYykpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVJlc3VsdHMgPSBxdWVyeVJlc3VsdHMuYWRkKG1heWJlRG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBxdWVyeVJlc3VsdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBsaW1pdCBxdWVyeSBuZWVkcyB0byBiZSByZWZpbGxlZCBmcm9tIGNhY2hlLCBtYWtpbmcgaXRcbiAgICAgKiBpbmVsaWdpYmxlIGZvciBpbmRleC1mcmVlIGV4ZWN1dGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeS5cbiAgICAgKiBAcGFyYW0gc29ydGVkUHJldmlvdXNSZXN1bHRzIC0gVGhlIGRvY3VtZW50cyB0aGF0IG1hdGNoZWQgdGhlIHF1ZXJ5IHdoZW4gaXRcbiAgICAgKiB3YXMgbGFzdCBzeW5jaHJvbml6ZWQsIHNvcnRlZCBieSB0aGUgcXVlcnkncyBjb21wYXJhdG9yLlxuICAgICAqIEBwYXJhbSByZW1vdGVLZXlzIC0gVGhlIGRvY3VtZW50IGtleXMgdGhhdCBtYXRjaGVkIHRoZSBxdWVyeSBhdCB0aGUgbGFzdFxuICAgICAqIHNuYXBzaG90LlxuICAgICAqIEBwYXJhbSBsaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gLSBUaGUgdmVyc2lvbiBvZiB0aGUgc25hcHNob3Qgd2hlbiB0aGVcbiAgICAgKiBxdWVyeSB3YXMgbGFzdCBzeW5jaHJvbml6ZWQuXG4gICAgICovXG4gICAgbmVlZHNSZWZpbGwocXVlcnksIHNvcnRlZFByZXZpb3VzUmVzdWx0cywgcmVtb3RlS2V5cywgbGltYm9GcmVlU25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgIGlmIChxdWVyeS5saW1pdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUXVlcmllcyB3aXRob3V0IGxpbWl0cyBkbyBub3QgbmVlZCB0byBiZSByZWZpbGxlZC5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtb3RlS2V5cy5zaXplICE9PSBzb3J0ZWRQcmV2aW91c1Jlc3VsdHMuc2l6ZSkge1xuICAgICAgICAgICAgLy8gVGhlIHF1ZXJ5IG5lZWRzIHRvIGJlIHJlZmlsbGVkIGlmIGEgcHJldmlvdXNseSBtYXRjaGluZyBkb2N1bWVudCBub1xuICAgICAgICAgICAgLy8gbG9uZ2VyIG1hdGNoZXMuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMaW1pdCBxdWVyaWVzIGFyZSBub3QgZWxpZ2libGUgZm9yIGluZGV4LWZyZWUgcXVlcnkgZXhlY3V0aW9uIGlmIHRoZXJlIGlzXG4gICAgICAgIC8vIGEgcG90ZW50aWFsIHRoYXQgYW4gb2xkZXIgZG9jdW1lbnQgZnJvbSBjYWNoZSBub3cgc29ydHMgYmVmb3JlIGEgZG9jdW1lbnRcbiAgICAgICAgLy8gdGhhdCB3YXMgcHJldmlvdXNseSBwYXJ0IG9mIHRoZSBsaW1pdC4gVGhpcywgaG93ZXZlciwgY2FuIG9ubHkgaGFwcGVuIGlmXG4gICAgICAgIC8vIHRoZSBkb2N1bWVudCBhdCB0aGUgZWRnZSBvZiB0aGUgbGltaXQgZ29lcyBvdXQgb2YgbGltaXQuXG4gICAgICAgIC8vIElmIGEgZG9jdW1lbnQgdGhhdCBpcyBub3QgdGhlIGxpbWl0IGJvdW5kYXJ5IHNvcnRzIGRpZmZlcmVudGx5LFxuICAgICAgICAvLyB0aGUgYm91bmRhcnkgb2YgdGhlIGxpbWl0IGl0c2VsZiBkaWQgbm90IGNoYW5nZSBhbmQgZG9jdW1lbnRzIGZyb20gY2FjaGVcbiAgICAgICAgLy8gd2lsbCBjb250aW51ZSB0byBiZSBcInJlamVjdGVkXCIgYnkgdGhpcyBib3VuZGFyeS4gVGhlcmVmb3JlLCB3ZSBjYW4gaWdub3JlXG4gICAgICAgIC8vIGFueSBtb2RpZmljYXRpb25zIHRoYXQgZG9uJ3QgYWZmZWN0IHRoZSBsYXN0IGRvY3VtZW50LlxuICAgICAgICBjb25zdCBkb2NBdExpbWl0RWRnZSA9IHF1ZXJ5LmxpbWl0VHlwZSA9PT0gXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovXG4gICAgICAgICAgICA/IHNvcnRlZFByZXZpb3VzUmVzdWx0cy5sYXN0KClcbiAgICAgICAgICAgIDogc29ydGVkUHJldmlvdXNSZXN1bHRzLmZpcnN0KCk7XG4gICAgICAgIGlmICghZG9jQXRMaW1pdEVkZ2UpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmVmaWxsIHRoZSBxdWVyeSBpZiB0aGVyZSB3ZXJlIGFscmVhZHkgbm8gZG9jdW1lbnRzLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZG9jQXRMaW1pdEVkZ2UuaGFzUGVuZGluZ1dyaXRlcyB8fFxuICAgICAgICAgICAgZG9jQXRMaW1pdEVkZ2UudmVyc2lvbi5jb21wYXJlVG8obGltYm9GcmVlU25hcHNob3RWZXJzaW9uKSA+IDApO1xuICAgIH1cbiAgICBleGVjdXRlRnVsbENvbGxlY3Rpb25TY2FuKHRyYW5zYWN0aW9uLCBxdWVyeSwgY29udGV4dCkge1xuICAgICAgICBpZiAoZ2V0TG9nTGV2ZWwoKSA8PSBMb2dMZXZlbC5ERUJVRykge1xuICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1VzaW5nIGZ1bGwgY29sbGVjdGlvbiBzY2FuIHRvIGV4ZWN1dGUgcXVlcnk6Jywgc3RyaW5naWZ5UXVlcnkocXVlcnkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbERvY3VtZW50c1ZpZXcuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIEluZGV4T2Zmc2V0Lm1pbigpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tYmluZXMgdGhlIHJlc3VsdHMgZnJvbSBhbiBpbmRleGVkIGV4ZWN1dGlvbiB3aXRoIHRoZSByZW1haW5pbmcgZG9jdW1lbnRzXG4gICAgICogdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiBpbmRleGVkLlxuICAgICAqL1xuICAgIGFwcGVuZFJlbWFpbmluZ1Jlc3VsdHModHJhbnNhY3Rpb24sIGluZGV4ZWRSZXN1bHRzLCBxdWVyeSwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIFJldHJpZXZlIGFsbCByZXN1bHRzIGZvciBkb2N1bWVudHMgdGhhdCB3ZXJlIHVwZGF0ZWQgc2luY2UgdGhlIG9mZnNldC5cbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxEb2N1bWVudHNWaWV3XG4gICAgICAgICAgICAuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIG9mZnNldClcbiAgICAgICAgICAgIC5uZXh0KHJlbWFpbmluZ1Jlc3VsdHMgPT4ge1xuICAgICAgICAgICAgLy8gTWVyZ2Ugd2l0aCBleGlzdGluZyByZXN1bHRzXG4gICAgICAgICAgICBpbmRleGVkUmVzdWx0cy5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZ1Jlc3VsdHMgPSByZW1haW5pbmdSZXN1bHRzLmluc2VydChkLmtleSwgZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZW1haW5pbmdSZXN1bHRzO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBUaGUgZm9ybWF0IG9mIHRoZSBMb2NhbFN0b3JhZ2Uga2V5IHRoYXQgc3RvcmVzIHRoZSBjbGllbnQgc3RhdGUgaXM6XG4vLyAgICAgZmlyZXN0b3JlX2NsaWVudHNfPHBlcnNpc3RlbmNlX3ByZWZpeD5fPGluc3RhbmNlX2tleT5cbmNvbnN0IENMSUVOVF9TVEFURV9LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV9jbGllbnRzJztcbi8qKiBBc3NlbWJsZXMgdGhlIGtleSBmb3IgYSBjbGllbnQgc3RhdGUgaW4gV2ViU3RvcmFnZSAqL1xuZnVuY3Rpb24gY3JlYXRlV2ViU3RvcmFnZUNsaWVudFN0YXRlS2V5KHBlcnNpc3RlbmNlS2V5LCBjbGllbnRJZCkge1xuICAgIHJldHVybiBgJHtDTElFTlRfU1RBVEVfS0VZX1BSRUZJWH1fJHtwZXJzaXN0ZW5jZUtleX1fJHtjbGllbnRJZH1gO1xufVxuLy8gVGhlIGZvcm1hdCBvZiB0aGUgV2ViU3RvcmFnZSBrZXkgdGhhdCBzdG9yZXMgdGhlIG11dGF0aW9uIHN0YXRlIGlzOlxuLy8gICAgIGZpcmVzdG9yZV9tdXRhdGlvbnNfPHBlcnNpc3RlbmNlX3ByZWZpeD5fPGJhdGNoX2lkPlxuLy8gICAgIChmb3IgdW5hdXRoZW50aWNhdGVkIHVzZXJzKVxuLy8gb3I6IGZpcmVzdG9yZV9tdXRhdGlvbnNfPHBlcnNpc3RlbmNlX3ByZWZpeD5fPGJhdGNoX2lkPl88dXNlcl91aWQ+XG4vL1xuLy8gJ3VzZXJfdWlkJyBpcyBsYXN0IHRvIGF2b2lkIG5lZWRpbmcgdG8gZXNjYXBlICdfJyBjaGFyYWN0ZXJzIHRoYXQgaXQgbWlnaHRcbi8vIGNvbnRhaW4uXG5jb25zdCBNVVRBVElPTl9CQVRDSF9LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV9tdXRhdGlvbnMnO1xuLyoqIEFzc2VtYmxlcyB0aGUga2V5IGZvciBhIG11dGF0aW9uIGJhdGNoIGluIFdlYlN0b3JhZ2UgKi9cbmZ1bmN0aW9uIGNyZWF0ZVdlYlN0b3JhZ2VNdXRhdGlvbkJhdGNoS2V5KHBlcnNpc3RlbmNlS2V5LCB1c2VyLCBiYXRjaElkKSB7XG4gICAgbGV0IG11dGF0aW9uS2V5ID0gYCR7TVVUQVRJT05fQkFUQ0hfS0VZX1BSRUZJWH1fJHtwZXJzaXN0ZW5jZUtleX1fJHtiYXRjaElkfWA7XG4gICAgaWYgKHVzZXIuaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICAgICAgbXV0YXRpb25LZXkgKz0gYF8ke3VzZXIudWlkfWA7XG4gICAgfVxuICAgIHJldHVybiBtdXRhdGlvbktleTtcbn1cbi8vIFRoZSBmb3JtYXQgb2YgdGhlIFdlYlN0b3JhZ2Uga2V5IHRoYXQgc3RvcmVzIGEgcXVlcnkgdGFyZ2V0J3MgbWV0YWRhdGEgaXM6XG4vLyAgICAgZmlyZXN0b3JlX3RhcmdldHNfPHBlcnNpc3RlbmNlX3ByZWZpeD5fPHRhcmdldF9pZD5cbmNvbnN0IFFVRVJZX1RBUkdFVF9LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV90YXJnZXRzJztcbi8qKiBBc3NlbWJsZXMgdGhlIGtleSBmb3IgYSBxdWVyeSBzdGF0ZSBpbiBXZWJTdG9yYWdlICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTdG9yYWdlUXVlcnlUYXJnZXRNZXRhZGF0YUtleShwZXJzaXN0ZW5jZUtleSwgdGFyZ2V0SWQpIHtcbiAgICByZXR1cm4gYCR7UVVFUllfVEFSR0VUX0tFWV9QUkVGSVh9XyR7cGVyc2lzdGVuY2VLZXl9XyR7dGFyZ2V0SWR9YDtcbn1cbi8vIFRoZSBXZWJTdG9yYWdlIHByZWZpeCB0aGF0IHN0b3JlcyB0aGUgcHJpbWFyeSB0YWIncyBvbmxpbmUgc3RhdGUuIFRoZVxuLy8gZm9ybWF0IG9mIHRoZSBrZXkgaXM6XG4vLyAgICAgZmlyZXN0b3JlX29ubGluZV9zdGF0ZV88cGVyc2lzdGVuY2VfcHJlZml4PlxuY29uc3QgT05MSU5FX1NUQVRFX0tFWV9QUkVGSVggPSAnZmlyZXN0b3JlX29ubGluZV9zdGF0ZSc7XG4vKiogQXNzZW1ibGVzIHRoZSBrZXkgZm9yIHRoZSBvbmxpbmUgc3RhdGUgb2YgdGhlIHByaW1hcnkgdGFiLiAqL1xuZnVuY3Rpb24gY3JlYXRlV2ViU3RvcmFnZU9ubGluZVN0YXRlS2V5KHBlcnNpc3RlbmNlS2V5KSB7XG4gICAgcmV0dXJuIGAke09OTElORV9TVEFURV9LRVlfUFJFRklYfV8ke3BlcnNpc3RlbmNlS2V5fWA7XG59XG4vLyBUaGUgV2ViU3RvcmFnZSBwcmVmaXggdGhhdCBwbGF5cyBhcyBhIGV2ZW50IHRvIGluZGljYXRlIHRoZSByZW1vdGUgZG9jdW1lbnRzXG4vLyBtaWdodCBoYXZlIGNoYW5nZWQgZHVlIHRvIHNvbWUgc2Vjb25kYXJ5IHRhYnMgbG9hZGluZyBhIGJ1bmRsZS5cbi8vIGZvcm1hdCBvZiB0aGUga2V5IGlzOlxuLy8gICAgIGZpcmVzdG9yZV9idW5kbGVfbG9hZGVkX3YyXzxwZXJzaXN0ZW5jZUtleT5cbi8vIFRoZSB2ZXJzaW9uIGVuZGluZyB3aXRoIFwidjJcIiBzdG9yZXMgdGhlIGxpc3Qgb2YgbW9kaWZpZWQgY29sbGVjdGlvbiBncm91cHMuXG5jb25zdCBCVU5ETEVfTE9BREVEX0tFWV9QUkVGSVggPSAnZmlyZXN0b3JlX2J1bmRsZV9sb2FkZWRfdjInO1xuZnVuY3Rpb24gY3JlYXRlQnVuZGxlTG9hZGVkS2V5KHBlcnNpc3RlbmNlS2V5KSB7XG4gICAgcmV0dXJuIGAke0JVTkRMRV9MT0FERURfS0VZX1BSRUZJWH1fJHtwZXJzaXN0ZW5jZUtleX1gO1xufVxuLy8gVGhlIFdlYlN0b3JhZ2Uga2V5IHByZWZpeCBmb3IgdGhlIGtleSB0aGF0IHN0b3JlcyB0aGUgbGFzdCBzZXF1ZW5jZSBudW1iZXIgYWxsb2NhdGVkLiBUaGUga2V5XG4vLyBsb29rcyBsaWtlICdmaXJlc3RvcmVfc2VxdWVuY2VfbnVtYmVyXzxwZXJzaXN0ZW5jZV9wcmVmaXg+Jy5cbmNvbnN0IFNFUVVFTkNFX05VTUJFUl9LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV9zZXF1ZW5jZV9udW1iZXInO1xuLyoqIEFzc2VtYmxlcyB0aGUga2V5IGZvciB0aGUgY3VycmVudCBzZXF1ZW5jZSBudW1iZXIuICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTdG9yYWdlU2VxdWVuY2VOdW1iZXJLZXkocGVyc2lzdGVuY2VLZXkpIHtcbiAgICByZXR1cm4gYCR7U0VRVUVOQ0VfTlVNQkVSX0tFWV9QUkVGSVh9XyR7cGVyc2lzdGVuY2VLZXl9YDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckYSA9ICdTaGFyZWRDbGllbnRTdGF0ZSc7XG4vKipcbiAqIEhvbGRzIHRoZSBzdGF0ZSBvZiBhIG11dGF0aW9uIGJhdGNoLCBpbmNsdWRpbmcgaXRzIHVzZXIgSUQsIGJhdGNoIElEIGFuZFxuICogd2hldGhlciB0aGUgYmF0Y2ggaXMgJ3BlbmRpbmcnLCAnYWNrbm93bGVkZ2VkJyBvciAncmVqZWN0ZWQnLlxuICovXG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nXG5jbGFzcyBNdXRhdGlvbk1ldGFkYXRhIHtcbiAgICBjb25zdHJ1Y3Rvcih1c2VyLCBiYXRjaElkLCBzdGF0ZSwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcbiAgICAgICAgdGhpcy5iYXRjaElkID0gYmF0Y2hJZDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIE11dGF0aW9uTWV0YWRhdGEgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiBpbiBXZWJTdG9yYWdlLlxuICAgICAqIExvZ3MgYSB3YXJuaW5nIGFuZCByZXR1cm5zIG51bGwgaWYgdGhlIGZvcm1hdCBvZiB0aGUgZGF0YSBpcyBub3QgdmFsaWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21XZWJTdG9yYWdlRW50cnkodXNlciwgYmF0Y2hJZCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbXV0YXRpb25CYXRjaCA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICBsZXQgdmFsaWREYXRhID0gdHlwZW9mIG11dGF0aW9uQmF0Y2ggPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBbJ3BlbmRpbmcnLCAnYWNrbm93bGVkZ2VkJywgJ3JlamVjdGVkJ10uaW5kZXhPZihtdXRhdGlvbkJhdGNoLnN0YXRlKSAhPT1cbiAgICAgICAgICAgICAgICAtMSAmJlxuICAgICAgICAgICAgKG11dGF0aW9uQmF0Y2guZXJyb3IgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBtdXRhdGlvbkJhdGNoLmVycm9yID09PSAnb2JqZWN0Jyk7XG4gICAgICAgIGxldCBmaXJlc3RvcmVFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHZhbGlkRGF0YSAmJiBtdXRhdGlvbkJhdGNoLmVycm9yKSB7XG4gICAgICAgICAgICB2YWxpZERhdGEgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBtdXRhdGlvbkJhdGNoLmVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBtdXRhdGlvbkJhdGNoLmVycm9yLmNvZGUgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgaWYgKHZhbGlkRGF0YSkge1xuICAgICAgICAgICAgICAgIGZpcmVzdG9yZUVycm9yID0gbmV3IEZpcmVzdG9yZUVycm9yKG11dGF0aW9uQmF0Y2guZXJyb3IuY29kZSwgbXV0YXRpb25CYXRjaC5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWREYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE11dGF0aW9uTWV0YWRhdGEodXNlciwgYmF0Y2hJZCwgbXV0YXRpb25CYXRjaC5zdGF0ZSwgZmlyZXN0b3JlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRhLCBgRmFpbGVkIHRvIHBhcnNlIG11dGF0aW9uIHN0YXRlIGZvciBJRCAnJHtiYXRjaElkfSc6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1dlYlN0b3JhZ2VKU09OKCkge1xuICAgICAgICBjb25zdCBiYXRjaE1ldGFkYXRhID0ge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICB1cGRhdGVUaW1lTXM6IERhdGUubm93KCkgLy8gTW9kaWZ5IHRoZSBleGlzdGluZyB2YWx1ZSB0byB0cmlnZ2VyIHVwZGF0ZS5cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgIGJhdGNoTWV0YWRhdGEuZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgY29kZTogdGhpcy5lcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMuZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYmF0Y2hNZXRhZGF0YSk7XG4gICAgfVxufVxuLyoqXG4gKiBIb2xkcyB0aGUgc3RhdGUgb2YgYSBxdWVyeSB0YXJnZXQsIGluY2x1ZGluZyBpdHMgdGFyZ2V0IElEIGFuZCB3aGV0aGVyIHRoZVxuICogdGFyZ2V0IGlzICdub3QtY3VycmVudCcsICdjdXJyZW50JyBvciAncmVqZWN0ZWQnLlxuICovXG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nXG5jbGFzcyBRdWVyeVRhcmdldE1ldGFkYXRhIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRJZCwgc3RhdGUsIGVycm9yKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIFF1ZXJ5VGFyZ2V0TWV0YWRhdGEgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiBpbiBXZWJTdG9yYWdlLlxuICAgICAqIExvZ3MgYSB3YXJuaW5nIGFuZCByZXR1cm5zIG51bGwgaWYgdGhlIGZvcm1hdCBvZiB0aGUgZGF0YSBpcyBub3QgdmFsaWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21XZWJTdG9yYWdlRW50cnkodGFyZ2V0SWQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIGxldCB2YWxpZERhdGEgPSB0eXBlb2YgdGFyZ2V0U3RhdGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBbJ25vdC1jdXJyZW50JywgJ2N1cnJlbnQnLCAncmVqZWN0ZWQnXS5pbmRleE9mKHRhcmdldFN0YXRlLnN0YXRlKSAhPT1cbiAgICAgICAgICAgICAgICAtMSAmJlxuICAgICAgICAgICAgKHRhcmdldFN0YXRlLmVycm9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0U3RhdGUuZXJyb3IgPT09ICdvYmplY3QnKTtcbiAgICAgICAgbGV0IGZpcmVzdG9yZUVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodmFsaWREYXRhICYmIHRhcmdldFN0YXRlLmVycm9yKSB7XG4gICAgICAgICAgICB2YWxpZERhdGEgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRTdGF0ZS5lcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0U3RhdGUuZXJyb3IuY29kZSA9PT0gJ3N0cmluZyc7XG4gICAgICAgICAgICBpZiAodmFsaWREYXRhKSB7XG4gICAgICAgICAgICAgICAgZmlyZXN0b3JlRXJyb3IgPSBuZXcgRmlyZXN0b3JlRXJyb3IodGFyZ2V0U3RhdGUuZXJyb3IuY29kZSwgdGFyZ2V0U3RhdGUuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeVRhcmdldE1ldGFkYXRhKHRhcmdldElkLCB0YXJnZXRTdGF0ZS5zdGF0ZSwgZmlyZXN0b3JlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRhLCBgRmFpbGVkIHRvIHBhcnNlIHRhcmdldCBzdGF0ZSBmb3IgSUQgJyR7dGFyZ2V0SWR9JzogJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvV2ViU3RvcmFnZUpTT04oKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0ge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICB1cGRhdGVUaW1lTXM6IERhdGUubm93KCkgLy8gTW9kaWZ5IHRoZSBleGlzdGluZyB2YWx1ZSB0byB0cmlnZ2VyIHVwZGF0ZS5cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgIHRhcmdldFN0YXRlLmVycm9yID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IHRoaXMuZXJyb3IuY29kZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0aGlzLmVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRhcmdldFN0YXRlKTtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgaW1tdXRhYmxlIENsaWVudFN0YXRlIGZvciBhIGNsaWVudCByZWFkIGZyb21cbiAqIFdlYlN0b3JhZ2UsIGNvbnRhaW5pbmcgdGhlIGxpc3Qgb2YgYWN0aXZlIHF1ZXJ5IHRhcmdldHMuXG4gKi9cbmNsYXNzIFJlbW90ZUNsaWVudFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnRJZCwgYWN0aXZlVGFyZ2V0SWRzKSB7XG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgdGhpcy5hY3RpdmVUYXJnZXRJZHMgPSBhY3RpdmVUYXJnZXRJZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIFJlbW90ZUNsaWVudFN0YXRlIGZyb20gdGhlIEpTT04gcmVwcmVzZW50YXRpb24gaW4gV2ViU3RvcmFnZS5cbiAgICAgKiBMb2dzIGEgd2FybmluZyBhbmQgcmV0dXJucyBudWxsIGlmIHRoZSBmb3JtYXQgb2YgdGhlIGRhdGEgaXMgbm90IHZhbGlkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tV2ViU3RvcmFnZUVudHJ5KGNsaWVudElkLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBjbGllbnRTdGF0ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICBsZXQgdmFsaWREYXRhID0gdHlwZW9mIGNsaWVudFN0YXRlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgY2xpZW50U3RhdGUuYWN0aXZlVGFyZ2V0SWRzIGluc3RhbmNlb2YgQXJyYXk7XG4gICAgICAgIGxldCBhY3RpdmVUYXJnZXRJZHNTZXQgPSB0YXJnZXRJZFNldCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgdmFsaWREYXRhICYmIGkgPCBjbGllbnRTdGF0ZS5hY3RpdmVUYXJnZXRJZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhbGlkRGF0YSA9IGlzU2FmZUludGVnZXIoY2xpZW50U3RhdGUuYWN0aXZlVGFyZ2V0SWRzW2ldKTtcbiAgICAgICAgICAgIGFjdGl2ZVRhcmdldElkc1NldCA9IGFjdGl2ZVRhcmdldElkc1NldC5hZGQoY2xpZW50U3RhdGUuYWN0aXZlVGFyZ2V0SWRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWREYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlbW90ZUNsaWVudFN0YXRlKGNsaWVudElkLCBhY3RpdmVUYXJnZXRJZHNTZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRhLCBgRmFpbGVkIHRvIHBhcnNlIGNsaWVudCBkYXRhIGZvciBpbnN0YW5jZSAnJHtjbGllbnRJZH0nOiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgb25saW5lIHN0YXRlIGZvciBhbGwgY2xpZW50cyBwYXJ0aWNpcGF0aW5nIGluXG4gKiBtdWx0aS10YWIuIFRoZSBvbmxpbmUgc3RhdGUgaXMgb25seSB3cml0dGVuIHRvIGJ5IHRoZSBwcmltYXJ5IGNsaWVudCwgYW5kXG4gKiB1c2VkIGluIHNlY29uZGFyeSBjbGllbnRzIHRvIHVwZGF0ZSB0aGVpciBxdWVyeSB2aWV3cy5cbiAqL1xuY2xhc3MgU2hhcmVkT25saW5lU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudElkLCBvbmxpbmVTdGF0ZSkge1xuICAgICAgICB0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBvbmxpbmVTdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgU2hhcmVkT25saW5lU3RhdGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiBpbiBXZWJTdG9yYWdlLlxuICAgICAqIExvZ3MgYSB3YXJuaW5nIGFuZCByZXR1cm5zIG51bGwgaWYgdGhlIGZvcm1hdCBvZiB0aGUgZGF0YSBpcyBub3QgdmFsaWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21XZWJTdG9yYWdlRW50cnkodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb25saW5lU3RhdGUgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsaWREYXRhID0gdHlwZW9mIG9ubGluZVN0YXRlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgWydVbmtub3duJywgJ09ubGluZScsICdPZmZsaW5lJ10uaW5kZXhPZihvbmxpbmVTdGF0ZS5vbmxpbmVTdGF0ZSkgIT09XG4gICAgICAgICAgICAgICAgLTEgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvbmxpbmVTdGF0ZS5jbGllbnRJZCA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGlmICh2YWxpZERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2hhcmVkT25saW5lU3RhdGUob25saW5lU3RhdGUuY2xpZW50SWQsIG9ubGluZVN0YXRlLm9ubGluZVN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYSwgYEZhaWxlZCB0byBwYXJzZSBvbmxpbmUgc3RhdGU6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogTWV0YWRhdGEgc3RhdGUgb2YgdGhlIGxvY2FsIGNsaWVudC4gVW5saWtlIGBSZW1vdGVDbGllbnRTdGF0ZWAsIHRoaXMgY2xhc3MgaXNcbiAqIG11dGFibGUgYW5kIGtlZXBzIHRyYWNrIG9mIGFsbCBwZW5kaW5nIG11dGF0aW9ucywgd2hpY2ggYWxsb3dzIHVzIHRvXG4gKiB1cGRhdGUgdGhlIHJhbmdlIG9mIHBlbmRpbmcgbXV0YXRpb24gYmF0Y2ggSURzIGFzIG5ldyBtdXRhdGlvbnMgYXJlIGFkZGVkIG9yXG4gKiByZW1vdmVkLlxuICpcbiAqIFRoZSBkYXRhIGluIGBMb2NhbENsaWVudFN0YXRlYCBpcyBub3QgcmVhZCBmcm9tIFdlYlN0b3JhZ2UgYW5kIGluc3RlYWRcbiAqIHVwZGF0ZWQgdmlhIGl0cyBpbnN0YW5jZSBtZXRob2RzLiBUaGUgdXBkYXRlZCBzdGF0ZSBjYW4gYmUgc2VyaWFsaXplZCB2aWFcbiAqIGB0b1dlYlN0b3JhZ2VKU09OKClgLlxuICovXG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nLlxuY2xhc3MgTG9jYWxDbGllbnRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlVGFyZ2V0SWRzID0gdGFyZ2V0SWRTZXQoKTtcbiAgICB9XG4gICAgYWRkUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVUYXJnZXRJZHMgPSB0aGlzLmFjdGl2ZVRhcmdldElkcy5hZGQodGFyZ2V0SWQpO1xuICAgIH1cbiAgICByZW1vdmVRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLmFjdGl2ZVRhcmdldElkcyA9IHRoaXMuYWN0aXZlVGFyZ2V0SWRzLmRlbGV0ZSh0YXJnZXRJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgZW50cnkgaW50byBhIEpTT04tZW5jb2RlZCBmb3JtYXQgd2UgY2FuIHVzZSBmb3IgV2ViU3RvcmFnZS5cbiAgICAgKiBEb2VzIG5vdCBlbmNvZGUgYGNsaWVudElkYCBhcyBpdCBpcyBwYXJ0IG9mIHRoZSBrZXkgaW4gV2ViU3RvcmFnZS5cbiAgICAgKi9cbiAgICB0b1dlYlN0b3JhZ2VKU09OKCkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgYWN0aXZlVGFyZ2V0SWRzOiB0aGlzLmFjdGl2ZVRhcmdldElkcy50b0FycmF5KCksXG4gICAgICAgICAgICB1cGRhdGVUaW1lTXM6IERhdGUubm93KCkgLy8gTW9kaWZ5IHRoZSBleGlzdGluZyB2YWx1ZSB0byB0cmlnZ2VyIHVwZGF0ZS5cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbn1cbi8qKlxuICogYFdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZWAgdXNlcyBXZWJTdG9yYWdlICh3aW5kb3cubG9jYWxTdG9yYWdlKSBhcyB0aGVcbiAqIGJhY2tpbmcgc3RvcmUgZm9yIHRoZSBTaGFyZWRDbGllbnRTdGF0ZS4gSXQga2VlcHMgdHJhY2sgb2YgYWxsIGFjdGl2ZVxuICogY2xpZW50cyBhbmQgc3VwcG9ydHMgbW9kaWZpY2F0aW9ucyBvZiB0aGUgbG9jYWwgY2xpZW50J3MgZGF0YS5cbiAqL1xuY2xhc3MgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcih3aW5kb3csIHF1ZXVlLCBwZXJzaXN0ZW5jZUtleSwgbG9jYWxDbGllbnRJZCwgaW5pdGlhbFVzZXIpIHtcbiAgICAgICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5O1xuICAgICAgICB0aGlzLmxvY2FsQ2xpZW50SWQgPSBsb2NhbENsaWVudElkO1xuICAgICAgICB0aGlzLnN5bmNFbmdpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLm9ubGluZVN0YXRlSGFuZGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXJIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9yYWdlTGlzdGVuZXIgPSB0aGlzLmhhbmRsZVdlYlN0b3JhZ2VFdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudHMgPSBuZXcgU29ydGVkTWFwKHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhcHR1cmVzIFdlYlN0b3JhZ2UgZXZlbnRzIHRoYXQgb2NjdXIgYmVmb3JlIGBzdGFydCgpYCBpcyBjYWxsZWQuIFRoZXNlXG4gICAgICAgICAqIGV2ZW50cyBhcmUgcmVwbGF5ZWQgb25jZSBgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlYCBpcyBzdGFydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lYXJseUV2ZW50cyA9IFtdO1xuICAgICAgICAvLyBFc2NhcGUgdGhlIHNwZWNpYWwgY2hhcmFjdGVycyBtZW50aW9uZWQgaGVyZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25zXG4gICAgICAgIGNvbnN0IGVzY2FwZWRQZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5LnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHRoaXMud2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICAgICAgdGhpcy5jdXJyZW50VXNlciA9IGluaXRpYWxVc2VyO1xuICAgICAgICB0aGlzLmxvY2FsQ2xpZW50U3RvcmFnZUtleSA9IGNyZWF0ZVdlYlN0b3JhZ2VDbGllbnRTdGF0ZUtleSh0aGlzLnBlcnNpc3RlbmNlS2V5LCB0aGlzLmxvY2FsQ2xpZW50SWQpO1xuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVyS2V5ID0gY3JlYXRlV2ViU3RvcmFnZVNlcXVlbmNlTnVtYmVyS2V5KHRoaXMucGVyc2lzdGVuY2VLZXkpO1xuICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudHMgPSB0aGlzLmFjdGl2ZUNsaWVudHMuaW5zZXJ0KHRoaXMubG9jYWxDbGllbnRJZCwgbmV3IExvY2FsQ2xpZW50U3RhdGUoKSk7XG4gICAgICAgIHRoaXMuY2xpZW50U3RhdGVLZXlSZSA9IG5ldyBSZWdFeHAoYF4ke0NMSUVOVF9TVEFURV9LRVlfUFJFRklYfV8ke2VzY2FwZWRQZXJzaXN0ZW5jZUtleX1fKFteX10qKSRgKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbkJhdGNoS2V5UmUgPSBuZXcgUmVnRXhwKGBeJHtNVVRBVElPTl9CQVRDSF9LRVlfUFJFRklYfV8ke2VzY2FwZWRQZXJzaXN0ZW5jZUtleX1fKFxcXFxkKykoPzpfKC4qKSk/JGApO1xuICAgICAgICB0aGlzLnF1ZXJ5VGFyZ2V0S2V5UmUgPSBuZXcgUmVnRXhwKGBeJHtRVUVSWV9UQVJHRVRfS0VZX1BSRUZJWH1fJHtlc2NhcGVkUGVyc2lzdGVuY2VLZXl9XyhcXFxcZCspJGApO1xuICAgICAgICB0aGlzLm9ubGluZVN0YXRlS2V5ID0gY3JlYXRlV2ViU3RvcmFnZU9ubGluZVN0YXRlS2V5KHRoaXMucGVyc2lzdGVuY2VLZXkpO1xuICAgICAgICB0aGlzLmJ1bmRsZUxvYWRlZEtleSA9IGNyZWF0ZUJ1bmRsZUxvYWRlZEtleSh0aGlzLnBlcnNpc3RlbmNlS2V5KTtcbiAgICAgICAgLy8gUmF0aGVyIHRoYW4gYWRkaW5nIHRoZSBzdG9yYWdlIG9ic2VydmVyIGR1cmluZyBzdGFydCgpLCB3ZSBhZGQgdGhlXG4gICAgICAgIC8vIHN0b3JhZ2Ugb2JzZXJ2ZXIgZHVyaW5nIGluaXRpYWxpemF0aW9uLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBjb2xsZWN0XG4gICAgICAgIC8vIGV2ZW50cyBiZWZvcmUgb3RoZXIgY29tcG9uZW50cyBwb3B1bGF0ZSB0aGVpciBpbml0aWFsIHN0YXRlIChkdXJpbmcgdGhlaXJcbiAgICAgICAgLy8gcmVzcGVjdGl2ZSBzdGFydCgpIGNhbGxzKS4gT3RoZXJ3aXNlLCB3ZSBtaWdodCBmb3IgZXhhbXBsZSBtaXNzIGFcbiAgICAgICAgLy8gbXV0YXRpb24gdGhhdCBpcyBhZGRlZCBhZnRlciBMb2NhbFN0b3JlJ3Mgc3RhcnQoKSBwcm9jZXNzZWQgdGhlIGV4aXN0aW5nXG4gICAgICAgIC8vIG11dGF0aW9ucyBidXQgYmVmb3JlIHdlIG9ic2VydmUgV2ViU3RvcmFnZSBldmVudHMuXG4gICAgICAgIHRoaXMud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCB0aGlzLnN0b3JhZ2VMaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zICd0cnVlJyBpZiBXZWJTdG9yYWdlIGlzIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gKi9cbiAgICBzdGF0aWMgaXNBdmFpbGFibGUod2luZG93KSB7XG4gICAgICAgIHJldHVybiAhISh3aW5kb3cgJiYgd2luZG93LmxvY2FsU3RvcmFnZSk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBleGlzdGluZyBjbGllbnRzIHRvIGJhY2tmaWxsIHRoZSBkYXRhIGluXG4gICAgICAgIC8vIFNoYXJlZENsaWVudFN0YXRlLlxuICAgICAgICBjb25zdCBleGlzdGluZ0NsaWVudHMgPSBhd2FpdCB0aGlzLnN5bmNFbmdpbmUuZ2V0QWN0aXZlQ2xpZW50cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNsaWVudElkIG9mIGV4aXN0aW5nQ2xpZW50cykge1xuICAgICAgICAgICAgaWYgKGNsaWVudElkID09PSB0aGlzLmxvY2FsQ2xpZW50SWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0b3JhZ2VJdGVtID0gdGhpcy5nZXRJdGVtKGNyZWF0ZVdlYlN0b3JhZ2VDbGllbnRTdGF0ZUtleSh0aGlzLnBlcnNpc3RlbmNlS2V5LCBjbGllbnRJZCkpO1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2VJdGVtKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50U3RhdGUgPSBSZW1vdGVDbGllbnRTdGF0ZS5mcm9tV2ViU3RvcmFnZUVudHJ5KGNsaWVudElkLCBzdG9yYWdlSXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKGNsaWVudFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2xpZW50cyA9IHRoaXMuYWN0aXZlQ2xpZW50cy5pbnNlcnQoY2xpZW50U3RhdGUuY2xpZW50SWQsIGNsaWVudFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZXJzaXN0Q2xpZW50U3RhdGUoKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYW4gZXhpc3Rpbmcgb25saW5lIHN0YXRlIGFuZCBjYWxsIHRoZSBjYWxsYmFjayBoYW5kbGVyXG4gICAgICAgIC8vIGlmIGFwcGxpY2FibGUuXG4gICAgICAgIGNvbnN0IG9ubGluZVN0YXRlSlNPTiA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMub25saW5lU3RhdGVLZXkpO1xuICAgICAgICBpZiAob25saW5lU3RhdGVKU09OKSB7XG4gICAgICAgICAgICBjb25zdCBvbmxpbmVTdGF0ZSA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VPbmxpbmVTdGF0ZShvbmxpbmVTdGF0ZUpTT04pO1xuICAgICAgICAgICAgaWYgKG9ubGluZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVPbmxpbmVTdGF0ZUV2ZW50KG9ubGluZVN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHRoaXMuZWFybHlFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlV2ViU3RvcmFnZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVhcmx5RXZlbnRzID0gW107XG4gICAgICAgIC8vIFJlZ2lzdGVyIGEgd2luZG93IHVubG9hZCBob29rIHRvIHJlbW92ZSB0aGUgY2xpZW50IG1ldGFkYXRhIGVudHJ5IGZyb21cbiAgICAgICAgLy8gV2ViU3RvcmFnZSBldmVuIGlmIGBzaHV0ZG93bigpYCB3YXMgbm90IGNhbGxlZC5cbiAgICAgICAgdGhpcy53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCAoKSA9PiB0aGlzLnNodXRkb3duKCkpO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB3cml0ZVNlcXVlbmNlTnVtYmVyKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuc2V0SXRlbSh0aGlzLnNlcXVlbmNlTnVtYmVyS2V5LCBKU09OLnN0cmluZ2lmeShzZXF1ZW5jZU51bWJlcikpO1xuICAgIH1cbiAgICBnZXRBbGxBY3RpdmVRdWVyeVRhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RBY3RpdmVRdWVyeVRhcmdldHModGhpcy5hY3RpdmVDbGllbnRzKTtcbiAgICB9XG4gICAgaXNBY3RpdmVRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY3RpdmVDbGllbnRzLmZvckVhY2goKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5hY3RpdmVUYXJnZXRJZHMuaGFzKHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgYWRkUGVuZGluZ011dGF0aW9uKGJhdGNoSWQpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0TXV0YXRpb25TdGF0ZShiYXRjaElkLCAncGVuZGluZycpO1xuICAgIH1cbiAgICB1cGRhdGVNdXRhdGlvblN0YXRlKGJhdGNoSWQsIHN0YXRlLCBlcnJvcikge1xuICAgICAgICB0aGlzLnBlcnNpc3RNdXRhdGlvblN0YXRlKGJhdGNoSWQsIHN0YXRlLCBlcnJvcik7XG4gICAgICAgIC8vIE9uY2UgYSBmaW5hbCBtdXRhdGlvbiByZXN1bHQgaXMgb2JzZXJ2ZWQgYnkgb3RoZXIgY2xpZW50cywgdGhleSBubyBsb25nZXJcbiAgICAgICAgLy8gYWNjZXNzIHRoZSBtdXRhdGlvbidzIG1ldGFkYXRhIGVudHJ5LiBTaW5jZSBXZWJTdG9yYWdlIHJlcGxheXMgZXZlbnRzXG4gICAgICAgIC8vIGluIG9yZGVyLCBpdCBpcyBzYWZlIHRvIGRlbGV0ZSB0aGUgZW50cnkgcmlnaHQgYWZ0ZXIgdXBkYXRpbmcgaXQuXG4gICAgICAgIHRoaXMucmVtb3ZlTXV0YXRpb25TdGF0ZShiYXRjaElkKTtcbiAgICB9XG4gICAgYWRkTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCwgYWRkVG9BY3RpdmVUYXJnZXRJZHMgPSB0cnVlKSB7XG4gICAgICAgIGxldCBxdWVyeVN0YXRlID0gJ25vdC1jdXJyZW50JztcbiAgICAgICAgLy8gTG9va3VwIGFuIGV4aXN0aW5nIHF1ZXJ5IHN0YXRlIGlmIHRoZSB0YXJnZXQgSUQgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgICAgICAvLyBieSBhbm90aGVyIHRhYlxuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZVF1ZXJ5VGFyZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmFnZUl0ZW0gPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbShjcmVhdGVXZWJTdG9yYWdlUXVlcnlUYXJnZXRNZXRhZGF0YUtleSh0aGlzLnBlcnNpc3RlbmNlS2V5LCB0YXJnZXRJZCkpO1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2VJdGVtKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBRdWVyeVRhcmdldE1ldGFkYXRhLmZyb21XZWJTdG9yYWdlRW50cnkodGFyZ2V0SWQsIHN0b3JhZ2VJdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlTdGF0ZSA9IG1ldGFkYXRhLnN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgcXVlcnkgaXMgbGlzdGVuaW5nIHRvIGNhY2hlIG9ubHksIHRoZSB0YXJnZXQgSUQgc2hvdWxkIG5vdCBiZSByZWdpc3RlcmVkIHdpdGggdGhlXG4gICAgICAgIC8vIGxvY2FsIEZpcmVzdG9yZSBjbGllbnQgYXMgYW4gYWN0aXZlIHdhdGNoIHRhcmdldC5cbiAgICAgICAgaWYgKGFkZFRvQWN0aXZlVGFyZ2V0SWRzKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsQ2xpZW50U3RhdGUuYWRkUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVyc2lzdENsaWVudFN0YXRlKCk7XG4gICAgICAgIHJldHVybiBxdWVyeVN0YXRlO1xuICAgIH1cbiAgICByZW1vdmVMb2NhbFF1ZXJ5VGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMubG9jYWxDbGllbnRTdGF0ZS5yZW1vdmVRdWVyeVRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgIHRoaXMucGVyc2lzdENsaWVudFN0YXRlKCk7XG4gICAgfVxuICAgIGlzTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbENsaWVudFN0YXRlLmFjdGl2ZVRhcmdldElkcy5oYXModGFyZ2V0SWQpO1xuICAgIH1cbiAgICBjbGVhclF1ZXJ5U3RhdGUodGFyZ2V0SWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGNyZWF0ZVdlYlN0b3JhZ2VRdWVyeVRhcmdldE1ldGFkYXRhS2V5KHRoaXMucGVyc2lzdGVuY2VLZXksIHRhcmdldElkKSk7XG4gICAgfVxuICAgIHVwZGF0ZVF1ZXJ5U3RhdGUodGFyZ2V0SWQsIHN0YXRlLCBlcnJvcikge1xuICAgICAgICB0aGlzLnBlcnNpc3RRdWVyeVRhcmdldFN0YXRlKHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpO1xuICAgIH1cbiAgICBoYW5kbGVVc2VyQ2hhbmdlKHVzZXIsIHJlbW92ZWRCYXRjaElkcywgYWRkZWRCYXRjaElkcykge1xuICAgICAgICByZW1vdmVkQmF0Y2hJZHMuZm9yRWFjaChiYXRjaElkID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTXV0YXRpb25TdGF0ZShiYXRjaElkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSB1c2VyO1xuICAgICAgICBhZGRlZEJhdGNoSWRzLmZvckVhY2goYmF0Y2hJZCA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdNdXRhdGlvbihiYXRjaElkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldE9ubGluZVN0YXRlKG9ubGluZVN0YXRlKSB7XG4gICAgICAgIHRoaXMucGVyc2lzdE9ubGluZVN0YXRlKG9ubGluZVN0YXRlKTtcbiAgICB9XG4gICAgbm90aWZ5QnVuZGxlTG9hZGVkKGNvbGxlY3Rpb25Hcm91cHMpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0QnVuZGxlTG9hZGVkU3RhdGUoY29sbGVjdGlvbkdyb3Vwcyk7XG4gICAgfVxuICAgIHNodXRkb3duKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgdGhpcy5zdG9yYWdlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVJdGVtKHRoaXMubG9jYWxDbGllbnRTdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRhLCAnUkVBRCcsIGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGEsICdTRVQnLCBrZXksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckYSwgJ1JFTU9WRScsIGtleSk7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxuICAgIGhhbmRsZVdlYlN0b3JhZ2VFdmVudChldmVudCkge1xuICAgICAgICAvLyBOb3RlOiBUaGUgZnVuY3Rpb24gaXMgdHlwZWQgdG8gdGFrZSBFdmVudCB0byBiZSBpbnRlcmZhY2UtY29tcGF0aWJsZSB3aXRoXG4gICAgICAgIC8vIGBXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcmAuXG4gICAgICAgIGNvbnN0IHN0b3JhZ2VFdmVudCA9IGV2ZW50O1xuICAgICAgICBpZiAoc3RvcmFnZUV2ZW50LnN0b3JhZ2VBcmVhID09PSB0aGlzLnN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckYSwgJ0VWRU5UJywgc3RvcmFnZUV2ZW50LmtleSwgc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlRXZlbnQua2V5ID09PSB0aGlzLmxvY2FsQ2xpZW50U3RvcmFnZUtleSkge1xuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdSZWNlaXZlZCBXZWJTdG9yYWdlIG5vdGlmaWNhdGlvbiBmb3IgbG9jYWwgY2hhbmdlLiBBbm90aGVyIGNsaWVudCBtaWdodCBoYXZlICcgK1xuICAgICAgICAgICAgICAgICAgICAnZ2FyYmFnZS1jb2xsZWN0ZWQgb3VyIHN0YXRlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhcmx5RXZlbnRzLnB1c2goc3RvcmFnZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50LmtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudFN0YXRlS2V5UmUudGVzdChzdG9yYWdlRXZlbnQua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFN0YXRlID0gdGhpcy5mcm9tV2ViU3RvcmFnZUNsaWVudFN0YXRlKHN0b3JhZ2VFdmVudC5rZXksIHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDbGllbnRTdGF0ZUV2ZW50KGNsaWVudFN0YXRlLmNsaWVudElkLCBjbGllbnRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRJZCA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VDbGllbnRTdGF0ZUtleShzdG9yYWdlRXZlbnQua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUNsaWVudFN0YXRlRXZlbnQoY2xpZW50SWQsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubXV0YXRpb25CYXRjaEtleVJlLnRlc3Qoc3RvcmFnZUV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXV0YXRpb25NZXRhZGF0YSA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VNdXRhdGlvbk1ldGFkYXRhKHN0b3JhZ2VFdmVudC5rZXksIHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXV0YXRpb25NZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZU11dGF0aW9uQmF0Y2hFdmVudChtdXRhdGlvbk1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnF1ZXJ5VGFyZ2V0S2V5UmUudGVzdChzdG9yYWdlRXZlbnQua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBxdWVyeVRhcmdldE1ldGFkYXRhID0gdGhpcy5mcm9tV2ViU3RvcmFnZVF1ZXJ5VGFyZ2V0TWV0YWRhdGEoc3RvcmFnZUV2ZW50LmtleSwgc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWVyeVRhcmdldE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUXVlcnlUYXJnZXRFdmVudChxdWVyeVRhcmdldE1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdG9yYWdlRXZlbnQua2V5ID09PSB0aGlzLm9ubGluZVN0YXRlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlRXZlbnQubmV3VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9ubGluZVN0YXRlID0gdGhpcy5mcm9tV2ViU3RvcmFnZU9ubGluZVN0YXRlKHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25saW5lU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVPbmxpbmVTdGF0ZUV2ZW50KG9ubGluZVN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdG9yYWdlRXZlbnQua2V5ID09PSB0aGlzLnNlcXVlbmNlTnVtYmVyS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyID0gZnJvbVdlYlN0b3JhZ2VTZXF1ZW5jZU51bWJlcihzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXIgIT09IExpc3RlblNlcXVlbmNlLklOVkFMSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXJIYW5kbGVyKHNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdG9yYWdlRXZlbnQua2V5ID09PSB0aGlzLmJ1bmRsZUxvYWRlZEtleSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uR3JvdXBzID0gdGhpcy5mcm9tV2ViU3RvcmVCdW5kbGVMb2FkZWRTdGF0ZShzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjb2xsZWN0aW9uR3JvdXBzLm1hcChjZyA9PiB0aGlzLnN5bmNFbmdpbmUuc3luY2hyb25pemVXaXRoQ2hhbmdlZERvY3VtZW50cyhjZykpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbG9jYWxDbGllbnRTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlQ2xpZW50cy5nZXQodGhpcy5sb2NhbENsaWVudElkKTtcbiAgICB9XG4gICAgcGVyc2lzdENsaWVudFN0YXRlKCkge1xuICAgICAgICB0aGlzLnNldEl0ZW0odGhpcy5sb2NhbENsaWVudFN0b3JhZ2VLZXksIHRoaXMubG9jYWxDbGllbnRTdGF0ZS50b1dlYlN0b3JhZ2VKU09OKCkpO1xuICAgIH1cbiAgICBwZXJzaXN0TXV0YXRpb25TdGF0ZShiYXRjaElkLCBzdGF0ZSwgZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbXV0YXRpb25TdGF0ZSA9IG5ldyBNdXRhdGlvbk1ldGFkYXRhKHRoaXMuY3VycmVudFVzZXIsIGJhdGNoSWQsIHN0YXRlLCBlcnJvcik7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uS2V5ID0gY3JlYXRlV2ViU3RvcmFnZU11dGF0aW9uQmF0Y2hLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgdGhpcy5jdXJyZW50VXNlciwgYmF0Y2hJZCk7XG4gICAgICAgIHRoaXMuc2V0SXRlbShtdXRhdGlvbktleSwgbXV0YXRpb25TdGF0ZS50b1dlYlN0b3JhZ2VKU09OKCkpO1xuICAgIH1cbiAgICByZW1vdmVNdXRhdGlvblN0YXRlKGJhdGNoSWQpIHtcbiAgICAgICAgY29uc3QgbXV0YXRpb25LZXkgPSBjcmVhdGVXZWJTdG9yYWdlTXV0YXRpb25CYXRjaEtleSh0aGlzLnBlcnNpc3RlbmNlS2V5LCB0aGlzLmN1cnJlbnRVc2VyLCBiYXRjaElkKTtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKG11dGF0aW9uS2V5KTtcbiAgICB9XG4gICAgcGVyc2lzdE9ubGluZVN0YXRlKG9ubGluZVN0YXRlKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMubG9jYWxDbGllbnRJZCxcbiAgICAgICAgICAgIG9ubGluZVN0YXRlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKHRoaXMub25saW5lU3RhdGVLZXksIEpTT04uc3RyaW5naWZ5KGVudHJ5KSk7XG4gICAgfVxuICAgIHBlcnNpc3RRdWVyeVRhcmdldFN0YXRlKHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gY3JlYXRlV2ViU3RvcmFnZVF1ZXJ5VGFyZ2V0TWV0YWRhdGFLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgdGFyZ2V0SWQpO1xuICAgICAgICBjb25zdCB0YXJnZXRNZXRhZGF0YSA9IG5ldyBRdWVyeVRhcmdldE1ldGFkYXRhKHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpO1xuICAgICAgICB0aGlzLnNldEl0ZW0odGFyZ2V0S2V5LCB0YXJnZXRNZXRhZGF0YS50b1dlYlN0b3JhZ2VKU09OKCkpO1xuICAgIH1cbiAgICBwZXJzaXN0QnVuZGxlTG9hZGVkU3RhdGUoY29sbGVjdGlvbkdyb3Vwcykge1xuICAgICAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbShjb2xsZWN0aW9uR3JvdXBzKSk7XG4gICAgICAgIHRoaXMuc2V0SXRlbSh0aGlzLmJ1bmRsZUxvYWRlZEtleSwganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGNsaWVudCBzdGF0ZSBrZXkgaW4gV2ViU3RvcmFnZS4gUmV0dXJucyBudWxsIGlmIHRoZSBrZXkgZG9lcyBub3RcbiAgICAgKiBtYXRjaCB0aGUgZXhwZWN0ZWQga2V5IGZvcm1hdC5cbiAgICAgKi9cbiAgICBmcm9tV2ViU3RvcmFnZUNsaWVudFN0YXRlS2V5KGtleSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHRoaXMuY2xpZW50U3RhdGVLZXlSZS5leGVjKGtleSk7XG4gICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgY2xpZW50IHN0YXRlIGluIFdlYlN0b3JhZ2UuIFJldHVybnMgJ251bGwnIGlmIHRoZSB2YWx1ZSBjb3VsZCBub3RcbiAgICAgKiBiZSBwYXJzZWQuXG4gICAgICovXG4gICAgZnJvbVdlYlN0b3JhZ2VDbGllbnRTdGF0ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudElkID0gdGhpcy5mcm9tV2ViU3RvcmFnZUNsaWVudFN0YXRlS2V5KGtleSk7XG4gICAgICAgIHJldHVybiBSZW1vdGVDbGllbnRTdGF0ZS5mcm9tV2ViU3RvcmFnZUVudHJ5KGNsaWVudElkLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIG11dGF0aW9uIGJhdGNoIHN0YXRlIGluIFdlYlN0b3JhZ2UuIFJldHVybnMgJ251bGwnIGlmIHRoZSB2YWx1ZVxuICAgICAqIGNvdWxkIG5vdCBiZSBwYXJzZWQuXG4gICAgICovXG4gICAgZnJvbVdlYlN0b3JhZ2VNdXRhdGlvbk1ldGFkYXRhKGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLm11dGF0aW9uQmF0Y2hLZXlSZS5leGVjKGtleSk7XG4gICAgICAgIGNvbnN0IGJhdGNoSWQgPSBOdW1iZXIobWF0Y2hbMV0pO1xuICAgICAgICBjb25zdCB1c2VySWQgPSBtYXRjaFsyXSAhPT0gdW5kZWZpbmVkID8gbWF0Y2hbMl0gOiBudWxsO1xuICAgICAgICByZXR1cm4gTXV0YXRpb25NZXRhZGF0YS5mcm9tV2ViU3RvcmFnZUVudHJ5KG5ldyBVc2VyKHVzZXJJZCksIGJhdGNoSWQsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgcXVlcnkgdGFyZ2V0IHN0YXRlIGZyb20gV2ViU3RvcmFnZS4gUmV0dXJucyAnbnVsbCcgaWYgdGhlIHZhbHVlXG4gICAgICogY291bGQgbm90IGJlIHBhcnNlZC5cbiAgICAgKi9cbiAgICBmcm9tV2ViU3RvcmFnZVF1ZXJ5VGFyZ2V0TWV0YWRhdGEoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHRoaXMucXVlcnlUYXJnZXRLZXlSZS5leGVjKGtleSk7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gTnVtYmVyKG1hdGNoWzFdKTtcbiAgICAgICAgcmV0dXJuIFF1ZXJ5VGFyZ2V0TWV0YWRhdGEuZnJvbVdlYlN0b3JhZ2VFbnRyeSh0YXJnZXRJZCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYW4gb25saW5lIHN0YXRlIGZyb20gV2ViU3RvcmFnZS4gUmV0dXJucyAnbnVsbCcgaWYgdGhlIHZhbHVlXG4gICAgICogY291bGQgbm90IGJlIHBhcnNlZC5cbiAgICAgKi9cbiAgICBmcm9tV2ViU3RvcmFnZU9ubGluZVN0YXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBTaGFyZWRPbmxpbmVTdGF0ZS5mcm9tV2ViU3RvcmFnZUVudHJ5KHZhbHVlKTtcbiAgICB9XG4gICAgZnJvbVdlYlN0b3JlQnVuZGxlTG9hZGVkU3RhdGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVNdXRhdGlvbkJhdGNoRXZlbnQobXV0YXRpb25CYXRjaCkge1xuICAgICAgICBpZiAobXV0YXRpb25CYXRjaC51c2VyLnVpZCAhPT0gdGhpcy5jdXJyZW50VXNlci51aWQpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckYSwgYElnbm9yaW5nIG11dGF0aW9uIGZvciBub24tYWN0aXZlIHVzZXIgJHttdXRhdGlvbkJhdGNoLnVzZXIudWlkfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN5bmNFbmdpbmUuYXBwbHlCYXRjaFN0YXRlKG11dGF0aW9uQmF0Y2guYmF0Y2hJZCwgbXV0YXRpb25CYXRjaC5zdGF0ZSwgbXV0YXRpb25CYXRjaC5lcnJvcik7XG4gICAgfVxuICAgIGhhbmRsZVF1ZXJ5VGFyZ2V0RXZlbnQodGFyZ2V0TWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY0VuZ2luZS5hcHBseVRhcmdldFN0YXRlKHRhcmdldE1ldGFkYXRhLnRhcmdldElkLCB0YXJnZXRNZXRhZGF0YS5zdGF0ZSwgdGFyZ2V0TWV0YWRhdGEuZXJyb3IpO1xuICAgIH1cbiAgICBoYW5kbGVDbGllbnRTdGF0ZUV2ZW50KGNsaWVudElkLCBjbGllbnRTdGF0ZSkge1xuICAgICAgICBjb25zdCB1cGRhdGVkQ2xpZW50cyA9IGNsaWVudFN0YXRlXG4gICAgICAgICAgICA/IHRoaXMuYWN0aXZlQ2xpZW50cy5pbnNlcnQoY2xpZW50SWQsIGNsaWVudFN0YXRlKVxuICAgICAgICAgICAgOiB0aGlzLmFjdGl2ZUNsaWVudHMucmVtb3ZlKGNsaWVudElkKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdUYXJnZXRzID0gdGhpcy5leHRyYWN0QWN0aXZlUXVlcnlUYXJnZXRzKHRoaXMuYWN0aXZlQ2xpZW50cyk7XG4gICAgICAgIGNvbnN0IG5ld1RhcmdldHMgPSB0aGlzLmV4dHJhY3RBY3RpdmVRdWVyeVRhcmdldHModXBkYXRlZENsaWVudHMpO1xuICAgICAgICBjb25zdCBhZGRlZFRhcmdldHMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZFRhcmdldHMgPSBbXTtcbiAgICAgICAgbmV3VGFyZ2V0cy5mb3JFYWNoKHRhcmdldElkID0+IHtcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdUYXJnZXRzLmhhcyh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgICAgICBhZGRlZFRhcmdldHMucHVzaCh0YXJnZXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBleGlzdGluZ1RhcmdldHMuZm9yRWFjaCh0YXJnZXRJZCA9PiB7XG4gICAgICAgICAgICBpZiAoIW5ld1RhcmdldHMuaGFzKHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRUYXJnZXRzLnB1c2godGFyZ2V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY0VuZ2luZS5hcHBseUFjdGl2ZVRhcmdldHNDaGFuZ2UoYWRkZWRUYXJnZXRzLCByZW1vdmVkVGFyZ2V0cykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudHMgPSB1cGRhdGVkQ2xpZW50cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZU9ubGluZVN0YXRlRXZlbnQob25saW5lU3RhdGUpIHtcbiAgICAgICAgLy8gV2UgY2hlY2sgd2hldGhlciB0aGUgY2xpZW50IHRoYXQgd3JvdGUgdGhpcyBvbmxpbmUgc3RhdGUgaXMgc3RpbGwgYWN0aXZlXG4gICAgICAgIC8vIGJ5IGNvbXBhcmluZyBpdHMgY2xpZW50IElEIHRvIHRoZSBsaXN0IG9mIGNsaWVudHMga2VwdCBhY3RpdmUgaW5cbiAgICAgICAgLy8gSW5kZXhlZERiLiBJZiBhIGNsaWVudCBkb2VzIG5vdCB1cGRhdGUgdGhlaXIgSW5kZXhlZERiIGNsaWVudCBzdGF0ZVxuICAgICAgICAvLyB3aXRoaW4gNSBzZWNvbmRzLCBpdCBpcyBjb25zaWRlcmVkIGluYWN0aXZlIGFuZCB3ZSBkb24ndCBlbWl0IGFuIG9ubGluZVxuICAgICAgICAvLyBzdGF0ZSBldmVudC5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ2xpZW50cy5nZXQob25saW5lU3RhdGUuY2xpZW50SWQpKSB7XG4gICAgICAgICAgICB0aGlzLm9ubGluZVN0YXRlSGFuZGxlcihvbmxpbmVTdGF0ZS5vbmxpbmVTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXh0cmFjdEFjdGl2ZVF1ZXJ5VGFyZ2V0cyhjbGllbnRzKSB7XG4gICAgICAgIGxldCBhY3RpdmVUYXJnZXRzID0gdGFyZ2V0SWRTZXQoKTtcbiAgICAgICAgY2xpZW50cy5mb3JFYWNoKChrZXYsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBhY3RpdmVUYXJnZXRzID0gYWN0aXZlVGFyZ2V0cy51bmlvbldpdGgodmFsdWUuYWN0aXZlVGFyZ2V0SWRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhY3RpdmVUYXJnZXRzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21XZWJTdG9yYWdlU2VxdWVuY2VOdW1iZXIoc2VxU3RyaW5nKSB7XG4gICAgbGV0IHNlcXVlbmNlTnVtYmVyID0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRDtcbiAgICBpZiAoc2VxU3RyaW5nICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc2VxU3RyaW5nKTtcbiAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIHBhcnNlZCA9PT0gJ251bWJlcicsIDB4NzdhYywgeyBzZXFTdHJpbmcgfSk7XG4gICAgICAgICAgICBzZXF1ZW5jZU51bWJlciA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRhLCAnRmFpbGVkIHRvIHJlYWQgc2VxdWVuY2UgbnVtYmVyIGZyb20gV2ViU3RvcmFnZScsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXF1ZW5jZU51bWJlcjtcbn1cbi8qKlxuICogYE1lbW9yeVNoYXJlZENsaWVudFN0YXRlYCBpcyBhIHNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBTaGFyZWRDbGllbnRTdGF0ZSBmb3JcbiAqIGNsaWVudHMgdXNpbmcgbWVtb3J5IHBlcnNpc3RlbmNlLiBUaGUgc3RhdGUgaW4gdGhpcyBjbGFzcyByZW1haW5zIGZ1bGx5XG4gKiBpc29sYXRlZCBhbmQgbm8gc3luY2hyb25pemF0aW9uIGlzIHBlcmZvcm1lZC5cbiAqL1xuY2xhc3MgTWVtb3J5U2hhcmVkQ2xpZW50U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxvY2FsU3RhdGUgPSBuZXcgTG9jYWxDbGllbnRTdGF0ZSgpO1xuICAgICAgICB0aGlzLnF1ZXJ5U3RhdGUgPSB7fTtcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVySGFuZGxlciA9IG51bGw7XG4gICAgfVxuICAgIGFkZFBlbmRpbmdNdXRhdGlvbihiYXRjaElkKSB7XG4gICAgICAgIC8vIE5vIG9wLlxuICAgIH1cbiAgICB1cGRhdGVNdXRhdGlvblN0YXRlKGJhdGNoSWQsIHN0YXRlLCBlcnJvcikge1xuICAgICAgICAvLyBObyBvcC5cbiAgICB9XG4gICAgYWRkTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCwgYWRkVG9BY3RpdmVUYXJnZXRJZHMgPSB0cnVlKSB7XG4gICAgICAgIGlmIChhZGRUb0FjdGl2ZVRhcmdldElkcykge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFN0YXRlLmFkZFF1ZXJ5VGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVN0YXRlW3RhcmdldElkXSB8fCAnbm90LWN1cnJlbnQnO1xuICAgIH1cbiAgICB1cGRhdGVRdWVyeVN0YXRlKHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5xdWVyeVN0YXRlW3RhcmdldElkXSA9IHN0YXRlO1xuICAgIH1cbiAgICByZW1vdmVMb2NhbFF1ZXJ5VGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdGF0ZS5yZW1vdmVRdWVyeVRhcmdldCh0YXJnZXRJZCk7XG4gICAgfVxuICAgIGlzTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0YXRlLmFjdGl2ZVRhcmdldElkcy5oYXModGFyZ2V0SWQpO1xuICAgIH1cbiAgICBjbGVhclF1ZXJ5U3RhdGUodGFyZ2V0SWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucXVlcnlTdGF0ZVt0YXJnZXRJZF07XG4gICAgfVxuICAgIGdldEFsbEFjdGl2ZVF1ZXJ5VGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTdGF0ZS5hY3RpdmVUYXJnZXRJZHM7XG4gICAgfVxuICAgIGlzQWN0aXZlUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTdGF0ZS5hY3RpdmVUYXJnZXRJZHMuaGFzKHRhcmdldElkKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdGF0ZSA9IG5ldyBMb2NhbENsaWVudFN0YXRlKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgaGFuZGxlVXNlckNoYW5nZSh1c2VyLCByZW1vdmVkQmF0Y2hJZHMsIGFkZGVkQmF0Y2hJZHMpIHtcbiAgICAgICAgLy8gTm8gb3AuXG4gICAgfVxuICAgIHNldE9ubGluZVN0YXRlKG9ubGluZVN0YXRlKSB7XG4gICAgICAgIC8vIE5vIG9wLlxuICAgIH1cbiAgICBzaHV0ZG93bigpIHsgfVxuICAgIHdyaXRlU2VxdWVuY2VOdW1iZXIoc2VxdWVuY2VOdW1iZXIpIHsgfVxuICAgIG5vdGlmeUJ1bmRsZUxvYWRlZChjb2xsZWN0aW9uR3JvdXBzKSB7XG4gICAgICAgIC8vIE5vIG9wLlxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE5vb3BDb25uZWN0aXZpdHlNb25pdG9yIHtcbiAgICBhZGRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICAvLyBOby1vcC5cbiAgICB9XG4gICAgc2h1dGRvd24oKSB7XG4gICAgICAgIC8vIE5vLW9wLlxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZXMgYSBzaW1wbGUgaGVscGVyIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB0aGUgU3RyZWFtIGludGVyZmFjZSB0b1xuICogYnJpZGdlIHRvIG90aGVyIGltcGxlbWVudGF0aW9ucyB0aGF0IGFyZSBzdHJlYW1zIGJ1dCBkbyBub3QgaW1wbGVtZW50IHRoZVxuICogaW50ZXJmYWNlLiBUaGUgc3RyZWFtIGNhbGxiYWNrcyBhcmUgaW52b2tlZCB3aXRoIHRoZSBjYWxsT24uLi4gbWV0aG9kcy5cbiAqL1xuY2xhc3MgU3RyZWFtQnJpZGdlIHtcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICAgIHRoaXMuc2VuZEZuID0gYXJncy5zZW5kRm47XG4gICAgICAgIHRoaXMuY2xvc2VGbiA9IGFyZ3MuY2xvc2VGbjtcbiAgICB9XG4gICAgb25Db25uZWN0ZWQoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwcGVkT25Db25uZWN0ZWQgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgb25PcGVuKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZE9uT3BlbiA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBvbkNsb3NlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZE9uQ2xvc2UgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgb25NZXNzYWdlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZE9uTWVzc2FnZSA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZUZuKCk7XG4gICAgfVxuICAgIHNlbmQobXNnKSB7XG4gICAgICAgIHRoaXMuc2VuZEZuKG1zZyk7XG4gICAgfVxuICAgIGNhbGxPbkNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkT25Db25uZWN0ZWQoKTtcbiAgICB9XG4gICAgY2FsbE9uT3BlbigpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkT25PcGVuKCk7XG4gICAgfVxuICAgIGNhbGxPbkNsb3NlKGVycikge1xuICAgICAgICB0aGlzLndyYXBwZWRPbkNsb3NlKGVycik7XG4gICAgfVxuICAgIGNhbGxPbk1lc3NhZ2UobXNnKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZE9uTWVzc2FnZShtc2cpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIG1vc3QgcmVjZW50IGludm9jYXRpb24gb2ZcbiAqIGBnZW5lcmF0ZVVuaXF1ZURlYnVnSWQoKWAsIG9yIG51bGwgaWYgaXQgaGFzIG5ldmVyIGJlZW4gaW52b2tlZC5cbiAqL1xubGV0IGxhc3RVbmlxdWVEZWJ1Z0lkID0gbnVsbDtcbi8qKlxuICogR2VuZXJhdGVzIGFuZCByZXR1cm5zIGFuIGluaXRpYWwgdmFsdWUgZm9yIGBsYXN0VW5pcXVlRGVidWdJZGAuXG4gKlxuICogVGhlIHJldHVybmVkIHZhbHVlIGlzIHJhbmRvbWx5IHNlbGVjdGVkIGZyb20gYSByYW5nZSBvZiBpbnRlZ2VycyB0aGF0IGFyZVxuICogcmVwcmVzZW50ZWQgYXMgOCBoZXhhZGVjaW1hbCBkaWdpdHMuIFRoaXMgbWVhbnMgdGhhdCAod2l0aGluIHJlYXNvbikgYW55XG4gKiBudW1iZXJzIGdlbmVyYXRlZCBieSBpbmNyZW1lbnRpbmcgdGhlIHJldHVybmVkIG51bWJlciBieSAxIHdpbGwgYWxzbyBiZVxuICogcmVwcmVzZW50ZWQgYnkgOCBoZXhhZGVjaW1hbCBkaWdpdHMuIFRoaXMgbGVhZHMgdG8gYWxsIFwiSURzXCIgaGF2aW5nIHRoZSBzYW1lXG4gKiBsZW5ndGggd2hlbiBjb252ZXJ0ZWQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcsIG1ha2luZyByZWFkaW5nIGxvZ3MgY29udGFpbmluZ1xuICogdGhlc2UgSURzIGVhc2llciB0byBmb2xsb3cuIEFuZCBzaW5jZSB0aGUgcmV0dXJuIHZhbHVlIGlzIHJhbmRvbWx5IHNlbGVjdGVkXG4gKiBpdCB3aWxsIGhlbHAgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGxvZ3MgZnJvbSBkaWZmZXJlbnQgZXhlY3V0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVJbml0aWFsVW5pcXVlRGVidWdJZCgpIHtcbiAgICBjb25zdCBtaW5SZXN1bHQgPSAweDEwMDAwMDAwO1xuICAgIGNvbnN0IG1heFJlc3VsdCA9IDB4OTAwMDAwMDA7XG4gICAgY29uc3QgcmVzdWx0UmFuZ2UgPSBtYXhSZXN1bHQgLSBtaW5SZXN1bHQ7XG4gICAgY29uc3QgcmVzdWx0T2Zmc2V0ID0gTWF0aC5yb3VuZChyZXN1bHRSYW5nZSAqIE1hdGgucmFuZG9tKCkpO1xuICAgIHJldHVybiBtaW5SZXN1bHQgKyByZXN1bHRPZmZzZXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyBhIHVuaXF1ZSBJRCBhcyBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgSUQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBkZWJ1ZyBsb2dnaW5nIG1lc3NhZ2VzIHRvIGhlbHBcbiAqIGNvcnJlbGF0ZSBsb2cgbWVzc2FnZXMgdGhhdCBtYXkgYmUgc3BhdGlhbGx5IHNlcGFyYXRlZCBpbiB0aGUgbG9ncywgYnV0XG4gKiBsb2dpY2FsbHkgcmVsYXRlZC4gRm9yIGV4YW1wbGUsIGEgbmV0d29yayBjb25uZWN0aW9uIGNvdWxkIGluY2x1ZGUgdGhlIHNhbWVcbiAqIFwiZGVidWcgSURcIiBzdHJpbmcgaW4gYWxsIG9mIGl0cyBsb2cgbWVzc2FnZXMgdG8gaGVscCB0cmFjZSBhIHNwZWNpZmljXG4gKiBjb25uZWN0aW9uIG92ZXIgdGltZS5cbiAqXG4gKiBAcmV0dXJucyB0aGUgMTAtY2hhcmFjdGVyIGdlbmVyYXRlZCBJRCAoZS5nLiBcIjB4YTFiMmMzZDRcIikuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVW5pcXVlRGVidWdJZCgpIHtcbiAgICBpZiAobGFzdFVuaXF1ZURlYnVnSWQgPT09IG51bGwpIHtcbiAgICAgICAgbGFzdFVuaXF1ZURlYnVnSWQgPSBnZW5lcmF0ZUluaXRpYWxVbmlxdWVEZWJ1Z0lkKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsYXN0VW5pcXVlRGVidWdJZCsrO1xuICAgIH1cbiAgICByZXR1cm4gJzB4JyArIGxhc3RVbmlxdWVEZWJ1Z0lkLnRvU3RyaW5nKDE2KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qXG4gKiBVdGlsaXRpZXMgZm9yIGRlYWxpbmcgd2l0aCBub2RlLmpzLXN0eWxlIEFQSXMuIFNlZSBub2RlUHJvbWlzZSBmb3IgbW9yZVxuICogZGV0YWlscy5cbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGEgbm9kZS1zdHlsZSBjYWxsYmFjayB0aGF0IHJlc29sdmVzIG9yIHJlamVjdHMgYSBuZXcgUHJvbWlzZS4gVGhlXG4gKiBjYWxsYmFjayBpcyBwYXNzZWQgdG8gdGhlIGdpdmVuIGFjdGlvbiB3aGljaCBjYW4gdGhlbiB1c2UgdGhlIGNhbGxiYWNrIGFzXG4gKiBhIHBhcmFtZXRlciB0byBhIG5vZGUtc3R5bGUgZnVuY3Rpb24uXG4gKlxuICogVGhlIGludGVudCBpcyB0byBkaXJlY3RseSBicmlkZ2UgYSBub2RlLXN0eWxlIGZ1bmN0aW9uICh3aGljaCB0YWtlcyBhXG4gKiBjYWxsYmFjaykgaW50byBhIFByb21pc2Ugd2l0aG91dCBtYW51YWxseSBjb252ZXJ0aW5nIGJldHdlZW4gdGhlIG5vZGUtc3R5bGVcbiAqIGNhbGxiYWNrIGFuZCB0aGUgcHJvbWlzZSBhdCBlYWNoIGNhbGwuXG4gKlxuICogSW4gZWZmZWN0IGl0IGFsbG93cyB5b3UgdG8gY29udmVydDpcbiAqXG4gKiBAZXhhbXBsZVxuICogbmV3IFByb21pc2UoKHJlc29sdmU6ICh2YWx1ZT86IGZzLlN0YXRzKSA9PiB2b2lkLFxuICogICAgICAgICAgICAgIHJlamVjdDogKGVycm9yPzogYW55KSA9PiB2b2lkKSA9PiB7XG4gKiAgIGZzLnN0YXQocGF0aCwgKGVycm9yPzogYW55LCBzdGF0PzogZnMuU3RhdHMpID0+IHtcbiAqICAgICBpZiAoZXJyb3IpIHtcbiAqICAgICAgIHJlamVjdChlcnJvcik7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgIHJlc29sdmUoc3RhdCk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqIH0pO1xuICpcbiAqIEludG9cbiAqIEBleGFtcGxlXG4gKiBub2RlUHJvbWlzZSgoY2FsbGJhY2s6IE5vZGVDYWxsYmFjazxmcy5TdGF0cz4pID0+IHtcbiAqICAgZnMuc3RhdChwYXRoLCBjYWxsYmFjayk7XG4gKiB9KTtcbiAqXG4gKiBAcGFyYW0gYWN0aW9uIC0gYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgbm9kZS1zdHlsZSBjYWxsYmFjayBhcyBhbiBhcmd1bWVudFxuICogICAgIGFuZCB0aGVuIHVzZXMgdGhhdCBjYWxsYmFjayB0byBpbnZva2Ugc29tZSBub2RlLXN0eWxlIEFQSS5cbiAqIEByZXR1cm5zIGEgbmV3IFByb21pc2Ugd2hpY2ggd2lsbCBiZSByZWplY3RlZCBpZiB0aGUgY2FsbGJhY2sgaXMgZ2l2ZW4gdGhlXG4gKiAgICAgZmlyc3QgRXJyb3IgcGFyYW1ldGVyIG9yIHdpbGwgcmVzb2x2ZSB0byB0aGUgdmFsdWUgZ2l2ZW4gb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBub2RlUHJvbWlzZShhY3Rpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBhY3Rpb24oKGVycm9yLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIFRPRE86IEZldGNoIHJ1bnRpbWUgdmVyc2lvbiBmcm9tIGdycGMtanMvcGFja2FnZS5qc29uIGluc3RlYWRcbi8vIHdoZW4gdGhlcmUncyBhIGNsZWFuZXIgd2F5IHRvIGR5bmFtaWMgcmVxdWlyZSBKU09OIGluIGJvdGggTm9kZSBFU00gYW5kIENKU1xuY29uc3QgZ3JwY1ZlcnNpb24gPSAnMS45LjE1JztcbmNvbnN0IExPR19UQUckOSA9ICdHcnBjQ29ubmVjdGlvbic7XG5jb25zdCBYX0dPT0dfQVBJX0NMSUVOVF9WQUxVRSA9IGBnbC1ub2RlLyR7cHJvY2Vzcy52ZXJzaW9ucy5ub2RlfSBmaXJlLyR7U0RLX1ZFUlNJT059IGdycGMvJHtncnBjVmVyc2lvbn1gO1xuZnVuY3Rpb24gY3JlYXRlTWV0YWRhdGEoZGF0YWJhc2VQYXRoLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIGFwcElkLCBhcGlLZXkpIHtcbiAgICBoYXJkQXNzZXJ0KGF1dGhUb2tlbiA9PT0gbnVsbCB8fCBhdXRoVG9rZW4udHlwZSA9PT0gJ09BdXRoJywgMHg5MDQ4KTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBncnBjLk1ldGFkYXRhKCk7XG4gICAgaWYgKGF1dGhUb2tlbikge1xuICAgICAgICBhdXRoVG9rZW4uaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBtZXRhZGF0YS5zZXQoa2V5LCB2YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAoYXBwQ2hlY2tUb2tlbikge1xuICAgICAgICBhcHBDaGVja1Rva2VuLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gbWV0YWRhdGEuc2V0KGtleSwgdmFsdWUpKTtcbiAgICB9XG4gICAgaWYgKGFwcElkKSB7XG4gICAgICAgIG1ldGFkYXRhLnNldCgnWC1GaXJlYmFzZS1HTVBJRCcsIGFwcElkKTtcbiAgICB9XG4gICAgbWV0YWRhdGEuc2V0KCdYLUdvb2ctQXBpLUNsaWVudCcsIFhfR09PR19BUElfQ0xJRU5UX1ZBTFVFKTtcbiAgICAvLyBUaGVzZSBoZWFkZXJzIGFyZSB1c2VkIHRvIGltcHJvdmUgcm91dGluZyBhbmQgcHJvamVjdCBpc29sYXRpb24gYnkgdGhlXG4gICAgLy8gYmFja2VuZC5cbiAgICAvLyBUT0RPKGIvMTk5NzY3NzEyKTogV2UgYXJlIGtlZXBpbmcgJ0dvb2dsZS1DbG91ZC1SZXNvdXJjZS1QcmVmaXgnIHVudGlsIEVtdWxhdG9ycyBjYW4gYmVcbiAgICAvLyByZWxlYXNlZCB3aXRoIGNsLzQyODgyMDA0Ni4gQ3VycmVudGx5IGJsb2NrZWQgYmVjYXVzZSBFbXVsYXRvcnMgYXJlIG5vdyBidWlsdCB3aXRoIEphdmFcbiAgICAvLyAxMSBmcm9tIEdvb2dsZTMuXG4gICAgbWV0YWRhdGEuc2V0KCdHb29nbGUtQ2xvdWQtUmVzb3VyY2UtUHJlZml4JywgZGF0YWJhc2VQYXRoKTtcbiAgICBtZXRhZGF0YS5zZXQoJ3gtZ29vZy1yZXF1ZXN0LXBhcmFtcycsIGRhdGFiYXNlUGF0aCk7XG4gICAgaWYgKGFwaUtleSkge1xuICAgICAgICBtZXRhZGF0YS5zZXQoJ1gtR29vZy1BcGktS2V5JywgYXBpS2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xufVxuLyoqXG4gKiBBIENvbm5lY3Rpb24gaW1wbGVtZW50ZWQgYnkgR1JQQy1Ob2RlLlxuICovXG5jbGFzcyBHcnBjQ29ubmVjdGlvbiB7XG4gICAgZ2V0IHNob3VsZFJlc291cmNlUGF0aEJlSW5jbHVkZWRJblJlcXVlc3QoKSB7XG4gICAgICAgIC8vIEJvdGggYGludm9rZVJQQygpYCBhbmQgYGludm9rZVN0cmVhbWluZ1JQQygpYCBpZ25vcmUgdGhlaXIgYHBhdGhgIGFyZ3VtZW50cywgYW5kIGV4cGVjdFxuICAgICAgICAvLyB0aGUgXCJwYXRoXCIgdG8gYmUgcGFydCBvZiB0aGUgZ2l2ZW4gYHJlcXVlc3RgLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJvdG9zLCBkYXRhYmFzZUluZm8pIHtcbiAgICAgICAgdGhpcy5kYXRhYmFzZUluZm8gPSBkYXRhYmFzZUluZm87XG4gICAgICAgIC8vIFdlIGNhY2hlIHN0dWJzIGZvciB0aGUgbW9zdC1yZWNlbnRseS11c2VkIHRva2VuLlxuICAgICAgICB0aGlzLmNhY2hlZFN0dWIgPSBudWxsO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0aGlzLmZpcmVzdG9yZSA9IHByb3Rvc1snZ29vZ2xlJ11bJ2ZpcmVzdG9yZSddWyd2MSddO1xuICAgICAgICB0aGlzLmRhdGFiYXNlUGF0aCA9IGBwcm9qZWN0cy8ke2RhdGFiYXNlSW5mby5kYXRhYmFzZUlkLnByb2plY3RJZH0vZGF0YWJhc2VzLyR7ZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQuZGF0YWJhc2V9YDtcbiAgICB9XG4gICAgLyoqIG1hZGUgcHJvdGVjdGVkIGZvciB0ZXN0aW5nICovXG4gICAgZW5zdXJlQWN0aXZlU3R1YigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlZFN0dWIpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgJ0NyZWF0aW5nIEZpcmVzdG9yZSBzdHViLicpO1xuICAgICAgICAgICAgY29uc3QgY3JlZGVudGlhbHMgPSB0aGlzLmRhdGFiYXNlSW5mby5zc2xcbiAgICAgICAgICAgICAgICA/IGdycGMuY3JlZGVudGlhbHMuY3JlYXRlU3NsKClcbiAgICAgICAgICAgICAgICA6IGdycGMuY3JlZGVudGlhbHMuY3JlYXRlSW5zZWN1cmUoKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkU3R1YiA9IG5ldyB0aGlzLmZpcmVzdG9yZS5GaXJlc3RvcmUodGhpcy5kYXRhYmFzZUluZm8uaG9zdCwgY3JlZGVudGlhbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlZFN0dWI7XG4gICAgfVxuICAgIGludm9rZVJQQyhycGNOYW1lLCBwYXRoLCByZXF1ZXN0LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtSWQgPSBnZW5lcmF0ZVVuaXF1ZURlYnVnSWQoKTtcbiAgICAgICAgY29uc3Qgc3R1YiA9IHRoaXMuZW5zdXJlQWN0aXZlU3R1YigpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGNyZWF0ZU1ldGFkYXRhKHRoaXMuZGF0YWJhc2VQYXRoLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIHRoaXMuZGF0YWJhc2VJbmZvLmFwcElkLCB0aGlzLmRhdGFiYXNlSW5mby5hcGlLZXkpO1xuICAgICAgICBjb25zdCBqc29uUmVxdWVzdCA9IHsgZGF0YWJhc2U6IHRoaXMuZGF0YWJhc2VQYXRoLCAuLi5yZXF1ZXN0IH07XG4gICAgICAgIHJldHVybiBub2RlUHJvbWlzZSgoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgJHtzdHJlYW1JZH0gaW52b2tlZCB3aXRoIHJlcXVlc3Q6YCwgcmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gc3R1YltycGNOYW1lXShqc29uUmVxdWVzdCwgbWV0YWRhdGEsIChncnBjRXJyb3IsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGdycGNFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nICR7c3RyZWFtSWR9IGZhaWxlZCB3aXRoIGVycm9yOmAsIGdycGNFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBGaXJlc3RvcmVFcnJvcihtYXBDb2RlRnJvbVJwY0NvZGUoZ3JwY0Vycm9yLmNvZGUpLCBncnBjRXJyb3IubWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyAke3N0cmVhbUlkfSBjb21wbGV0ZWQgd2l0aCByZXNwb25zZTpgLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW52b2tlU3RyZWFtaW5nUlBDKHJwY05hbWUsIHBhdGgsIHJlcXVlc3QsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgZXhwZWN0ZWRSZXNwb25zZUNvdW50KSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbUlkID0gZ2VuZXJhdGVVbmlxdWVEZWJ1Z0lkKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VEZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nICR7c3RyZWFtSWR9IGludm9rZWQgKHN0cmVhbWluZykgd2l0aCByZXF1ZXN0OmAsIHJlcXVlc3QpO1xuICAgICAgICBjb25zdCBzdHViID0gdGhpcy5lbnN1cmVBY3RpdmVTdHViKCk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlTWV0YWRhdGEodGhpcy5kYXRhYmFzZVBhdGgsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgdGhpcy5kYXRhYmFzZUluZm8uYXBwSWQsIHRoaXMuZGF0YWJhc2VJbmZvLmFwaUtleSk7XG4gICAgICAgIGNvbnN0IGpzb25SZXF1ZXN0ID0geyAuLi5yZXF1ZXN0LCBkYXRhYmFzZTogdGhpcy5kYXRhYmFzZVBhdGggfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gc3R1YltycGNOYW1lXShqc29uUmVxdWVzdCwgbWV0YWRhdGEpO1xuICAgICAgICBsZXQgY2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuICAgICAgICBzdHJlYW0ub24oJ2RhdGEnLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAke3JwY05hbWV9ICR7c3RyZWFtSWR9IHJlY2VpdmVkIHJlc3VsdDpgLCByZXNwb25zZSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzcG9uc2UpO1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkUmVzcG9uc2VDb3VudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5sZW5ndGggPT09IGV4cGVjdGVkUmVzcG9uc2VDb3VudCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrRmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlRGVmZXJyZWQucmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyAke3N0cmVhbUlkfSBjb21wbGV0ZWQuYCk7XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrRmlyZWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja0ZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXNwb25zZURlZmVycmVkLnJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgKGdycGNFcnJvcikgPT4ge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyAke3N0cmVhbUlkfSBmYWlsZWQgd2l0aCBlcnJvcjpgLCBncnBjRXJyb3IpO1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IG1hcENvZGVGcm9tUnBjQ29kZShncnBjRXJyb3IuY29kZSk7XG4gICAgICAgICAgICByZXNwb25zZURlZmVycmVkLnJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoY29kZSwgZ3JwY0Vycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZURlZmVycmVkLnByb21pc2U7XG4gICAgfVxuICAgIC8vIFRPRE8obWlrZWxlaGVuKTogVGhpcyBcIm1ldGhvZFwiIGlzIGEgbW9uc3Rlci4gU2hvdWxkIGJlIHJlZmFjdG9yZWQuXG4gICAgb3BlblN0cmVhbShycGNOYW1lLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtSWQgPSBnZW5lcmF0ZVVuaXF1ZURlYnVnSWQoKTtcbiAgICAgICAgY29uc3Qgc3R1YiA9IHRoaXMuZW5zdXJlQWN0aXZlU3R1YigpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGNyZWF0ZU1ldGFkYXRhKHRoaXMuZGF0YWJhc2VQYXRoLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIHRoaXMuZGF0YWJhc2VJbmZvLmFwcElkLCB0aGlzLmRhdGFiYXNlSW5mby5hcGlLZXkpO1xuICAgICAgICBjb25zdCBncnBjU3RyZWFtID0gc3R1YltycGNOYW1lXShtZXRhZGF0YSk7XG4gICAgICAgIGxldCBjbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2xvc2UgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmNhbGxPbkNsb3NlKGVycik7XG4gICAgICAgICAgICAgICAgZ3JwY1N0cmVhbS5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFN0cmVhbUJyaWRnZSh7XG4gICAgICAgICAgICBzZW5kRm46IChtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSBzZW5kaW5nOmAsIG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncnBjU3RyZWFtLndyaXRlKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcHJvYmFibHkgbWVhbnMgd2UgZGlkbid0IGNvbmZvcm0gdG8gdGhlIHByb3RvLiAgTWFrZSBzdXJlIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2cgdGhlIG1lc3NhZ2Ugd2Ugc2VudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdGYWlsdXJlIHNlbmRpbmc6JywgbXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdFcnJvcjonLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25vdCBzZW5kaW5nIGJlY2F1c2UgZ1JQQyBzdHJlYW0gaXMgY2xvc2VkOicsIG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlRm46ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSBjbG9zZWQgbG9jYWxseSB2aWEgY2xvc2UoKS5gKTtcbiAgICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IG9uQ29ubmVjdGVkU2VudCA9IGZhbHNlO1xuICAgICAgICBncnBjU3RyZWFtLm9uKCdkYXRhJywgKG1zZykgPT4ge1xuICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSByZWNlaXZlZDpgLCBtc2cpO1xuICAgICAgICAgICAgICAgIC8vIEVtdWxhdGUgdGhlIFwib25Db25uZWN0ZWRcIiBldmVudCB0aGF0IFdlYkNoYW5uZWxDb25uZWN0aW9uIHNlbmRzLlxuICAgICAgICAgICAgICAgIGlmICghb25Db25uZWN0ZWRTZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5jYWxsT25Db25uZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgb25Db25uZWN0ZWRTZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyZWFtLmNhbGxPbk1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGdycGNTdHJlYW0ub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IGVuZGVkLmApO1xuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdycGNTdHJlYW0ub24oJ2Vycm9yJywgKGdycGNFcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBsb2dXYXJuKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IGVycm9yLiBDb2RlOmAsIGdycGNFcnJvci5jb2RlLCAnTWVzc2FnZTonLCBncnBjRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IG1hcENvZGVGcm9tUnBjQ29kZShncnBjRXJyb3IuY29kZSk7XG4gICAgICAgICAgICAgICAgY2xvc2UobmV3IEZpcmVzdG9yZUVycm9yKGNvZGUsIGdycGNFcnJvci5tZXNzYWdlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBPcGVuaW5nIFJQQyAnJHtycGNOYW1lfScgc3RyZWFtICR7c3RyZWFtSWR9IGAgK1xuICAgICAgICAgICAgYHRvICR7dGhpcy5kYXRhYmFzZUluZm8uaG9zdH1gKTtcbiAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiBTaW5jZSBncnBjIGhhcyBubyBleHBsaWNpdCBvcGVuIHN0YXR1cyAob3IgZG9lcyBpdD8pIHdlXG4gICAgICAgIC8vIHNpbXVsYXRlIGFuIG9uT3BlbiBpbiB0aGUgbmV4dCBsb29wIGFmdGVyIHRoZSBzdHJlYW0gaGFkIGl0J3MgbGlzdGVuZXJzXG4gICAgICAgIC8vIHJlZ2lzdGVyZWRcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0uY2FsbE9uT3BlbigpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGFuZCBjbGVhbnMgdXAgYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhlIEdycGNDb25uZWN0aW9uLlxuICAgICAqIElmIGEgZ1JQQyBjbGllbnQgaGFzIGJlZW4gZ2VuZXJhdGVkIGZvciB0aGlzIGNvbm5lY3Rpb24sIHRoZSBnUlBDIGNsaWVudFxuICAgICAqIGlzIGNsb3NlZC4gRmFpbHVyZSB0byBjYWxsIHRlcm1pbmF0ZSBvbiBhIEdycGNDb25uZWN0aW9uIGNhbiByZXN1bHRcbiAgICAgKiBpbiBsZWFrZWQgcmVzb3VyY2VzIG9mIHRoZSBnUlBDIGNsaWVudC5cbiAgICAgKi9cbiAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZFN0dWIpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkU3R1Yi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRTdHViID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBuZXN0ZWQgPSB7XG5cdGdvb2dsZToge1xuXHRcdG5lc3RlZDoge1xuXHRcdFx0cHJvdG9idWY6IHtcblx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiZ2l0aHViLmNvbS9nb2xhbmcvcHJvdG9idWYvcHJvdG9jLWdlbi1nby9kZXNjcmlwdG9yO2Rlc2NyaXB0b3JcIixcblx0XHRcdFx0XHRqYXZhX3BhY2thZ2U6IFwiY29tLmdvb2dsZS5wcm90b2J1ZlwiLFxuXHRcdFx0XHRcdGphdmFfb3V0ZXJfY2xhc3NuYW1lOiBcIkRlc2NyaXB0b3JQcm90b3NcIixcblx0XHRcdFx0XHRjc2hhcnBfbmFtZXNwYWNlOiBcIkdvb2dsZS5Qcm90b2J1Zi5SZWZsZWN0aW9uXCIsXG5cdFx0XHRcdFx0b2JqY19jbGFzc19wcmVmaXg6IFwiR1BCXCIsXG5cdFx0XHRcdFx0Y2NfZW5hYmxlX2FyZW5hczogdHJ1ZSxcblx0XHRcdFx0XHRvcHRpbWl6ZV9mb3I6IFwiU1BFRURcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRTdHJ1Y3Q6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRWYWx1ZToge1xuXHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdGtpbmQ6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJudWxsVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwibnVtYmVyVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwic3RyaW5nVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwiYm9vbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcInN0cnVjdFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcImxpc3RWYWx1ZVwiXG5cdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG51bGxWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTnVsbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bnVtYmVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHN0cmluZ1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRib29sVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRzdHJ1Y3RWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU3RydWN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bGlzdFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJMaXN0VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHROdWxsVmFsdWU6IHtcblx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHROVUxMX1ZBTFVFOiAwXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRMaXN0VmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFRpbWVzdGFtcDoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHNlY29uZHM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bmFub3M6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmlsZURlc2NyaXB0b3JTZXQ6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRmaWxlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmlsZURlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZpbGVEZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcInBhY2thZ2VcIjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHB1YmxpY0RlcGVuZGVuY3k6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMCxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYWNrZWQ6IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR3ZWFrRGVwZW5kZW5jeToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDExLFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhY2tlZDogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2VUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZW51bVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c2VydmljZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNlcnZpY2VEZXNjcmlwdG9yUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRleHRlbnNpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZERlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpbGVPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c291cmNlQ29kZUluZm86IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNvdXJjZUNvZGVJbmZvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDlcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c3ludGF4OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZERlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bmVzdGVkVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGVudW1UeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRW51bURlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvblJhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uUmFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvbmVvZkRlY2w6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPbmVvZkRlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cmVzZXJ2ZWRSYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlJlc2VydmVkUmFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRyZXNlcnZlZE5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTBcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRFeHRlbnNpb25SYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhcnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGVuZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkV4dGVuc2lvblJhbmdlT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UmVzZXJ2ZWRSYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhcnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGVuZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRFeHRlbnNpb25SYW5nZU9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZpZWxkRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bnVtYmVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGxhYmVsOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJMYWJlbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlR5cGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR0eXBlTmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZXh0ZW5kZWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b25lb2ZJbmRleDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRqc29uTmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDEwXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9ET1VCTEU6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0ZMT0FUOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9JTlQ2NDogMyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfVUlOVDY0OiA0LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9JTlQzMjogNSxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfRklYRUQ2NDogNixcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfRklYRUQzMjogNyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfQk9PTDogOCxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU1RSSU5HOiA5LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9HUk9VUDogMTAsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX01FU1NBR0U6IDExLFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9CWVRFUzogMTIsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX1VJTlQzMjogMTMsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0VOVU06IDE0LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9TRklYRUQzMjogMTUsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX1NGSVhFRDY0OiAxNixcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU0lOVDMyOiAxNyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU0lOVDY0OiAxOFxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0TGFiZWw6IHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdExBQkVMX09QVElPTkFMOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0TEFCRUxfUkVRVUlSRUQ6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRMQUJFTF9SRVBFQVRFRDogM1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0T25lb2ZEZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPbmVvZk9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRFbnVtRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHJlc2VydmVkUmFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtUmVzZXJ2ZWRSYW5nZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHJlc2VydmVkTmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0RW51bVJlc2VydmVkUmFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRlbmQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RW51bVZhbHVlRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bnVtYmVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkVudW1WYWx1ZU9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRTZXJ2aWNlRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bWV0aG9kOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTWV0aG9kRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU2VydmljZU9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRNZXRob2REZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRpbnB1dFR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG91dHB1dFR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk1ldGhvZE9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjbGllbnRTdHJlYW1pbmc6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNSxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHNlcnZlclN0cmVhbWluZzoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA2LFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmlsZU9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRqYXZhUGFja2FnZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0amF2YU91dGVyQ2xhc3NuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRqYXZhTXVsdGlwbGVGaWxlczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMCxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGphdmFHZW5lcmF0ZUVxdWFsc0FuZEhhc2g6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMjAsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDogdHJ1ZVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0amF2YVN0cmluZ0NoZWNrVXRmODoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyNyxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGltaXplRm9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPcHRpbWl6ZU1vZGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOSxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogXCJTUEVFRFwiXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRnb1BhY2thZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjY0dlbmVyaWNTZXJ2aWNlczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxNixcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGphdmFHZW5lcmljU2VydmljZXM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTcsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRweUdlbmVyaWNTZXJ2aWNlczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxOCxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBocEdlbmVyaWNTZXJ2aWNlczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0Mixcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMjMsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjY0VuYWJsZUFyZW5hczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzMSxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9iamNDbGFzc1ByZWZpeDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDM2XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGNzaGFycE5hbWVzcGFjZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDM3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHN3aWZ0UHJlZml4OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMzlcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cGhwQ2xhc3NQcmVmaXg6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0MFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRwaHBOYW1lc3BhY2U6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0MVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRwaHBNZXRhZGF0YU5hbWVzcGFjZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDQ0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHJ1YnlQYWNrYWdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dW5pbnRlcnByZXRlZE9wdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlVuaW50ZXJwcmV0ZWRPcHRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOTk5XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRleHRlbnNpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQxMDAwLFxuXHRcdFx0XHRcdFx0XHRcdDUzNjg3MDkxMVxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0cmVzZXJ2ZWQ6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDM4LFxuXHRcdFx0XHRcdFx0XHRcdDM4XG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0T3B0aW1pemVNb2RlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRTUEVFRDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdENPREVfU0laRTogMixcblx0XHRcdFx0XHRcdFx0XHRcdExJVEVfUlVOVElNRTogM1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0TWVzc2FnZU9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRtZXNzYWdlU2V0V2lyZUZvcm1hdDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bm9TdGFuZGFyZERlc2NyaXB0b3JBY2Nlc3Nvcjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyLFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzLFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bWFwRW50cnk6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNlcnZlZDogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0OCxcblx0XHRcdFx0XHRcdFx0XHQ4XG5cdFx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQ5LFxuXHRcdFx0XHRcdFx0XHRcdDlcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmllbGRPcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0Y3R5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkNUeXBlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiU1RSSU5HXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBhY2tlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGpzdHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiSlNUeXBlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDYsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiSlNfTk9STUFMXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGxhenk6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNSxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMyxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHdlYWs6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTAsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWZhdWx0XCI6IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNlcnZlZDogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0NCxcblx0XHRcdFx0XHRcdFx0XHQ0XG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0Q1R5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFNUUklORzogMCxcblx0XHRcdFx0XHRcdFx0XHRcdENPUkQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRTVFJJTkdfUElFQ0U6IDJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEpTVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0SlNfTk9STUFMOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0SlNfU1RSSU5HOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0SlNfTlVNQkVSOiAyXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRPbmVvZk9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVudW1PcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0YWxsb3dBbGlhczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMyxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmludGVycHJldGVkT3B0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDk5OVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MTAwMCxcblx0XHRcdFx0XHRcdFx0XHQ1MzY4NzA5MTFcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2VydmVkOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQ1LFxuXHRcdFx0XHRcdFx0XHRcdDVcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RW51bVZhbHVlT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmludGVycHJldGVkT3B0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDk5OVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MTAwMCxcblx0XHRcdFx0XHRcdFx0XHQ1MzY4NzA5MTFcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0U2VydmljZU9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRkZXByZWNhdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDMzLFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFwiZGVmYXVsdFwiOiBmYWxzZVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dW5pbnRlcnByZXRlZE9wdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlVuaW50ZXJwcmV0ZWRPcHRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOTk5XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRleHRlbnNpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQxMDAwLFxuXHRcdFx0XHRcdFx0XHRcdDUzNjg3MDkxMVxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRNZXRob2RPcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzMyxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImRlZmF1bHRcIjogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGlkZW1wb3RlbmN5TGV2ZWw6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIklkZW1wb3RlbmN5TGV2ZWxcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMzQsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiSURFTVBPVEVOQ1lfVU5LTk9XTlwiXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0SWRlbXBvdGVuY3lMZXZlbDoge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0SURFTVBPVEVOQ1lfVU5LTk9XTjogMCxcblx0XHRcdFx0XHRcdFx0XHRcdE5PX1NJREVfRUZGRUNUUzogMSxcblx0XHRcdFx0XHRcdFx0XHRcdElERU1QT1RFTlQ6IDJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTmFtZVBhcnRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRpZGVudGlmaWVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBvc2l0aXZlSW50VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInVpbnQ2NFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG5lZ2F0aXZlSW50VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZG91YmxlVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHN0cmluZ1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGFnZ3JlZ2F0ZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdE5hbWVQYXJ0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lUGFydDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcXVpcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0aXNFeHRlbnNpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXF1aXJlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFNvdXJjZUNvZGVJbmZvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bG9jYXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJMb2NhdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0TG9jYXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhdGg6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3Bhbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsZWFkaW5nQ29tbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFpbGluZ0NvbW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bGVhZGluZ0RldGFjaGVkQ29tbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0R2VuZXJhdGVkQ29kZUluZm86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRhbm5vdGF0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQW5ub3RhdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0QW5ub3RhdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzb3VyY2VGaWxlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0YmVnaW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGVuZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHREb3VibGVWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJkb3VibGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRGbG9hdFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImZsb2F0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0SW50NjRWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQ2NFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFVJbnQ2NFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInVpbnQ2NFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEludDMyVmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRVSW50MzJWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJ1aW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRCb29sVmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFN0cmluZ1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEJ5dGVzVmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRFbXB0eToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRBbnk6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR0eXBlX3VybDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RHVyYXRpb246IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRzZWNvbmRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQ2NFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG5hbm9zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmaXJlc3RvcmU6IHtcblx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0djE6IHtcblx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0Y3NoYXJwX25hbWVzcGFjZTogXCJHb29nbGUuQ2xvdWQuRmlyZXN0b3JlLlYxXCIsXG5cdFx0XHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiY2xvdWQuZ29vZ2xlLmNvbS9nby9maXJlc3RvcmUvYXBpdjEvZmlyZXN0b3JlcGI7ZmlyZXN0b3JlcGJcIixcblx0XHRcdFx0XHRcdFx0amF2YV9tdWx0aXBsZV9maWxlczogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0amF2YV9vdXRlcl9jbGFzc25hbWU6IFwiUXVlcnlQcm9maWxlUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0amF2YV9wYWNrYWdlOiBcImNvbS5nb29nbGUuZmlyZXN0b3JlLnYxXCIsXG5cdFx0XHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIkdDRlNcIixcblx0XHRcdFx0XHRcdFx0cGhwX25hbWVzcGFjZTogXCJHb29nbGVcXFxcQ2xvdWRcXFxcRmlyZXN0b3JlXFxcXFYxXCIsXG5cdFx0XHRcdFx0XHRcdHJ1YnlfcGFja2FnZTogXCJHb29nbGU6OkNsb3VkOjpGaXJlc3RvcmU6OlYxXCJcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0QWdncmVnYXRpb25SZXN1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGFnZ3JlZ2F0ZUZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3JlYXRlVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibnVsbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJib29sZWFuVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImludGVnZXJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZG91YmxlVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInRpbWVzdGFtcFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJpbmdWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYnl0ZXNWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVmZXJlbmNlVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImdlb1BvaW50VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImFycmF5VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm1hcFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJmaWVsZFJlZmVyZW5jZVZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJmdW5jdGlvblZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJwaXBlbGluZVZhbHVlXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRudWxsVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGJvb2xlYW5WYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRpbnRlZ2VyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQ2NFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvdWJsZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZG91YmxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGltZXN0YW1wVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cmluZ1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxN1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGJ5dGVzVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMThcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWZlcmVuY2VWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGdlb1BvaW50VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUudHlwZS5MYXRMbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRhcnJheVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQXJyYXlWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG1hcFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTWFwVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZFJlZmVyZW5jZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxOVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGdW5jdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMjBcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwaXBlbGluZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUGlwZWxpbmVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDIxXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRBcnJheVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRNYXBWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGtleVR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFwiRnVuY3Rpb25cIjoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRQaXBlbGluZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhZ2VzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJTdGFnZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRTdGFnZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJpdFNlcXVlbmNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRiaXRtYXA6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhZGRpbmc6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Qmxvb21GaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGJpdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJCaXRTZXF1ZW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGhhc2hDb3VudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudE1hc2s6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkUGF0aHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UHJlY29uZGl0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25kaXRpb25UeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJleGlzdHNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInVwZGF0ZVRpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGV4aXN0czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VHJhbnNhY3Rpb25PcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb2RlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkT25seVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZFdyaXRlXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkT25seToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlJlYWRPbmx5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFdyaXRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUmVhZFdyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFJlYWRXcml0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXRyeVRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFJlYWRPbmx5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNpc3RlbmN5U2VsZWN0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZFRpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEZpcmVzdG9yZToge1xuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZGVmYXVsdF9ob3N0KVwiOiBcImZpcmVzdG9yZS5nb29nbGVhcGlzLmNvbVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5vYXV0aF9zY29wZXMpXCI6IFwiaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9jbG91ZC1wbGF0Zm9ybSxodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2RhdGFzdG9yZVwiXG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRtZXRob2RzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRHZXREb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJHZXREb2N1bWVudFJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmdldFwiOiBcIi92MS97bmFtZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Z2V0OiBcIi92MS97bmFtZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0TGlzdERvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJMaXN0RG9jdW1lbnRzUmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiTGlzdERvY3VtZW50c1Jlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmdldFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9L3tjb2xsZWN0aW9uX2lkfVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Z2V0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9L3tjb2xsZWN0aW9uX2lkfVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0VXBkYXRlRG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiVXBkYXRlRG9jdW1lbnRSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wYXRjaFwiOiBcIi92MS97ZG9jdW1lbnQubmFtZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcImRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRvY3VtZW50LHVwZGF0ZV9tYXNrXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYXRjaDogXCIvdjEve2RvY3VtZW50Lm5hbWU9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCJkb2N1bWVudFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwiZG9jdW1lbnQsdXBkYXRlX21hc2tcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdERlbGV0ZURvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkRlbGV0ZURvY3VtZW50UmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLkVtcHR5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmRlbGV0ZVwiOiBcIi92MS97bmFtZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJuYW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImRlbGV0ZVwiOiBcIi92MS97bmFtZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwibmFtZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0QmF0Y2hHZXREb2N1bWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiQmF0Y2hHZXREb2N1bWVudHNSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJCYXRjaEdldERvY3VtZW50c1Jlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmF0Y2hHZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmJhdGNoR2V0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0QmVnaW5UcmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJCZWdpblRyYW5zYWN0aW9uUmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiQmVnaW5UcmFuc2FjdGlvblJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpiZWdpblRyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkYXRhYmFzZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpiZWdpblRyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwiZGF0YWJhc2VcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdENvbW1pdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJDb21taXRSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJDb21taXRSZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6Y29tbWl0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkYXRhYmFzZSx3cml0ZXNcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6Y29tbWl0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwiZGF0YWJhc2Usd3JpdGVzXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRSb2xsYmFjazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJSb2xsYmFja1JlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcImdvb2dsZS5wcm90b2J1Zi5FbXB0eVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6cm9sbGJhY2tcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRhdGFiYXNlLHRyYW5zYWN0aW9uXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOnJvbGxiYWNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwiZGF0YWJhc2UsdHJhbnNhY3Rpb25cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFJ1blF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIlJ1blF1ZXJ5UmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiUnVuUXVlcnlSZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVN0cmVhbTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzfTpydW5RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnJ1blF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLmJvZHlcIjogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzfTpydW5RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkaXRpb25hbF9iaW5kaW5nczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn06cnVuUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RXhlY3V0ZVBpcGVsaW5lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkV4ZWN1dGVQaXBlbGluZVJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkV4ZWN1dGVQaXBlbGluZVJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6ZXhlY3V0ZVBpcGVsaW5lXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpleGVjdXRlUGlwZWxpbmVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRSdW5BZ2dyZWdhdGlvblF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIlJ1bkFnZ3JlZ2F0aW9uUXVlcnlSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJSdW5BZ2dyZWdhdGlvblF1ZXJ5UmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cnVuQWdncmVnYXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnJ1bkFnZ3JlZ2F0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9OnJ1bkFnZ3JlZ2F0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFkZGl0aW9uYWxfYmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnJ1bkFnZ3JlZ2F0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0UGFydGl0aW9uUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiUGFydGl0aW9uUXVlcnlSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJQYXJ0aXRpb25RdWVyeVJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cGFydGl0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpwYXJ0aXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cGFydGl0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFkZGl0aW9uYWxfYmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnBhcnRpdGlvblF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFdyaXRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIldyaXRlUmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0U3RyZWFtOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiV3JpdGVSZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVN0cmVhbTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOndyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czp3cml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdExpc3Rlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJMaXN0ZW5SZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJMaXN0ZW5SZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVN0cmVhbTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmxpc3RlblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6bGlzdGVuXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0TGlzdENvbGxlY3Rpb25JZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiTGlzdENvbGxlY3Rpb25JZHNSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJMaXN0Q29sbGVjdGlvbklkc1Jlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306bGlzdENvbGxlY3Rpb25JZHNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpsaXN0Q29sbGVjdGlvbklkc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5ib2R5XCI6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJwYXJlbnRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9Omxpc3RDb2xsZWN0aW9uSWRzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRpdGlvbmFsX2JpbmRpbmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpsaXN0Q29sbGVjdGlvbklkc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJwYXJlbnRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdEJhdGNoV3JpdGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiQmF0Y2hXcml0ZVJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkJhdGNoV3JpdGVSZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmF0Y2hXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmF0Y2hXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdENyZWF0ZURvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkNyZWF0ZURvY3VtZW50UmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyoqfS97Y29sbGVjdGlvbl9pZH1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCJkb2N1bWVudFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qKn0ve2NvbGxlY3Rpb25faWR9XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiZG9jdW1lbnRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0R2V0RG9jdW1lbnRSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZFRpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG1hc2s6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudE1hc2tcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMaXN0RG9jdW1lbnRzUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc2lzdGVuY3lTZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvbGxlY3Rpb25JZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVNpemU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhZ2VUb2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG9yZGVyQnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMTBcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzaG93TWlzc2luZzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMaXN0RG9jdW1lbnRzUmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXh0UGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRDcmVhdGVEb2N1bWVudFJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29sbGVjdGlvbklkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudElkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VXBkYXRlRG9jdW1lbnRSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVNYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnREb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlByZWNvbmRpdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RGVsZXRlRG9jdW1lbnRSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50RG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJQcmVjb25kaXRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJhdGNoR2V0RG9jdW1lbnRzUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc2lzdGVuY3lTZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm5ld1RyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdUcmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRyYW5zYWN0aW9uT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0QmF0Y2hHZXREb2N1bWVudHNSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJmb3VuZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibWlzc2luZ1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm91bmQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG1pc3Npbmc6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRCZWdpblRyYW5zYWN0aW9uUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUcmFuc2FjdGlvbk9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJlZ2luVHJhbnNhY3Rpb25SZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Q29tbWl0UmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiV3JpdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRDb21taXRSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVSZXN1bHRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJXcml0ZVJlc3VsdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvbW1pdFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRSb2xsYmFja1JlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFiYXNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFJ1blF1ZXJ5UmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cXVlcnlUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJ1Y3R1cmVkUXVlcnlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc2lzdGVuY3lTZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm5ld1RyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJ1Y3R1cmVkUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJTdHJ1Y3R1cmVkUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3VHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUcmFuc2FjdGlvbk9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFJ1blF1ZXJ5UmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c2tpcHBlZFJlc3VsdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RXhlY3V0ZVBpcGVsaW5lUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGlwZWxpbmVUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJ1Y3R1cmVkUGlwZWxpbmVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc2lzdGVuY3lTZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm5ld1RyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cnVjdHVyZWRQaXBlbGluZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRQaXBlbGluZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdUcmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRyYW5zYWN0aW9uT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RXhlY3V0ZVBpcGVsaW5lUmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGV4ZWN1dGlvblRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRSdW5BZ2dyZWdhdGlvblF1ZXJ5UmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cXVlcnlUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJ1Y3R1cmVkQWdncmVnYXRpb25RdWVyeVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibmV3VHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cnVjdHVyZWRBZ2dyZWdhdGlvblF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU3RydWN0dXJlZEFnZ3JlZ2F0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3VHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUcmFuc2FjdGlvbk9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFJ1bkFnZ3JlZ2F0aW9uUXVlcnlSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQWdncmVnYXRpb25SZXN1bHRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRQYXJ0aXRpb25RdWVyeVJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHF1ZXJ5VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic3RydWN0dXJlZFF1ZXJ5XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cnVjdHVyZWRRdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRRdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhcnRpdGlvbkNvdW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50NjRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlU2l6ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRQYXJ0aXRpb25RdWVyeVJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJ0aXRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDdXJzb3JcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXh0UGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRXcml0ZVJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFiYXNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1JZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiV3JpdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1Ub2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bGFiZWxzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGtleVR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRXcml0ZVJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1JZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cmVhbVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR3cml0ZVJlc3VsdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIldyaXRlUmVzdWx0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29tbWl0VGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3RlblJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldENoYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYWRkVGFyZ2V0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZW1vdmVUYXJnZXRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFiYXNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRhZGRUYXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUYXJnZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZW1vdmVUYXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0TGlzdGVuUmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidGFyZ2V0Q2hhbmdlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJkb2N1bWVudENoYW5nZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZG9jdW1lbnREZWxldGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImRvY3VtZW50UmVtb3ZlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJmaWx0ZXJcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldENoYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRhcmdldENoYW5nZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50Q2hhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRDaGFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudERlbGV0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50RGVsZXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnRSZW1vdmU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudFJlbW92ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkV4aXN0ZW5jZUZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJxdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZG9jdW1lbnRzXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VtZVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlc3VtZVRva2VuXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJRdWVyeVRhcmdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50c1RhcmdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VtZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDExXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0SWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG9uY2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZXhwZWN0ZWRDb3VudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHREb2N1bWVudHNUYXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRRdWVyeVRhcmdldDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRxdWVyeVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic3RydWN0dXJlZFF1ZXJ5XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdHJ1Y3R1cmVkUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU3RydWN0dXJlZFF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VGFyZ2V0Q2hhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRDaGFuZ2VUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVGFyZ2V0Q2hhbmdlVHlwZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldElkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXVzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5ycGMuU3RhdHVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdW1lVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRUYXJnZXRDaGFuZ2VUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdE5PX0NIQU5HRTogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBREQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0UkVNT1ZFOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdENVUlJFTlQ6IDMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0UkVTRVQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0TGlzdENvbGxlY3Rpb25JZHNSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhZ2VTaXplOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3RDb2xsZWN0aW9uSWRzUmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbGxlY3Rpb25JZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG5leHRQYWdlVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJhdGNoV3JpdGVSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0QmF0Y2hXcml0ZVJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR3cml0ZVJlc3VsdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIldyaXRlUmVzdWx0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdHVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucnBjLlN0YXR1c1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0U3RydWN0dXJlZFBpcGVsaW5lOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwaXBlbGluZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlBpcGVsaW5lXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRTdHJ1Y3R1cmVkUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHNlbGVjdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlByb2plY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRmcm9tOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDb2xsZWN0aW9uU2VsZWN0b3JcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR3aGVyZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG9yZGVyQnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9yZGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhcnRBdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkN1cnNvclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGVuZEF0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ3Vyc29yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0b2Zmc2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsaW1pdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdENvbGxlY3Rpb25TZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb2xsZWN0aW9uSWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWxsRGVzY2VuZGFudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmlsdGVyVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJjb21wb3NpdGVGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJmaWVsZEZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInVuYXJ5RmlsdGVyXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbXBvc2l0ZUZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDb21wb3NpdGVGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZEZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZEZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuYXJ5RmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlVuYXJ5RmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdENvbXBvc2l0ZUZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPcGVyYXRvclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpbHRlcnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0T3BlcmF0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPUEVSQVRPUl9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0QU5EOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPUjogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdEZpZWxkRmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkUmVmZXJlbmNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3A6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiT3BlcmF0b3JcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9wZXJhdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0T1BFUkFUT1JfVU5TUEVDSUZJRUQ6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdExFU1NfVEhBTjogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0TEVTU19USEFOX09SX0VRVUFMOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRHUkVBVEVSX1RIQU46IDMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEdSRUFURVJfVEhBTl9PUl9FUVVBTDogNCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0RVFVQUw6IDUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdE5PVF9FUVVBTDogNixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0QVJSQVlfQ09OVEFJTlM6IDcsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdElOOiA4LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBUlJBWV9DT05UQUlOU19BTlk6IDksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdE5PVF9JTjogMTBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRVbmFyeUZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcGVyYW5kVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJmaWVsZFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPcGVyYXRvclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkUmVmZXJlbmNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0T3BlcmF0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPUEVSQVRPUl9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0SVNfTkFOOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRJU19OVUxMOiAzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRJU19OT1RfTkFOOiA0LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRJU19OT1RfTlVMTDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdE9yZGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkUmVmZXJlbmNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRpcmVjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRGaWVsZFJlZmVyZW5jZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZFBhdGg6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFByb2plY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkUmVmZXJlbmNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdERpcmVjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRESVJFQ1RJT05fVU5TUEVDSUZJRUQ6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0QVNDRU5ESU5HOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdERFU0NFTkRJTkc6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0U3RydWN0dXJlZEFnZ3JlZ2F0aW9uUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHF1ZXJ5VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic3RydWN0dXJlZFF1ZXJ5XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJ1Y3R1cmVkUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJTdHJ1Y3R1cmVkUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRhZ2dyZWdhdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkFnZ3JlZ2F0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdEFnZ3JlZ2F0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wZXJhdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImNvdW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic3VtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYXZnXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvdW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkNvdW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3VtOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN1bVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGF2Zzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJBdmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhbGlhczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRDb3VudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVwVG86IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5JbnQ2NFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0U3VtOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRRdWVyeS5GaWVsZFJlZmVyZW5jZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdEF2Zzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJTdHJ1Y3R1cmVkUXVlcnkuRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRDdXJzb3I6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRiZWZvcmU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRXcml0ZToge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3BlcmF0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ1cGRhdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImRlbGV0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidmVyaWZ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2Zvcm1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWxldGVcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHZlcmlmeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zZm9ybToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50VHJhbnNmb3JtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlTWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZVRyYW5zZm9ybXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50VHJhbnNmb3JtLkZpZWxkVHJhbnNmb3JtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudERvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUHJlY29uZGl0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudFRyYW5zZm9ybToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZFRyYW5zZm9ybXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkVHJhbnNmb3JtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdEZpZWxkVHJhbnNmb3JtOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zZm9ybVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic2V0VG9TZXJ2ZXJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImluY3JlbWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm1heGltdW1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJtaW5pbXVtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYXBwZW5kTWlzc2luZ0VsZW1lbnRzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVtb3ZlQWxsRnJvbUFycmF5XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkUGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzZXRUb1NlcnZlclZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNlcnZlclZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW5jcmVtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4aW11bToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pbmltdW06IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcHBlbmRNaXNzaW5nRWxlbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQXJyYXlWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlbW92ZUFsbEZyb21BcnJheToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJBcnJheVZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0U2VydmVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRTRVJWRVJfVkFMVUVfVU5TUEVDSUZJRUQ6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFJFUVVFU1RfVElNRTogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0V3JpdGVSZXN1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZVRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtUmVzdWx0czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdERvY3VtZW50Q2hhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0SWRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlbW92ZWRUYXJnZXRJZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudERlbGV0ZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZW1vdmVkVGFyZ2V0SWRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RG9jdW1lbnRSZW1vdmU6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVtb3ZlZFRhcmdldElkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEV4aXN0ZW5jZUZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0SWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvdW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1bmNoYW5nZWROYW1lczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkJsb29tRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRFeHBsYWluT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0YW5hbHl6ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIk9QVElPTkFMXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RXhwbGFpbk1ldHJpY3M6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBsYW5TdW1tYXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUGxhblN1bW1hcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRleGVjdXRpb25TdGF0czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkV4ZWN1dGlvblN0YXRzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRQbGFuU3VtbWFyeToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5kZXhlc1VzZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEV4ZWN1dGlvblN0YXRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzUmV0dXJuZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQ2NFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGV4ZWN1dGlvbkR1cmF0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZE9wZXJhdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQ2NFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRlYnVnU3RhdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuU3RydWN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dHlwZToge1xuXHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0Y2NfZW5hYmxlX2FyZW5hczogdHJ1ZSxcblx0XHRcdFx0XHRnb19wYWNrYWdlOiBcImdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvdHlwZS9sYXRsbmc7bGF0bG5nXCIsXG5cdFx0XHRcdFx0amF2YV9tdWx0aXBsZV9maWxlczogdHJ1ZSxcblx0XHRcdFx0XHRqYXZhX291dGVyX2NsYXNzbmFtZTogXCJMYXRMbmdQcm90b1wiLFxuXHRcdFx0XHRcdGphdmFfcGFja2FnZTogXCJjb20uZ29vZ2xlLnR5cGVcIixcblx0XHRcdFx0XHRvYmpjX2NsYXNzX3ByZWZpeDogXCJHVFBcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRMYXRMbmc6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRsYXRpdHVkZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZG91YmxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bG9uZ2l0dWRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJkb3VibGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YXBpOiB7XG5cdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRnb19wYWNrYWdlOiBcImdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvYXBpO2FwaVwiLFxuXHRcdFx0XHRcdGphdmFfbXVsdGlwbGVfZmlsZXM6IHRydWUsXG5cdFx0XHRcdFx0amF2YV9vdXRlcl9jbGFzc25hbWU6IFwiTGF1bmNoU3RhZ2VQcm90b1wiLFxuXHRcdFx0XHRcdGphdmFfcGFja2FnZTogXCJjb20uZ29vZ2xlLmFwaVwiLFxuXHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIkdBUElcIixcblx0XHRcdFx0XHRjY19lbmFibGVfYXJlbmFzOiB0cnVlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdGh0dHA6IHtcblx0XHRcdFx0XHRcdHR5cGU6IFwiSHR0cFJ1bGVcIixcblx0XHRcdFx0XHRcdGlkOiA3MjI5NTcyOCxcblx0XHRcdFx0XHRcdGV4dGVuZDogXCJnb29nbGUucHJvdG9idWYuTWV0aG9kT3B0aW9uc1wiXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRIdHRwOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0cnVsZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJIdHRwUnVsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGZ1bGx5RGVjb2RlUmVzZXJ2ZWRFeHBhbnNpb246IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRIdHRwUnVsZToge1xuXHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdHBhdHRlcm46IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJnZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwicHV0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcInBvc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwiZGVsZXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcInBhdGNoXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcImN1c3RvbVwiXG5cdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRnZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHB1dDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cG9zdDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XCJkZWxldGVcIjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cGF0Y2g6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGN1c3RvbToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ3VzdG9tSHR0cFBhdHRlcm5cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRib2R5OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUJvZHk6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRhZGRpdGlvbmFsQmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJIdHRwUnVsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRDdXN0b21IdHRwUGF0dGVybjoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGtpbmQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBhdGg6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG1ldGhvZFNpZ25hdHVyZToge1xuXHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdGlkOiAxMDUxLFxuXHRcdFx0XHRcdFx0ZXh0ZW5kOiBcImdvb2dsZS5wcm90b2J1Zi5NZXRob2RPcHRpb25zXCJcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGRlZmF1bHRIb3N0OiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0aWQ6IDEwNDksXG5cdFx0XHRcdFx0XHRleHRlbmQ6IFwiZ29vZ2xlLnByb3RvYnVmLlNlcnZpY2VPcHRpb25zXCJcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG9hdXRoU2NvcGVzOiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0aWQ6IDEwNTAsXG5cdFx0XHRcdFx0XHRleHRlbmQ6IFwiZ29vZ2xlLnByb3RvYnVmLlNlcnZpY2VPcHRpb25zXCJcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGZpZWxkQmVoYXZpb3I6IHtcblx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLmFwaS5GaWVsZEJlaGF2aW9yXCIsXG5cdFx0XHRcdFx0XHRpZDogMTA1Mixcblx0XHRcdFx0XHRcdGV4dGVuZDogXCJnb29nbGUucHJvdG9idWYuRmllbGRPcHRpb25zXCJcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZpZWxkQmVoYXZpb3I6IHtcblx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRGSUVMRF9CRUhBVklPUl9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0T1BUSU9OQUw6IDEsXG5cdFx0XHRcdFx0XHRcdFJFUVVJUkVEOiAyLFxuXHRcdFx0XHRcdFx0XHRPVVRQVVRfT05MWTogMyxcblx0XHRcdFx0XHRcdFx0SU5QVVRfT05MWTogNCxcblx0XHRcdFx0XHRcdFx0SU1NVVRBQkxFOiA1LFxuXHRcdFx0XHRcdFx0XHRVTk9SREVSRURfTElTVDogNixcblx0XHRcdFx0XHRcdFx0Tk9OX0VNUFRZX0RFRkFVTFQ6IDdcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdExhdW5jaFN0YWdlOiB7XG5cdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0TEFVTkNIX1NUQUdFX1VOU1BFQ0lGSUVEOiAwLFxuXHRcdFx0XHRcdFx0XHRVTklNUExFTUVOVEVEOiA2LFxuXHRcdFx0XHRcdFx0XHRQUkVMQVVOQ0g6IDcsXG5cdFx0XHRcdFx0XHRcdEVBUkxZX0FDQ0VTUzogMSxcblx0XHRcdFx0XHRcdFx0QUxQSEE6IDIsXG5cdFx0XHRcdFx0XHRcdEJFVEE6IDMsXG5cdFx0XHRcdFx0XHRcdEdBOiA0LFxuXHRcdFx0XHRcdFx0XHRERVBSRUNBVEVEOiA1XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cnBjOiB7XG5cdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRjY19lbmFibGVfYXJlbmFzOiB0cnVlLFxuXHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiZ29vZ2xlLmdvbGFuZy5vcmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy9ycGMvc3RhdHVzO3N0YXR1c1wiLFxuXHRcdFx0XHRcdGphdmFfbXVsdGlwbGVfZmlsZXM6IHRydWUsXG5cdFx0XHRcdFx0amF2YV9vdXRlcl9jbGFzc25hbWU6IFwiU3RhdHVzUHJvdG9cIixcblx0XHRcdFx0XHRqYXZhX3BhY2thZ2U6IFwiY29tLmdvb2dsZS5ycGNcIixcblx0XHRcdFx0XHRvYmpjX2NsYXNzX3ByZWZpeDogXCJSUENcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRTdGF0dXM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRjb2RlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRldGFpbHM6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuQW55XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcbnZhciBwcm90b3MgPSB7XG5cdG5lc3RlZDogbmVzdGVkXG59O1xuXG52YXIgcHJvdG9zJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgbmVzdGVkOiBuZXN0ZWQsXG4gICdkZWZhdWx0JzogcHJvdG9zXG59KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBVc2VkIGJ5IHRlc3RzIHNvIHdlIGNhbiBtYXRjaCBAZ3JwYy9wcm90by1sb2FkZXIgYmVoYXZpb3IuICovXG5jb25zdCBwcm90b0xvYWRlck9wdGlvbnMgPSB7XG4gICAgbG9uZ3M6IFN0cmluZyxcbiAgICBlbnVtczogU3RyaW5nLFxuICAgIGRlZmF1bHRzOiB0cnVlLFxuICAgIG9uZW9mczogZmFsc2Vcbn07XG4vKipcbiAqIExvYWRzIHRoZSBwcm90b2NvbCBidWZmZXIgZGVmaW5pdGlvbnMgZm9yIEZpcmVzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyBUaGUgR3JwY09iamVjdCByZXByZXNlbnRpbmcgb3VyIHByb3Rvcy5cbiAqL1xuZnVuY3Rpb24gbG9hZFByb3RvcygpIHtcbiAgICBjb25zdCBwYWNrYWdlRGVmaW5pdGlvbiA9IHByb3RvTG9hZGVyLmZyb21KU09OKHByb3RvcyQxLCBwcm90b0xvYWRlck9wdGlvbnMpO1xuICAgIHJldHVybiBncnBjLmxvYWRQYWNrYWdlRGVmaW5pdGlvbihwYWNrYWdlRGVmaW5pdGlvbik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogTG9hZHMgdGhlIEdSUEMgc3RhY2sgKi9cbmZ1bmN0aW9uIG5ld0Nvbm5lY3Rpb24oZGF0YWJhc2VJbmZvKSB7XG4gICAgY29uc3QgcHJvdG9zID0gbG9hZFByb3RvcygpO1xuICAgIHJldHVybiBuZXcgR3JwY0Nvbm5lY3Rpb24ocHJvdG9zLCBkYXRhYmFzZUluZm8pO1xufVxuLyoqIFJldHVybiB0aGUgUGxhdGZvcm0tc3BlY2lmaWMgY29ubmVjdGl2aXR5IG1vbml0b3IuICovXG5mdW5jdGlvbiBuZXdDb25uZWN0aXZpdHlNb25pdG9yKCkge1xuICAgIHJldHVybiBuZXcgTm9vcENvbm5lY3Rpdml0eU1vbml0b3IoKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBUaGUgUGxhdGZvcm0ncyAnd2luZG93JyBpbXBsZW1lbnRhdGlvbiBvciBudWxsIGlmIG5vdCBhdmFpbGFibGUuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52LlVTRV9NT0NLX1BFUlNJU1RFTkNFID09PSAnWUVTJykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqIFRoZSBQbGF0Zm9ybSdzICdkb2N1bWVudCcgaW1wbGVtZW50YXRpb24gb3IgbnVsbCBpZiBub3QgYXZhaWxhYmxlLiAqL1xuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBuZXdTZXJpYWxpemVyKGRhdGFiYXNlSWQpIHtcbiAgICByZXR1cm4gbmV3IEpzb25Qcm90b1NlcmlhbGl6ZXIoZGF0YWJhc2VJZCwgLyogdXNlUHJvdG8zSnNvbj0gKi8gZmFsc2UpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyQ4ID0gJ0V4cG9uZW50aWFsQmFja29mZic7XG4vKipcbiAqIEluaXRpYWwgYmFja29mZiB0aW1lIGluIG1pbGxpc2Vjb25kcyBhZnRlciBhbiBlcnJvci5cbiAqIFNldCB0byAxcyBhY2NvcmRpbmcgdG8gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2FwaXMvZGVzaWduL2Vycm9ycy5cbiAqL1xuY29uc3QgREVGQVVMVF9CQUNLT0ZGX0lOSVRJQUxfREVMQVlfTVMgPSAxMDAwO1xuY29uc3QgREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUiA9IDEuNTtcbi8qKiBNYXhpbXVtIGJhY2tvZmYgdGltZSBpbiBtaWxsaXNlY29uZHMgKi9cbmNvbnN0IERFRkFVTFRfQkFDS09GRl9NQVhfREVMQVlfTVMgPSA2MCAqIDEwMDA7XG4vKipcbiAqIEEgaGVscGVyIGZvciBydW5uaW5nIGRlbGF5ZWQgdGFza3MgZm9sbG93aW5nIGFuIGV4cG9uZW50aWFsIGJhY2tvZmYgY3VydmVcbiAqIGJldHdlZW4gYXR0ZW1wdHMuXG4gKlxuICogRWFjaCBkZWxheSBpcyBtYWRlIHVwIG9mIGEgXCJiYXNlXCIgZGVsYXkgd2hpY2ggZm9sbG93cyB0aGUgZXhwb25lbnRpYWxcbiAqIGJhY2tvZmYgY3VydmUsIGFuZCBhICsvLSA1MCUgXCJqaXR0ZXJcIiB0aGF0IGlzIGNhbGN1bGF0ZWQgYW5kIGFkZGVkIHRvIHRoZVxuICogYmFzZSBkZWxheS4gVGhpcyBwcmV2ZW50cyBjbGllbnRzIGZyb20gYWNjaWRlbnRhbGx5IHN5bmNocm9uaXppbmcgdGhlaXJcbiAqIGRlbGF5cyBjYXVzaW5nIHNwaWtlcyBvZiBsb2FkIHRvIHRoZSBiYWNrZW5kLlxuICovXG5jbGFzcyBFeHBvbmVudGlhbEJhY2tvZmYge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBBc3luY1F1ZXVlIHRvIHJ1biBiYWNrb2ZmIG9wZXJhdGlvbnMgb24uXG4gICAgICovXG4gICAgcXVldWUsIFxuICAgIC8qKlxuICAgICAqIFRoZSBJRCB0byB1c2Ugd2hlbiBzY2hlZHVsaW5nIGJhY2tvZmYgb3BlcmF0aW9ucyBvbiB0aGUgQXN5bmNRdWV1ZS5cbiAgICAgKi9cbiAgICB0aW1lcklkLCBcbiAgICAvKipcbiAgICAgKiBUaGUgaW5pdGlhbCBkZWxheSAodXNlZCBhcyB0aGUgYmFzZSBkZWxheSBvbiB0aGUgZmlyc3QgcmV0cnkgYXR0ZW1wdCkuXG4gICAgICogTm90ZSB0aGF0IGppdHRlciB3aWxsIHN0aWxsIGJlIGFwcGxpZWQsIHNvIHRoZSBhY3R1YWwgZGVsYXkgY291bGQgYmUgYXNcbiAgICAgKiBsaXR0bGUgYXMgMC41KmluaXRpYWxEZWxheU1zLlxuICAgICAqL1xuICAgIGluaXRpYWxEZWxheU1zID0gREVGQVVMVF9CQUNLT0ZGX0lOSVRJQUxfREVMQVlfTVMsIFxuICAgIC8qKlxuICAgICAqIFRoZSBtdWx0aXBsaWVyIHRvIHVzZSB0byBkZXRlcm1pbmUgdGhlIGV4dGVuZGVkIGJhc2UgZGVsYXkgYWZ0ZXIgZWFjaFxuICAgICAqIGF0dGVtcHQuXG4gICAgICovXG4gICAgYmFja29mZkZhY3RvciA9IERFRkFVTFRfQkFDS09GRl9GQUNUT1IsIFxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIGJhc2UgZGVsYXkgYWZ0ZXIgd2hpY2ggbm8gZnVydGhlciBiYWNrb2ZmIGlzIHBlcmZvcm1lZC5cbiAgICAgKiBOb3RlIHRoYXQgaml0dGVyIHdpbGwgc3RpbGwgYmUgYXBwbGllZCwgc28gdGhlIGFjdHVhbCBkZWxheSBjb3VsZCBiZSBhc1xuICAgICAqIG11Y2ggYXMgMS41Km1heERlbGF5TXMuXG4gICAgICovXG4gICAgbWF4RGVsYXlNcyA9IERFRkFVTFRfQkFDS09GRl9NQVhfREVMQVlfTVMpIHtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IHF1ZXVlO1xuICAgICAgICB0aGlzLnRpbWVySWQgPSB0aW1lcklkO1xuICAgICAgICB0aGlzLmluaXRpYWxEZWxheU1zID0gaW5pdGlhbERlbGF5TXM7XG4gICAgICAgIHRoaXMuYmFja29mZkZhY3RvciA9IGJhY2tvZmZGYWN0b3I7XG4gICAgICAgIHRoaXMubWF4RGVsYXlNcyA9IG1heERlbGF5TXM7XG4gICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyA9IDA7XG4gICAgICAgIHRoaXMudGltZXJQcm9taXNlID0gbnVsbDtcbiAgICAgICAgLyoqIFRoZSBsYXN0IGJhY2tvZmYgYXR0ZW1wdCwgYXMgZXBvY2ggbWlsbGlzZWNvbmRzLiAqL1xuICAgICAgICB0aGlzLmxhc3RBdHRlbXB0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBiYWNrb2ZmIGRlbGF5LlxuICAgICAqXG4gICAgICogVGhlIHZlcnkgbmV4dCBiYWNrb2ZmQW5kV2FpdCgpIHdpbGwgaGF2ZSBubyBkZWxheS4gSWYgaXQgaXMgY2FsbGVkIGFnYWluXG4gICAgICogKGkuZS4gZHVlIHRvIGFuIGVycm9yKSwgaW5pdGlhbERlbGF5TXMgKHBsdXMgaml0dGVyKSB3aWxsIGJlIHVzZWQsIGFuZFxuICAgICAqIHN1YnNlcXVlbnQgb25lcyB3aWxsIGluY3JlYXNlIGFjY29yZGluZyB0byB0aGUgYmFja29mZkZhY3Rvci5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QmFzZU1zID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBiYWNrb2ZmIGRlbGF5IHRvIHRoZSBtYXhpbXVtIGRlbGF5IChlLmcuIGZvciB1c2UgYWZ0ZXIgYVxuICAgICAqIFJFU09VUkNFX0VYSEFVU1RFRCBlcnJvcikuXG4gICAgICovXG4gICAgcmVzZXRUb01heCgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QmFzZU1zID0gdGhpcy5tYXhEZWxheU1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIGN1cnJlbnREZWxheU1zLCBhbmQgaW5jcmVhc2VzIHRoZVxuICAgICAqIGRlbGF5IGZvciBhbnkgc3Vic2VxdWVudCBhdHRlbXB0cy4gSWYgdGhlcmUgd2FzIGEgcGVuZGluZyBiYWNrb2ZmIG9wZXJhdGlvblxuICAgICAqIGFscmVhZHksIGl0IHdpbGwgYmUgY2FuY2VsZWQuXG4gICAgICovXG4gICAgYmFja29mZkFuZFJ1bihvcCkge1xuICAgICAgICAvLyBDYW5jZWwgYW55IHBlbmRpbmcgYmFja29mZiBvcGVyYXRpb24uXG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgIC8vIEZpcnN0IHNjaGVkdWxlIHVzaW5nIHRoZSBjdXJyZW50IGJhc2UgKHdoaWNoIG1heSBiZSAwIGFuZCBzaG91bGQgYmVcbiAgICAgICAgLy8gaG9ub3JlZCBhcyBzdWNoKS5cbiAgICAgICAgY29uc3QgZGVzaXJlZERlbGF5V2l0aEppdHRlck1zID0gTWF0aC5mbG9vcih0aGlzLmN1cnJlbnRCYXNlTXMgKyB0aGlzLmppdHRlckRlbGF5TXMoKSk7XG4gICAgICAgIC8vIEd1YXJkIGFnYWluc3QgbGFzdEF0dGVtcHRUaW1lIGJlaW5nIGluIHRoZSBmdXR1cmUgZHVlIHRvIGEgY2xvY2sgY2hhbmdlLlxuICAgICAgICBjb25zdCBkZWxheVNvRmFyTXMgPSBNYXRoLm1heCgwLCBEYXRlLm5vdygpIC0gdGhpcy5sYXN0QXR0ZW1wdFRpbWUpO1xuICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSBiYWNrb2ZmIGRlbGF5IGFscmVhZHkgYmVpbmcgcGFzdC5cbiAgICAgICAgY29uc3QgcmVtYWluaW5nRGVsYXlNcyA9IE1hdGgubWF4KDAsIGRlc2lyZWREZWxheVdpdGhKaXR0ZXJNcyAtIGRlbGF5U29GYXJNcyk7XG4gICAgICAgIGlmIChyZW1haW5pbmdEZWxheU1zID4gMCkge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ4LCBgQmFja2luZyBvZmYgZm9yICR7cmVtYWluaW5nRGVsYXlNc30gbXMgYCArXG4gICAgICAgICAgICAgICAgYChiYXNlIGRlbGF5OiAke3RoaXMuY3VycmVudEJhc2VNc30gbXMsIGAgK1xuICAgICAgICAgICAgICAgIGBkZWxheSB3aXRoIGppdHRlcjogJHtkZXNpcmVkRGVsYXlXaXRoSml0dGVyTXN9IG1zLCBgICtcbiAgICAgICAgICAgICAgICBgbGFzdCBhdHRlbXB0OiAke2RlbGF5U29GYXJNc30gbXMgYWdvKWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZXJQcm9taXNlID0gdGhpcy5xdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheSh0aGlzLnRpbWVySWQsIHJlbWFpbmluZ0RlbGF5TXMsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGFzdEF0dGVtcHRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHJldHVybiBvcCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQXBwbHkgYmFja29mZiBmYWN0b3IgdG8gZGV0ZXJtaW5lIG5leHQgZGVsYXkgYW5kIGVuc3VyZSBpdCBpcyB3aXRoaW5cbiAgICAgICAgLy8gYm91bmRzLlxuICAgICAgICB0aGlzLmN1cnJlbnRCYXNlTXMgKj0gdGhpcy5iYWNrb2ZmRmFjdG9yO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50QmFzZU1zIDwgdGhpcy5pbml0aWFsRGVsYXlNcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50QmFzZU1zID0gdGhpcy5pbml0aWFsRGVsYXlNcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QmFzZU1zID4gdGhpcy5tYXhEZWxheU1zKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRCYXNlTXMgPSB0aGlzLm1heERlbGF5TXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2tpcEJhY2tvZmYoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyUHJvbWlzZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aW1lclByb21pc2Uuc2tpcERlbGF5KCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lclByb21pc2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXJQcm9taXNlLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy50aW1lclByb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgcmFuZG9tIHZhbHVlIGluIHRoZSByYW5nZSBbLWN1cnJlbnRCYXNlTXMvMiwgY3VycmVudEJhc2VNcy8yXSAqL1xuICAgIGppdHRlckRlbGF5TXMoKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiB0aGlzLmN1cnJlbnRCYXNlTXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyQ3ID0gJ1BlcnNpc3RlbnRTdHJlYW0nO1xuLyoqIFRoZSB0aW1lIGEgc3RyZWFtIHN0YXlzIG9wZW4gYWZ0ZXIgaXQgaXMgbWFya2VkIGlkbGUuICovXG5jb25zdCBJRExFX1RJTUVPVVRfTVMgPSA2MCAqIDEwMDA7XG4vKiogVGhlIHRpbWUgYSBzdHJlYW0gc3RheXMgb3BlbiB1bnRpbCB3ZSBjb25zaWRlciBpdCBoZWFsdGh5LiAqL1xuY29uc3QgSEVBTFRIWV9USU1FT1VUX01TID0gMTAgKiAxMDAwO1xuLyoqXG4gKiBBIFBlcnNpc3RlbnRTdHJlYW0gaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBzdHJlYW1pbmcgUlBDXG4gKiB0byB0aGUgRmlyZXN0b3JlIGJhY2tlbmQuIEl0J3MgYnVpbHQgb24gdG9wIG9mIHRoZSBjb25uZWN0aW9ucyBvd24gc3VwcG9ydFxuICogZm9yIHN0cmVhbWluZyBSUENzLCBhbmQgYWRkcyBzZXZlcmFsIGNyaXRpY2FsIGZlYXR1cmVzIGZvciBvdXIgY2xpZW50czpcbiAqXG4gKiAgIC0gRXhwb25lbnRpYWwgYmFja29mZiBvbiBmYWlsdXJlXG4gKiAgIC0gQXV0aGVudGljYXRpb24gdmlhIENyZWRlbnRpYWxzUHJvdmlkZXJcbiAqICAgLSBEaXNwYXRjaGluZyBhbGwgY2FsbGJhY2tzIGludG8gdGhlIHNoYXJlZCB3b3JrZXIgcXVldWVcbiAqICAgLSBDbG9zaW5nIGlkbGUgc3RyZWFtcyBhZnRlciA2MCBzZWNvbmRzIG9mIGluYWN0aXZpdHlcbiAqXG4gKiBTdWJjbGFzc2VzIG9mIFBlcnNpc3RlbnRTdHJlYW0gaW1wbGVtZW50IHNlcmlhbGl6YXRpb24gb2YgbW9kZWxzIHRvIGFuZFxuICogZnJvbSB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJvdG9jb2wgYnVmZmVycyBmb3IgYSBzcGVjaWZpY1xuICogc3RyZWFtaW5nIFJQQy5cbiAqXG4gKiAjIyBTdGFydGluZyBhbmQgU3RvcHBpbmdcbiAqXG4gKiBTdHJlYW1pbmcgUlBDcyBhcmUgc3RhdGVmdWwgYW5kIG5lZWQgdG8gYmUgc3RhcnQoKWVkIGJlZm9yZSBtZXNzYWdlcyBjYW5cbiAqIGJlIHNlbnQgYW5kIHJlY2VpdmVkLiBUaGUgUGVyc2lzdGVudFN0cmVhbSB3aWxsIGNhbGwgdGhlIG9uT3BlbigpIGZ1bmN0aW9uXG4gKiBvZiB0aGUgbGlzdGVuZXIgb25jZSB0aGUgc3RyZWFtIGlzIHJlYWR5IHRvIGFjY2VwdCByZXF1ZXN0cy5cbiAqXG4gKiBTaG91bGQgYSBzdGFydCgpIGZhaWwsIFBlcnNpc3RlbnRTdHJlYW0gd2lsbCBjYWxsIHRoZSByZWdpc3RlcmVkIG9uQ2xvc2UoKVxuICogbGlzdGVuZXIgd2l0aCBhIEZpcmVzdG9yZUVycm9yIGluZGljYXRpbmcgd2hhdCB3ZW50IHdyb25nLlxuICpcbiAqIEEgUGVyc2lzdGVudFN0cmVhbSBjYW4gYmUgc3RhcnRlZCBhbmQgc3RvcHBlZCByZXBlYXRlZGx5LlxuICpcbiAqIEdlbmVyaWMgdHlwZXM6XG4gKiAgU2VuZFR5cGU6IFRoZSB0eXBlIG9mIHRoZSBvdXRnb2luZyBtZXNzYWdlIG9mIHRoZSB1bmRlcmx5aW5nXG4gKiAgICBjb25uZWN0aW9uIHN0cmVhbVxuICogIFJlY2VpdmVUeXBlOiBUaGUgdHlwZSBvZiB0aGUgaW5jb21pbmcgbWVzc2FnZSBvZiB0aGUgdW5kZXJseWluZ1xuICogICAgY29ubmVjdGlvbiBzdHJlYW1cbiAqICBMaXN0ZW5lclR5cGU6IFRoZSB0eXBlIG9mIHRoZSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgY2FsbGJhY2tzXG4gKi9cbmNsYXNzIFBlcnNpc3RlbnRTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXVlLCBjb25uZWN0aW9uVGltZXJJZCwgaWRsZVRpbWVySWQsIGhlYWx0aFRpbWVySWQsIGNvbm5lY3Rpb24sIGF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyLCBhcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXIsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICAgICAgdGhpcy5pZGxlVGltZXJJZCA9IGlkbGVUaW1lcklkO1xuICAgICAgICB0aGlzLmhlYWx0aFRpbWVySWQgPSBoZWFsdGhUaW1lcklkO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyID0gYXV0aENyZWRlbnRpYWxzUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFsc1Byb3ZpZGVyID0gYXBwQ2hlY2tDcmVkZW50aWFsc1Byb3ZpZGVyO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAwIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5Jbml0aWFsICovO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBjbG9zZSBjb3VudCB0aGF0J3MgaW5jcmVtZW50ZWQgZXZlcnkgdGltZSB0aGUgc3RyZWFtIGlzIGNsb3NlZDsgdXNlZCBieVxuICAgICAgICAgKiBnZXRDbG9zZUd1YXJkZWREaXNwYXRjaGVyKCkgdG8gaW52YWxpZGF0ZSBjYWxsYmFja3MgdGhhdCBoYXBwZW4gYWZ0ZXJcbiAgICAgICAgICogY2xvc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuaGVhbHRoQ2hlY2sgPSBudWxsO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3VudCBvZiByZXNwb25zZSBtZXNzYWdlcyByZWNlaXZlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzcG9uc2VDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuYmFja29mZiA9IG5ldyBFeHBvbmVudGlhbEJhY2tvZmYocXVldWUsIGNvbm5lY3Rpb25UaW1lcklkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHN0YXJ0KCkgaGFzIGJlZW4gY2FsbGVkIGFuZCBubyBlcnJvciBoYXMgb2NjdXJyZWQuIFRydWVcbiAgICAgKiBpbmRpY2F0ZXMgdGhlIHN0cmVhbSBpcyBvcGVuIG9yIGluIHRoZSBwcm9jZXNzIG9mIG9wZW5pbmcgKHdoaWNoXG4gICAgICogZW5jb21wYXNzZXMgcmVzcGVjdGluZyBiYWNrb2ZmLCBnZXR0aW5nIGF1dGggdG9rZW5zLCBhbmQgc3RhcnRpbmcgdGhlXG4gICAgICogYWN0dWFsIFJQQykuIFVzZSBpc09wZW4oKSB0byBkZXRlcm1pbmUgaWYgdGhlIHN0cmVhbSBpcyBvcGVuIGFuZCByZWFkeSBmb3JcbiAgICAgKiBvdXRib3VuZCByZXF1ZXN0cy5cbiAgICAgKi9cbiAgICBpc1N0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZSA9PT0gMSAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuU3RhcnRpbmcgKi8gfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IDUgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkJhY2tvZmYgKi8gfHxcbiAgICAgICAgICAgIHRoaXMuaXNPcGVuKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHVuZGVybHlpbmcgUlBDIGlzIG9wZW4gKHRoZSBvbk9wZW4oKSBsaXN0ZW5lciBoYXMgYmVlblxuICAgICAqIGNhbGxlZCkgYW5kIHRoZSBzdHJlYW0gaXMgcmVhZHkgZm9yIG91dGJvdW5kIHJlcXVlc3RzLlxuICAgICAqL1xuICAgIGlzT3BlbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXRlID09PSAyIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5PcGVuICovIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSAzIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5IZWFsdGh5ICovKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBSUEMuIE9ubHkgYWxsb3dlZCBpZiBpc1N0YXJ0ZWQoKSByZXR1cm5zIGZhbHNlLiBUaGUgc3RyZWFtIGlzXG4gICAgICogbm90IGltbWVkaWF0ZWx5IHJlYWR5IGZvciB1c2U6IG9uT3BlbigpIHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSBSUEMgaXNcbiAgICAgKiByZWFkeSBmb3Igb3V0Ym91bmQgcmVxdWVzdHMsIGF0IHdoaWNoIHBvaW50IGlzT3BlbigpIHdpbGwgcmV0dXJuIHRydWUuXG4gICAgICpcbiAgICAgKiBXaGVuIHN0YXJ0IHJldHVybnMsIGlzU3RhcnRlZCgpIHdpbGwgcmV0dXJuIHRydWUuXG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2VDb3VudCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSA0IC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5FcnJvciAqLykge1xuICAgICAgICAgICAgdGhpcy5wZXJmb3JtQmFja29mZigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXV0aCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgUlBDLiBUaGlzIGNhbGwgaXMgaWRlbXBvdGVudCBhbmQgYWxsb3dlZCByZWdhcmRsZXNzIG9mIHRoZVxuICAgICAqIGN1cnJlbnQgaXNTdGFydGVkKCkgc3RhdGUuXG4gICAgICpcbiAgICAgKiBXaGVuIHN0b3AgcmV0dXJucywgaXNTdGFydGVkKCkgYW5kIGlzT3BlbigpIHdpbGwgYm90aCByZXR1cm4gZmFsc2UuXG4gICAgICovXG4gICAgYXN5bmMgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGFydGVkKCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xvc2UoMCAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuSW5pdGlhbCAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWZ0ZXIgYW4gZXJyb3IgdGhlIHN0cmVhbSB3aWxsIHVzdWFsbHkgYmFjayBvZmYgb24gdGhlIG5leHQgYXR0ZW1wdCB0b1xuICAgICAqIHN0YXJ0IGl0LiBJZiB0aGUgZXJyb3Igd2FycmFudHMgYW4gaW1tZWRpYXRlIHJlc3RhcnQgb2YgdGhlIHN0cmVhbSwgdGhlXG4gICAgICogc2VuZGVyIGNhbiB1c2UgdGhpcyB0byBpbmRpY2F0ZSB0aGF0IHRoZSByZWNlaXZlciBzaG91bGQgbm90IGJhY2sgb2ZmLlxuICAgICAqXG4gICAgICogRWFjaCBlcnJvciB3aWxsIGNhbGwgdGhlIG9uQ2xvc2UoKSBsaXN0ZW5lci4gVGhhdCBmdW5jdGlvbiBjYW4gZGVjaWRlIHRvXG4gICAgICogaW5oaWJpdCBiYWNrb2ZmIGlmIHJlcXVpcmVkLlxuICAgICAqL1xuICAgIGluaGliaXRCYWNrb2ZmKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gMCAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuSW5pdGlhbCAqLztcbiAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoaXMgc3RyZWFtIGFzIGlkbGUuIElmIG5vIGZ1cnRoZXIgYWN0aW9ucyBhcmUgcGVyZm9ybWVkIG9uIHRoZVxuICAgICAqIHN0cmVhbSBmb3Igb25lIG1pbnV0ZSwgdGhlIHN0cmVhbSB3aWxsIGF1dG9tYXRpY2FsbHkgY2xvc2UgaXRzZWxmIGFuZFxuICAgICAqIG5vdGlmeSB0aGUgc3RyZWFtJ3Mgb25DbG9zZSgpIGhhbmRsZXIgd2l0aCBTdGF0dXMuT0suIFRoZSBzdHJlYW0gd2lsbCB0aGVuXG4gICAgICogYmUgaW4gYSAhaXNTdGFydGVkKCkgc3RhdGUsIHJlcXVpcmluZyB0aGUgY2FsbGVyIHRvIHN0YXJ0IHRoZSBzdHJlYW0gYWdhaW5cbiAgICAgKiBiZWZvcmUgZnVydGhlciB1c2UuXG4gICAgICpcbiAgICAgKiBPbmx5IHN0cmVhbXMgdGhhdCBhcmUgaW4gc3RhdGUgJ09wZW4nIGNhbiBiZSBtYXJrZWQgaWRsZSwgYXMgYWxsIG90aGVyXG4gICAgICogc3RhdGVzIGltcGx5IHBlbmRpbmcgbmV0d29yayBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIG1hcmtJZGxlKCkge1xuICAgICAgICAvLyBTdGFydHMgdGhlIGlkbGUgdGltZSBpZiB3ZSBhcmUgaW4gc3RhdGUgJ09wZW4nIGFuZCBhcmUgbm90IHlldCBhbHJlYWR5XG4gICAgICAgIC8vIHJ1bm5pbmcgYSB0aW1lciAoaW4gd2hpY2ggY2FzZSB0aGUgcHJldmlvdXMgaWRsZSB0aW1lb3V0IHN0aWxsIGFwcGxpZXMpLlxuICAgICAgICBpZiAodGhpcy5pc09wZW4oKSAmJiB0aGlzLmlkbGVUaW1lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZGxlVGltZXIgPSB0aGlzLnF1ZXVlLmVucXVldWVBZnRlckRlbGF5KHRoaXMuaWRsZVRpbWVySWQsIElETEVfVElNRU9VVF9NUywgKCkgPT4gdGhpcy5oYW5kbGVJZGxlQ2xvc2VUaW1lcigpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSB1bmRlcmx5aW5nIHN0cmVhbS4gKi9cbiAgICBzZW5kUmVxdWVzdChtc2cpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxJZGxlQ2hlY2soKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uc2VuZChtc2cpO1xuICAgIH1cbiAgICAvKiogQ2FsbGVkIGJ5IHRoZSBpZGxlIHRpbWVyIHdoZW4gdGhlIHN0cmVhbSBzaG91bGQgY2xvc2UgZHVlIHRvIGluYWN0aXZpdHkuICovXG4gICAgYXN5bmMgaGFuZGxlSWRsZUNsb3NlVGltZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHRpbWluZyBvdXQgYW4gaWRsZSBzdHJlYW0gdGhlcmUncyBubyByZWFzb24gdG8gZm9yY2UgdGhlIHN0cmVhbSBpbnRvIGJhY2tvZmYgd2hlblxuICAgICAgICAgICAgLy8gaXQgcmVzdGFydHMgc28gc2V0IHRoZSBzdHJlYW0gc3RhdGUgdG8gSW5pdGlhbCBpbnN0ZWFkIG9mIEVycm9yLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UoMCAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuSW5pdGlhbCAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIE1hcmtzIHRoZSBzdHJlYW0gYXMgYWN0aXZlIGFnYWluLiAqL1xuICAgIGNhbmNlbElkbGVDaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuaWRsZVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLmlkbGVUaW1lci5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQ2FuY2VscyB0aGUgaGVhbHRoIGNoZWNrIGRlbGF5ZWQgb3BlcmF0aW9uLiAqL1xuICAgIGNhbmNlbEhlYWx0aENoZWNrKCkge1xuICAgICAgICBpZiAodGhpcy5oZWFsdGhDaGVjaykge1xuICAgICAgICAgICAgdGhpcy5oZWFsdGhDaGVjay5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuaGVhbHRoQ2hlY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgc3RyZWFtIGFuZCBjbGVhbnMgdXAgYXMgbmVjZXNzYXJ5OlxuICAgICAqXG4gICAgICogKiBjbG9zZXMgdGhlIHVuZGVybHlpbmcgR1JQQyBzdHJlYW07XG4gICAgICogKiBjYWxscyB0aGUgb25DbG9zZSBoYW5kbGVyIHdpdGggdGhlIGdpdmVuICdlcnJvcic7XG4gICAgICogKiBzZXRzIGludGVybmFsIHN0cmVhbSBzdGF0ZSB0byAnZmluYWxTdGF0ZSc7XG4gICAgICogKiBhZGp1c3RzIHRoZSBiYWNrb2ZmIHRpbWVyIGJhc2VkIG9uIHRoZSBlcnJvclxuICAgICAqXG4gICAgICogQSBuZXcgc3RyZWFtIGNhbiBiZSBvcGVuZWQgYnkgY2FsbGluZyBzdGFydCgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbmFsU3RhdGUgLSB0aGUgaW50ZW5kZWQgc3RhdGUgb2YgdGhlIHN0cmVhbSBhZnRlciBjbG9zaW5nLlxuICAgICAqIEBwYXJhbSBlcnJvciAtIHRoZSBlcnJvciB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIHdpdGguXG4gICAgICovXG4gICAgYXN5bmMgY2xvc2UoZmluYWxTdGF0ZSwgZXJyb3IpIHtcbiAgICAgICAgLy8gQ2FuY2VsIGFueSBvdXRzdGFuZGluZyB0aW1lcnMgKHRoZXkncmUgZ3VhcmFudGVlZCBub3QgdG8gZXhlY3V0ZSkuXG4gICAgICAgIHRoaXMuY2FuY2VsSWRsZUNoZWNrKCk7XG4gICAgICAgIHRoaXMuY2FuY2VsSGVhbHRoQ2hlY2soKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmLmNhbmNlbCgpO1xuICAgICAgICAvLyBJbnZhbGlkYXRlcyBhbnkgc3RyZWFtLXJlbGF0ZWQgY2FsbGJhY2tzIChlLmcuIGZyb20gYXV0aCBvciB0aGVcbiAgICAgICAgLy8gdW5kZXJseWluZyBzdHJlYW0pLCBndWFyYW50ZWVpbmcgdGhleSB3b24ndCBleGVjdXRlLlxuICAgICAgICB0aGlzLmNsb3NlQ291bnQrKztcbiAgICAgICAgaWYgKGZpbmFsU3RhdGUgIT09IDQgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkVycm9yICovKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGludGVudGlvbmFsIGNsb3NlIGVuc3VyZSB3ZSBkb24ndCBkZWxheSBvdXIgbmV4dCBjb25uZWN0aW9uIGF0dGVtcHQuXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBlcnJvci5jb2RlID09PSBDb2RlLlJFU09VUkNFX0VYSEFVU1RFRCkge1xuICAgICAgICAgICAgLy8gTG9nIHRoZSBlcnJvci4gKFByb2JhYmx5IGVpdGhlciAncXVvdGEgZXhjZWVkZWQnIG9yICdtYXggcXVldWUgbGVuZ3RoIHJlYWNoZWQnLilcbiAgICAgICAgICAgIGxvZ0Vycm9yKGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgbG9nRXJyb3IoJ1VzaW5nIG1heGltdW0gYmFja29mZiBkZWxheSB0byBwcmV2ZW50IG92ZXJsb2FkaW5nIHRoZSBiYWNrZW5kLicpO1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0VG9NYXgoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnJvciAmJlxuICAgICAgICAgICAgZXJyb3IuY29kZSA9PT0gQ29kZS5VTkFVVEhFTlRJQ0FURUQgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgIT09IDMgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkhlYWx0aHkgKi8pIHtcbiAgICAgICAgICAgIC8vIFwidW5hdXRoZW50aWNhdGVkXCIgZXJyb3IgbWVhbnMgdGhlIHRva2VuIHdhcyByZWplY3RlZC4gVGhpcyBzaG91bGQgcmFyZWx5XG4gICAgICAgICAgICAvLyBoYXBwZW4gc2luY2UgYm90aCBBdXRoIGFuZCBBcHBDaGVjayBlbnN1cmUgYSBzdWZmaWNpZW50IFRUTCB3aGVuIHdlXG4gICAgICAgICAgICAvLyByZXF1ZXN0IGEgdG9rZW4uIElmIGEgdXNlciBtYW51YWxseSByZXNldHMgdGhlaXIgc3lzdGVtIGNsb2NrIHRoaXMgY2FuXG4gICAgICAgICAgICAvLyBmYWlsLCBob3dldmVyLiBJbiB0aGlzIGNhc2UsIHdlIHNob3VsZCBnZXQgYSBDb2RlLlVOQVVUSEVOVElDQVRFRCBlcnJvclxuICAgICAgICAgICAgLy8gYmVmb3JlIHdlIHJlY2VpdmVkIHRoZSBmaXJzdCBtZXNzYWdlIGFuZCB3ZSBuZWVkIHRvIGludmFsaWRhdGUgdGhlIHRva2VuXG4gICAgICAgICAgICAvLyB0byBlbnN1cmUgdGhhdCB3ZSBmZXRjaCBhIG5ldyB0b2tlbi5cbiAgICAgICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxzUHJvdmlkZXIuaW52YWxpZGF0ZVRva2VuKCk7XG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHNQcm92aWRlci5pbnZhbGlkYXRlVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhbiB1cCB0aGUgdW5kZXJseWluZyBzdHJlYW0gYmVjYXVzZSB3ZSBhcmUgbm8gbG9uZ2VyIGludGVyZXN0ZWQgaW4gZXZlbnRzLlxuICAgICAgICBpZiAodGhpcy5zdHJlYW0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGVhckRvd24oKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBzdGF0ZSBtdXN0IGJlIGFzc2lnbmVkIGJlZm9yZSBjYWxsaW5nIG9uQ2xvc2UoKSB0byBhbGxvdyB0aGUgY2FsbGJhY2sgdG9cbiAgICAgICAgLy8gaW5oaWJpdCBiYWNrb2ZmIG9yIG90aGVyd2lzZSBtYW5pcHVsYXRlIHRoZSBzdGF0ZSBpbiBpdHMgbm9uLXN0YXJ0ZWQgc3RhdGUuXG4gICAgICAgIHRoaXMuc3RhdGUgPSBmaW5hbFN0YXRlO1xuICAgICAgICAvLyBOb3RpZnkgdGhlIGxpc3RlbmVyIHRoYXQgdGhlIHN0cmVhbSBjbG9zZWQuXG4gICAgICAgIGF3YWl0IHRoaXMubGlzdGVuZXIub25DbG9zZShlcnJvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbiBiZSBvdmVycmlkZGVuIHRvIHBlcmZvcm0gYWRkaXRpb25hbCBjbGVhbnVwIGJlZm9yZSB0aGUgc3RyZWFtIGlzIGNsb3NlZC5cbiAgICAgKiBDYWxsaW5nIHN1cGVyLnRlYXJEb3duKCkgaXMgbm90IHJlcXVpcmVkLlxuICAgICAqL1xuICAgIHRlYXJEb3duKCkgeyB9XG4gICAgYXV0aCgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLlN0YXJ0aW5nICovO1xuICAgICAgICBjb25zdCBkaXNwYXRjaElmTm90Q2xvc2VkID0gdGhpcy5nZXRDbG9zZUd1YXJkZWREaXNwYXRjaGVyKHRoaXMuY2xvc2VDb3VudCk7XG4gICAgICAgIC8vIFRPRE8obWlrZWxlaGVuKTogSnVzdCB1c2UgZGlzcGF0Y2hJZk5vdENsb3NlZCwgYnV0IHNlZSBUT0RPIGJlbG93LlxuICAgICAgICBjb25zdCBjbG9zZUNvdW50ID0gdGhpcy5jbG9zZUNvdW50O1xuICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyLmdldFRva2VuKCksXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHNQcm92aWRlci5nZXRUb2tlbigpXG4gICAgICAgIF0pLnRoZW4oKFthdXRoVG9rZW4sIGFwcENoZWNrVG9rZW5dKSA9PiB7XG4gICAgICAgICAgICAvLyBTdHJlYW0gY2FuIGJlIHN0b3BwZWQgd2hpbGUgd2FpdGluZyBmb3IgYXV0aGVudGljYXRpb24uXG4gICAgICAgICAgICAvLyBUT0RPKG1pa2VsZWhlbik6IFdlIHJlYWxseSBzaG91bGQganVzdCB1c2UgZGlzcGF0Y2hJZk5vdENsb3NlZFxuICAgICAgICAgICAgLy8gYW5kIGxldCB0aGlzIGRpc3BhdGNoIG9udG8gdGhlIHF1ZXVlLCBidXQgdGhhdCBvcGVuZWQgYSBzcGVjIHRlc3QgY2FuXG4gICAgICAgICAgICAvLyBvZiB3b3JtcyB0aGF0IEkgZG9uJ3Qgd2FudCB0byBkZWFsIHdpdGggaW4gdGhpcyBQUi5cbiAgICAgICAgICAgIGlmICh0aGlzLmNsb3NlQ291bnQgPT09IGNsb3NlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIGhhdmUgdG8gc2NoZWR1bGUgdGhlIGNhbGxiYWNrIG9uIHRoZSBBc3luY1F1ZXVlLlxuICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoZSBmb2xsb3dpbmcgY2FsbHMgYXJlIHNhZmUgdG8gYmUgY2FsbGVkIG91dHNpZGUgdGhlXG4gICAgICAgICAgICAgICAgLy8gQXN5bmNRdWV1ZSBzaW5jZSB0aGV5IGRvbid0IGNoYWluIGFzeW5jaHJvbm91cyBjYWxsc1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTdHJlYW0oYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaElmTm90Q2xvc2VkKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBycGNFcnJvciA9IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOS05PV04sICdGZXRjaGluZyBhdXRoIHRva2VuIGZhaWxlZDogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVN0cmVhbUNsb3NlKHJwY0Vycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhcnRTdHJlYW0oYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSB7XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoSWZOb3RDbG9zZWQgPSB0aGlzLmdldENsb3NlR3VhcmRlZERpc3BhdGNoZXIodGhpcy5jbG9zZUNvdW50KTtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSB0aGlzLnN0YXJ0UnBjKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uQ29ubmVjdGVkKCgpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoSWZOb3RDbG9zZWQoKCkgPT4gdGhpcy5saXN0ZW5lci5vbkNvbm5lY3RlZCgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uT3BlbigoKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaElmTm90Q2xvc2VkKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMiAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuT3BlbiAqLztcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWx0aENoZWNrID0gdGhpcy5xdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheSh0aGlzLmhlYWx0aFRpbWVySWQsIEhFQUxUSFlfVElNRU9VVF9NUywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkhlYWx0aHkgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLm9uT3BlbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbkNsb3NlKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2hJZk5vdENsb3NlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU3RyZWFtQ2xvc2UoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbk1lc3NhZ2UoKG1zZykgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2hJZk5vdENsb3NlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCsrdGhpcy5yZXNwb25zZUNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uRmlyc3QobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uTmV4dChtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGVyZm9ybUJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA1IC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5CYWNrb2ZmICovO1xuICAgICAgICB0aGlzLmJhY2tvZmYuYmFja29mZkFuZFJ1bihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMCAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuSW5pdGlhbCAqLztcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFZpc2libGUgZm9yIHRlc3RzXG4gICAgaGFuZGxlU3RyZWFtQ2xvc2UoZXJyb3IpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ3LCBgY2xvc2Ugd2l0aCBlcnJvcjogJHtlcnJvcn1gKTtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgICAgICAvLyBJbiB0aGVvcnkgdGhlIHN0cmVhbSBjb3VsZCBjbG9zZSBjbGVhbmx5LCBob3dldmVyLCBpbiBvdXIgY3VycmVudCBtb2RlbFxuICAgICAgICAvLyB3ZSBuZXZlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVjYXVzZSBpZiB3ZSBzdG9wIGEgc3RyZWFtIG91cnNlbHZlcyxcbiAgICAgICAgLy8gdGhpcyBjYWxsYmFjayB3aWxsIG5ldmVyIGJlIGNhbGxlZC4gVG8gcHJldmVudCBjYXNlcyB3aGVyZSB3ZSByZXRyeVxuICAgICAgICAvLyB3aXRob3V0IGEgYmFja29mZiBhY2NpZGVudGFsbHksIHdlIHNldCB0aGUgc3RyZWFtIHRvIGVycm9yIGluIGFsbCBjYXNlcy5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UoNCAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuRXJyb3IgKi8sIGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFwiZGlzcGF0Y2hlclwiIGZ1bmN0aW9uIHRoYXQgZGlzcGF0Y2hlcyBvcGVyYXRpb25zIG9udG8gdGhlXG4gICAgICogQXN5bmNRdWV1ZSBidXQgb25seSBydW5zIHRoZW0gaWYgY2xvc2VDb3VudCByZW1haW5zIHVuY2hhbmdlZC4gVGhpcyBhbGxvd3NcbiAgICAgKiB1cyB0byB0dXJuIGF1dGggLyBzdHJlYW0gY2FsbGJhY2tzIGludG8gbm8tb3BzIGlmIHRoZSBzdHJlYW0gaXMgY2xvc2VkIC9cbiAgICAgKiByZS1vcGVuZWQsIGV0Yy5cbiAgICAgKi9cbiAgICBnZXRDbG9zZUd1YXJkZWREaXNwYXRjaGVyKHN0YXJ0Q2xvc2VDb3VudCkge1xuICAgICAgICByZXR1cm4gKGZuKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsb3NlQ291bnQgPT09IHN0YXJ0Q2xvc2VDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNywgJ3N0cmVhbSBjYWxsYmFjayBza2lwcGVkIGJ5IGdldENsb3NlR3VhcmRlZERpc3BhdGNoZXIuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIEEgUGVyc2lzdGVudFN0cmVhbSB0aGF0IGltcGxlbWVudHMgdGhlIExpc3RlbiBSUEMuXG4gKlxuICogT25jZSB0aGUgTGlzdGVuIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBvbk9wZW4oKSBsaXN0ZW5lciwgYW55IG51bWJlciBvZlxuICogbGlzdGVuKCkgYW5kIHVubGlzdGVuKCkgY2FsbHMgY2FuIGJlIG1hZGUgdG8gY29udHJvbCB3aGF0IGNoYW5nZXMgd2lsbCBiZVxuICogc2VudCBmcm9tIHRoZSBzZXJ2ZXIgZm9yIExpc3RlblJlc3BvbnNlcy5cbiAqL1xuY2xhc3MgUGVyc2lzdGVudExpc3RlblN0cmVhbSBleHRlbmRzIFBlcnNpc3RlbnRTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXVlLCBjb25uZWN0aW9uLCBhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIHNlcmlhbGl6ZXIsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyKHF1ZXVlLCBcImxpc3Rlbl9zdHJlYW1fY29ubmVjdGlvbl9iYWNrb2ZmXCIgLyogVGltZXJJZC5MaXN0ZW5TdHJlYW1Db25uZWN0aW9uQmFja29mZiAqLywgXCJsaXN0ZW5fc3RyZWFtX2lkbGVcIiAvKiBUaW1lcklkLkxpc3RlblN0cmVhbUlkbGUgKi8sIFwiaGVhbHRoX2NoZWNrX3RpbWVvdXRcIiAvKiBUaW1lcklkLkhlYWx0aENoZWNrVGltZW91dCAqLywgY29ubmVjdGlvbiwgYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBsaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgfVxuICAgIHN0YXJ0UnBjKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLm9wZW5TdHJlYW0oJ0xpc3RlbicsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XG4gICAgfVxuICAgIG9uRmlyc3Qod2F0Y2hDaGFuZ2VQcm90bykge1xuICAgICAgICByZXR1cm4gdGhpcy5vbk5leHQod2F0Y2hDaGFuZ2VQcm90byk7XG4gICAgfVxuICAgIG9uTmV4dCh3YXRjaENoYW5nZVByb3RvKSB7XG4gICAgICAgIC8vIEEgc3VjY2Vzc2Z1bCByZXNwb25zZSBtZWFucyB0aGUgc3RyZWFtIGlzIGhlYWx0aHlcbiAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIGNvbnN0IHdhdGNoQ2hhbmdlID0gZnJvbVdhdGNoQ2hhbmdlKHRoaXMuc2VyaWFsaXplciwgd2F0Y2hDaGFuZ2VQcm90byk7XG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gdmVyc2lvbkZyb21MaXN0ZW5SZXNwb25zZSh3YXRjaENoYW5nZVByb3RvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIub25XYXRjaENoYW5nZSh3YXRjaENoYW5nZSwgc25hcHNob3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgaW50ZXJlc3QgaW4gdGhlIHJlc3VsdHMgb2YgdGhlIGdpdmVuIHRhcmdldC4gSWYgdGhlIHRhcmdldFxuICAgICAqIGluY2x1ZGVzIGEgcmVzdW1lVG9rZW4gaXQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVxdWVzdC4gUmVzdWx0cyB0aGF0XG4gICAgICogYWZmZWN0IHRoZSB0YXJnZXQgd2lsbCBiZSBzdHJlYW1lZCBiYWNrIGFzIFdhdGNoQ2hhbmdlIG1lc3NhZ2VzIHRoYXRcbiAgICAgKiByZWZlcmVuY2UgdGhlIHRhcmdldElkLlxuICAgICAqL1xuICAgIHdhdGNoKHRhcmdldERhdGEpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHt9O1xuICAgICAgICByZXF1ZXN0LmRhdGFiYXNlID0gZ2V0RW5jb2RlZERhdGFiYXNlSWQodGhpcy5zZXJpYWxpemVyKTtcbiAgICAgICAgcmVxdWVzdC5hZGRUYXJnZXQgPSB0b1RhcmdldCh0aGlzLnNlcmlhbGl6ZXIsIHRhcmdldERhdGEpO1xuICAgICAgICBjb25zdCBsYWJlbHMgPSB0b0xpc3RlblJlcXVlc3RMYWJlbHModGhpcy5zZXJpYWxpemVyLCB0YXJnZXREYXRhKTtcbiAgICAgICAgaWYgKGxhYmVscykge1xuICAgICAgICAgICAgcmVxdWVzdC5sYWJlbHMgPSBsYWJlbHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlcnMgaW50ZXJlc3QgaW4gdGhlIHJlc3VsdHMgb2YgdGhlIHRhcmdldCBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgICogZ2l2ZW4gdGFyZ2V0SWQuXG4gICAgICovXG4gICAgdW53YXRjaCh0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge307XG4gICAgICAgIHJlcXVlc3QuZGF0YWJhc2UgPSBnZXRFbmNvZGVkRGF0YWJhc2VJZCh0aGlzLnNlcmlhbGl6ZXIpO1xuICAgICAgICByZXF1ZXN0LnJlbW92ZVRhcmdldCA9IHRhcmdldElkO1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIH1cbn1cbi8qKlxuICogQSBTdHJlYW0gdGhhdCBpbXBsZW1lbnRzIHRoZSBXcml0ZSBSUEMuXG4gKlxuICogVGhlIFdyaXRlIFJQQyByZXF1aXJlcyB0aGUgY2FsbGVyIHRvIG1haW50YWluIHNwZWNpYWwgc3RyZWFtVG9rZW5cbiAqIHN0YXRlIGluIGJldHdlZW4gY2FsbHMsIHRvIGhlbHAgdGhlIHNlcnZlciB1bmRlcnN0YW5kIHdoaWNoIHJlc3BvbnNlcyB0aGVcbiAqIGNsaWVudCBoYXMgcHJvY2Vzc2VkIGJ5IHRoZSB0aW1lIHRoZSBuZXh0IHJlcXVlc3QgaXMgbWFkZS4gRXZlcnkgcmVzcG9uc2VcbiAqIHdpbGwgY29udGFpbiBhIHN0cmVhbVRva2VuOyB0aGlzIHZhbHVlIG11c3QgYmUgcGFzc2VkIHRvIHRoZSBuZXh0XG4gKiByZXF1ZXN0LlxuICpcbiAqIEFmdGVyIGNhbGxpbmcgc3RhcnQoKSBvbiB0aGlzIHN0cmVhbSwgdGhlIG5leHQgcmVxdWVzdCBtdXN0IGJlIGEgaGFuZHNoYWtlLFxuICogY29udGFpbmluZyB3aGF0ZXZlciBzdHJlYW1Ub2tlbiBpcyBvbiBoYW5kLiBPbmNlIGEgcmVzcG9uc2UgdG8gdGhpc1xuICogcmVxdWVzdCBpcyByZWNlaXZlZCwgYWxsIHBlbmRpbmcgbXV0YXRpb25zIG1heSBiZSBzdWJtaXR0ZWQuIFdoZW5cbiAqIHN1Ym1pdHRpbmcgbXVsdGlwbGUgYmF0Y2hlcyBvZiBtdXRhdGlvbnMgYXQgdGhlIHNhbWUgdGltZSwgaXQnc1xuICogb2theSB0byB1c2UgdGhlIHNhbWUgc3RyZWFtVG9rZW4gZm9yIHRoZSBjYWxscyB0byB3cml0ZU11dGF0aW9ucy5cbiAqXG4gKiBUT0RPKGIvMzMyNzEyMzUpOiBVc2UgcHJvdG8gdHlwZXNcbiAqL1xuY2xhc3MgUGVyc2lzdGVudFdyaXRlU3RyZWFtIGV4dGVuZHMgUGVyc2lzdGVudFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IocXVldWUsIGNvbm5lY3Rpb24sIGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgc2VyaWFsaXplciwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIocXVldWUsIFwid3JpdGVfc3RyZWFtX2Nvbm5lY3Rpb25fYmFja29mZlwiIC8qIFRpbWVySWQuV3JpdGVTdHJlYW1Db25uZWN0aW9uQmFja29mZiAqLywgXCJ3cml0ZV9zdHJlYW1faWRsZVwiIC8qIFRpbWVySWQuV3JpdGVTdHJlYW1JZGxlICovLCBcImhlYWx0aF9jaGVja190aW1lb3V0XCIgLyogVGltZXJJZC5IZWFsdGhDaGVja1RpbWVvdXQgKi8sIGNvbm5lY3Rpb24sIGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgbGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFja3Mgd2hldGhlciBvciBub3QgYSBoYW5kc2hha2UgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGV4Y2hhbmdlZCBhbmRcbiAgICAgKiB0aGUgc3RyZWFtIGlzIHJlYWR5IHRvIGFjY2VwdCBtdXRhdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IGhhbmRzaGFrZUNvbXBsZXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUNvdW50ID4gMDtcbiAgICB9XG4gICAgLy8gT3ZlcnJpZGUgb2YgUGVyc2lzdGVudFN0cmVhbS5zdGFydFxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLmxhc3RTdHJlYW1Ub2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3VwZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgdGVhckRvd24oKSB7XG4gICAgICAgIGlmICh0aGlzLmhhbmRzaGFrZUNvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlTXV0YXRpb25zKFtdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFJwYyhhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5vcGVuU3RyZWFtKCdXcml0ZScsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XG4gICAgfVxuICAgIG9uRmlyc3QocmVzcG9uc2VQcm90bykge1xuICAgICAgICAvLyBBbHdheXMgY2FwdHVyZSB0aGUgbGFzdCBzdHJlYW0gdG9rZW4uXG4gICAgICAgIGhhcmRBc3NlcnQoISFyZXNwb25zZVByb3RvLnN0cmVhbVRva2VuLCAweDdhNWEpO1xuICAgICAgICB0aGlzLmxhc3RTdHJlYW1Ub2tlbiA9IHJlc3BvbnNlUHJvdG8uc3RyZWFtVG9rZW47XG4gICAgICAgIC8vIFRoZSBmaXJzdCByZXNwb25zZSBpcyBhbHdheXMgdGhlIGhhbmRzaGFrZSByZXNwb25zZVxuICAgICAgICBoYXJkQXNzZXJ0KCFyZXNwb25zZVByb3RvLndyaXRlUmVzdWx0cyB8fCByZXNwb25zZVByb3RvLndyaXRlUmVzdWx0cy5sZW5ndGggPT09IDAsIDB4ZGEwOCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLm9uSGFuZHNoYWtlQ29tcGxldGUoKTtcbiAgICB9XG4gICAgb25OZXh0KHJlc3BvbnNlUHJvdG8pIHtcbiAgICAgICAgLy8gQWx3YXlzIGNhcHR1cmUgdGhlIGxhc3Qgc3RyZWFtIHRva2VuLlxuICAgICAgICBoYXJkQXNzZXJ0KCEhcmVzcG9uc2VQcm90by5zdHJlYW1Ub2tlbiwgMHgzMTg2KTtcbiAgICAgICAgdGhpcy5sYXN0U3RyZWFtVG9rZW4gPSByZXNwb25zZVByb3RvLnN0cmVhbVRva2VuO1xuICAgICAgICAvLyBBIHN1Y2Nlc3NmdWwgZmlyc3Qgd3JpdGUgcmVzcG9uc2UgbWVhbnMgdGhlIHN0cmVhbSBpcyBoZWFsdGh5LFxuICAgICAgICAvLyBOb3RlLCB0aGF0IHdlIGNvdWxkIGNvbnNpZGVyIGEgc3VjY2Vzc2Z1bCBoYW5kc2hha2UgaGVhbHRoeSwgaG93ZXZlcixcbiAgICAgICAgLy8gdGhlIHdyaXRlIGl0c2VsZiBtaWdodCBiZSBjYXVzaW5nIGFuIGVycm9yIHdlIHdhbnQgdG8gYmFjayBvZmYgZnJvbS5cbiAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBmcm9tV3JpdGVSZXN1bHRzKHJlc3BvbnNlUHJvdG8ud3JpdGVSZXN1bHRzLCByZXNwb25zZVByb3RvLmNvbW1pdFRpbWUpO1xuICAgICAgICBjb25zdCBjb21taXRWZXJzaW9uID0gZnJvbVZlcnNpb24ocmVzcG9uc2VQcm90by5jb21taXRUaW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIub25NdXRhdGlvblJlc3VsdChjb21taXRWZXJzaW9uLCByZXN1bHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYW4gaW5pdGlhbCBzdHJlYW1Ub2tlbiB0byB0aGUgc2VydmVyLCBwZXJmb3JtaW5nIHRoZSBoYW5kc2hha2VcbiAgICAgKiByZXF1aXJlZCB0byBtYWtlIHRoZSBTdHJlYW1pbmdXcml0ZSBSUEMgd29yay4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHNob3VsZCB3YWl0IHVudGlsIG9uSGFuZHNoYWtlQ29tcGxldGUgd2FzIGNhbGxlZC5cbiAgICAgKi9cbiAgICB3cml0ZUhhbmRzaGFrZSgpIHtcbiAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiBTdXBwb3J0IHN0cmVhbSByZXN1bXB0aW9uLiBXZSBpbnRlbnRpb25hbGx5IGRvIG5vdCBzZXQgdGhlXG4gICAgICAgIC8vIHN0cmVhbSB0b2tlbiBvbiB0aGUgaGFuZHNoYWtlLCBpZ25vcmluZyBhbnkgc3RyZWFtIHRva2VuIHdlIG1pZ2h0IGhhdmUuXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgcmVxdWVzdC5kYXRhYmFzZSA9IGdldEVuY29kZWREYXRhYmFzZUlkKHRoaXMuc2VyaWFsaXplcik7XG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCk7XG4gICAgfVxuICAgIC8qKiBTZW5kcyBhIGdyb3VwIG9mIG11dGF0aW9ucyB0byB0aGUgRmlyZXN0b3JlIGJhY2tlbmQgdG8gYXBwbHkuICovXG4gICAgd3JpdGVNdXRhdGlvbnMobXV0YXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBzdHJlYW1Ub2tlbjogdGhpcy5sYXN0U3RyZWFtVG9rZW4sXG4gICAgICAgICAgICB3cml0ZXM6IG11dGF0aW9ucy5tYXAobXV0YXRpb24gPT4gdG9NdXRhdGlvbih0aGlzLnNlcmlhbGl6ZXIsIG11dGF0aW9uKSlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIERhdGFzdG9yZSBhbmQgaXRzIHJlbGF0ZWQgbWV0aG9kcyBhcmUgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZXh0ZXJuYWwgR29vZ2xlXG4gKiBDbG91ZCBEYXRhc3RvcmUgZ3JwYyBBUEksIHdoaWNoIHByb3ZpZGVzIGFuIGludGVyZmFjZSB0aGF0IGlzIG1vcmUgY29udmVuaWVudFxuICogZm9yIHRoZSByZXN0IG9mIHRoZSBjbGllbnQgU0RLIGFyY2hpdGVjdHVyZSB0byBjb25zdW1lLlxuICovXG5jbGFzcyBEYXRhc3RvcmUge1xufVxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBEYXRhc3RvcmUgdGhhdCBleHBvc2VzIGFkZGl0aW9uYWwgc3RhdGUgZm9yIGludGVybmFsXG4gKiBjb25zdW1wdGlvbi5cbiAqL1xuY2xhc3MgRGF0YXN0b3JlSW1wbCBleHRlbmRzIERhdGFzdG9yZSB7XG4gICAgY29uc3RydWN0b3IoYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBjb25uZWN0aW9uLCBzZXJpYWxpemVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxzID0gYXV0aENyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMgPSBhcHBDaGVja0NyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICB0aGlzLnRlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdmVyaWZ5SW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdUaGUgY2xpZW50IGhhcyBhbHJlYWR5IGJlZW4gdGVybWluYXRlZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogSW52b2tlcyB0aGUgcHJvdmlkZWQgUlBDIHdpdGggYXV0aCBhbmQgQXBwQ2hlY2sgdG9rZW5zLiAqL1xuICAgIGludm9rZVJQQyhycGNOYW1lLCBkYXRhYmFzZUlkLCByZXNvdXJjZVBhdGgsIHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlJbml0aWFsaXplZCgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuZ2V0VG9rZW4oKSxcbiAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscy5nZXRUb2tlbigpXG4gICAgICAgIF0pXG4gICAgICAgICAgICAudGhlbigoW2F1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbl0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uaW52b2tlUlBDKHJwY05hbWUsIHRvUmVzb3VyY2VQYXRoKGRhdGFiYXNlSWQsIHJlc291cmNlUGF0aCksIHJlcXVlc3QsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0ZpcmViYXNlRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IENvZGUuVU5BVVRIRU5USUNBVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxzLmludmFsaWRhdGVUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuaW52YWxpZGF0ZVRva2VuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5LTk9XTiwgZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogSW52b2tlcyB0aGUgcHJvdmlkZWQgUlBDIHdpdGggc3RyZWFtZWQgcmVzdWx0cyB3aXRoIGF1dGggYW5kIEFwcENoZWNrIHRva2Vucy4gKi9cbiAgICBpbnZva2VTdHJlYW1pbmdSUEMocnBjTmFtZSwgZGF0YWJhc2VJZCwgcmVzb3VyY2VQYXRoLCByZXF1ZXN0LCBleHBlY3RlZFJlc3BvbnNlQ291bnQpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlJbml0aWFsaXplZCgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuZ2V0VG9rZW4oKSxcbiAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscy5nZXRUb2tlbigpXG4gICAgICAgIF0pXG4gICAgICAgICAgICAudGhlbigoW2F1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbl0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uaW52b2tlU3RyZWFtaW5nUlBDKHJwY05hbWUsIHRvUmVzb3VyY2VQYXRoKGRhdGFiYXNlSWQsIHJlc291cmNlUGF0aCksIHJlcXVlc3QsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgZXhwZWN0ZWRSZXNwb25zZUNvdW50KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnRmlyZWJhc2VFcnJvcicpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gQ29kZS5VTkFVVEhFTlRJQ0FURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuaW52YWxpZGF0ZVRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscy5pbnZhbGlkYXRlVG9rZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTktOT1dOLCBlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnRlcm1pbmF0ZSgpO1xuICAgIH1cbn1cbi8vIFRPRE8oZmlyZXN0b3JleHApOiBNYWtlIHN1cmUgdGhlcmUgaXMgb25seSBvbmUgRGF0YXN0b3JlIGluc3RhbmNlIHBlclxuLy8gZmlyZXN0b3JlLWV4cCBjbGllbnQuXG5mdW5jdGlvbiBuZXdEYXRhc3RvcmUoYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBjb25uZWN0aW9uLCBzZXJpYWxpemVyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhc3RvcmVJbXBsKGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcik7XG59XG5hc3luYyBmdW5jdGlvbiBpbnZva2VDb21taXRScGMoZGF0YXN0b3JlLCBtdXRhdGlvbnMpIHtcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgd3JpdGVzOiBtdXRhdGlvbnMubWFwKG0gPT4gdG9NdXRhdGlvbihkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIsIG0pKVxuICAgIH07XG4gICAgYXdhaXQgZGF0YXN0b3JlSW1wbC5pbnZva2VSUEMoJ0NvbW1pdCcsIGRhdGFzdG9yZUltcGwuc2VyaWFsaXplci5kYXRhYmFzZUlkLCBSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCksIHJlcXVlc3QpO1xufVxuYXN5bmMgZnVuY3Rpb24gaW52b2tlQmF0Y2hHZXREb2N1bWVudHNScGMoZGF0YXN0b3JlLCBrZXlzKSB7XG4gICAgY29uc3QgZGF0YXN0b3JlSW1wbCA9IGRlYnVnQ2FzdChkYXRhc3RvcmUpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIGRvY3VtZW50czoga2V5cy5tYXAoayA9PiB0b05hbWUoZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBrKSlcbiAgICB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZGF0YXN0b3JlSW1wbC5pbnZva2VTdHJlYW1pbmdSUEMoJ0JhdGNoR2V0RG9jdW1lbnRzJywgZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLmRhdGFiYXNlSWQsIFJlc291cmNlUGF0aC5lbXB0eVBhdGgoKSwgcmVxdWVzdCwga2V5cy5sZW5ndGgpO1xuICAgIGNvbnN0IGRvY3MgPSBuZXcgTWFwKCk7XG4gICAgcmVzcG9uc2UuZm9yRWFjaChwcm90byA9PiB7XG4gICAgICAgIGNvbnN0IGRvYyA9IGZyb21CYXRjaEdldERvY3VtZW50c1Jlc3BvbnNlKGRhdGFzdG9yZUltcGwuc2VyaWFsaXplciwgcHJvdG8pO1xuICAgICAgICBkb2NzLnNldChkb2Mua2V5LnRvU3RyaW5nKCksIGRvYyk7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGNvbnN0IGRvYyA9IGRvY3MuZ2V0KGtleS50b1N0cmluZygpKTtcbiAgICAgICAgaGFyZEFzc2VydCghIWRvYywgMHhkN2MyLCB7XG4gICAgICAgICAgICBrZXlcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGRvYyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGludm9rZUV4ZWN1dGVQaXBlbGluZShkYXRhc3RvcmUsIHN0cnVjdHVyZWRQaXBlbGluZSkge1xuICAgIGNvbnN0IGRhdGFzdG9yZUltcGwgPSBkZWJ1Z0Nhc3QoZGF0YXN0b3JlKTtcbiAgICBjb25zdCBleGVjdXRlUGlwZWxpbmVSZXF1ZXN0ID0ge1xuICAgICAgICBkYXRhYmFzZTogZ2V0RW5jb2RlZERhdGFiYXNlSWQoZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyKSxcbiAgICAgICAgc3RydWN0dXJlZFBpcGVsaW5lOiBzdHJ1Y3R1cmVkUGlwZWxpbmUuX3RvUHJvdG8oZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyKVxuICAgIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkYXRhc3RvcmVJbXBsLmludm9rZVN0cmVhbWluZ1JQQygnRXhlY3V0ZVBpcGVsaW5lJywgZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLmRhdGFiYXNlSWQsIFJlc291cmNlUGF0aC5lbXB0eVBhdGgoKSwgZXhlY3V0ZVBpcGVsaW5lUmVxdWVzdCk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgcmVzcG9uc2UuZm9yRWFjaChwcm90byA9PiB7XG4gICAgICAgIGlmICghcHJvdG8ucmVzdWx0cyB8fCBwcm90by5yZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbVBpcGVsaW5lUmVzcG9uc2UoZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBwcm90bykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByb3RvLnJlc3VsdHMuZm9yRWFjaChkb2N1bWVudCA9PiByZXN1bHQucHVzaChmcm9tUGlwZWxpbmVSZXNwb25zZShkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIsIHByb3RvLCBkb2N1bWVudCkpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5hc3luYyBmdW5jdGlvbiBpbnZva2VSdW5BZ2dyZWdhdGlvblF1ZXJ5UnBjKGRhdGFzdG9yZSwgcXVlcnksIGFnZ3JlZ2F0ZXMpIHtcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XG4gICAgY29uc3QgeyByZXF1ZXN0LCBhbGlhc01hcCwgcGFyZW50IH0gPSB0b1J1bkFnZ3JlZ2F0aW9uUXVlcnlSZXF1ZXN0KGRhdGFzdG9yZUltcGwuc2VyaWFsaXplciwgcXVlcnlUb0FnZ3JlZ2F0ZVRhcmdldChxdWVyeSksIGFnZ3JlZ2F0ZXMpO1xuICAgIGlmICghZGF0YXN0b3JlSW1wbC5jb25uZWN0aW9uLnNob3VsZFJlc291cmNlUGF0aEJlSW5jbHVkZWRJblJlcXVlc3QpIHtcbiAgICAgICAgZGVsZXRlIHJlcXVlc3QucGFyZW50O1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRhdGFzdG9yZUltcGwuaW52b2tlU3RyZWFtaW5nUlBDKCdSdW5BZ2dyZWdhdGlvblF1ZXJ5JywgZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLmRhdGFiYXNlSWQsIHBhcmVudCwgcmVxdWVzdCwgXG4gICAgLypleHBlY3RlZFJlc3BvbnNlQ291bnQ9Ki8gMSk7XG4gICAgLy8gT21pdCBSdW5BZ2dyZWdhdGlvblF1ZXJ5UmVzcG9uc2UgdGhhdCBvbmx5IGNvbnRhaW4gcmVhZFRpbWVzLlxuICAgIGNvbnN0IGZpbHRlcmVkUmVzdWx0ID0gcmVzcG9uc2UuZmlsdGVyKHByb3RvID0+ICEhcHJvdG8ucmVzdWx0KTtcbiAgICBoYXJkQXNzZXJ0KGZpbHRlcmVkUmVzdWx0Lmxlbmd0aCA9PT0gMSwgMHhmY2Q3KTtcbiAgICAvLyBSZW1hcCB0aGUgc2hvcnQtZm9ybSBhbGlhc2VzIHRoYXQgd2VyZSBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICAvLyB0byB0aGUgY2xpZW50LXNpZGUgYWxpYXNlcy4gVXNlcnMgd2lsbCBhY2Nlc3MgdGhlIHJlc3VsdHNcbiAgICAvLyB1c2luZyB0aGUgY2xpZW50LXNpZGUgYWxpYXMuXG4gICAgY29uc3QgdW5tYXBwZWRBZ2dyZWdhdGVGaWVsZHMgPSBmaWx0ZXJlZFJlc3VsdFswXS5yZXN1bHQ/LmFnZ3JlZ2F0ZUZpZWxkcztcbiAgICBjb25zdCByZW1hcHBlZEZpZWxkcyA9IE9iamVjdC5rZXlzKHVubWFwcGVkQWdncmVnYXRlRmllbGRzKS5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBrZXkpID0+IHtcbiAgICAgICAgYWNjdW11bGF0b3JbYWxpYXNNYXBba2V5XV0gPSB1bm1hcHBlZEFnZ3JlZ2F0ZUZpZWxkc1trZXldO1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfSwge30pO1xuICAgIHJldHVybiByZW1hcHBlZEZpZWxkcztcbn1cbmZ1bmN0aW9uIG5ld1BlcnNpc3RlbnRXcml0ZVN0cmVhbShkYXRhc3RvcmUsIHF1ZXVlLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGRhdGFzdG9yZUltcGwgPSBkZWJ1Z0Nhc3QoZGF0YXN0b3JlKTtcbiAgICBkYXRhc3RvcmVJbXBsLnZlcmlmeUluaXRpYWxpemVkKCk7XG4gICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW50V3JpdGVTdHJlYW0ocXVldWUsIGRhdGFzdG9yZUltcGwuY29ubmVjdGlvbiwgZGF0YXN0b3JlSW1wbC5hdXRoQ3JlZGVudGlhbHMsIGRhdGFzdG9yZUltcGwuYXBwQ2hlY2tDcmVkZW50aWFscywgZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBsaXN0ZW5lcik7XG59XG5mdW5jdGlvbiBuZXdQZXJzaXN0ZW50V2F0Y2hTdHJlYW0oZGF0YXN0b3JlLCBxdWV1ZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XG4gICAgZGF0YXN0b3JlSW1wbC52ZXJpZnlJbml0aWFsaXplZCgpO1xuICAgIHJldHVybiBuZXcgUGVyc2lzdGVudExpc3RlblN0cmVhbShxdWV1ZSwgZGF0YXN0b3JlSW1wbC5jb25uZWN0aW9uLCBkYXRhc3RvcmVJbXBsLmF1dGhDcmVkZW50aWFscywgZGF0YXN0b3JlSW1wbC5hcHBDaGVja0NyZWRlbnRpYWxzLCBkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIsIGxpc3RlbmVyKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckNiA9ICdPbmxpbmVTdGF0ZVRyYWNrZXInO1xuLy8gVG8gZGVhbCB3aXRoIHRyYW5zaWVudCBmYWlsdXJlcywgd2UgYWxsb3cgbXVsdGlwbGUgc3RyZWFtIGF0dGVtcHRzIGJlZm9yZVxuLy8gZ2l2aW5nIHVwIGFuZCB0cmFuc2l0aW9uaW5nIGZyb20gT25saW5lU3RhdGUuVW5rbm93biB0byBPZmZsaW5lLlxuLy8gVE9ETyhtaWtlbGVoZW4pOiBUaGlzIHVzZWQgdG8gYmUgc2V0IHRvIDIgYXMgYSBtaXRpZ2F0aW9uIGZvciBiLzY2MjI4Mzk0LlxuLy8gQGpkaW1vbmQgdGhpbmtzIHRoYXQgYnVnIGlzIHN1ZmZpY2llbnRseSBmaXhlZCBzbyB0aGF0IHdlIGNhbiBzZXQgdGhpcyBiYWNrXG4vLyB0byAxLiBJZiB0aGF0IHdvcmtzIG9rYXksIHdlIGNvdWxkIHBvdGVudGlhbGx5IHJlbW92ZSB0aGlzIGxvZ2ljIGVudGlyZWx5LlxuY29uc3QgTUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFUyA9IDE7XG4vLyBUbyBkZWFsIHdpdGggc3RyZWFtIGF0dGVtcHRzIHRoYXQgZG9uJ3Qgc3VjY2VlZCBvciBmYWlsIGluIGEgdGltZWx5IG1hbm5lcixcbi8vIHdlIGhhdmUgYSB0aW1lb3V0IGZvciBPbmxpbmVTdGF0ZSB0byByZWFjaCBPbmxpbmUgb3IgT2ZmbGluZS5cbi8vIElmIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQsIHdlIHRyYW5zaXRpb24gdG8gT2ZmbGluZSByYXRoZXIgdGhhbiB3YWl0aW5nXG4vLyBpbmRlZmluaXRlbHkuXG5jb25zdCBPTkxJTkVfU1RBVEVfVElNRU9VVF9NUyA9IDEwICogMTAwMDtcbi8qKlxuICogQSBjb21wb25lbnQgdXNlZCBieSB0aGUgUmVtb3RlU3RvcmUgdG8gdHJhY2sgdGhlIE9ubGluZVN0YXRlICh0aGF0IGlzLFxuICogd2hldGhlciBvciBub3QgdGhlIGNsaWVudCBhcyBhIHdob2xlIHNob3VsZCBiZSBjb25zaWRlcmVkIHRvIGJlIG9ubGluZSBvclxuICogb2ZmbGluZSksIGltcGxlbWVudGluZyB0aGUgYXBwcm9wcmlhdGUgaGV1cmlzdGljcy5cbiAqXG4gKiBJbiBwYXJ0aWN1bGFyLCB3aGVuIHRoZSBjbGllbnQgaXMgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gdGhlIGJhY2tlbmQsIHdlXG4gKiBhbGxvdyB1cCB0byBNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTIHdpdGhpbiBPTkxJTkVfU1RBVEVfVElNRU9VVF9NUyBmb3JcbiAqIGEgY29ubmVjdGlvbiB0byBzdWNjZWVkLiBJZiB3ZSBoYXZlIHRvbyBtYW55IGZhaWx1cmVzIG9yIHRoZSB0aW1lb3V0IGVsYXBzZXMsXG4gKiB0aGVuIHdlIHNldCB0aGUgT25saW5lU3RhdGUgdG8gT2ZmbGluZSwgYW5kIHRoZSBjbGllbnQgd2lsbCBiZWhhdmUgYXMgaWZcbiAqIGl0IGlzIG9mZmxpbmUgKGdldCgpcyB3aWxsIHJldHVybiBjYWNoZWQgZGF0YSwgZXRjLikuXG4gKi9cbmNsYXNzIE9ubGluZVN0YXRlVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoYXN5bmNRdWV1ZSwgb25saW5lU3RhdGVIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZSA9IGFzeW5jUXVldWU7XG4gICAgICAgIHRoaXMub25saW5lU3RhdGVIYW5kbGVyID0gb25saW5lU3RhdGVIYW5kbGVyO1xuICAgICAgICAvKiogVGhlIGN1cnJlbnQgT25saW5lU3RhdGUuICovXG4gICAgICAgIHRoaXMuc3RhdGUgPSBcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBjb3VudCBvZiBjb25zZWN1dGl2ZSBmYWlsdXJlcyB0byBvcGVuIHRoZSBzdHJlYW0uIElmIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgICAqIG1heGltdW0gZGVmaW5lZCBieSBNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTLCB3ZSdsbCBzZXQgdGhlIE9ubGluZVN0YXRlIHRvXG4gICAgICAgICAqIE9mZmxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSB0aW1lciB0aGF0IGVsYXBzZXMgYWZ0ZXIgT05MSU5FX1NUQVRFX1RJTUVPVVRfTVMsIGF0IHdoaWNoIHBvaW50IHdlXG4gICAgICAgICAqIHRyYW5zaXRpb24gZnJvbSBPbmxpbmVTdGF0ZS5Vbmtub3duIHRvIE9ubGluZVN0YXRlLk9mZmxpbmUgd2l0aG91dCB3YWl0aW5nXG4gICAgICAgICAqIGZvciB0aGUgc3RyZWFtIHRvIGFjdHVhbGx5IGZhaWwgKE1BWF9XQVRDSF9TVFJFQU1fRkFJTFVSRVMgdGltZXMpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNsaWVudCBzaG91bGQgbG9nIGEgd2FybmluZyBtZXNzYWdlIGlmIGl0IGZhaWxzIHRvIGNvbm5lY3QgdG9cbiAgICAgICAgICogdGhlIGJhY2tlbmQgKGluaXRpYWxseSB0cnVlLCBjbGVhcmVkIGFmdGVyIGEgc3VjY2Vzc2Z1bCBzdHJlYW0sIG9yIGlmIHdlJ3ZlXG4gICAgICAgICAqIGxvZ2dlZCB0aGUgbWVzc2FnZSBhbHJlYWR5KS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hvdWxkV2FybkNsaWVudElzT2ZmbGluZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCBieSBSZW1vdGVTdG9yZSB3aGVuIGEgd2F0Y2ggc3RyZWFtIGlzIHN0YXJ0ZWQgKGluY2x1ZGluZyBvbiBlYWNoXG4gICAgICogYmFja29mZiBhdHRlbXB0KS5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgaXMgdGhlIGZpcnN0IGF0dGVtcHQsIGl0IHNldHMgdGhlIE9ubGluZVN0YXRlIHRvIFVua25vd24gYW5kIHN0YXJ0c1xuICAgICAqIHRoZSBvbmxpbmVTdGF0ZVRpbWVyLlxuICAgICAqL1xuICAgIGhhbmRsZVdhdGNoU3RyZWFtU3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QW5kQnJvYWRjYXN0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xuICAgICAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZVRpbWVyID0gdGhpcy5hc3luY1F1ZXVlLmVucXVldWVBZnRlckRlbGF5KFwib25saW5lX3N0YXRlX3RpbWVvdXRcIiAvKiBUaW1lcklkLk9ubGluZVN0YXRlVGltZW91dCAqLywgT05MSU5FX1NUQVRFX1RJTUVPVVRfTVMsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ubGluZVN0YXRlVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nQ2xpZW50T2ZmbGluZVdhcm5pbmdJZk5lY2Vzc2FyeShgQmFja2VuZCBkaWRuJ3QgcmVzcG9uZCB3aXRoaW4gJHtPTkxJTkVfU1RBVEVfVElNRU9VVF9NUyAvIDEwMDB9IGAgK1xuICAgICAgICAgICAgICAgICAgICBgc2Vjb25kcy5gKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFuZEJyb2FkY2FzdChcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovKTtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBoYW5kbGVXYXRjaFN0cmVhbUZhaWx1cmUoKSB3aWxsIGNvbnRpbnVlIHRvIGluY3JlbWVudFxuICAgICAgICAgICAgICAgIC8vIHdhdGNoU3RyZWFtRmFpbHVyZXMgZXZlbiB0aG91Z2ggd2UgYXJlIGFscmVhZHkgbWFya2VkIE9mZmxpbmUsXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoaXMgaXMgbm9uLWhhcm1mdWwuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBvdXIgT25saW5lU3RhdGUgYXMgYXBwcm9wcmlhdGUgYWZ0ZXIgdGhlIHdhdGNoIHN0cmVhbSByZXBvcnRzIGFcbiAgICAgKiBmYWlsdXJlLiBUaGUgZmlyc3QgZmFpbHVyZSBtb3ZlcyB1cyB0byB0aGUgJ1Vua25vd24nIHN0YXRlLiBXZSB0aGVuIG1heVxuICAgICAqIGFsbG93IG11bHRpcGxlIGZhaWx1cmVzIChiYXNlZCBvbiBNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTKSBiZWZvcmUgd2VcbiAgICAgKiBhY3R1YWxseSB0cmFuc2l0aW9uIHRvIHRoZSAnT2ZmbGluZScgc3RhdGUuXG4gICAgICovXG4gICAgaGFuZGxlV2F0Y2hTdHJlYW1GYWlsdXJlKGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcIk9ubGluZVwiIC8qIE9ubGluZVN0YXRlLk9ubGluZSAqLykge1xuICAgICAgICAgICAgdGhpcy5zZXRBbmRCcm9hZGNhc3QoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMrKztcbiAgICAgICAgICAgIGlmICh0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMgPj0gTUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFUykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJPbmxpbmVTdGF0ZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dDbGllbnRPZmZsaW5lV2FybmluZ0lmTmVjZXNzYXJ5KGBDb25uZWN0aW9uIGZhaWxlZCAke01BWF9XQVRDSF9TVFJFQU1fRkFJTFVSRVN9IGAgK1xuICAgICAgICAgICAgICAgICAgICBgdGltZXMuIE1vc3QgcmVjZW50IGVycm9yOiAke2Vycm9yLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBbmRCcm9hZGNhc3QoXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwbGljaXRseSBzZXRzIHRoZSBPbmxpbmVTdGF0ZSB0byB0aGUgc3BlY2lmaWVkIHN0YXRlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgcmVzZXRzIG91ciB0aW1lcnMgLyBmYWlsdXJlIGNvdW50ZXJzLCBldGMuIHVzZWQgYnkgb3VyXG4gICAgICogT2ZmbGluZSBoZXVyaXN0aWNzLCBzbyBtdXN0IG5vdCBiZSB1c2VkIGluIHBsYWNlIG9mXG4gICAgICogaGFuZGxlV2F0Y2hTdHJlYW1TdGFydCgpIGFuZCBoYW5kbGVXYXRjaFN0cmVhbUZhaWx1cmUoKS5cbiAgICAgKi9cbiAgICBzZXQobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5jbGVhck9ubGluZVN0YXRlVGltZXIoKTtcbiAgICAgICAgdGhpcy53YXRjaFN0cmVhbUZhaWx1cmVzID0gMDtcbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSBcIk9ubGluZVwiIC8qIE9ubGluZVN0YXRlLk9ubGluZSAqLykge1xuICAgICAgICAgICAgLy8gV2UndmUgY29ubmVjdGVkIHRvIHdhdGNoIGF0IGxlYXN0IG9uY2UuIERvbid0IHdhcm4gdGhlIGRldmVsb3BlclxuICAgICAgICAgICAgLy8gYWJvdXQgYmVpbmcgb2ZmbGluZSBnb2luZyBmb3J3YXJkLlxuICAgICAgICAgICAgdGhpcy5zaG91bGRXYXJuQ2xpZW50SXNPZmZsaW5lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBbmRCcm9hZGNhc3QobmV3U3RhdGUpO1xuICAgIH1cbiAgICBzZXRBbmRCcm9hZGNhc3QobmV3U3RhdGUpIHtcbiAgICAgICAgaWYgKG5ld1N0YXRlICE9PSB0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICB0aGlzLm9ubGluZVN0YXRlSGFuZGxlcihuZXdTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9nQ2xpZW50T2ZmbGluZVdhcm5pbmdJZk5lY2Vzc2FyeShkZXRhaWxzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgQ291bGQgbm90IHJlYWNoIENsb3VkIEZpcmVzdG9yZSBiYWNrZW5kLiAke2RldGFpbHN9XFxuYCArXG4gICAgICAgICAgICBgVGhpcyB0eXBpY2FsbHkgaW5kaWNhdGVzIHRoYXQgeW91ciBkZXZpY2UgZG9lcyBub3QgaGF2ZSBhIGhlYWx0aHkgYCArXG4gICAgICAgICAgICBgSW50ZXJuZXQgY29ubmVjdGlvbiBhdCB0aGUgbW9tZW50LiBUaGUgY2xpZW50IHdpbGwgb3BlcmF0ZSBpbiBvZmZsaW5lIGAgK1xuICAgICAgICAgICAgYG1vZGUgdW50aWwgaXQgaXMgYWJsZSB0byBzdWNjZXNzZnVsbHkgY29ubmVjdCB0byB0aGUgYmFja2VuZC5gO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRXYXJuQ2xpZW50SXNPZmZsaW5lKSB7XG4gICAgICAgICAgICBsb2dFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkV2FybkNsaWVudElzT2ZmbGluZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ2LCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhck9ubGluZVN0YXRlVGltZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ubGluZVN0YXRlVGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMub25saW5lU3RhdGVUaW1lci5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMub25saW5lU3RhdGVUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJDUgPSAnUmVtb3RlU3RvcmUnO1xuLy8gVE9ETyhiLzM1ODUzNDAyKTogTmVnb3RpYXRlIHRoaXMgd2l0aCB0aGUgc3RyZWFtLlxuY29uc3QgTUFYX1BFTkRJTkdfV1JJVEVTID0gMTA7XG5jbGFzcyBSZW1vdGVTdG9yZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhbCBzdG9yZSwgdXNlZCB0byBmaWxsIHRoZSB3cml0ZSBwaXBlbGluZSB3aXRoIG91dGJvdW5kIG11dGF0aW9ucy5cbiAgICAgKi9cbiAgICBsb2NhbFN0b3JlLCBcbiAgICAvKiogVGhlIGNsaWVudC1zaWRlIHByb3h5IGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBiYWNrZW5kLiAqL1xuICAgIGRhdGFzdG9yZSwgYXN5bmNRdWV1ZSwgb25saW5lU3RhdGVIYW5kbGVyLCBjb25uZWN0aXZpdHlNb25pdG9yKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdG9yZSA9IGxvY2FsU3RvcmU7XG4gICAgICAgIHRoaXMuZGF0YXN0b3JlID0gZGF0YXN0b3JlO1xuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSBhc3luY1F1ZXVlO1xuICAgICAgICB0aGlzLnJlbW90ZVN5bmNlciA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIHVwIHRvIE1BWF9QRU5ESU5HX1dSSVRFUyB3cml0ZXMgdGhhdCB3ZSBoYXZlIGZldGNoZWQgZnJvbSB0aGVcbiAgICAgICAgICogTG9jYWxTdG9yZSB2aWEgZmlsbFdyaXRlUGlwZWxpbmUoKSBhbmQgaGF2ZSBvciB3aWxsIHNlbmQgdG8gdGhlIHdyaXRlXG4gICAgICAgICAqIHN0cmVhbS5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbmV2ZXIgd3JpdGVQaXBlbGluZS5sZW5ndGggPiAwIHRoZSBSZW1vdGVTdG9yZSB3aWxsIGF0dGVtcHQgdG8gc3RhcnQgb3JcbiAgICAgICAgICogcmVzdGFydCB0aGUgd3JpdGUgc3RyZWFtLiBXaGVuIHRoZSBzdHJlYW0gaXMgZXN0YWJsaXNoZWQgdGhlIHdyaXRlcyBpbiB0aGVcbiAgICAgICAgICogcGlwZWxpbmUgd2lsbCBiZSBzZW50IGluIG9yZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXcml0ZXMgcmVtYWluIGluIHdyaXRlUGlwZWxpbmUgdW50aWwgdGhleSBhcmUgYWNrbm93bGVkZ2VkIGJ5IHRoZSBiYWNrZW5kXG4gICAgICAgICAqIGFuZCB0aHVzIHdpbGwgYXV0b21hdGljYWxseSBiZSByZS1zZW50IGlmIHRoZSBzdHJlYW0gaXMgaW50ZXJydXB0ZWQgL1xuICAgICAgICAgKiByZXN0YXJ0ZWQgYmVmb3JlIHRoZXkncmUgYWNrbm93bGVkZ2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXcml0ZSByZXNwb25zZXMgZnJvbSB0aGUgYmFja2VuZCBhcmUgbGlua2VkIHRvIHRoZWlyIG9yaWdpbmF0aW5nIHJlcXVlc3RcbiAgICAgICAgICogcHVyZWx5IGJhc2VkIG9uIG9yZGVyLCBhbmQgc28gd2UgY2FuIGp1c3Qgc2hpZnQoKSB3cml0ZXMgZnJvbSB0aGUgZnJvbnQgb2ZcbiAgICAgICAgICogdGhlIHdyaXRlUGlwZWxpbmUgYXMgd2UgcmVjZWl2ZSByZXNwb25zZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndyaXRlUGlwZWxpbmUgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwcGluZyBvZiB3YXRjaGVkIHRhcmdldHMgdGhhdCB0aGUgY2xpZW50IGNhcmVzIGFib3V0IHRyYWNraW5nIGFuZCB0aGVcbiAgICAgICAgICogdXNlciBoYXMgZXhwbGljaXRseSBjYWxsZWQgYSAnbGlzdGVuJyBmb3IgdGhpcyB0YXJnZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZXNlIHRhcmdldHMgbWF5IG9yIG1heSBub3QgaGF2ZSBiZWVuIHNlbnQgdG8gb3IgYWNrbm93bGVkZ2VkIGJ5IHRoZVxuICAgICAgICAgKiBzZXJ2ZXIuIE9uIHJlLWVzdGFibGlzaGluZyB0aGUgbGlzdGVuIHN0cmVhbSwgdGhlc2UgdGFyZ2V0cyBzaG91bGQgYmUgc2VudFxuICAgICAgICAgKiB0byB0aGUgc2VydmVyLiBUaGUgdGFyZ2V0cyByZW1vdmVkIHdpdGggdW5saXN0ZW5zIGFyZSByZW1vdmVkIGVhZ2VybHlcbiAgICAgICAgICogd2l0aG91dCB3YWl0aW5nIGZvciBjb25maXJtYXRpb24gZnJvbSB0aGUgbGlzdGVuIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdGVuVGFyZ2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2V0IG9mIHJlYXNvbnMgZm9yIHdoeSB0aGUgUmVtb3RlU3RvcmUgbWF5IGJlIG9mZmxpbmUuIElmIGVtcHR5LCB0aGVcbiAgICAgICAgICogUmVtb3RlU3RvcmUgbWF5IHN0YXJ0IGl0cyBuZXR3b3JrIGNvbm5lY3Rpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vZmZsaW5lQ2F1c2VzID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgaGFuZGxlcnMgdGhhdCBnZXQgY2FsbGVkIHdoZW4gdGhlIG5ldHdvcmsgaXMgZGlzYWJsZWQgb3IgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogUE9SVElORyBOT1RFOiBUaGVzZSBmdW5jdGlvbnMgYXJlIHVzZWQgb24gdGhlIFdlYiBjbGllbnQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAgKiB1bmRlcmx5aW5nIHN0cmVhbXMgKHRvIHN1cHBvcnQgdHJlZS1zaGFrZWFibGUgc3RyZWFtcykuIE9uIEFuZHJvaWQgYW5kIGlPUyxcbiAgICAgICAgICogdGhlIHN0cmVhbXMgYXJlIGNyZWF0ZWQgZHVyaW5nIGNvbnN0cnVjdGlvbiBvZiBSZW1vdGVTdG9yZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25OZXR3b3JrU3RhdHVzQ2hhbmdlID0gW107XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5TW9uaXRvciA9IGNvbm5lY3Rpdml0eU1vbml0b3I7XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5TW9uaXRvci5hZGRDYWxsYmFjaygoXykgPT4ge1xuICAgICAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQb3J0aW5nIE5vdGU6IFVubGlrZSBpT1MsIGByZXN0YXJ0TmV0d29yaygpYCBpcyBjYWxsZWQgZXZlbiB3aGVuIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5ldHdvcmsgYmVjb21lcyB1bnJlYWNoYWJsZSBhcyB3ZSBkb24ndCBoYXZlIGFueSBvdGhlciB3YXkgdG8gdGVhclxuICAgICAgICAgICAgICAgIC8vIGRvd24gb3VyIHN0cmVhbXMuXG4gICAgICAgICAgICAgICAgaWYgKGNhblVzZU5ldHdvcmsodGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ1LCAnUmVzdGFydGluZyBzdHJlYW1zIGZvciBuZXR3b3JrIHJlYWNoYWJpbGl0eSBjaGFuZ2UuJyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3RhcnROZXR3b3JrKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZVRyYWNrZXIgPSBuZXcgT25saW5lU3RhdGVUcmFja2VyKGFzeW5jUXVldWUsIG9ubGluZVN0YXRlSGFuZGxlcik7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3UmVtb3RlU3RvcmUobG9jYWxTdG9yZSwgZGF0YXN0b3JlLCBhc3luY1F1ZXVlLCBvbmxpbmVTdGF0ZUhhbmRsZXIsIGNvbm5lY3Rpdml0eU1vbml0b3IpIHtcbiAgICByZXR1cm4gbmV3IFJlbW90ZVN0b3JlSW1wbChsb2NhbFN0b3JlLCBkYXRhc3RvcmUsIGFzeW5jUXVldWUsIG9ubGluZVN0YXRlSGFuZGxlciwgY29ubmVjdGl2aXR5TW9uaXRvcik7XG59XG4vKiogUmUtZW5hYmxlcyB0aGUgbmV0d29yay4gSWRlbXBvdGVudC4gKi9cbmZ1bmN0aW9uIHJlbW90ZVN0b3JlRW5hYmxlTmV0d29yayhyZW1vdGVTdG9yZSkge1xuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDAgLyogT2ZmbGluZUNhdXNlLlVzZXJEaXNhYmxlZCAqLyk7XG4gICAgcmV0dXJuIGVuYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIGlmIChjYW5Vc2VOZXR3b3JrKHJlbW90ZVN0b3JlSW1wbCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBuZXR3b3JrU3RhdHVzSGFuZGxlciBvZiByZW1vdGVTdG9yZUltcGwub25OZXR3b3JrU3RhdHVzQ2hhbmdlKSB7XG4gICAgICAgICAgICBhd2FpdCBuZXR3b3JrU3RhdHVzSGFuZGxlcigvKiBlbmFibGVkPSAqLyB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVGVtcG9yYXJpbHkgZGlzYWJsZXMgdGhlIG5ldHdvcmsuIFRoZSBuZXR3b3JrIGNhbiBiZSByZS1lbmFibGVkIHVzaW5nXG4gKiBlbmFibGVOZXR3b3JrKCkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbW90ZVN0b3JlRGlzYWJsZU5ldHdvcmsocmVtb3RlU3RvcmUpIHtcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xuICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmFkZCgwIC8qIE9mZmxpbmVDYXVzZS5Vc2VyRGlzYWJsZWQgKi8pO1xuICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAvLyBTZXQgdGhlIE9ubGluZVN0YXRlIHRvIE9mZmxpbmUgc28gZ2V0KClzIHJldHVybiBmcm9tIGNhY2hlLCBldGMuXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLyk7XG59XG5hc3luYyBmdW5jdGlvbiBkaXNhYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIGZvciAoY29uc3QgbmV0d29ya1N0YXR1c0hhbmRsZXIgb2YgcmVtb3RlU3RvcmVJbXBsLm9uTmV0d29ya1N0YXR1c0NoYW5nZSkge1xuICAgICAgICBhd2FpdCBuZXR3b3JrU3RhdHVzSGFuZGxlcigvKiBlbmFibGVkPSAqLyBmYWxzZSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVtb3RlU3RvcmVTaHV0ZG93bihyZW1vdGVTdG9yZSkge1xuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XG4gICAgbG9nRGVidWcoTE9HX1RBRyQ1LCAnUmVtb3RlU3RvcmUgc2h1dHRpbmcgZG93bi4nKTtcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoNSAvKiBPZmZsaW5lQ2F1c2UuU2h1dGRvd24gKi8pO1xuICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICByZW1vdGVTdG9yZUltcGwuY29ubmVjdGl2aXR5TW9uaXRvci5zaHV0ZG93bigpO1xuICAgIC8vIFNldCB0aGUgT25saW5lU3RhdGUgdG8gVW5rbm93biAocmF0aGVyIHRoYW4gT2ZmbGluZSkgdG8gYXZvaWQgcG90ZW50aWFsbHlcbiAgICAvLyB0cmlnZ2VyaW5nIHNwdXJpb3VzIGxpc3RlbmVyIGV2ZW50cyB3aXRoIGNhY2hlZCBkYXRhLCBldGMuXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XG59XG4vKipcbiAqIFN0YXJ0cyBuZXcgbGlzdGVuIGZvciB0aGUgZ2l2ZW4gdGFyZ2V0LiBVc2VzIHJlc3VtZSB0b2tlbiBpZiBwcm92aWRlZC4gSXRcbiAqIGlzIGEgbm8tb3AgaWYgdGhlIHRhcmdldCBvZiBnaXZlbiBgVGFyZ2V0RGF0YWAgaXMgYWxyZWFkeSBiZWluZyBsaXN0ZW5lZCB0by5cbiAqL1xuZnVuY3Rpb24gcmVtb3RlU3RvcmVMaXN0ZW4ocmVtb3RlU3RvcmUsIHRhcmdldERhdGEpIHtcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xuICAgIGlmIChyZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5oYXModGFyZ2V0RGF0YS50YXJnZXRJZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBNYXJrIHRoaXMgYXMgc29tZXRoaW5nIHRoZSBjbGllbnQgaXMgY3VycmVudGx5IGxpc3RlbmluZyBmb3IuXG4gICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuc2V0KHRhcmdldERhdGEudGFyZ2V0SWQsIHRhcmdldERhdGEpO1xuICAgIGlmIChzaG91bGRTdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkpIHtcbiAgICAgICAgLy8gVGhlIGxpc3RlbiB3aWxsIGJlIHNlbnQgaW4gb25XYXRjaFN0cmVhbU9wZW5cbiAgICAgICAgc3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpLmlzT3BlbigpKSB7XG4gICAgICAgIHNlbmRXYXRjaFJlcXVlc3QocmVtb3RlU3RvcmVJbXBsLCB0YXJnZXREYXRhKTtcbiAgICB9XG59XG4vKipcbiAqIFJlbW92ZXMgdGhlIGxpc3RlbiBmcm9tIHNlcnZlci4gSXQgaXMgYSBuby1vcCBpZiB0aGUgZ2l2ZW4gdGFyZ2V0IGlkIGlzXG4gKiBub3QgYmVpbmcgbGlzdGVuZWQgdG8uXG4gKi9cbmZ1bmN0aW9uIHJlbW90ZVN0b3JlVW5saXN0ZW4ocmVtb3RlU3RvcmUsIHRhcmdldElkKSB7XG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcbiAgICBjb25zdCB3YXRjaFN0cmVhbSA9IGVuc3VyZVdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuZGVsZXRlKHRhcmdldElkKTtcbiAgICBpZiAod2F0Y2hTdHJlYW0uaXNPcGVuKCkpIHtcbiAgICAgICAgc2VuZFVud2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0SWQpO1xuICAgIH1cbiAgICBpZiAocmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBpZiAod2F0Y2hTdHJlYW0uaXNPcGVuKCkpIHtcbiAgICAgICAgICAgIHdhdGNoU3RyZWFtLm1hcmtJZGxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZUltcGwpKSB7XG4gICAgICAgICAgICAvLyBSZXZlcnQgdG8gT25saW5lU3RhdGUuVW5rbm93biBpZiB0aGUgd2F0Y2ggc3RyZWFtIGlzIG5vdCBvcGVuIGFuZCB3ZVxuICAgICAgICAgICAgLy8gaGF2ZSBubyBsaXN0ZW5lcnMsIHNpbmNlIHdpdGhvdXQgYW55IGxpc3RlbnMgdG8gc2VuZCB3ZSBjYW5ub3RcbiAgICAgICAgICAgIC8vIGNvbmZpcm0gaWYgdGhlIHN0cmVhbSBpcyBoZWFsdGh5IGFuZCB1cGdyYWRlIHRvIE9ubGluZVN0YXRlLk9ubGluZS5cbiAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBXZSBuZWVkIHRvIGluY3JlbWVudCB0aGUgZXhwZWN0ZWQgbnVtYmVyIG9mIHBlbmRpbmcgcmVzcG9uc2VzIHdlJ3JlIGR1ZVxuICogZnJvbSB3YXRjaCBzbyB3ZSB3YWl0IGZvciB0aGUgYWNrIHRvIHByb2Nlc3MgYW55IG1lc3NhZ2VzIGZyb20gdGhpcyB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRXYXRjaFJlcXVlc3QocmVtb3RlU3RvcmVJbXBsLCB0YXJnZXREYXRhKSB7XG4gICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5yZWNvcmRQZW5kaW5nVGFyZ2V0UmVxdWVzdCh0YXJnZXREYXRhLnRhcmdldElkKTtcbiAgICBpZiAodGFyZ2V0RGF0YS5yZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPiAwIHx8XG4gICAgICAgIHRhcmdldERhdGEuc25hcHNob3RWZXJzaW9uLmNvbXBhcmVUbyhTbmFwc2hvdFZlcnNpb24ubWluKCkpID4gMCkge1xuICAgICAgICBjb25zdCBleHBlY3RlZENvdW50ID0gcmVtb3RlU3RvcmVJbXBsLnJlbW90ZVN5bmNlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHRhcmdldERhdGEudGFyZ2V0SWQpLnNpemU7XG4gICAgICAgIHRhcmdldERhdGEgPSB0YXJnZXREYXRhLndpdGhFeHBlY3RlZENvdW50KGV4cGVjdGVkQ291bnQpO1xuICAgIH1cbiAgICBlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpLndhdGNoKHRhcmdldERhdGEpO1xufVxuLyoqXG4gKiBXZSBuZWVkIHRvIGluY3JlbWVudCB0aGUgZXhwZWN0ZWQgbnVtYmVyIG9mIHBlbmRpbmcgcmVzcG9uc2VzIHdlJ3JlIGR1ZVxuICogZnJvbSB3YXRjaCBzbyB3ZSB3YWl0IGZvciB0aGUgcmVtb3ZhbCBvbiB0aGUgc2VydmVyIGJlZm9yZSB3ZSBwcm9jZXNzIGFueVxuICogbWVzc2FnZXMgZnJvbSB0aGlzIHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gc2VuZFVud2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0SWQpIHtcbiAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yLnJlY29yZFBlbmRpbmdUYXJnZXRSZXF1ZXN0KHRhcmdldElkKTtcbiAgICBlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpLnVud2F0Y2godGFyZ2V0SWQpO1xufVxuZnVuY3Rpb24gc3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpIHtcbiAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yID0gbmV3IFdhdGNoQ2hhbmdlQWdncmVnYXRvcih7XG4gICAgICAgIGdldFJlbW90ZUtleXNGb3JUYXJnZXQ6IHRhcmdldElkID0+IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCh0YXJnZXRJZCksXG4gICAgICAgIGdldFRhcmdldERhdGFGb3JUYXJnZXQ6IHRhcmdldElkID0+IHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmdldCh0YXJnZXRJZCkgfHwgbnVsbCxcbiAgICAgICAgZ2V0RGF0YWJhc2VJZDogKCkgPT4gcmVtb3RlU3RvcmVJbXBsLmRhdGFzdG9yZS5zZXJpYWxpemVyLmRhdGFiYXNlSWRcbiAgICB9KTtcbiAgICBlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpLnN0YXJ0KCk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5oYW5kbGVXYXRjaFN0cmVhbVN0YXJ0KCk7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgd2F0Y2ggc3RyZWFtIHNob3VsZCBiZSBzdGFydGVkIGJlY2F1c2UgaXQncyBuZWNlc3NhcnlcbiAqIGFuZCBoYXMgbm90IHlldCBiZWVuIHN0YXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSB7XG4gICAgcmV0dXJuIChjYW5Vc2VOZXR3b3JrKHJlbW90ZVN0b3JlSW1wbCkgJiZcbiAgICAgICAgIWVuc3VyZVdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuaXNTdGFydGVkKCkgJiZcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuc2l6ZSA+IDApO1xufVxuZnVuY3Rpb24gY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZSkge1xuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XG4gICAgcmV0dXJuIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLnNpemUgPT09IDA7XG59XG5mdW5jdGlvbiBjbGVhblVwV2F0Y2hTdHJlYW1TdGF0ZShyZW1vdGVTdG9yZUltcGwpIHtcbiAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yID0gdW5kZWZpbmVkO1xufVxuYXN5bmMgZnVuY3Rpb24gb25XYXRjaFN0cmVhbUNvbm5lY3RlZChyZW1vdGVTdG9yZUltcGwpIHtcbiAgICAvLyBNYXJrIHRoZSBjbGllbnQgYXMgb25saW5lIHNpbmNlIHdlIGdvdCBhIFwiY29ubmVjdGVkXCIgbm90aWZpY2F0aW9uLlxuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiT25saW5lXCIgLyogT25saW5lU3RhdGUuT25saW5lICovKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG9uV2F0Y2hTdHJlYW1PcGVuKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmZvckVhY2goKHRhcmdldERhdGEsIHRhcmdldElkKSA9PiB7XG4gICAgICAgIHNlbmRXYXRjaFJlcXVlc3QocmVtb3RlU3RvcmVJbXBsLCB0YXJnZXREYXRhKTtcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG9uV2F0Y2hTdHJlYW1DbG9zZShyZW1vdGVTdG9yZUltcGwsIGVycm9yKSB7XG4gICAgY2xlYW5VcFdhdGNoU3RyZWFtU3RhdGUocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAvLyBJZiB3ZSBzdGlsbCBuZWVkIHRoZSB3YXRjaCBzdHJlYW0sIHJldHJ5IHRoZSBjb25uZWN0aW9uLlxuICAgIGlmIChzaG91bGRTdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkpIHtcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5oYW5kbGVXYXRjaFN0cmVhbUZhaWx1cmUoZXJyb3IpO1xuICAgICAgICBzdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBObyBuZWVkIHRvIHJlc3RhcnQgd2F0Y2ggc3RyZWFtIGJlY2F1c2UgdGhlcmUgYXJlIG5vIGFjdGl2ZSB0YXJnZXRzLlxuICAgICAgICAvLyBUaGUgb25saW5lIHN0YXRlIGlzIHNldCB0byB1bmtub3duIGJlY2F1c2UgdGhlcmUgaXMgbm8gYWN0aXZlIGF0dGVtcHRcbiAgICAgICAgLy8gYXQgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvblxuICAgICAgICByZW1vdGVTdG9yZUltcGwub25saW5lU3RhdGVUcmFja2VyLnNldChcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBvbldhdGNoU3RyZWFtQ2hhbmdlKHJlbW90ZVN0b3JlSW1wbCwgd2F0Y2hDaGFuZ2UsIHNuYXBzaG90VmVyc2lvbikge1xuICAgIC8vIE1hcmsgdGhlIGNsaWVudCBhcyBvbmxpbmUgc2luY2Ugd2UgZ290IGEgbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICByZW1vdGVTdG9yZUltcGwub25saW5lU3RhdGVUcmFja2VyLnNldChcIk9ubGluZVwiIC8qIE9ubGluZVN0YXRlLk9ubGluZSAqLyk7XG4gICAgaWYgKHdhdGNoQ2hhbmdlIGluc3RhbmNlb2YgV2F0Y2hUYXJnZXRDaGFuZ2UgJiZcbiAgICAgICAgd2F0Y2hDaGFuZ2Uuc3RhdGUgPT09IDIgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5SZW1vdmVkICovICYmXG4gICAgICAgIHdhdGNoQ2hhbmdlLmNhdXNlKSB7XG4gICAgICAgIC8vIFRoZXJlIHdhcyBhbiBlcnJvciBvbiBhIHRhcmdldCwgZG9uJ3Qgd2FpdCBmb3IgYSBjb25zaXN0ZW50IHNuYXBzaG90XG4gICAgICAgIC8vIHRvIHJhaXNlIGV2ZW50c1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlVGFyZ2V0RXJyb3IocmVtb3RlU3RvcmVJbXBsLCB3YXRjaENoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNSwgJ0ZhaWxlZCB0byByZW1vdmUgdGFyZ2V0cyAlczogJXMgJywgd2F0Y2hDaGFuZ2UudGFyZ2V0SWRzLmpvaW4oJywnKSwgZSk7XG4gICAgICAgICAgICBhd2FpdCBkaXNhYmxlTmV0d29ya1VudGlsUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh3YXRjaENoYW5nZSBpbnN0YW5jZW9mIERvY3VtZW50V2F0Y2hDaGFuZ2UpIHtcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5oYW5kbGVEb2N1bWVudENoYW5nZSh3YXRjaENoYW5nZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdhdGNoQ2hhbmdlIGluc3RhbmNlb2YgRXhpc3RlbmNlRmlsdGVyQ2hhbmdlKSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IuaGFuZGxlRXhpc3RlbmNlRmlsdGVyKHdhdGNoQ2hhbmdlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IuaGFuZGxlVGFyZ2V0Q2hhbmdlKHdhdGNoQ2hhbmdlKTtcbiAgICB9XG4gICAgaWYgKCFzbmFwc2hvdFZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uID0gYXdhaXQgbG9jYWxTdG9yZUdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24ocmVtb3RlU3RvcmVJbXBsLmxvY2FsU3RvcmUpO1xuICAgICAgICAgICAgaWYgKHNuYXBzaG90VmVyc2lvbi5jb21wYXJlVG8obGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbikgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgcmVjZWl2ZWQgYSB0YXJnZXQgY2hhbmdlIHdpdGggYSBnbG9iYWwgc25hcHNob3QgaWYgdGhlIHNuYXBzaG90XG4gICAgICAgICAgICAgICAgLy8gdmVyc2lvbiBpcyBub3QgZXF1YWwgdG8gU25hcHNob3RWZXJzaW9uLm1pbigpLlxuICAgICAgICAgICAgICAgIGF3YWl0IHJhaXNlV2F0Y2hTbmFwc2hvdChyZW1vdGVTdG9yZUltcGwsIHNuYXBzaG90VmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNSwgJ0ZhaWxlZCB0byByYWlzZSBzbmFwc2hvdDonLCBlKTtcbiAgICAgICAgICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrVW50aWxSZWNvdmVyeShyZW1vdGVTdG9yZUltcGwsIGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZWNvdmVyeSBsb2dpYyBmb3IgSW5kZXhlZERCIGVycm9ycyB0aGF0IHRha2VzIHRoZSBuZXR3b3JrIG9mZmxpbmUgdW50aWxcbiAqIGBvcGAgc3VjY2VlZHMuIFJldHJpZXMgYXJlIHNjaGVkdWxlZCB3aXRoIGJhY2tvZmYgdXNpbmdcbiAqIGBlbnF1ZXVlUmV0cnlhYmxlKClgLiBJZiBgb3AoKWAgaXMgbm90IHByb3ZpZGVkLCBJbmRleGVkREIgYWNjZXNzIGlzXG4gKiB2YWxpZGF0ZWQgdmlhIGEgZ2VuZXJpYyBvcGVyYXRpb24uXG4gKlxuICogVGhlIHJldHVybmVkIFByb21pc2UgaXMgcmVzb2x2ZWQgb25jZSB0aGUgbmV0d29yayBpcyBkaXNhYmxlZCBhbmQgYmVmb3JlXG4gKiBhbnkgcmV0cnkgYXR0ZW1wdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGlzYWJsZU5ldHdvcmtVbnRpbFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgZSwgb3ApIHtcbiAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmFkZCgxIC8qIE9mZmxpbmVDYXVzZS5JbmRleGVkRGJGYWlsZWQgKi8pO1xuICAgICAgICAvLyBEaXNhYmxlIG5ldHdvcmsgYW5kIHJhaXNlIG9mZmxpbmUgc25hcHNob3RzXG4gICAgICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLyk7XG4gICAgICAgIGlmICghb3ApIHtcbiAgICAgICAgICAgIC8vIFVzZSBhIHNpbXBsZSByZWFkIG9wZXJhdGlvbiB0byBkZXRlcm1pbmUgaWYgSW5kZXhlZERCIHJlY292ZXJlZC5cbiAgICAgICAgICAgIC8vIElkZWFsbHksIHdlIHdvdWxkIGV4cG9zZSBhIGhlYWx0aCBjaGVjayBkaXJlY3RseSBvbiBTaW1wbGVEYiwgYnV0XG4gICAgICAgICAgICAvLyBSZW1vdGVTdG9yZSBvbmx5IGhhcyBhY2Nlc3MgdG8gcGVyc2lzdGVuY2UgdGhyb3VnaCBMb2NhbFN0b3JlLlxuICAgICAgICAgICAgb3AgPSAoKSA9PiBsb2NhbFN0b3JlR2V0TGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbihyZW1vdGVTdG9yZUltcGwubG9jYWxTdG9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvYmUgSW5kZXhlZERCIHBlcmlvZGljYWxseSBhbmQgcmUtZW5hYmxlIG5ldHdvcmtcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLmFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDUsICdSZXRyeWluZyBJbmRleGVkREIgYWNjZXNzJyk7XG4gICAgICAgICAgICBhd2FpdCBvcCgpO1xuICAgICAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDEgLyogT2ZmbGluZUNhdXNlLkluZGV4ZWREYkZhaWxlZCAqLyk7XG4gICAgICAgICAgICBhd2FpdCBlbmFibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cbi8qKlxuICogRXhlY3V0ZXMgYG9wYC4gSWYgYG9wYCBmYWlscywgdGFrZXMgdGhlIG5ldHdvcmsgb2ZmbGluZSB1bnRpbCBgb3BgXG4gKiBzdWNjZWVkcy4gUmV0dXJucyBhZnRlciB0aGUgZmlyc3QgYXR0ZW1wdC5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZVdpdGhSZWNvdmVyeShyZW1vdGVTdG9yZUltcGwsIG9wKSB7XG4gICAgcmV0dXJuIG9wKCkuY2F0Y2goZSA9PiBkaXNhYmxlTmV0d29ya1VudGlsUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBlLCBvcCkpO1xufVxuLyoqXG4gKiBUYWtlcyBhIGJhdGNoIG9mIGNoYW5nZXMgZnJvbSB0aGUgRGF0YXN0b3JlLCByZXBhY2thZ2VzIHRoZW0gYXMgYVxuICogUmVtb3RlRXZlbnQsIGFuZCBwYXNzZXMgdGhhdCBvbiB0byB0aGUgbGlzdGVuZXIsIHdoaWNoIGlzIHR5cGljYWxseSB0aGVcbiAqIFN5bmNFbmdpbmUuXG4gKi9cbmZ1bmN0aW9uIHJhaXNlV2F0Y2hTbmFwc2hvdChyZW1vdGVTdG9yZUltcGwsIHNuYXBzaG90VmVyc2lvbikge1xuICAgIGNvbnN0IHJlbW90ZUV2ZW50ID0gcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5jcmVhdGVSZW1vdGVFdmVudChzbmFwc2hvdFZlcnNpb24pO1xuICAgIC8vIFVwZGF0ZSBpbi1tZW1vcnkgcmVzdW1lIHRva2Vucy4gTG9jYWxTdG9yZSB3aWxsIHVwZGF0ZSB0aGVcbiAgICAvLyBwZXJzaXN0ZW50IHZpZXcgb2YgdGhlc2Ugd2hlbiBhcHBseWluZyB0aGUgY29tcGxldGVkIFJlbW90ZUV2ZW50LlxuICAgIHJlbW90ZUV2ZW50LnRhcmdldENoYW5nZXMuZm9yRWFjaCgoY2hhbmdlLCB0YXJnZXRJZCkgPT4ge1xuICAgICAgICBpZiAoY2hhbmdlLnJlc3VtZVRva2VuLmFwcHJveGltYXRlQnl0ZVNpemUoKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5nZXQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgLy8gQSB3YXRjaGVkIHRhcmdldCBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZCBhbHJlYWR5LlxuICAgICAgICAgICAgaWYgKHRhcmdldERhdGEpIHtcbiAgICAgICAgICAgICAgICByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5zZXQodGFyZ2V0SWQsIHRhcmdldERhdGEud2l0aFJlc3VtZVRva2VuKGNoYW5nZS5yZXN1bWVUb2tlbiwgc25hcHNob3RWZXJzaW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBSZS1lc3RhYmxpc2ggbGlzdGVucyBmb3IgdGhlIHRhcmdldHMgdGhhdCBoYXZlIGJlZW4gaW52YWxpZGF0ZWQgYnlcbiAgICAvLyBleGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoZXMuXG4gICAgcmVtb3RlRXZlbnQudGFyZ2V0TWlzbWF0Y2hlcy5mb3JFYWNoKCh0YXJnZXRJZCwgdGFyZ2V0UHVycG9zZSkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuZ2V0KHRhcmdldElkKTtcbiAgICAgICAgaWYgKCF0YXJnZXREYXRhKSB7XG4gICAgICAgICAgICAvLyBBIHdhdGNoZWQgdGFyZ2V0IG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkIGFscmVhZHkuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgdGhlIHJlc3VtZSB0b2tlbiBmb3IgdGhlIHRhcmdldCwgc2luY2Ugd2UncmUgaW4gYSBrbm93biBtaXNtYXRjaFxuICAgICAgICAvLyBzdGF0ZS5cbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuc2V0KHRhcmdldElkLCB0YXJnZXREYXRhLndpdGhSZXN1bWVUb2tlbihCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HLCB0YXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbikpO1xuICAgICAgICAvLyBDYXVzZSBhIGhhcmQgcmVzZXQgYnkgdW53YXRjaGluZyBhbmQgcmV3YXRjaGluZyBpbW1lZGlhdGVseSwgYnV0XG4gICAgICAgIC8vIGRlbGliZXJhdGVseSBkb24ndCBzZW5kIGEgcmVzdW1lIHRva2VuIHNvIHRoYXQgd2UgZ2V0IGEgZnVsbCB1cGRhdGUuXG4gICAgICAgIHNlbmRVbndhdGNoUmVxdWVzdChyZW1vdGVTdG9yZUltcGwsIHRhcmdldElkKTtcbiAgICAgICAgLy8gTWFyayB0aGUgdGFyZ2V0IHdlIHNlbmQgYXMgYmVpbmcgb24gYmVoYWxmIG9mIGFuIGV4aXN0ZW5jZSBmaWx0ZXJcbiAgICAgICAgLy8gbWlzbWF0Y2gsIGJ1dCBkb24ndCBhY3R1YWxseSByZXRhaW4gdGhhdCBpbiBsaXN0ZW5UYXJnZXRzLiBUaGlzIGVuc3VyZXNcbiAgICAgICAgLy8gdGhhdCB3ZSBmbGFnIHRoZSBmaXJzdCByZS1saXN0ZW4gdGhpcyB3YXkgd2l0aG91dCBpbXBhY3RpbmcgZnV0dXJlXG4gICAgICAgIC8vIGxpc3RlbnMgb2YgdGhpcyB0YXJnZXQgKHRoYXQgbWlnaHQgaGFwcGVuIGUuZy4gb24gcmVjb25uZWN0KS5cbiAgICAgICAgY29uc3QgcmVxdWVzdFRhcmdldERhdGEgPSBuZXcgVGFyZ2V0RGF0YSh0YXJnZXREYXRhLnRhcmdldCwgdGFyZ2V0SWQsIHRhcmdldFB1cnBvc2UsIHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICBzZW5kV2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgcmVxdWVzdFRhcmdldERhdGEpO1xuICAgIH0pO1xuICAgIHJldHVybiByZW1vdGVTdG9yZUltcGwucmVtb3RlU3luY2VyLmFwcGx5UmVtb3RlRXZlbnQocmVtb3RlRXZlbnQpO1xufVxuLyoqIEhhbmRsZXMgYW4gZXJyb3Igb24gYSB0YXJnZXQgKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVRhcmdldEVycm9yKHJlbW90ZVN0b3JlSW1wbCwgd2F0Y2hDaGFuZ2UpIHtcbiAgICBjb25zdCBlcnJvciA9IHdhdGNoQ2hhbmdlLmNhdXNlO1xuICAgIGZvciAoY29uc3QgdGFyZ2V0SWQgb2Ygd2F0Y2hDaGFuZ2UudGFyZ2V0SWRzKSB7XG4gICAgICAgIC8vIEEgd2F0Y2hlZCB0YXJnZXQgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWQgYWxyZWFkeS5cbiAgICAgICAgaWYgKHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmhhcyh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIucmVqZWN0TGlzdGVuKHRhcmdldElkLCBlcnJvcik7XG4gICAgICAgICAgICByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5kZWxldGUodGFyZ2V0SWQpO1xuICAgICAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5yZW1vdmVUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBmaWxsIG91ciB3cml0ZSBwaXBlbGluZSB3aXRoIHdyaXRlcyBmcm9tIHRoZSBMb2NhbFN0b3JlLlxuICpcbiAqIENhbGxlZCBpbnRlcm5hbGx5IHRvIGJvb3RzdHJhcCBvciByZWZpbGwgdGhlIHdyaXRlIHBpcGVsaW5lIGFuZCBieVxuICogU3luY0VuZ2luZSB3aGVuZXZlciB0aGVyZSBhcmUgbmV3IG11dGF0aW9ucyB0byBwcm9jZXNzLlxuICpcbiAqIFN0YXJ0cyB0aGUgd3JpdGUgc3RyZWFtIGlmIG5lY2Vzc2FyeS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmlsbFdyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmUpIHtcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xuICAgIGNvbnN0IHdyaXRlU3RyZWFtID0gZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcbiAgICBsZXQgbGFzdEJhdGNoSWRSZXRyaWV2ZWQgPSByZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5sZW5ndGggPiAwXG4gICAgICAgID8gcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmVbcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgIC5iYXRjaElkXG4gICAgICAgIDogQkFUQ0hJRF9VTktOT1dOO1xuICAgIHdoaWxlIChjYW5BZGRUb1dyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBhd2FpdCBsb2NhbFN0b3JlR2V0TmV4dE11dGF0aW9uQmF0Y2gocmVtb3RlU3RvcmVJbXBsLmxvY2FsU3RvcmUsIGxhc3RCYXRjaElkUmV0cmlldmVkKTtcbiAgICAgICAgICAgIGlmIChiYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVTdHJlYW0ubWFya0lkbGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0QmF0Y2hJZFJldHJpZXZlZCA9IGJhdGNoLmJhdGNoSWQ7XG4gICAgICAgICAgICAgICAgYWRkVG9Xcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCwgYmF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBkaXNhYmxlTmV0d29ya1VudGlsUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hvdWxkU3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XG4gICAgICAgIHN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB3ZSBjYW4gYWRkIHRvIHRoZSB3cml0ZSBwaXBlbGluZSAoaS5lLiB0aGUgbmV0d29yayBpc1xuICogZW5hYmxlZCBhbmQgdGhlIHdyaXRlIHBpcGVsaW5lIGlzIG5vdCBmdWxsKS5cbiAqL1xuZnVuY3Rpb24gY2FuQWRkVG9Xcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIHJldHVybiAoY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZUltcGwpICYmXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLmxlbmd0aCA8IE1BWF9QRU5ESU5HX1dSSVRFUyk7XG59XG4vKipcbiAqIFF1ZXVlcyBhZGRpdGlvbmFsIHdyaXRlcyB0byBiZSBzZW50IHRvIHRoZSB3cml0ZSBzdHJlYW0sIHNlbmRpbmcgdGhlbVxuICogaW1tZWRpYXRlbHkgaWYgdGhlIHdyaXRlIHN0cmVhbSBpcyBlc3RhYmxpc2hlZC5cbiAqL1xuZnVuY3Rpb24gYWRkVG9Xcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCwgYmF0Y2gpIHtcbiAgICByZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5wdXNoKGJhdGNoKTtcbiAgICBjb25zdCB3cml0ZVN0cmVhbSA9IGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgaWYgKHdyaXRlU3RyZWFtLmlzT3BlbigpICYmIHdyaXRlU3RyZWFtLmhhbmRzaGFrZUNvbXBsZXRlKSB7XG4gICAgICAgIHdyaXRlU3RyZWFtLndyaXRlTXV0YXRpb25zKGJhdGNoLm11dGF0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2hvdWxkU3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpIHtcbiAgICByZXR1cm4gKGNhblVzZU5ldHdvcmsocmVtb3RlU3RvcmVJbXBsKSAmJlxuICAgICAgICAhZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS5pc1N0YXJ0ZWQoKSAmJlxuICAgICAgICByZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5sZW5ndGggPiAwKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSB7XG4gICAgZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS5zdGFydCgpO1xufVxuYXN5bmMgZnVuY3Rpb24gb25Xcml0ZVN0cmVhbU9wZW4ocmVtb3RlU3RvcmVJbXBsKSB7XG4gICAgZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS53cml0ZUhhbmRzaGFrZSgpO1xufVxuYXN5bmMgZnVuY3Rpb24gb25Xcml0ZUhhbmRzaGFrZUNvbXBsZXRlKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIGNvbnN0IHdyaXRlU3RyZWFtID0gZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAvLyBTZW5kIHRoZSB3cml0ZSBwaXBlbGluZSBub3cgdGhhdCB0aGUgc3RyZWFtIGlzIGVzdGFibGlzaGVkLlxuICAgIGZvciAoY29uc3QgYmF0Y2ggb2YgcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUpIHtcbiAgICAgICAgd3JpdGVTdHJlYW0ud3JpdGVNdXRhdGlvbnMoYmF0Y2gubXV0YXRpb25zKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBvbk11dGF0aW9uUmVzdWx0KHJlbW90ZVN0b3JlSW1wbCwgY29tbWl0VmVyc2lvbiwgcmVzdWx0cykge1xuICAgIGNvbnN0IGJhdGNoID0gcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUuc2hpZnQoKTtcbiAgICBjb25zdCBzdWNjZXNzID0gTXV0YXRpb25CYXRjaFJlc3VsdC5mcm9tKGJhdGNoLCBjb21taXRWZXJzaW9uLCByZXN1bHRzKTtcbiAgICBhd2FpdCBleGVjdXRlV2l0aFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgKCkgPT4gcmVtb3RlU3RvcmVJbXBsLnJlbW90ZVN5bmNlci5hcHBseVN1Y2Nlc3NmdWxXcml0ZShzdWNjZXNzKSk7XG4gICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHdpdGggdGhlIGNvbXBsZXRpb24gb2YgdGhpcyBtdXRhdGlvbiBhbm90aGVyXG4gICAgLy8gc2xvdCBoYXMgZnJlZWQgdXAuXG4gICAgYXdhaXQgZmlsbFdyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG9uV3JpdGVTdHJlYW1DbG9zZShyZW1vdGVTdG9yZUltcGwsIGVycm9yKSB7XG4gICAgLy8gSWYgdGhlIHdyaXRlIHN0cmVhbSBjbG9zZWQgYWZ0ZXIgdGhlIHdyaXRlIGhhbmRzaGFrZSBjb21wbGV0ZXMsIGEgd3JpdGVcbiAgICAvLyBvcGVyYXRpb24gZmFpbGVkIGFuZCB3ZSBmYWlsIHRoZSBwZW5kaW5nIG9wZXJhdGlvbi5cbiAgICBpZiAoZXJyb3IgJiYgZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS5oYW5kc2hha2VDb21wbGV0ZSkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIGFmZmVjdHMgdGhlIGFjdHVhbCB3cml0ZS5cbiAgICAgICAgYXdhaXQgaGFuZGxlV3JpdGVFcnJvcihyZW1vdGVTdG9yZUltcGwsIGVycm9yKTtcbiAgICB9XG4gICAgLy8gVGhlIHdyaXRlIHN0cmVhbSBtaWdodCBoYXZlIGJlZW4gc3RhcnRlZCBieSByZWZpbGxpbmcgdGhlIHdyaXRlXG4gICAgLy8gcGlwZWxpbmUgZm9yIGZhaWxlZCB3cml0ZXNcbiAgICBpZiAoc2hvdWxkU3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XG4gICAgICAgIHN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVXcml0ZUVycm9yKHJlbW90ZVN0b3JlSW1wbCwgZXJyb3IpIHtcbiAgICAvLyBPbmx5IGhhbmRsZSBwZXJtYW5lbnQgZXJyb3JzIGhlcmUuIElmIGl0J3MgdHJhbnNpZW50LCBqdXN0IGxldCB0aGUgcmV0cnlcbiAgICAvLyBsb2dpYyBraWNrIGluLlxuICAgIGlmIChpc1Blcm1hbmVudFdyaXRlRXJyb3IoZXJyb3IuY29kZSkpIHtcbiAgICAgICAgLy8gVGhpcyB3YXMgYSBwZXJtYW5lbnQgZXJyb3IsIHRoZSByZXF1ZXN0IGl0c2VsZiB3YXMgdGhlIHByb2JsZW1cbiAgICAgICAgLy8gc28gaXQncyBub3QgZ29pbmcgdG8gc3VjY2VlZCBpZiB3ZSByZXNlbmQgaXQuXG4gICAgICAgIGNvbnN0IGJhdGNoID0gcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUuc2hpZnQoKTtcbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIGl0J3MgYWxzbyB1bmxpa2VseSB0aGF0IHRoZSBzZXJ2ZXIgaXRzZWxmIGlzIG1lbHRpbmdcbiAgICAgICAgLy8gZG93biAtLSB0aGlzIHdhcyBqdXN0IGEgYmFkIHJlcXVlc3Qgc28gaW5oaWJpdCBiYWNrb2ZmIG9uIHRoZSBuZXh0XG4gICAgICAgIC8vIHJlc3RhcnQuXG4gICAgICAgIGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuaW5oaWJpdEJhY2tvZmYoKTtcbiAgICAgICAgYXdhaXQgZXhlY3V0ZVdpdGhSZWNvdmVyeShyZW1vdGVTdG9yZUltcGwsICgpID0+IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIucmVqZWN0RmFpbGVkV3JpdGUoYmF0Y2guYmF0Y2hJZCwgZXJyb3IpKTtcbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHdpdGggdGhlIGNvbXBsZXRpb24gb2YgdGhpcyBtdXRhdGlvblxuICAgICAgICAvLyBhbm90aGVyIHNsb3QgaGFzIGZyZWVkIHVwLlxuICAgICAgICBhd2FpdCBmaWxsV3JpdGVQaXBlbGluZShyZW1vdGVTdG9yZUltcGwpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc3RhcnROZXR3b3JrKHJlbW90ZVN0b3JlKSB7XG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoNCAvKiBPZmZsaW5lQ2F1c2UuQ29ubmVjdGl2aXR5Q2hhbmdlICovKTtcbiAgICBhd2FpdCBkaXNhYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDQgLyogT2ZmbGluZUNhdXNlLkNvbm5lY3Rpdml0eUNoYW5nZSAqLyk7XG4gICAgYXdhaXQgZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XG59XG5hc3luYyBmdW5jdGlvbiByZW1vdGVTdG9yZUhhbmRsZUNyZWRlbnRpYWxDaGFuZ2UocmVtb3RlU3RvcmUsIHVzZXIpIHtcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xuICAgIHJlbW90ZVN0b3JlSW1wbC5hc3luY1F1ZXVlLnZlcmlmeU9wZXJhdGlvbkluUHJvZ3Jlc3MoKTtcbiAgICBsb2dEZWJ1ZyhMT0dfVEFHJDUsICdSZW1vdGVTdG9yZSByZWNlaXZlZCBuZXcgY3JlZGVudGlhbHMnKTtcbiAgICBjb25zdCB1c2VzTmV0d29yayA9IGNhblVzZU5ldHdvcmsocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAvLyBUZWFyIGRvd24gYW5kIHJlLWNyZWF0ZSBvdXIgbmV0d29yayBzdHJlYW1zLiBUaGlzIHdpbGwgZW5zdXJlIHdlIGdldCBhXG4gICAgLy8gZnJlc2ggYXV0aCB0b2tlbiBmb3IgdGhlIG5ldyB1c2VyIGFuZCByZS1maWxsIHRoZSB3cml0ZSBwaXBlbGluZSB3aXRoXG4gICAgLy8gbmV3IG11dGF0aW9ucyBmcm9tIHRoZSBMb2NhbFN0b3JlIChzaW5jZSBtdXRhdGlvbnMgYXJlIHBlci11c2VyKS5cbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoMyAvKiBPZmZsaW5lQ2F1c2UuQ3JlZGVudGlhbENoYW5nZSAqLyk7XG4gICAgYXdhaXQgZGlzYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xuICAgIGlmICh1c2VzTmV0d29yaykge1xuICAgICAgICAvLyBEb24ndCBzZXQgdGhlIG5ldHdvcmsgc3RhdHVzIHRvIFVua25vd24gaWYgd2UgYXJlIG9mZmxpbmUuXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xuICAgIH1cbiAgICBhd2FpdCByZW1vdGVTdG9yZUltcGwucmVtb3RlU3luY2VyLmhhbmRsZUNyZWRlbnRpYWxDaGFuZ2UodXNlcik7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDMgLyogT2ZmbGluZUNhdXNlLkNyZWRlbnRpYWxDaGFuZ2UgKi8pO1xuICAgIGF3YWl0IGVuYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xufVxuLyoqXG4gKiBUb2dnbGVzIHRoZSBuZXR3b3JrIHN0YXRlIHdoZW4gdGhlIGNsaWVudCBnYWlucyBvciBsb3NlcyBpdHMgcHJpbWFyeSBsZWFzZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVtb3RlU3RvcmVBcHBseVByaW1hcnlTdGF0ZShyZW1vdGVTdG9yZSwgaXNQcmltYXJ5KSB7XG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcbiAgICBpZiAoaXNQcmltYXJ5KSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmRlbGV0ZSgyIC8qIE9mZmxpbmVDYXVzZS5Jc1NlY29uZGFyeSAqLyk7XG4gICAgICAgIGF3YWl0IGVuYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNQcmltYXJ5KSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmFkZCgyIC8qIE9mZmxpbmVDYXVzZS5Jc1NlY29uZGFyeSAqLyk7XG4gICAgICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XG4gICAgfVxufVxuLyoqXG4gKiBJZiBub3QgeWV0IGluaXRpYWxpemVkLCByZWdpc3RlcnMgdGhlIFdhdGNoU3RyZWFtIGFuZCBpdHMgbmV0d29yayBzdGF0ZVxuICogY2FsbGJhY2sgd2l0aCBgcmVtb3RlU3RvcmVJbXBsYC4gUmV0dXJucyB0aGUgZXhpc3Rpbmcgc3RyZWFtIGlmIG9uZSBpc1xuICogYWxyZWFkeSBhdmFpbGFibGUuXG4gKlxuICogUE9SVElORyBOT1RFOiBPbiBpT1MgYW5kIEFuZHJvaWQsIHRoZSBXYXRjaFN0cmVhbSBnZXRzIHJlZ2lzdGVyZWQgb24gc3RhcnR1cC5cbiAqIFRoaXMgaXMgbm90IGRvbmUgb24gV2ViIHRvIGFsbG93IGl0IHRvIGJlIHRyZWUtc2hha2VuLlxuICovXG5mdW5jdGlvbiBlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpIHtcbiAgICBpZiAoIXJlbW90ZVN0b3JlSW1wbC53YXRjaFN0cmVhbSkge1xuICAgICAgICAvLyBDcmVhdGUgc3RyZWFtIChidXQgbm90ZSB0aGF0IGl0IGlzIG5vdCBzdGFydGVkIHlldCkuXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaFN0cmVhbSA9IG5ld1BlcnNpc3RlbnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwuZGF0YXN0b3JlLCByZW1vdGVTdG9yZUltcGwuYXN5bmNRdWV1ZSwge1xuICAgICAgICAgICAgb25Db25uZWN0ZWQ6IG9uV2F0Y2hTdHJlYW1Db25uZWN0ZWQuYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpLFxuICAgICAgICAgICAgb25PcGVuOiBvbldhdGNoU3RyZWFtT3Blbi5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbCksXG4gICAgICAgICAgICBvbkNsb3NlOiBvbldhdGNoU3RyZWFtQ2xvc2UuYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpLFxuICAgICAgICAgICAgb25XYXRjaENoYW5nZTogb25XYXRjaFN0cmVhbUNoYW5nZS5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbClcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbk5ldHdvcmtTdGF0dXNDaGFuZ2UucHVzaChhc3luYyAoZW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hTdHJlYW0uaW5oaWJpdEJhY2tvZmYoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlSW1wbC53YXRjaFN0cmVhbS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgY2xlYW5VcFdhdGNoU3RyZWFtU3RhdGUocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdGVTdG9yZUltcGwud2F0Y2hTdHJlYW07XG59XG4vKipcbiAqIElmIG5vdCB5ZXQgaW5pdGlhbGl6ZWQsIHJlZ2lzdGVycyB0aGUgV3JpdGVTdHJlYW0gYW5kIGl0cyBuZXR3b3JrIHN0YXRlXG4gKiBjYWxsYmFjayB3aXRoIGByZW1vdGVTdG9yZUltcGxgLiBSZXR1cm5zIHRoZSBleGlzdGluZyBzdHJlYW0gaWYgb25lIGlzXG4gKiBhbHJlYWR5IGF2YWlsYWJsZS5cbiAqXG4gKiBQT1JUSU5HIE5PVEU6IE9uIGlPUyBhbmQgQW5kcm9pZCwgdGhlIFdyaXRlU3RyZWFtIGdldHMgcmVnaXN0ZXJlZCBvbiBzdGFydHVwLlxuICogVGhpcyBpcyBub3QgZG9uZSBvbiBXZWIgdG8gYWxsb3cgaXQgdG8gYmUgdHJlZS1zaGFrZW4uXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIGlmICghcmVtb3RlU3RvcmVJbXBsLndyaXRlU3RyZWFtKSB7XG4gICAgICAgIC8vIENyZWF0ZSBzdHJlYW0gKGJ1dCBub3RlIHRoYXQgaXQgaXMgbm90IHN0YXJ0ZWQgeWV0KS5cbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndyaXRlU3RyZWFtID0gbmV3UGVyc2lzdGVudFdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbC5kYXRhc3RvcmUsIHJlbW90ZVN0b3JlSW1wbC5hc3luY1F1ZXVlLCB7XG4gICAgICAgICAgICBvbkNvbm5lY3RlZDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCksXG4gICAgICAgICAgICBvbk9wZW46IG9uV3JpdGVTdHJlYW1PcGVuLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcbiAgICAgICAgICAgIG9uQ2xvc2U6IG9uV3JpdGVTdHJlYW1DbG9zZS5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbCksXG4gICAgICAgICAgICBvbkhhbmRzaGFrZUNvbXBsZXRlOiBvbldyaXRlSGFuZHNoYWtlQ29tcGxldGUuYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpLFxuICAgICAgICAgICAgb25NdXRhdGlvblJlc3VsdDogb25NdXRhdGlvblJlc3VsdC5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbClcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbk5ldHdvcmtTdGF0dXNDaGFuZ2UucHVzaChhc3luYyAoZW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZW1vdGVTdG9yZUltcGwud3JpdGVTdHJlYW0uaW5oaWJpdEJhY2tvZmYoKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgc3RhcnQgdGhlIHdyaXRlIHN0cmVhbSBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICAgICAgYXdhaXQgZmlsbFdyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ1LCBgU3RvcHBpbmcgd3JpdGUgc3RyZWFtIHdpdGggJHtyZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5sZW5ndGh9IHBlbmRpbmcgd3JpdGVzYCk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckNCA9ICdBc3luY1F1ZXVlJztcbi8qKlxuICogUmVwcmVzZW50cyBhbiBvcGVyYXRpb24gc2NoZWR1bGVkIHRvIGJlIHJ1biBpbiB0aGUgZnV0dXJlIG9uIGFuIEFzeW5jUXVldWUuXG4gKlxuICogSXQgaXMgY3JlYXRlZCB2aWEgRGVsYXllZE9wZXJhdGlvbi5jcmVhdGVBbmRTY2hlZHVsZSgpLlxuICpcbiAqIFN1cHBvcnRzIGNhbmNlbGxhdGlvbiAodmlhIGNhbmNlbCgpKSBhbmQgZWFybHkgZXhlY3V0aW9uICh2aWEgc2tpcERlbGF5KCkpLlxuICpcbiAqIE5vdGU6IFdlIGltcGxlbWVudCBgUHJvbWlzZUxpa2VgIGluc3RlYWQgb2YgYFByb21pc2VgLCBhcyB0aGUgYFByb21pc2VgIHR5cGVcbiAqIGluIG5ld2VyIHZlcnNpb25zIG9mIFR5cGVTY3JpcHQgZGVmaW5lcyBgZmluYWxseWAsIHdoaWNoIGlzIG5vdCBhdmFpbGFibGUgaW5cbiAqIElFLlxuICovXG5jbGFzcyBEZWxheWVkT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihhc3luY1F1ZXVlLCB0aW1lcklkLCB0YXJnZXRUaW1lTXMsIG9wLCByZW1vdmFsQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcbiAgICAgICAgdGhpcy50aW1lcklkID0gdGltZXJJZDtcbiAgICAgICAgdGhpcy50YXJnZXRUaW1lTXMgPSB0YXJnZXRUaW1lTXM7XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICAgICAgdGhpcy5yZW1vdmFsQ2FsbGJhY2sgPSByZW1vdmFsQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMuZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy50aGVuID0gdGhpcy5kZWZlcnJlZC5wcm9taXNlLnRoZW4uYmluZCh0aGlzLmRlZmVycmVkLnByb21pc2UpO1xuICAgICAgICAvLyBJdCdzIG5vcm1hbCBmb3IgdGhlIGRlZmVycmVkIHByb21pc2UgdG8gYmUgY2FuY2VsZWQgKGR1ZSB0byBjYW5jZWxsYXRpb24pXG4gICAgICAgIC8vIGFuZCBzbyB3ZSBhdHRhY2ggYSBkdW1teSBjYXRjaCBjYWxsYmFjayB0byBhdm9pZFxuICAgICAgICAvLyAnVW5oYW5kbGVkUHJvbWlzZVJlamVjdGlvbldhcm5pbmcnIGxvZyBzcGFtLlxuICAgICAgICB0aGlzLmRlZmVycmVkLnByb21pc2UuY2F0Y2goZXJyID0+IHsgfSk7XG4gICAgfVxuICAgIGdldCBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgRGVsYXllZE9wZXJhdGlvbiB0aGF0IGhhcyBiZWVuIHNjaGVkdWxlZCB0byBiZVxuICAgICAqIGV4ZWN1dGVkIG9uIHRoZSBwcm92aWRlZCBhc3luY1F1ZXVlIGFmdGVyIHRoZSBwcm92aWRlZCBkZWxheU1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzeW5jUXVldWUgLSBUaGUgcXVldWUgdG8gc2NoZWR1bGUgdGhlIG9wZXJhdGlvbiBvbi5cbiAgICAgKiBAcGFyYW0gaWQgLSBBIFRpbWVyIElEIGlkZW50aWZ5aW5nIHRoZSB0eXBlIG9mIG9wZXJhdGlvbiB0aGlzIGlzLlxuICAgICAqIEBwYXJhbSBkZWxheU1zIC0gVGhlIGRlbGF5IChtcykgYmVmb3JlIHRoZSBvcGVyYXRpb24gc2hvdWxkIGJlIHNjaGVkdWxlZC5cbiAgICAgKiBAcGFyYW0gb3AgLSBUaGUgb3BlcmF0aW9uIHRvIHJ1bi5cbiAgICAgKiBAcGFyYW0gcmVtb3ZhbENhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBiZSBjYWxsZWQgc3luY2hyb25vdXNseSBvbmNlIHRoZVxuICAgICAqICAgb3BlcmF0aW9uIGlzIGV4ZWN1dGVkIG9yIGNhbmNlbGVkLCBub3RpZnlpbmcgdGhlIEFzeW5jUXVldWUgdG8gcmVtb3ZlIGl0XG4gICAgICogICBmcm9tIGl0cyBkZWxheWVkT3BlcmF0aW9ucyBsaXN0LlxuICAgICAqICAgUE9SVElORyBOT1RFOiBUaGlzIGV4aXN0cyB0byBwcmV2ZW50IG1ha2luZyByZW1vdmVEZWxheWVkT3BlcmF0aW9uKCkgYW5kXG4gICAgICogICB0aGUgRGVsYXllZE9wZXJhdGlvbiBjbGFzcyBwdWJsaWMuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUFuZFNjaGVkdWxlKGFzeW5jUXVldWUsIHRpbWVySWQsIGRlbGF5TXMsIG9wLCByZW1vdmFsQ2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0VGltZSA9IERhdGUubm93KCkgKyBkZWxheU1zO1xuICAgICAgICBjb25zdCBkZWxheWVkT3AgPSBuZXcgRGVsYXllZE9wZXJhdGlvbihhc3luY1F1ZXVlLCB0aW1lcklkLCB0YXJnZXRUaW1lLCBvcCwgcmVtb3ZhbENhbGxiYWNrKTtcbiAgICAgICAgZGVsYXllZE9wLnN0YXJ0KGRlbGF5TXMpO1xuICAgICAgICByZXR1cm4gZGVsYXllZE9wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIHRpbWVyLiBUaGlzIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBjb25zdHJ1Y3Rpb24gYnlcbiAgICAgKiBjcmVhdGVBbmRTY2hlZHVsZSgpLlxuICAgICAqL1xuICAgIHN0YXJ0KGRlbGF5TXMpIHtcbiAgICAgICAgdGhpcy50aW1lckhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oYW5kbGVEZWxheUVsYXBzZWQoKSwgZGVsYXlNcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXVlcyB0aGUgb3BlcmF0aW9uIHRvIHJ1biBpbW1lZGlhdGVseSAoaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBydW4gb3JcbiAgICAgKiBjYW5jZWxlZCkuXG4gICAgICovXG4gICAgc2tpcERlbGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVEZWxheUVsYXBzZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyB0aGUgb3BlcmF0aW9uIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gZXhlY3V0ZWQgb3IgY2FuY2VsZWQuIFRoZVxuICAgICAqIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZC5cbiAgICAgKlxuICAgICAqIEFzIGxvbmcgYXMgdGhlIG9wZXJhdGlvbiBoYXMgbm90IHlldCBiZWVuIHJ1biwgY2FsbGluZyBjYW5jZWwoKSBwcm92aWRlcyBhXG4gICAgICogZ3VhcmFudGVlIHRoYXQgdGhlIG9wZXJhdGlvbiB3aWxsIG5vdCBiZSBydW4uXG4gICAgICovXG4gICAgY2FuY2VsKHJlYXNvbikge1xuICAgICAgICBpZiAodGhpcy50aW1lckhhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkNBTkNFTExFRCwgJ09wZXJhdGlvbiBjYW5jZWxsZWQnICsgKHJlYXNvbiA/ICc6ICcgKyByZWFzb24gOiAnJykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVEZWxheUVsYXBzZWQoKSB7XG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVySGFuZGxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcCgpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lckhhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmFsQ2FsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lckhhbmRsZSk7XG4gICAgICAgICAgICB0aGlzLnRpbWVySGFuZGxlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyBhIEZpcmVzdG9yZUVycm9yIHRoYXQgY2FuIGJlIHN1cmZhY2VkIHRvIHRoZSB1c2VyIGlmIHRoZSBwcm92aWRlZFxuICogZXJyb3IgaXMgYW4gSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvci4gUmUtdGhyb3dzIHRoZSBlcnJvciBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgbXNnKSB7XG4gICAgbG9nRXJyb3IoTE9HX1RBRyQ0LCBgJHttc2d9OiAke2V9YCk7XG4gICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xuICAgICAgICByZXR1cm4gbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsIGAke21zZ306ICR7ZX1gKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEb2N1bWVudFNldCBpcyBhbiBpbW11dGFibGUgKGNvcHktb24td3JpdGUpIGNvbGxlY3Rpb24gdGhhdCBob2xkcyBkb2N1bWVudHNcbiAqIGluIG9yZGVyIHNwZWNpZmllZCBieSB0aGUgcHJvdmlkZWQgY29tcGFyYXRvci4gV2UgYWx3YXlzIGFkZCBhIGRvY3VtZW50IGtleVxuICogY29tcGFyYXRvciBvbiB0b3Agb2Ygd2hhdCBpcyBwcm92aWRlZCB0byBndWFyYW50ZWUgZG9jdW1lbnQgZXF1YWxpdHkgYmFzZWQgb25cbiAqIHRoZSBrZXkuXG4gKi9cbmNsYXNzIERvY3VtZW50U2V0IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGVtcHR5IGNvcHkgb2YgdGhlIGV4aXN0aW5nIERvY3VtZW50U2V0LCB1c2luZyB0aGUgc2FtZVxuICAgICAqIGNvbXBhcmF0b3IuXG4gICAgICovXG4gICAgc3RhdGljIGVtcHR5U2V0KG9sZFNldCkge1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50U2V0KG9sZFNldC5jb21wYXJhdG9yKTtcbiAgICB9XG4gICAgLyoqIFRoZSBkZWZhdWx0IG9yZGVyaW5nIGlzIGJ5IGtleSBpZiB0aGUgY29tcGFyYXRvciBpcyBvbWl0dGVkICovXG4gICAgY29uc3RydWN0b3IoY29tcCkge1xuICAgICAgICAvLyBXZSBhcmUgYWRkaW5nIGRvY3VtZW50IGtleSBjb21wYXJhdG9yIHRvIHRoZSBlbmQgYXMgaXQncyB0aGUgb25seVxuICAgICAgICAvLyBndWFyYW50ZWVkIHVuaXF1ZSBwcm9wZXJ0eSBvZiBhIGRvY3VtZW50LlxuICAgICAgICBpZiAoY29tcCkge1xuICAgICAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gKGQxLCBkMikgPT4gY29tcChkMSwgZDIpIHx8IERvY3VtZW50S2V5LmNvbXBhcmF0b3IoZDEua2V5LCBkMi5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gKGQxLCBkMikgPT4gRG9jdW1lbnRLZXkuY29tcGFyYXRvcihkMS5rZXksIGQyLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXllZE1hcCA9IGRvY3VtZW50TWFwKCk7XG4gICAgICAgIHRoaXMuc29ydGVkU2V0ID0gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3IpO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleWVkTWFwLmdldChrZXkpICE9IG51bGw7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5ZWRNYXAuZ2V0KGtleSk7XG4gICAgfVxuICAgIGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRTZXQubWluS2V5KCk7XG4gICAgfVxuICAgIGxhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvcnRlZFNldC5tYXhLZXkoKTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydGVkU2V0LmlzRW1wdHkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHByb3ZpZGVkIGtleSBpbiB0aGUgZG9jdW1lbnQgc2V0LCBvciAtMSBpZiB0aGVcbiAgICAgKiBkb2N1bWVudCBrZXkgaXMgbm90IHByZXNlbnQgaW4gdGhlIHNldDtcbiAgICAgKi9cbiAgICBpbmRleE9mKGtleSkge1xuICAgICAgICBjb25zdCBkb2MgPSB0aGlzLmtleWVkTWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gZG9jID8gdGhpcy5zb3J0ZWRTZXQuaW5kZXhPZihkb2MpIDogLTE7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRTZXQuc2l6ZTtcbiAgICB9XG4gICAgLyoqIEl0ZXJhdGVzIGRvY3VtZW50cyBpbiBvcmRlciBkZWZpbmVkIGJ5IFwiY29tcGFyYXRvclwiICovXG4gICAgZm9yRWFjaChjYikge1xuICAgICAgICB0aGlzLnNvcnRlZFNldC5pbm9yZGVyVHJhdmVyc2FsKChrLCB2KSA9PiB7XG4gICAgICAgICAgICBjYihrKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBJbnNlcnRzIG9yIHVwZGF0ZXMgYSBkb2N1bWVudCB3aXRoIHRoZSBzYW1lIGtleSAqL1xuICAgIGFkZChkb2MpIHtcbiAgICAgICAgLy8gRmlyc3QgcmVtb3ZlIHRoZSBlbGVtZW50IGlmIHdlIGhhdmUgaXQuXG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMuZGVsZXRlKGRvYy5rZXkpO1xuICAgICAgICByZXR1cm4gc2V0LmNvcHkoc2V0LmtleWVkTWFwLmluc2VydChkb2Mua2V5LCBkb2MpLCBzZXQuc29ydGVkU2V0Lmluc2VydChkb2MsIG51bGwpKTtcbiAgICB9XG4gICAgLyoqIERlbGV0ZXMgYSBkb2N1bWVudCB3aXRoIGEgZ2l2ZW4ga2V5ICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBkb2MgPSB0aGlzLmdldChrZXkpO1xuICAgICAgICBpZiAoIWRvYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmtleWVkTWFwLnJlbW92ZShrZXkpLCB0aGlzLnNvcnRlZFNldC5yZW1vdmUoZG9jKSk7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEb2N1bWVudFNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaXplICE9PSBvdGhlci5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhpc0l0ID0gdGhpcy5zb3J0ZWRTZXQuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgY29uc3Qgb3RoZXJJdCA9IG90aGVyLnNvcnRlZFNldC5nZXRJdGVyYXRvcigpO1xuICAgICAgICB3aGlsZSAodGhpc0l0Lmhhc05leHQoKSkge1xuICAgICAgICAgICAgY29uc3QgdGhpc0RvYyA9IHRoaXNJdC5nZXROZXh0KCkua2V5O1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJEb2MgPSBvdGhlckl0LmdldE5leHQoKS5rZXk7XG4gICAgICAgICAgICBpZiAoIXRoaXNEb2MuaXNFcXVhbChvdGhlckRvYykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBkb2NTdHJpbmdzID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgICAgICAgZG9jU3RyaW5ncy5wdXNoKGRvYy50b1N0cmluZygpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkb2NTdHJpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdEb2N1bWVudFNldCAoKSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ0RvY3VtZW50U2V0IChcXG4gICcgKyBkb2NTdHJpbmdzLmpvaW4oJyAgXFxuJykgKyAnXFxuKSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29weShrZXllZE1hcCwgc29ydGVkU2V0KSB7XG4gICAgICAgIGNvbnN0IG5ld1NldCA9IG5ldyBEb2N1bWVudFNldCgpO1xuICAgICAgICBuZXdTZXQuY29tcGFyYXRvciA9IHRoaXMuY29tcGFyYXRvcjtcbiAgICAgICAgbmV3U2V0LmtleWVkTWFwID0ga2V5ZWRNYXA7XG4gICAgICAgIG5ld1NldC5zb3J0ZWRTZXQgPSBzb3J0ZWRTZXQ7XG4gICAgICAgIHJldHVybiBuZXdTZXQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEb2N1bWVudENoYW5nZVNldCBrZWVwcyB0cmFjayBvZiBhIHNldCBvZiBjaGFuZ2VzIHRvIGRvY3MgaW4gYSBxdWVyeSwgbWVyZ2luZ1xuICogZHVwbGljYXRlIGV2ZW50cyBmb3IgdGhlIHNhbWUgZG9jLlxuICovXG5jbGFzcyBEb2N1bWVudENoYW5nZVNldCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlTWFwID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbiAgICB9XG4gICAgdHJhY2soY2hhbmdlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGNoYW5nZS5kb2Mua2V5O1xuICAgICAgICBjb25zdCBvbGRDaGFuZ2UgPSB0aGlzLmNoYW5nZU1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFvbGRDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwgY2hhbmdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNZXJnZSB0aGUgbmV3IGNoYW5nZSB3aXRoIHRoZSBleGlzdGluZyBjaGFuZ2UuXG4gICAgICAgIGlmIChjaGFuZ2UudHlwZSAhPT0gMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovICYmXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMyAvKiBDaGFuZ2VUeXBlLk1ldGFkYXRhICovKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIGNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IDMgLyogQ2hhbmdlVHlwZS5NZXRhZGF0YSAqLyAmJlxuICAgICAgICAgICAgb2xkQ2hhbmdlLnR5cGUgIT09IDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBvbGRDaGFuZ2UudHlwZSxcbiAgICAgICAgICAgICAgICBkb2M6IGNoYW5nZS5kb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8gJiZcbiAgICAgICAgICAgIG9sZENoYW5nZS50eXBlID09PSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IDIgLyogQ2hhbmdlVHlwZS5Nb2RpZmllZCAqLyxcbiAgICAgICAgICAgICAgICBkb2M6IGNoYW5nZS5kb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8gJiZcbiAgICAgICAgICAgIG9sZENoYW5nZS50eXBlID09PSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLyxcbiAgICAgICAgICAgICAgICBkb2M6IGNoYW5nZS5kb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLyAmJlxuICAgICAgICAgICAgb2xkQ2hhbmdlLnR5cGUgPT09IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLykge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSB0aGlzLmNoYW5nZU1hcC5yZW1vdmUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8gJiZcbiAgICAgICAgICAgIG9sZENoYW5nZS50eXBlID09PSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAuaW5zZXJ0KGtleSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovLFxuICAgICAgICAgICAgICAgIGRvYzogb2xkQ2hhbmdlLmRvY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLyAmJlxuICAgICAgICAgICAgb2xkQ2hhbmdlLnR5cGUgPT09IDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8sXG4gICAgICAgICAgICAgICAgZG9jOiBjaGFuZ2UuZG9jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaW5jbHVkZXMgdGhlc2UgY2FzZXMsIHdoaWNoIGRvbid0IG1ha2Ugc2Vuc2U6XG4gICAgICAgICAgICAvLyBBZGRlZC0+QWRkZWRcbiAgICAgICAgICAgIC8vIFJlbW92ZWQtPlJlbW92ZWRcbiAgICAgICAgICAgIC8vIE1vZGlmaWVkLT5BZGRlZFxuICAgICAgICAgICAgLy8gUmVtb3ZlZC0+TW9kaWZpZWRcbiAgICAgICAgICAgIC8vIE1ldGFkYXRhLT5BZGRlZFxuICAgICAgICAgICAgLy8gUmVtb3ZlZC0+TWV0YWRhdGFcbiAgICAgICAgICAgIGZhaWwoMHhmNzZkLCB7XG4gICAgICAgICAgICAgICAgY2hhbmdlLFxuICAgICAgICAgICAgICAgIG9sZENoYW5nZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2hhbmdlcygpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoYW5nZU1hcC5pbm9yZGVyVHJhdmVyc2FsKChrZXksIGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9XG59XG5jbGFzcyBWaWV3U25hcHNob3Qge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBkb2NzLCBvbGREb2NzLCBkb2NDaGFuZ2VzLCBtdXRhdGVkS2V5cywgZnJvbUNhY2hlLCBzeW5jU3RhdGVDaGFuZ2VkLCBleGNsdWRlc01ldGFkYXRhQ2hhbmdlcywgaGFzQ2FjaGVkUmVzdWx0cykge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuZG9jcyA9IGRvY3M7XG4gICAgICAgIHRoaXMub2xkRG9jcyA9IG9sZERvY3M7XG4gICAgICAgIHRoaXMuZG9jQ2hhbmdlcyA9IGRvY0NoYW5nZXM7XG4gICAgICAgIHRoaXMubXV0YXRlZEtleXMgPSBtdXRhdGVkS2V5cztcbiAgICAgICAgdGhpcy5mcm9tQ2FjaGUgPSBmcm9tQ2FjaGU7XG4gICAgICAgIHRoaXMuc3luY1N0YXRlQ2hhbmdlZCA9IHN5bmNTdGF0ZUNoYW5nZWQ7XG4gICAgICAgIHRoaXMuZXhjbHVkZXNNZXRhZGF0YUNoYW5nZXMgPSBleGNsdWRlc01ldGFkYXRhQ2hhbmdlcztcbiAgICAgICAgdGhpcy5oYXNDYWNoZWRSZXN1bHRzID0gaGFzQ2FjaGVkUmVzdWx0cztcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSB2aWV3IHNuYXBzaG90IGFzIGlmIGFsbCBkb2N1bWVudHMgaW4gdGhlIHNuYXBzaG90IHdlcmUgYWRkZWQuICovXG4gICAgc3RhdGljIGZyb21Jbml0aWFsRG9jdW1lbnRzKHF1ZXJ5LCBkb2N1bWVudHMsIG11dGF0ZWRLZXlzLCBmcm9tQ2FjaGUsIGhhc0NhY2hlZFJlc3VsdHMpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgICAgICBkb2N1bWVudHMuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgdHlwZTogMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovLCBkb2MgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdTbmFwc2hvdChxdWVyeSwgZG9jdW1lbnRzLCBEb2N1bWVudFNldC5lbXB0eVNldChkb2N1bWVudHMpLCBjaGFuZ2VzLCBtdXRhdGVkS2V5cywgZnJvbUNhY2hlLCBcbiAgICAgICAgLyogc3luY1N0YXRlQ2hhbmdlZD0gKi8gdHJ1ZSwgXG4gICAgICAgIC8qIGV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzPSAqLyBmYWxzZSwgaGFzQ2FjaGVkUmVzdWx0cyk7XG4gICAgfVxuICAgIGdldCBoYXNQZW5kaW5nV3JpdGVzKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMubXV0YXRlZEtleXMuaXNFbXB0eSgpO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmZyb21DYWNoZSAhPT0gb3RoZXIuZnJvbUNhY2hlIHx8XG4gICAgICAgICAgICB0aGlzLmhhc0NhY2hlZFJlc3VsdHMgIT09IG90aGVyLmhhc0NhY2hlZFJlc3VsdHMgfHxcbiAgICAgICAgICAgIHRoaXMuc3luY1N0YXRlQ2hhbmdlZCAhPT0gb3RoZXIuc3luY1N0YXRlQ2hhbmdlZCB8fFxuICAgICAgICAgICAgIXRoaXMubXV0YXRlZEtleXMuaXNFcXVhbChvdGhlci5tdXRhdGVkS2V5cykgfHxcbiAgICAgICAgICAgICFxdWVyeUVxdWFscyh0aGlzLnF1ZXJ5LCBvdGhlci5xdWVyeSkgfHxcbiAgICAgICAgICAgICF0aGlzLmRvY3MuaXNFcXVhbChvdGhlci5kb2NzKSB8fFxuICAgICAgICAgICAgIXRoaXMub2xkRG9jcy5pc0VxdWFsKG90aGVyLm9sZERvY3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuZG9jQ2hhbmdlcztcbiAgICAgICAgY29uc3Qgb3RoZXJDaGFuZ2VzID0gb3RoZXIuZG9jQ2hhbmdlcztcbiAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoICE9PSBvdGhlckNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlc1tpXS50eXBlICE9PSBvdGhlckNoYW5nZXNbaV0udHlwZSB8fFxuICAgICAgICAgICAgICAgICFjaGFuZ2VzW2ldLmRvYy5pc0VxdWFsKG90aGVyQ2hhbmdlc1tpXS5kb2MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogSG9sZHMgdGhlIGxpc3RlbmVycyBhbmQgdGhlIGxhc3QgcmVjZWl2ZWQgVmlld1NuYXBzaG90IGZvciBhIHF1ZXJ5IGJlaW5nXG4gKiB0cmFja2VkIGJ5IEV2ZW50TWFuYWdlci5cbiAqL1xuY2xhc3MgUXVlcnlMaXN0ZW5lcnNJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3U25hcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgLy8gSGVscGVyIG1ldGhvZHMgdGhhdCBjaGVja3MgaWYgdGhlIHF1ZXJ5IGhhcyBsaXN0ZW5lcnMgdGhhdCBsaXN0ZW5pbmcgdG8gcmVtb3RlIHN0b3JlXG4gICAgaGFzUmVtb3RlTGlzdGVuZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMuc29tZShsaXN0ZW5lciA9PiBsaXN0ZW5lci5saXN0ZW5zVG9SZW1vdGVTdG9yZSgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdFdmVudE1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBFdmVudE1hbmFnZXJJbXBsKCk7XG59XG5jbGFzcyBFdmVudE1hbmFnZXJJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5xdWVyaWVzID0gbmV3UXVlcmllc09iamVjdE1hcCgpO1xuICAgICAgICB0aGlzLm9ubGluZVN0YXRlID0gXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLztcbiAgICAgICAgdGhpcy5zbmFwc2hvdHNJblN5bmNMaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgZXJyb3JBbGxUYXJnZXRzKHRoaXMsIG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkFCT1JURUQsICdGaXJlc3RvcmUgc2h1dHRpbmcgZG93bicpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdRdWVyaWVzT2JqZWN0TWFwKCkge1xuICAgIHJldHVybiBuZXcgT2JqZWN0TWFwKHEgPT4gY2Fub25pZnlRdWVyeShxKSwgcXVlcnlFcXVhbHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gZXZlbnRNYW5hZ2VyTGlzdGVuKGV2ZW50TWFuYWdlciwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XG4gICAgbGV0IGxpc3RlbmVyQWN0aW9uID0gMyAvKiBMaXN0ZW5lclNldHVwQWN0aW9uLk5vQWN0aW9uUmVxdWlyZWQgKi87XG4gICAgY29uc3QgcXVlcnkgPSBsaXN0ZW5lci5xdWVyeTtcbiAgICBsZXQgcXVlcnlJbmZvID0gZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmdldChxdWVyeSk7XG4gICAgaWYgKCFxdWVyeUluZm8pIHtcbiAgICAgICAgcXVlcnlJbmZvID0gbmV3IFF1ZXJ5TGlzdGVuZXJzSW5mbygpO1xuICAgICAgICBsaXN0ZW5lckFjdGlvbiA9IGxpc3RlbmVyLmxpc3RlbnNUb1JlbW90ZVN0b3JlKClcbiAgICAgICAgICAgID8gMCAvKiBMaXN0ZW5lclNldHVwQWN0aW9uLkluaXRpYWxpemVMb2NhbExpc3RlbkFuZFJlcXVpcmVXYXRjaENvbm5lY3Rpb24gKi9cbiAgICAgICAgICAgIDogMSAvKiBMaXN0ZW5lclNldHVwQWN0aW9uLkluaXRpYWxpemVMb2NhbExpc3Rlbk9ubHkgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCFxdWVyeUluZm8uaGFzUmVtb3RlTGlzdGVuZXJzKCkgJiZcbiAgICAgICAgbGlzdGVuZXIubGlzdGVuc1RvUmVtb3RlU3RvcmUoKSkge1xuICAgICAgICAvLyBRdWVyeSBoYXMgYmVlbiBsaXN0ZW5pbmcgdG8gbG9jYWwgY2FjaGUsIGFuZCB0cmllcyB0byBhZGQgYSBuZXcgbGlzdGVuZXIgc291cmNlZCBmcm9tIHdhdGNoLlxuICAgICAgICBsaXN0ZW5lckFjdGlvbiA9IDIgLyogTGlzdGVuZXJTZXR1cEFjdGlvbi5SZXF1aXJlV2F0Y2hDb25uZWN0aW9uT25seSAqLztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgc3dpdGNoIChsaXN0ZW5lckFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAwIC8qIExpc3RlbmVyU2V0dXBBY3Rpb24uSW5pdGlhbGl6ZUxvY2FsTGlzdGVuQW5kUmVxdWlyZVdhdGNoQ29ubmVjdGlvbiAqLzpcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8udmlld1NuYXAgPSBhd2FpdCBldmVudE1hbmFnZXJJbXBsLm9uTGlzdGVuKHF1ZXJ5LCBcbiAgICAgICAgICAgICAgICAvKiogZW5hYmxlUmVtb3RlTGlzdGVuPSAqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMSAvKiBMaXN0ZW5lclNldHVwQWN0aW9uLkluaXRpYWxpemVMb2NhbExpc3Rlbk9ubHkgKi86XG4gICAgICAgICAgICAgICAgcXVlcnlJbmZvLnZpZXdTbmFwID0gYXdhaXQgZXZlbnRNYW5hZ2VySW1wbC5vbkxpc3RlbihxdWVyeSwgXG4gICAgICAgICAgICAgICAgLyoqIGVuYWJsZVJlbW90ZUxpc3Rlbj0gKi8gZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIExpc3RlbmVyU2V0dXBBY3Rpb24uUmVxdWlyZVdhdGNoQ29ubmVjdGlvbk9ubHkgKi86XG4gICAgICAgICAgICAgICAgYXdhaXQgZXZlbnRNYW5hZ2VySW1wbC5vbkZpcnN0UmVtb3RlU3RvcmVMaXN0ZW4ocXVlcnkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBmaXJlc3RvcmVFcnJvciA9IHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgYEluaXRpYWxpemF0aW9uIG9mIHF1ZXJ5ICcke3N0cmluZ2lmeVF1ZXJ5KGxpc3RlbmVyLnF1ZXJ5KX0nIGZhaWxlZGApO1xuICAgICAgICBsaXN0ZW5lci5vbkVycm9yKGZpcmVzdG9yZUVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuc2V0KHF1ZXJ5LCBxdWVyeUluZm8pO1xuICAgIHF1ZXJ5SW5mby5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgLy8gUnVuIGdsb2JhbCBzbmFwc2hvdCBsaXN0ZW5lcnMgaWYgYSBjb25zaXN0ZW50IHNuYXBzaG90IGhhcyBiZWVuIGVtaXR0ZWQuXG4gICAgbGlzdGVuZXIuYXBwbHlPbmxpbmVTdGF0ZUNoYW5nZShldmVudE1hbmFnZXJJbXBsLm9ubGluZVN0YXRlKTtcbiAgICBpZiAocXVlcnlJbmZvLnZpZXdTbmFwKSB7XG4gICAgICAgIGNvbnN0IHJhaXNlZEV2ZW50ID0gbGlzdGVuZXIub25WaWV3U25hcHNob3QocXVlcnlJbmZvLnZpZXdTbmFwKTtcbiAgICAgICAgaWYgKHJhaXNlZEV2ZW50KSB7XG4gICAgICAgICAgICByYWlzZVNuYXBzaG90c0luU3luY0V2ZW50KGV2ZW50TWFuYWdlckltcGwpO1xuICAgICAgICB9XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZXZlbnRNYW5hZ2VyVW5saXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGV2ZW50TWFuYWdlckltcGwgPSBkZWJ1Z0Nhc3QoZXZlbnRNYW5hZ2VyKTtcbiAgICBjb25zdCBxdWVyeSA9IGxpc3RlbmVyLnF1ZXJ5O1xuICAgIGxldCBsaXN0ZW5lckFjdGlvbiA9IDMgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLk5vQWN0aW9uUmVxdWlyZWQgKi87XG4gICAgY29uc3QgcXVlcnlJbmZvID0gZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmdldChxdWVyeSk7XG4gICAgaWYgKHF1ZXJ5SW5mbykge1xuICAgICAgICBjb25zdCBpID0gcXVlcnlJbmZvLmxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgcXVlcnlJbmZvLmxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpZiAocXVlcnlJbmZvLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lckFjdGlvbiA9IGxpc3RlbmVyLmxpc3RlbnNUb1JlbW90ZVN0b3JlKClcbiAgICAgICAgICAgICAgICAgICAgPyAwIC8qIExpc3RlbmVyUmVtb3ZhbEFjdGlvbi5UZXJtaW5hdGVMb2NhbExpc3RlbkFuZFJlcXVpcmVXYXRjaERpc2Nvbm5lY3Rpb24gKi9cbiAgICAgICAgICAgICAgICAgICAgOiAxIC8qIExpc3RlbmVyUmVtb3ZhbEFjdGlvbi5UZXJtaW5hdGVMb2NhbExpc3Rlbk9ubHkgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghcXVlcnlJbmZvLmhhc1JlbW90ZUxpc3RlbmVycygpICYmXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuc1RvUmVtb3RlU3RvcmUoKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSByZW1vdmVkIGxpc3RlbmVyIGlzIHRoZSBsYXN0IG9uZSB0aGF0IHNvdXJjZWQgZnJvbSB3YXRjaC5cbiAgICAgICAgICAgICAgICBsaXN0ZW5lckFjdGlvbiA9IDIgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLlJlcXVpcmVXYXRjaERpc2Nvbm5lY3Rpb25Pbmx5ICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAobGlzdGVuZXJBY3Rpb24pIHtcbiAgICAgICAgY2FzZSAwIC8qIExpc3RlbmVyUmVtb3ZhbEFjdGlvbi5UZXJtaW5hdGVMb2NhbExpc3RlbkFuZFJlcXVpcmVXYXRjaERpc2Nvbm5lY3Rpb24gKi86XG4gICAgICAgICAgICBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuZGVsZXRlKHF1ZXJ5KTtcbiAgICAgICAgICAgIHJldHVybiBldmVudE1hbmFnZXJJbXBsLm9uVW5saXN0ZW4ocXVlcnksIFxuICAgICAgICAgICAgLyoqIGRpc2FibGVSZW1vdGVMaXN0ZW49ICovIHRydWUpO1xuICAgICAgICBjYXNlIDEgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLlRlcm1pbmF0ZUxvY2FsTGlzdGVuT25seSAqLzpcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5kZWxldGUocXVlcnkpO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TWFuYWdlckltcGwub25Vbmxpc3RlbihxdWVyeSwgXG4gICAgICAgICAgICAvKiogZGlzYWJsZVJlbW90ZUxpc3Rlbj0gKi8gZmFsc2UpO1xuICAgICAgICBjYXNlIDIgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLlJlcXVpcmVXYXRjaERpc2Nvbm5lY3Rpb25Pbmx5ICovOlxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TWFuYWdlckltcGwub25MYXN0UmVtb3RlU3RvcmVVbmxpc3RlbihxdWVyeSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgfVxufVxuZnVuY3Rpb24gZXZlbnRNYW5hZ2VyT25XYXRjaENoYW5nZShldmVudE1hbmFnZXIsIHZpZXdTbmFwcykge1xuICAgIGNvbnN0IGV2ZW50TWFuYWdlckltcGwgPSBkZWJ1Z0Nhc3QoZXZlbnRNYW5hZ2VyKTtcbiAgICBsZXQgcmFpc2VkRXZlbnQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHZpZXdTbmFwIG9mIHZpZXdTbmFwcykge1xuICAgICAgICBjb25zdCBxdWVyeSA9IHZpZXdTbmFwLnF1ZXJ5O1xuICAgICAgICBjb25zdCBxdWVyeUluZm8gPSBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuZ2V0KHF1ZXJ5KTtcbiAgICAgICAgaWYgKHF1ZXJ5SW5mbykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBxdWVyeUluZm8ubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm9uVmlld1NuYXBzaG90KHZpZXdTbmFwKSkge1xuICAgICAgICAgICAgICAgICAgICByYWlzZWRFdmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVlcnlJbmZvLnZpZXdTbmFwID0gdmlld1NuYXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJhaXNlZEV2ZW50KSB7XG4gICAgICAgIHJhaXNlU25hcHNob3RzSW5TeW5jRXZlbnQoZXZlbnRNYW5hZ2VySW1wbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXZlbnRNYW5hZ2VyT25XYXRjaEVycm9yKGV2ZW50TWFuYWdlciwgcXVlcnksIGVycm9yKSB7XG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xuICAgIGNvbnN0IHF1ZXJ5SW5mbyA9IGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5nZXQocXVlcnkpO1xuICAgIGlmIChxdWVyeUluZm8pIHtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBxdWVyeUluZm8ubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycy4gTk9URTogV2UgZG9uJ3QgbmVlZCB0byBjYWxsIHN5bmNFbmdpbmUudW5saXN0ZW4oKVxuICAgIC8vIGFmdGVyIGFuIGVycm9yLlxuICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5kZWxldGUocXVlcnkpO1xufVxuZnVuY3Rpb24gZXZlbnRNYW5hZ2VyT25PbmxpbmVTdGF0ZUNoYW5nZShldmVudE1hbmFnZXIsIG9ubGluZVN0YXRlKSB7XG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xuICAgIGV2ZW50TWFuYWdlckltcGwub25saW5lU3RhdGUgPSBvbmxpbmVTdGF0ZTtcbiAgICBsZXQgcmFpc2VkRXZlbnQgPSBmYWxzZTtcbiAgICBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuZm9yRWFjaCgoXywgcXVlcnlJbmZvKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgcXVlcnlJbmZvLmxpc3RlbmVycykge1xuICAgICAgICAgICAgLy8gUnVuIGdsb2JhbCBzbmFwc2hvdCBsaXN0ZW5lcnMgaWYgYSBjb25zaXN0ZW50IHNuYXBzaG90IGhhcyBiZWVuIGVtaXR0ZWQuXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIuYXBwbHlPbmxpbmVTdGF0ZUNoYW5nZShvbmxpbmVTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByYWlzZWRFdmVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocmFpc2VkRXZlbnQpIHtcbiAgICAgICAgcmFpc2VTbmFwc2hvdHNJblN5bmNFdmVudChldmVudE1hbmFnZXJJbXBsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRTbmFwc2hvdHNJblN5bmNMaXN0ZW5lcihldmVudE1hbmFnZXIsIG9ic2VydmVyKSB7XG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xuICAgIGV2ZW50TWFuYWdlckltcGwuc25hcHNob3RzSW5TeW5jTGlzdGVuZXJzLmFkZChvYnNlcnZlcik7XG4gICAgLy8gSW1tZWRpYXRlbHkgZmlyZSBhbiBpbml0aWFsIGV2ZW50LCBpbmRpY2F0aW5nIGFsbCBleGlzdGluZyBsaXN0ZW5lcnNcbiAgICAvLyBhcmUgaW4tc3luYy5cbiAgICBvYnNlcnZlci5uZXh0KCk7XG59XG5mdW5jdGlvbiByZW1vdmVTbmFwc2hvdHNJblN5bmNMaXN0ZW5lcihldmVudE1hbmFnZXIsIG9ic2VydmVyKSB7XG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xuICAgIGV2ZW50TWFuYWdlckltcGwuc25hcHNob3RzSW5TeW5jTGlzdGVuZXJzLmRlbGV0ZShvYnNlcnZlcik7XG59XG5mdW5jdGlvbiBlcnJvckFsbFRhcmdldHMoZXZlbnRNYW5hZ2VyLCBlcnJvcikge1xuICAgIGNvbnN0IGV2ZW50TWFuYWdlckltcGwgPSBkZWJ1Z0Nhc3QoZXZlbnRNYW5hZ2VyKTtcbiAgICBjb25zdCBxdWVyaWVzID0gZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzO1xuICAgIC8vIFByZXZlbnQgZnVydGhlciBhY2Nlc3MgYnkgY2xlYXJpbmcgT2JqZWN0TWFwLlxuICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcyA9IG5ld1F1ZXJpZXNPYmplY3RNYXAoKTtcbiAgICBxdWVyaWVzLmZvckVhY2goKF8sIHF1ZXJ5SW5mbykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHF1ZXJ5SW5mby5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyBDYWxsIGFsbCBnbG9iYWwgc25hcHNob3QgbGlzdGVuZXJzIHRoYXQgaGF2ZSBiZWVuIHNldC5cbmZ1bmN0aW9uIHJhaXNlU25hcHNob3RzSW5TeW5jRXZlbnQoZXZlbnRNYW5hZ2VySW1wbCkge1xuICAgIGV2ZW50TWFuYWdlckltcGwuc25hcHNob3RzSW5TeW5jTGlzdGVuZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4ge1xuICAgICAgICBvYnNlcnZlci5uZXh0KCk7XG4gICAgfSk7XG59XG52YXIgTGlzdGVuZXJEYXRhU291cmNlO1xuKGZ1bmN0aW9uIChMaXN0ZW5lckRhdGFTb3VyY2UpIHtcbiAgICAvKiogTGlzdGVuIHRvIGJvdGggY2FjaGUgYW5kIHNlcnZlciBjaGFuZ2VzICovXG4gICAgTGlzdGVuZXJEYXRhU291cmNlW1wiRGVmYXVsdFwiXSA9IFwiZGVmYXVsdFwiO1xuICAgIC8qKiBMaXN0ZW4gdG8gY2hhbmdlcyBpbiBjYWNoZSBvbmx5ICovXG4gICAgTGlzdGVuZXJEYXRhU291cmNlW1wiQ2FjaGVcIl0gPSBcImNhY2hlXCI7XG59KShMaXN0ZW5lckRhdGFTb3VyY2UgfHwgKExpc3RlbmVyRGF0YVNvdXJjZSA9IHt9KSk7XG4vKipcbiAqIFF1ZXJ5TGlzdGVuZXIgdGFrZXMgYSBzZXJpZXMgb2YgaW50ZXJuYWwgdmlldyBzbmFwc2hvdHMgYW5kIGRldGVybWluZXNcbiAqIHdoZW4gdG8gcmFpc2UgdGhlIGV2ZW50LlxuICpcbiAqIEl0IHVzZXMgYW4gT2JzZXJ2ZXIgdG8gZGlzcGF0Y2ggZXZlbnRzLlxuICovXG5jbGFzcyBRdWVyeUxpc3RlbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihxdWVyeSwgcXVlcnlPYnNlcnZlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMucXVlcnlPYnNlcnZlciA9IHF1ZXJ5T2JzZXJ2ZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsIHNuYXBzaG90cyAoZS5nLiBmcm9tIGNhY2hlKSBtYXkgbm90IGJlIHByb3BhZ2F0ZWQgdG8gdGhlIHdyYXBwZWRcbiAgICAgICAgICogb2JzZXJ2ZXIuIFRoaXMgZmxhZyBpcyBzZXQgdG8gdHJ1ZSBvbmNlIHdlJ3ZlIGFjdHVhbGx5IHJhaXNlZCBhbiBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFpc2VkSW5pdGlhbEV2ZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc25hcCA9IG51bGw7XG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBuZXcgVmlld1NuYXBzaG90IHRvIHRoaXMgbGlzdGVuZXIsIHJhaXNpbmcgYSB1c2VyLWZhY2luZyBldmVudFxuICAgICAqIGlmIGFwcGxpY2FibGUgKGRlcGVuZGluZyBvbiB3aGF0IGNoYW5nZWQsIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIGludG9cbiAgICAgKiBtZXRhZGF0YS1vbmx5IGNoYW5nZXMsIGV0Yy4pLiBSZXR1cm5zIHRydWUgaWYgYSB1c2VyLWZhY2luZyBldmVudCB3YXNcbiAgICAgKiBpbmRlZWQgcmFpc2VkLlxuICAgICAqL1xuICAgIG9uVmlld1NuYXBzaG90KHNuYXApIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcykge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBtZXRhZGF0YSBvbmx5IGNoYW5nZXMuXG4gICAgICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRvY0NoYW5nZSBvZiBzbmFwLmRvY0NoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jQ2hhbmdlLnR5cGUgIT09IDMgLyogQ2hhbmdlVHlwZS5NZXRhZGF0YSAqLykge1xuICAgICAgICAgICAgICAgICAgICBkb2NDaGFuZ2VzLnB1c2goZG9jQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzbmFwID0gbmV3IFZpZXdTbmFwc2hvdChzbmFwLnF1ZXJ5LCBzbmFwLmRvY3MsIHNuYXAub2xkRG9jcywgZG9jQ2hhbmdlcywgc25hcC5tdXRhdGVkS2V5cywgc25hcC5mcm9tQ2FjaGUsIHNuYXAuc3luY1N0YXRlQ2hhbmdlZCwgXG4gICAgICAgICAgICAvKiBleGNsdWRlc01ldGFkYXRhQ2hhbmdlcz0gKi8gdHJ1ZSwgc25hcC5oYXNDYWNoZWRSZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFpc2VkRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLnJhaXNlZEluaXRpYWxFdmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkUmFpc2VJbml0aWFsRXZlbnQoc25hcCwgdGhpcy5vbmxpbmVTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhaXNlSW5pdGlhbEV2ZW50KHNuYXApO1xuICAgICAgICAgICAgICAgIHJhaXNlZEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNob3VsZFJhaXNlRXZlbnQoc25hcCkpIHtcbiAgICAgICAgICAgIHRoaXMucXVlcnlPYnNlcnZlci5uZXh0KHNuYXApO1xuICAgICAgICAgICAgcmFpc2VkRXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc25hcCA9IHNuYXA7XG4gICAgICAgIHJldHVybiByYWlzZWRFdmVudDtcbiAgICB9XG4gICAgb25FcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLnF1ZXJ5T2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB3aGV0aGVyIGEgc25hcHNob3Qgd2FzIHJhaXNlZC4gKi9cbiAgICBhcHBseU9ubGluZVN0YXRlQ2hhbmdlKG9ubGluZVN0YXRlKSB7XG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBvbmxpbmVTdGF0ZTtcbiAgICAgICAgbGV0IHJhaXNlZEV2ZW50ID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnNuYXAgJiZcbiAgICAgICAgICAgICF0aGlzLnJhaXNlZEluaXRpYWxFdmVudCAmJlxuICAgICAgICAgICAgdGhpcy5zaG91bGRSYWlzZUluaXRpYWxFdmVudCh0aGlzLnNuYXAsIG9ubGluZVN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZUluaXRpYWxFdmVudCh0aGlzLnNuYXApO1xuICAgICAgICAgICAgcmFpc2VkRXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYWlzZWRFdmVudDtcbiAgICB9XG4gICAgc2hvdWxkUmFpc2VJbml0aWFsRXZlbnQoc25hcCwgb25saW5lU3RhdGUpIHtcbiAgICAgICAgLy8gQWx3YXlzIHJhaXNlIHRoZSBmaXJzdCBldmVudCB3aGVuIHdlJ3JlIHN5bmNlZFxuICAgICAgICBpZiAoIXNuYXAuZnJvbUNhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbHdheXMgcmFpc2UgZXZlbnQgaWYgbGlzdGVuaW5nIHRvIGNhY2hlXG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5zVG9SZW1vdGVTdG9yZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOT1RFOiBXZSBjb25zaWRlciBPbmxpbmVTdGF0ZS5Vbmtub3duIGFzIG9ubGluZSAoaXQgc2hvdWxkIGJlY29tZSBPZmZsaW5lXG4gICAgICAgIC8vIG9yIE9ubGluZSBpZiB3ZSB3YWl0IGxvbmcgZW5vdWdoKS5cbiAgICAgICAgY29uc3QgbWF5YmVPbmxpbmUgPSBvbmxpbmVTdGF0ZSAhPT0gXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLztcbiAgICAgICAgLy8gRG9uJ3QgcmFpc2UgdGhlIGV2ZW50IGlmIHdlJ3JlIG9ubGluZSwgYXJlbid0IHN5bmNlZCB5ZXQgKGNoZWNrZWRcbiAgICAgICAgLy8gYWJvdmUpIGFuZCBhcmUgd2FpdGluZyBmb3IgYSBzeW5jLlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLndhaXRGb3JTeW5jV2hlbk9ubGluZSAmJiBtYXliZU9ubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJhaXNlIGRhdGEgZnJvbSBjYWNoZSBpZiB3ZSBoYXZlIGFueSBkb2N1bWVudHMsIGhhdmUgY2FjaGVkIHJlc3VsdHMgYmVmb3JlLFxuICAgICAgICAvLyBvciB3ZSBhcmUgb2ZmbGluZS5cbiAgICAgICAgcmV0dXJuICghc25hcC5kb2NzLmlzRW1wdHkoKSB8fFxuICAgICAgICAgICAgc25hcC5oYXNDYWNoZWRSZXN1bHRzIHx8XG4gICAgICAgICAgICBvbmxpbmVTdGF0ZSA9PT0gXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLyk7XG4gICAgfVxuICAgIHNob3VsZFJhaXNlRXZlbnQoc25hcCkge1xuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGhhbmRsZSBpbmNsdWRlRG9jdW1lbnRNZXRhZGF0YUNoYW5nZXMgaGVyZSBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBNZXRhZGF0YSBvbmx5IGNoYW5nZXMgaGF2ZSBhbHJlYWR5IGJlZW4gc3RyaXBwZWQgb3V0IGlmIG5lZWRlZC5cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgb25seSBjaGFuZ2VzIHdlIHdpbGwgc2VlIGFyZSB0aGUgb25lcyB3ZSBzaG91bGRcbiAgICAgICAgLy8gcHJvcGFnYXRlLlxuICAgICAgICBpZiAoc25hcC5kb2NDaGFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc1BlbmRpbmdXcml0ZXNDaGFuZ2VkID0gdGhpcy5zbmFwICYmIHRoaXMuc25hcC5oYXNQZW5kaW5nV3JpdGVzICE9PSBzbmFwLmhhc1BlbmRpbmdXcml0ZXM7XG4gICAgICAgIGlmIChzbmFwLnN5bmNTdGF0ZUNoYW5nZWQgfHwgaGFzUGVuZGluZ1dyaXRlc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyA9PT0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZW5lcmFsbHkgd2Ugc2hvdWxkIGhhdmUgaGl0IG9uZSBvZiB0aGUgY2FzZXMgYWJvdmUsIGJ1dCBpdCdzIHBvc3NpYmxlXG4gICAgICAgIC8vIHRvIGdldCBoZXJlIGlmIHRoZXJlIHdlcmUgb25seSBtZXRhZGF0YSBkb2NDaGFuZ2VzIGFuZCB0aGV5IGdvdFxuICAgICAgICAvLyBzdHJpcHBlZCBvdXQuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmFpc2VJbml0aWFsRXZlbnQoc25hcCkge1xuICAgICAgICBzbmFwID0gVmlld1NuYXBzaG90LmZyb21Jbml0aWFsRG9jdW1lbnRzKHNuYXAucXVlcnksIHNuYXAuZG9jcywgc25hcC5tdXRhdGVkS2V5cywgc25hcC5mcm9tQ2FjaGUsIHNuYXAuaGFzQ2FjaGVkUmVzdWx0cyk7XG4gICAgICAgIHRoaXMucmFpc2VkSW5pdGlhbEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5xdWVyeU9ic2VydmVyLm5leHQoc25hcCk7XG4gICAgfVxuICAgIGxpc3RlbnNUb1JlbW90ZVN0b3JlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNvdXJjZSAhPT0gTGlzdGVuZXJEYXRhU291cmNlLkNhY2hlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBzZXQgb2YgY2hhbmdlcyB0byB3aGF0IGRvY3VtZW50cyBhcmUgY3VycmVudGx5IGluIHZpZXcgYW5kIG91dCBvZiB2aWV3IGZvclxuICogYSBnaXZlbiBxdWVyeS4gVGhlc2UgY2hhbmdlcyBhcmUgc2VudCB0byB0aGUgTG9jYWxTdG9yZSBieSB0aGUgVmlldyAodmlhXG4gKiB0aGUgU3luY0VuZ2luZSkgYW5kIGFyZSB1c2VkIHRvIHBpbiAvIHVucGluIGRvY3VtZW50cyBhcyBhcHByb3ByaWF0ZS5cbiAqL1xuY2xhc3MgTG9jYWxWaWV3Q2hhbmdlcyB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0SWQsIGZyb21DYWNoZSwgYWRkZWRLZXlzLCByZW1vdmVkS2V5cykge1xuICAgICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XG4gICAgICAgIHRoaXMuZnJvbUNhY2hlID0gZnJvbUNhY2hlO1xuICAgICAgICB0aGlzLmFkZGVkS2V5cyA9IGFkZGVkS2V5cztcbiAgICAgICAgdGhpcy5yZW1vdmVkS2V5cyA9IHJlbW92ZWRLZXlzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVNuYXBzaG90KHRhcmdldElkLCB2aWV3U25hcHNob3QpIHtcbiAgICAgICAgbGV0IGFkZGVkS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIGxldCByZW1vdmVkS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgZG9jQ2hhbmdlIG9mIHZpZXdTbmFwc2hvdC5kb2NDaGFuZ2VzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGRvY0NoYW5nZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi86XG4gICAgICAgICAgICAgICAgICAgIGFkZGVkS2V5cyA9IGFkZGVkS2V5cy5hZGQoZG9jQ2hhbmdlLmRvYy5rZXkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovOlxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkS2V5cyA9IHJlbW92ZWRLZXlzLmFkZChkb2NDaGFuZ2UuZG9jLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExvY2FsVmlld0NoYW5nZXModGFyZ2V0SWQsIHZpZXdTbmFwc2hvdC5mcm9tQ2FjaGUsIGFkZGVkS2V5cywgcmVtb3ZlZEtleXMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogSGVscGVyIHRvIGNvbnZlcnQgb2JqZWN0cyBmcm9tIGJ1bmRsZXMgdG8gbW9kZWwgb2JqZWN0cyBpbiB0aGUgU0RLLlxuICovXG5jbGFzcyBCdW5kbGVDb252ZXJ0ZXJJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyKSB7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgfVxuICAgIHRvRG9jdW1lbnRLZXkobmFtZSkge1xuICAgICAgICByZXR1cm4gZnJvbU5hbWUodGhpcy5zZXJpYWxpemVyLCBuYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBCdW5kbGVEb2N1bWVudCB0byBhIE11dGFibGVEb2N1bWVudC5cbiAgICAgKi9cbiAgICB0b011dGFibGVEb2N1bWVudChidW5kbGVkRG9jKSB7XG4gICAgICAgIGlmIChidW5kbGVkRG9jLm1ldGFkYXRhLmV4aXN0cykge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21Eb2N1bWVudCh0aGlzLnNlcmlhbGl6ZXIsIGJ1bmRsZWREb2MuZG9jdW1lbnQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudCh0aGlzLnRvRG9jdW1lbnRLZXkoYnVuZGxlZERvYy5tZXRhZGF0YS5uYW1lKSwgdGhpcy50b1NuYXBzaG90VmVyc2lvbihidW5kbGVkRG9jLm1ldGFkYXRhLnJlYWRUaW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TbmFwc2hvdFZlcnNpb24odGltZSkge1xuICAgICAgICByZXR1cm4gZnJvbVZlcnNpb24odGltZSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGNsYXNzIHRvIHByb2Nlc3MgdGhlIGVsZW1lbnRzIGZyb20gYSBidW5kbGUsIGFuZCBvcHRpb25hbGx5IGxvYWQgdGhlbSBpbnRvIGxvY2FsXG4gKiBzdG9yYWdlIGFuZCBwcm92aWRlIHByb2dyZXNzIHVwZGF0ZSB3aGlsZSBsb2FkaW5nLlxuICovXG5jbGFzcyBCdW5kbGVMb2FkZXIge1xuICAgIGNvbnN0cnVjdG9yKGJ1bmRsZU1ldGFkYXRhLCBzZXJpYWxpemVyKSB7XG4gICAgICAgIHRoaXMuYnVuZGxlTWV0YWRhdGEgPSBidW5kbGVNZXRhZGF0YTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICAgICAgLyoqIEJhdGNoZWQgcXVlcmllcyB0byBiZSBzYXZlZCBpbnRvIHN0b3JhZ2UgKi9cbiAgICAgICAgdGhpcy5fcXVlcmllcyA9IFtdO1xuICAgICAgICAvKiogQmF0Y2hlZCBkb2N1bWVudHMgdG8gYmUgc2F2ZWQgaW50byBzdG9yYWdlICovXG4gICAgICAgIHRoaXMuX2RvY3VtZW50cyA9IFtdO1xuICAgICAgICAvKiogVGhlIGNvbGxlY3Rpb24gZ3JvdXBzIGFmZmVjdGVkIGJ5IHRoaXMgYnVuZGxlLiAqL1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25Hcm91cHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBidW5kbGVJbml0aWFsUHJvZ3Jlc3MoYnVuZGxlTWV0YWRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lZCBxdWVyaWVzIHRoYXQgaGF2ZSBiZWVuIHBhcnNlZCBmcm9tIHRoZSBTaXplQnVuZGxlRWxlbWVudHMgYWRkZWQgYnlcbiAgICAgKiBjYWxsaW5nIHtAbGluayBhZFNpemVkRWxlbWVudH0uXG4gICAgICovXG4gICAgZ2V0IHF1ZXJpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWVyaWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBCdW5kbGVkRG9jdW1lbnRzIHRoYXQgaGF2ZSBiZWVuIHBhcnNlZCBmcm9tIHRoZSBTaXplQnVuZGxlRWxlbWVudHMgYWRkZWQgYnlcbiAgICAgKiBjYWxsaW5nIHtAbGluayBhZGRTaXplZEVsZW1lbnR9LlxuICAgICAqL1xuICAgIGdldCBkb2N1bWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb2N1bWVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZWxlbWVudCBmcm9tIHRoZSBidW5kbGUgdG8gdGhlIGxvYWRlci5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBuZXcgcHJvZ3Jlc3MgaWYgYWRkaW5nIHRoZSBlbGVtZW50IGxlYWRzIHRvIGEgbmV3IHByb2dyZXNzLFxuICAgICAqIG90aGVyd2lzZSByZXR1cm5zIG51bGwuXG4gICAgICovXG4gICAgYWRkU2l6ZWRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcy5ieXRlc0xvYWRlZCArPSBlbGVtZW50LmJ5dGVMZW5ndGg7XG4gICAgICAgIGxldCBkb2N1bWVudHNMb2FkZWQgPSB0aGlzLnByb2dyZXNzLmRvY3VtZW50c0xvYWRlZDtcbiAgICAgICAgaWYgKGVsZW1lbnQucGF5bG9hZC5uYW1lZFF1ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLl9xdWVyaWVzLnB1c2goZWxlbWVudC5wYXlsb2FkLm5hbWVkUXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnQucGF5bG9hZC5kb2N1bWVudE1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9kb2N1bWVudHMucHVzaCh7IG1ldGFkYXRhOiBlbGVtZW50LnBheWxvYWQuZG9jdW1lbnRNZXRhZGF0YSB9KTtcbiAgICAgICAgICAgIGlmICghZWxlbWVudC5wYXlsb2FkLmRvY3VtZW50TWV0YWRhdGEuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgKytkb2N1bWVudHNMb2FkZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcoZWxlbWVudC5wYXlsb2FkLmRvY3VtZW50TWV0YWRhdGEubmFtZSk7XG4gICAgICAgICAgICB0aGlzLmNvbGxlY3Rpb25Hcm91cHMuYWRkKHBhdGguZ2V0KHBhdGgubGVuZ3RoIC0gMikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnQucGF5bG9hZC5kb2N1bWVudCkge1xuICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnRzW3RoaXMuX2RvY3VtZW50cy5sZW5ndGggLSAxXS5kb2N1bWVudCA9XG4gICAgICAgICAgICAgICAgZWxlbWVudC5wYXlsb2FkLmRvY3VtZW50O1xuICAgICAgICAgICAgKytkb2N1bWVudHNMb2FkZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY3VtZW50c0xvYWRlZCAhPT0gdGhpcy5wcm9ncmVzcy5kb2N1bWVudHNMb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MuZG9jdW1lbnRzTG9hZGVkID0gZG9jdW1lbnRzTG9hZGVkO1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4udGhpcy5wcm9ncmVzcyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRRdWVyeURvY3VtZW50TWFwcGluZyhkb2N1bWVudHMpIHtcbiAgICAgICAgY29uc3QgcXVlcnlEb2N1bWVudE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgYnVuZGxlQ29udmVydGVyID0gbmV3IEJ1bmRsZUNvbnZlcnRlckltcGwodGhpcy5zZXJpYWxpemVyKTtcbiAgICAgICAgZm9yIChjb25zdCBidW5kbGVEb2Mgb2YgZG9jdW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoYnVuZGxlRG9jLm1ldGFkYXRhLnF1ZXJpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudEtleSA9IGJ1bmRsZUNvbnZlcnRlci50b0RvY3VtZW50S2V5KGJ1bmRsZURvYy5tZXRhZGF0YS5uYW1lKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHF1ZXJ5TmFtZSBvZiBidW5kbGVEb2MubWV0YWRhdGEucXVlcmllcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudEtleXMgPSAocXVlcnlEb2N1bWVudE1hcC5nZXQocXVlcnlOYW1lKSB8fCBkb2N1bWVudEtleVNldCgpKS5hZGQoZG9jdW1lbnRLZXkpO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeURvY3VtZW50TWFwLnNldChxdWVyeU5hbWUsIGRvY3VtZW50S2V5cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyeURvY3VtZW50TWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHByb2dyZXNzIHRvICdTdWNjZXNzJyBhbmQgcmV0dXJuIHRoZSB1cGRhdGVkIHByb2dyZXNzLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbXBsZXRlQW5kU3RvcmVBc3luYyhsb2NhbFN0b3JlKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZWREb2NzID0gYXdhaXQgbG9jYWxTdG9yZUFwcGx5QnVuZGxlZERvY3VtZW50cyhsb2NhbFN0b3JlLCBuZXcgQnVuZGxlQ29udmVydGVySW1wbCh0aGlzLnNlcmlhbGl6ZXIpLCB0aGlzLl9kb2N1bWVudHMsIHRoaXMuYnVuZGxlTWV0YWRhdGEuaWQpO1xuICAgICAgICBjb25zdCBxdWVyeURvY3VtZW50TWFwID0gdGhpcy5nZXRRdWVyeURvY3VtZW50TWFwcGluZyh0aGlzLmRvY3VtZW50cyk7XG4gICAgICAgIGZvciAoY29uc3QgcSBvZiB0aGlzLl9xdWVyaWVzKSB7XG4gICAgICAgICAgICBhd2FpdCBsb2NhbFN0b3JlU2F2ZU5hbWVkUXVlcnkobG9jYWxTdG9yZSwgcSwgcXVlcnlEb2N1bWVudE1hcC5nZXQocS5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9ncmVzcy50YXNrU3RhdGUgPSAnU3VjY2Vzcyc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9ncmVzczogdGhpcy5wcm9ncmVzcyxcbiAgICAgICAgICAgIGNoYW5nZWRDb2xsZWN0aW9uR3JvdXBzOiB0aGlzLmNvbGxlY3Rpb25Hcm91cHMsXG4gICAgICAgICAgICBjaGFuZ2VkRG9jc1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyBhIGBMb2FkQnVuZGxlVGFza1Byb2dyZXNzYCByZXByZXNlbnRpbmcgdGhlIGluaXRpYWwgcHJvZ3Jlc3Mgb2ZcbiAqIGxvYWRpbmcgYSBidW5kbGUuXG4gKi9cbmZ1bmN0aW9uIGJ1bmRsZUluaXRpYWxQcm9ncmVzcyhtZXRhZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhc2tTdGF0ZTogJ1J1bm5pbmcnLFxuICAgICAgICBkb2N1bWVudHNMb2FkZWQ6IDAsXG4gICAgICAgIGJ5dGVzTG9hZGVkOiAwLFxuICAgICAgICB0b3RhbERvY3VtZW50czogbWV0YWRhdGEudG90YWxEb2N1bWVudHMsXG4gICAgICAgIHRvdGFsQnl0ZXM6IG1ldGFkYXRhLnRvdGFsQnl0ZXNcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgYExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3NgIHJlcHJlc2VudGluZyB0aGUgcHJvZ3Jlc3MgdGhhdCB0aGUgbG9hZGluZ1xuICogaGFzIHN1Y2NlZWRlZC5cbiAqL1xuZnVuY3Rpb24gYnVuZGxlU3VjY2Vzc1Byb2dyZXNzKG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFza1N0YXRlOiAnU3VjY2VzcycsXG4gICAgICAgIGRvY3VtZW50c0xvYWRlZDogbWV0YWRhdGEudG90YWxEb2N1bWVudHMsXG4gICAgICAgIGJ5dGVzTG9hZGVkOiBtZXRhZGF0YS50b3RhbEJ5dGVzLFxuICAgICAgICB0b3RhbERvY3VtZW50czogbWV0YWRhdGEudG90YWxEb2N1bWVudHMsXG4gICAgICAgIHRvdGFsQnl0ZXM6IG1ldGFkYXRhLnRvdGFsQnl0ZXNcbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgQWRkZWRMaW1ib0RvY3VtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxufVxuY2xhc3MgUmVtb3ZlZExpbWJvRG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGtleSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG59XG4vKipcbiAqIFZpZXcgaXMgcmVzcG9uc2libGUgZm9yIGNvbXB1dGluZyB0aGUgZmluYWwgbWVyZ2VkIHRydXRoIG9mIHdoYXQgZG9jcyBhcmUgaW5cbiAqIGEgcXVlcnkuIEl0IGdldHMgbm90aWZpZWQgb2YgbG9jYWwgYW5kIHJlbW90ZSBjaGFuZ2VzIHRvIGRvY3MsIGFuZCBhcHBsaWVzXG4gKiB0aGUgcXVlcnkgZmlsdGVycyBhbmQgbGltaXRzIHRvIGRldGVybWluZSB0aGUgbW9zdCBjb3JyZWN0IHBvc3NpYmxlIHJlc3VsdHMuXG4gKi9cbmNsYXNzIFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBcbiAgICAvKiogRG9jdW1lbnRzIGluY2x1ZGVkIGluIHRoZSByZW1vdGUgdGFyZ2V0ICovXG4gICAgX3N5bmNlZERvY3VtZW50cykge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IF9zeW5jZWREb2N1bWVudHM7XG4gICAgICAgIHRoaXMuc3luY1N0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNDYWNoZWRSZXN1bHRzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgd2hldGhlciB0aGUgdmlldyBpcyBjdXJyZW50IHdpdGggdGhlIGJhY2tlbmQuIEEgdmlldyBpcyBjb25zaWRlcmVkXG4gICAgICAgICAqIGN1cnJlbnQgYWZ0ZXIgaXQgaGFzIHNlZW4gdGhlIGN1cnJlbnQgZmxhZyBmcm9tIHRoZSBiYWNrZW5kIGFuZCBkaWQgbm90XG4gICAgICAgICAqIGxvc2UgY29uc2lzdGVuY3kgd2l0aGluIHRoZSB3YXRjaCBzdHJlYW0gKGUuZy4gYmVjYXVzZSBvZiBhbiBleGlzdGVuY2VcbiAgICAgICAgICogZmlsdGVyIG1pc21hdGNoKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAvKiogRG9jdW1lbnRzIGluIHRoZSB2aWV3IGJ1dCBub3QgaW4gdGhlIHJlbW90ZSB0YXJnZXQgKi9cbiAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIC8qKiBEb2N1bWVudCBLZXlzIHRoYXQgaGF2ZSBsb2NhbCBjaGFuZ2VzICovXG4gICAgICAgIHRoaXMubXV0YXRlZEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICB0aGlzLmRvY0NvbXBhcmF0b3IgPSBuZXdRdWVyeUNvbXBhcmF0b3IocXVlcnkpO1xuICAgICAgICB0aGlzLmRvY3VtZW50U2V0ID0gbmV3IERvY3VtZW50U2V0KHRoaXMuZG9jQ29tcGFyYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzZXQgb2YgcmVtb3RlIGRvY3VtZW50cyB0aGF0IHRoZSBzZXJ2ZXIgaGFzIHRvbGQgdXMgYmVsb25ncyB0byB0aGUgdGFyZ2V0IGFzc29jaWF0ZWQgd2l0aFxuICAgICAqIHRoaXMgdmlldy5cbiAgICAgKi9cbiAgICBnZXQgc3luY2VkRG9jdW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3luY2VkRG9jdW1lbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGEgc2V0IG9mIGRvYyBjaGFuZ2VzLCBhcHBsaWVzIHRoZSBxdWVyeSBsaW1pdCwgYW5kIGNvbXB1dGVzXG4gICAgICogd2hhdCB0aGUgbmV3IHJlc3VsdHMgc2hvdWxkIGJlLCB3aGF0IHRoZSBjaGFuZ2VzIHdlcmUsIGFuZCB3aGV0aGVyIHdlIG1heVxuICAgICAqIG5lZWQgdG8gZ28gYmFjayB0byB0aGUgbG9jYWwgY2FjaGUgZm9yIG1vcmUgcmVzdWx0cy4gRG9lcyBub3QgbWFrZSBhbnlcbiAgICAgKiBjaGFuZ2VzIHRvIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSBkb2NDaGFuZ2VzIC0gVGhlIGRvYyBjaGFuZ2VzIHRvIGFwcGx5IHRvIHRoaXMgdmlldy5cbiAgICAgKiBAcGFyYW0gcHJldmlvdXNDaGFuZ2VzIC0gSWYgdGhpcyBpcyBiZWluZyBjYWxsZWQgd2l0aCBhIHJlZmlsbCwgdGhlbiBzdGFydFxuICAgICAqICAgICAgICB3aXRoIHRoaXMgc2V0IG9mIGRvY3MgYW5kIGNoYW5nZXMgaW5zdGVhZCBvZiB0aGUgY3VycmVudCB2aWV3LlxuICAgICAqIEByZXR1cm5zIGEgbmV3IHNldCBvZiBkb2NzLCBjaGFuZ2VzLCBhbmQgcmVmaWxsIGZsYWcuXG4gICAgICovXG4gICAgY29tcHV0ZURvY0NoYW5nZXMoZG9jQ2hhbmdlcywgcHJldmlvdXNDaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZVNldCA9IHByZXZpb3VzQ2hhbmdlc1xuICAgICAgICAgICAgPyBwcmV2aW91c0NoYW5nZXMuY2hhbmdlU2V0XG4gICAgICAgICAgICA6IG5ldyBEb2N1bWVudENoYW5nZVNldCgpO1xuICAgICAgICBjb25zdCBvbGREb2N1bWVudFNldCA9IHByZXZpb3VzQ2hhbmdlc1xuICAgICAgICAgICAgPyBwcmV2aW91c0NoYW5nZXMuZG9jdW1lbnRTZXRcbiAgICAgICAgICAgIDogdGhpcy5kb2N1bWVudFNldDtcbiAgICAgICAgbGV0IG5ld011dGF0ZWRLZXlzID0gcHJldmlvdXNDaGFuZ2VzXG4gICAgICAgICAgICA/IHByZXZpb3VzQ2hhbmdlcy5tdXRhdGVkS2V5c1xuICAgICAgICAgICAgOiB0aGlzLm11dGF0ZWRLZXlzO1xuICAgICAgICBsZXQgbmV3RG9jdW1lbnRTZXQgPSBvbGREb2N1bWVudFNldDtcbiAgICAgICAgbGV0IG5lZWRzUmVmaWxsID0gZmFsc2U7XG4gICAgICAgIC8vIFRyYWNrIHRoZSBsYXN0IGRvYyBpbiBhIChmdWxsKSBsaW1pdC4gVGhpcyBpcyBuZWNlc3NhcnksIGJlY2F1c2Ugc29tZVxuICAgICAgICAvLyB1cGRhdGUgKGEgZGVsZXRlLCBvciBhbiB1cGRhdGUgbW92aW5nIGEgZG9jIHBhc3QgdGhlIG9sZCBsaW1pdCkgbWlnaHRcbiAgICAgICAgLy8gbWVhbiB0aGVyZSBpcyBzb21lIG90aGVyIGRvY3VtZW50IGluIHRoZSBsb2NhbCBjYWNoZSB0aGF0IGVpdGhlciBzaG91bGRcbiAgICAgICAgLy8gY29tZSAoMSkgYmV0d2VlbiB0aGUgb2xkIGxhc3QgbGltaXQgZG9jIGFuZCB0aGUgbmV3IGxhc3QgZG9jdW1lbnQsIGluIHRoZVxuICAgICAgICAvLyBjYXNlIG9mIHVwZGF0ZXMsIG9yICgyKSBhZnRlciB0aGUgbmV3IGxhc3QgZG9jdW1lbnQsIGluIHRoZSBjYXNlIG9mXG4gICAgICAgIC8vIGRlbGV0ZXMuIFNvIHdlIGtlZXAgdGhpcyBkb2MgYXQgdGhlIG9sZCBsaW1pdCB0byBjb21wYXJlIHRoZSB1cGRhdGVzIHRvLlxuICAgICAgICAvL1xuICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBzaG91bGQgbmV2ZXIgZ2V0IHVzZWQgaW4gYSByZWZpbGwgKHdoZW4gcHJldmlvdXNDaGFuZ2VzIGlzXG4gICAgICAgIC8vIHNldCksIGJlY2F1c2UgdGhlcmUgd2lsbCBvbmx5IGJlIGFkZHMgLS0gbm8gZGVsZXRlcyBvciB1cGRhdGVzLlxuICAgICAgICBjb25zdCBsYXN0RG9jSW5MaW1pdCA9IHRoaXMucXVlcnkubGltaXRUeXBlID09PSBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8gJiZcbiAgICAgICAgICAgIG9sZERvY3VtZW50U2V0LnNpemUgPT09IHRoaXMucXVlcnkubGltaXRcbiAgICAgICAgICAgID8gb2xkRG9jdW1lbnRTZXQubGFzdCgpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGNvbnN0IGZpcnN0RG9jSW5MaW1pdCA9IHRoaXMucXVlcnkubGltaXRUeXBlID09PSBcIkxcIiAvKiBMaW1pdFR5cGUuTGFzdCAqLyAmJlxuICAgICAgICAgICAgb2xkRG9jdW1lbnRTZXQuc2l6ZSA9PT0gdGhpcy5xdWVyeS5saW1pdFxuICAgICAgICAgICAgPyBvbGREb2N1bWVudFNldC5maXJzdCgpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGRvY0NoYW5nZXMuaW5vcmRlclRyYXZlcnNhbCgoa2V5LCBlbnRyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2xkRG9jID0gb2xkRG9jdW1lbnRTZXQuZ2V0KGtleSk7XG4gICAgICAgICAgICBjb25zdCBuZXdEb2MgPSBxdWVyeU1hdGNoZXModGhpcy5xdWVyeSwgZW50cnkpID8gZW50cnkgOiBudWxsO1xuICAgICAgICAgICAgY29uc3Qgb2xkRG9jSGFkUGVuZGluZ011dGF0aW9ucyA9IG9sZERvY1xuICAgICAgICAgICAgICAgID8gdGhpcy5tdXRhdGVkS2V5cy5oYXMob2xkRG9jLmtleSlcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgbmV3RG9jSGFzUGVuZGluZ011dGF0aW9ucyA9IG5ld0RvY1xuICAgICAgICAgICAgICAgID8gbmV3RG9jLmhhc0xvY2FsTXV0YXRpb25zIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgY29uc2lkZXIgY29tbWl0dGVkIG11dGF0aW9ucyBmb3IgZG9jdW1lbnRzIHRoYXQgd2VyZVxuICAgICAgICAgICAgICAgICAgICAvLyBtdXRhdGVkIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgdGhlIHZpZXcuXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLm11dGF0ZWRLZXlzLmhhcyhuZXdEb2Mua2V5KSAmJiBuZXdEb2MuaGFzQ29tbWl0dGVkTXV0YXRpb25zKVxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICBsZXQgY2hhbmdlQXBwbGllZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNoYW5nZVxuICAgICAgICAgICAgaWYgKG9sZERvYyAmJiBuZXdEb2MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2NzRXF1YWwgPSBvbGREb2MuZGF0YS5pc0VxdWFsKG5ld0RvYy5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvY3NFcXVhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkV2FpdEZvclN5bmNlZERvY3VtZW50KG9sZERvYywgbmV3RG9jKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlU2V0LnRyYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jOiBuZXdEb2NcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlQXBwbGllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGxhc3REb2NJbkxpbWl0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NDb21wYXJhdG9yKG5ld0RvYywgbGFzdERvY0luTGltaXQpID4gMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmlyc3REb2NJbkxpbWl0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jQ29tcGFyYXRvcihuZXdEb2MsIGZpcnN0RG9jSW5MaW1pdCkgPCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZG9jIG1vdmVkIGZyb20gaW5zaWRlIHRoZSBsaW1pdCB0byBvdXRzaWRlIHRoZSBsaW1pdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGF0IG1lYW5zIHRoZXJlIG1heSBiZSBzb21lIG90aGVyIGRvYyBpbiB0aGUgbG9jYWwgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHNob3VsZCBiZSBpbmNsdWRlZCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzUmVmaWxsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGREb2NIYWRQZW5kaW5nTXV0YXRpb25zICE9PSBuZXdEb2NIYXNQZW5kaW5nTXV0YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVNldC50cmFjayh7IHR5cGU6IDMgLyogQ2hhbmdlVHlwZS5NZXRhZGF0YSAqLywgZG9jOiBuZXdEb2MgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUFwcGxpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFvbGREb2MgJiYgbmV3RG9jKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlU2V0LnRyYWNrKHsgdHlwZTogMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovLCBkb2M6IG5ld0RvYyB9KTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VBcHBsaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9sZERvYyAmJiAhbmV3RG9jKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlU2V0LnRyYWNrKHsgdHlwZTogMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8sIGRvYzogb2xkRG9jIH0pO1xuICAgICAgICAgICAgICAgIGNoYW5nZUFwcGxpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0RG9jSW5MaW1pdCB8fCBmaXJzdERvY0luTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBkb2Mgd2FzIHJlbW92ZWQgZnJvbSBhIGZ1bGwgbGltaXQgcXVlcnkuIFdlJ2xsIG5lZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWVyeSBmcm9tIHRoZSBsb2NhbCBjYWNoZSB0byBzZWUgaWYgd2Uga25vdyBhYm91dCBzb21lIG90aGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvYyB0aGF0IHNob3VsZCBiZSBpbiB0aGUgcmVzdWx0cy5cbiAgICAgICAgICAgICAgICAgICAgbmVlZHNSZWZpbGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VBcHBsaWVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0RvYykge1xuICAgICAgICAgICAgICAgICAgICBuZXdEb2N1bWVudFNldCA9IG5ld0RvY3VtZW50U2V0LmFkZChuZXdEb2MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3RG9jSGFzUGVuZGluZ011dGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TXV0YXRlZEtleXMgPSBuZXdNdXRhdGVkS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld011dGF0ZWRLZXlzID0gbmV3TXV0YXRlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RvY3VtZW50U2V0ID0gbmV3RG9jdW1lbnRTZXQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld011dGF0ZWRLZXlzID0gbmV3TXV0YXRlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRHJvcCBkb2N1bWVudHMgb3V0IHRvIG1lZXQgbGltaXQvbGltaXRUb0xhc3QgcmVxdWlyZW1lbnQuXG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5LmxpbWl0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB3aGlsZSAobmV3RG9jdW1lbnRTZXQuc2l6ZSA+IHRoaXMucXVlcnkubGltaXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGREb2MgPSB0aGlzLnF1ZXJ5LmxpbWl0VHlwZSA9PT0gXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovXG4gICAgICAgICAgICAgICAgICAgID8gbmV3RG9jdW1lbnRTZXQubGFzdCgpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3RG9jdW1lbnRTZXQuZmlyc3QoKTtcbiAgICAgICAgICAgICAgICBuZXdEb2N1bWVudFNldCA9IG5ld0RvY3VtZW50U2V0LmRlbGV0ZShvbGREb2Mua2V5KTtcbiAgICAgICAgICAgICAgICBuZXdNdXRhdGVkS2V5cyA9IG5ld011dGF0ZWRLZXlzLmRlbGV0ZShvbGREb2Mua2V5KTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VTZXQudHJhY2soeyB0eXBlOiAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLywgZG9jOiBvbGREb2MgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvY3VtZW50U2V0OiBuZXdEb2N1bWVudFNldCxcbiAgICAgICAgICAgIGNoYW5nZVNldCxcbiAgICAgICAgICAgIG5lZWRzUmVmaWxsLFxuICAgICAgICAgICAgbXV0YXRlZEtleXM6IG5ld011dGF0ZWRLZXlzXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNob3VsZFdhaXRGb3JTeW5jZWREb2N1bWVudChvbGREb2MsIG5ld0RvYykge1xuICAgICAgICAvLyBXZSBzdXBwcmVzcyB0aGUgaW5pdGlhbCBjaGFuZ2UgZXZlbnQgZm9yIGRvY3VtZW50cyB0aGF0IHdlcmUgbW9kaWZpZWQgYXNcbiAgICAgICAgLy8gcGFydCBvZiBhIHdyaXRlIGFja25vd2xlZGdtZW50IChlLmcuIHdoZW4gdGhlIHZhbHVlIG9mIGEgc2VydmVyIHRyYW5zZm9ybVxuICAgICAgICAvLyBpcyBhcHBsaWVkKSBhcyBXYXRjaCB3aWxsIHNlbmQgdXMgdGhlIHNhbWUgZG9jdW1lbnQgYWdhaW4uXG4gICAgICAgIC8vIEJ5IHN1cHByZXNzaW5nIHRoZSBldmVudCwgd2Ugb25seSByYWlzZSB0d28gdXNlciB2aXNpYmxlIGV2ZW50cyAob25lIHdpdGhcbiAgICAgICAgLy8gYGhhc1BlbmRpbmdXcml0ZXNgIGFuZCB0aGUgZmluYWwgc3RhdGUgb2YgdGhlIGRvY3VtZW50KSBpbnN0ZWFkIG9mIHRocmVlXG4gICAgICAgIC8vIChvbmUgd2l0aCBgaGFzUGVuZGluZ1dyaXRlc2AsIHRoZSBtb2RpZmllZCBkb2N1bWVudCB3aXRoXG4gICAgICAgIC8vIGBoYXNQZW5kaW5nV3JpdGVzYCBhbmQgdGhlIGZpbmFsIHN0YXRlIG9mIHRoZSBkb2N1bWVudCkuXG4gICAgICAgIHJldHVybiAob2xkRG9jLmhhc0xvY2FsTXV0YXRpb25zICYmXG4gICAgICAgICAgICBuZXdEb2MuaGFzQ29tbWl0dGVkTXV0YXRpb25zICYmXG4gICAgICAgICAgICAhbmV3RG9jLmhhc0xvY2FsTXV0YXRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdmlldyB3aXRoIHRoZSBnaXZlbiBWaWV3RG9jdW1lbnRDaGFuZ2VzIGFuZCBvcHRpb25hbGx5IHVwZGF0ZXNcbiAgICAgKiBsaW1ibyBkb2NzIGFuZCBzeW5jIHN0YXRlIGZyb20gdGhlIHByb3ZpZGVkIHRhcmdldCBjaGFuZ2UuXG4gICAgICogQHBhcmFtIGRvY0NoYW5nZXMgLSBUaGUgc2V0IG9mIGNoYW5nZXMgdG8gbWFrZSB0byB0aGUgdmlldydzIGRvY3MuXG4gICAgICogQHBhcmFtIGxpbWJvUmVzb2x1dGlvbkVuYWJsZWQgLSBXaGV0aGVyIHRvIHVwZGF0ZSBsaW1ibyBkb2N1bWVudHMgYmFzZWQgb25cbiAgICAgKiAgICAgICAgdGhpcyBjaGFuZ2UuXG4gICAgICogQHBhcmFtIHRhcmdldENoYW5nZSAtIEEgdGFyZ2V0IGNoYW5nZSB0byBhcHBseSBmb3IgY29tcHV0aW5nIGxpbWJvIGRvY3MgYW5kXG4gICAgICogICAgICAgIHN5bmMgc3RhdGUuXG4gICAgICogQHBhcmFtIHRhcmdldElzUGVuZGluZ1Jlc2V0IC0gV2hldGhlciB0aGUgdGFyZ2V0IGlzIHBlbmRpbmcgdG8gcmVzZXQgZHVlIHRvXG4gICAgICogICAgICAgIGV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2guIElmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCwgaXQgaXMgdHJlYXRlZFxuICAgICAqICAgICAgICBlcXVpdmFsZW50bHkgdG8gYGZhbHNlYC5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBWaWV3Q2hhbmdlIHdpdGggdGhlIGdpdmVuIGRvY3MsIGNoYW5nZXMsIGFuZCBzeW5jIHN0YXRlLlxuICAgICAqL1xuICAgIC8vIFBPUlRJTkcgTk9URTogVGhlIGlPUy9BbmRyb2lkIGNsaWVudHMgYWx3YXlzIGNvbXB1dGUgbGltYm8gZG9jdW1lbnQgY2hhbmdlcy5cbiAgICBhcHBseUNoYW5nZXMoZG9jQ2hhbmdlcywgbGltYm9SZXNvbHV0aW9uRW5hYmxlZCwgdGFyZ2V0Q2hhbmdlLCB0YXJnZXRJc1BlbmRpbmdSZXNldCkge1xuICAgICAgICBjb25zdCBvbGREb2NzID0gdGhpcy5kb2N1bWVudFNldDtcbiAgICAgICAgdGhpcy5kb2N1bWVudFNldCA9IGRvY0NoYW5nZXMuZG9jdW1lbnRTZXQ7XG4gICAgICAgIHRoaXMubXV0YXRlZEtleXMgPSBkb2NDaGFuZ2VzLm11dGF0ZWRLZXlzO1xuICAgICAgICAvLyBTb3J0IGNoYW5nZXMgYmFzZWQgb24gdHlwZSBhbmQgcXVlcnkgY29tcGFyYXRvclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gZG9jQ2hhbmdlcy5jaGFuZ2VTZXQuZ2V0Q2hhbmdlcygpO1xuICAgICAgICBjaGFuZ2VzLnNvcnQoKGMxLCBjMikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChjb21wYXJlQ2hhbmdlVHlwZShjMS50eXBlLCBjMi50eXBlKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZG9jQ29tcGFyYXRvcihjMS5kb2MsIGMyLmRvYykpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcHBseVRhcmdldENoYW5nZSh0YXJnZXRDaGFuZ2UpO1xuICAgICAgICB0YXJnZXRJc1BlbmRpbmdSZXNldCA9IHRhcmdldElzUGVuZGluZ1Jlc2V0ID8/IGZhbHNlO1xuICAgICAgICBjb25zdCBsaW1ib0NoYW5nZXMgPSBsaW1ib1Jlc29sdXRpb25FbmFibGVkICYmICF0YXJnZXRJc1BlbmRpbmdSZXNldFxuICAgICAgICAgICAgPyB0aGlzLnVwZGF0ZUxpbWJvRG9jdW1lbnRzKClcbiAgICAgICAgICAgIDogW107XG4gICAgICAgIC8vIFdlIGFyZSBhdCBzeW5jZWQgc3RhdGUgaWYgdGhlcmUgaXMgbm8gbGltYm8gZG9jcyBhcmUgd2FpdGluZyB0byBiZSByZXNvbHZlZCwgdmlldyBpcyBjdXJyZW50XG4gICAgICAgIC8vIHdpdGggdGhlIGJhY2tlbmQsIGFuZCB0aGUgcXVlcnkgaXMgbm90IHBlbmRpbmcgdG8gcmVzZXQgZHVlIHRvIGV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2guXG4gICAgICAgIGNvbnN0IHN5bmNlZCA9IHRoaXMubGltYm9Eb2N1bWVudHMuc2l6ZSA9PT0gMCAmJiB0aGlzLmN1cnJlbnQgJiYgIXRhcmdldElzUGVuZGluZ1Jlc2V0O1xuICAgICAgICBjb25zdCBuZXdTeW5jU3RhdGUgPSBzeW5jZWQgPyAxIC8qIFN5bmNTdGF0ZS5TeW5jZWQgKi8gOiAwIC8qIFN5bmNTdGF0ZS5Mb2NhbCAqLztcbiAgICAgICAgY29uc3Qgc3luY1N0YXRlQ2hhbmdlZCA9IG5ld1N5bmNTdGF0ZSAhPT0gdGhpcy5zeW5jU3RhdGU7XG4gICAgICAgIHRoaXMuc3luY1N0YXRlID0gbmV3U3luY1N0YXRlO1xuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPT09IDAgJiYgIXN5bmNTdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIG5vIGNoYW5nZXNcbiAgICAgICAgICAgIHJldHVybiB7IGxpbWJvQ2hhbmdlcyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc25hcCA9IG5ldyBWaWV3U25hcHNob3QodGhpcy5xdWVyeSwgZG9jQ2hhbmdlcy5kb2N1bWVudFNldCwgb2xkRG9jcywgY2hhbmdlcywgZG9jQ2hhbmdlcy5tdXRhdGVkS2V5cywgbmV3U3luY1N0YXRlID09PSAwIC8qIFN5bmNTdGF0ZS5Mb2NhbCAqLywgc3luY1N0YXRlQ2hhbmdlZCwgXG4gICAgICAgICAgICAvKiBleGNsdWRlc01ldGFkYXRhQ2hhbmdlcz0gKi8gZmFsc2UsIHRhcmdldENoYW5nZVxuICAgICAgICAgICAgICAgID8gdGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuLmFwcHJveGltYXRlQnl0ZVNpemUoKSA+IDBcbiAgICAgICAgICAgICAgICA6IGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc25hcHNob3Q6IHNuYXAsXG4gICAgICAgICAgICAgICAgbGltYm9DaGFuZ2VzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYW4gT25saW5lU3RhdGUgY2hhbmdlIHRvIHRoZSB2aWV3LCBwb3RlbnRpYWxseSBnZW5lcmF0aW5nIGFcbiAgICAgKiBWaWV3Q2hhbmdlIGlmIHRoZSB2aWV3J3Mgc3luY1N0YXRlIGNoYW5nZXMgYXMgYSByZXN1bHQuXG4gICAgICovXG4gICAgYXBwbHlPbmxpbmVTdGF0ZUNoYW5nZShvbmxpbmVTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50ICYmIG9ubGluZVN0YXRlID09PSBcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBvZmZsaW5lLCBzZXQgYGN1cnJlbnRgIHRvIGZhbHNlIGFuZCB0aGVuIGNhbGwgYXBwbHlDaGFuZ2VzKClcbiAgICAgICAgICAgIC8vIHRvIHJlZnJlc2ggb3VyIHN5bmNTdGF0ZSBhbmQgZ2VuZXJhdGUgYSBWaWV3Q2hhbmdlIGFzIGFwcHJvcHJpYXRlLiBXZVxuICAgICAgICAgICAgLy8gYXJlIGd1YXJhbnRlZWQgdG8gZ2V0IGEgbmV3IFRhcmdldENoYW5nZSB0aGF0IHNldHMgYGN1cnJlbnRgIGJhY2sgdG9cbiAgICAgICAgICAgIC8vIHRydWUgb25jZSB0aGUgY2xpZW50IGlzIGJhY2sgb25saW5lLlxuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseUNoYW5nZXMoe1xuICAgICAgICAgICAgICAgIGRvY3VtZW50U2V0OiB0aGlzLmRvY3VtZW50U2V0LFxuICAgICAgICAgICAgICAgIGNoYW5nZVNldDogbmV3IERvY3VtZW50Q2hhbmdlU2V0KCksXG4gICAgICAgICAgICAgICAgbXV0YXRlZEtleXM6IHRoaXMubXV0YXRlZEtleXMsXG4gICAgICAgICAgICAgICAgbmVlZHNSZWZpbGw6IGZhbHNlXG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qIGxpbWJvUmVzb2x1dGlvbkVuYWJsZWQ9ICovIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIGVmZmVjdCwganVzdCByZXR1cm4gYSBuby1vcCBWaWV3Q2hhbmdlLlxuICAgICAgICAgICAgcmV0dXJuIHsgbGltYm9DaGFuZ2VzOiBbXSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZG9jIGZvciB0aGUgZ2l2ZW4ga2V5IHNob3VsZCBiZSBpbiBsaW1iby5cbiAgICAgKi9cbiAgICBzaG91bGRCZUluTGltYm8oa2V5KSB7XG4gICAgICAgIC8vIElmIHRoZSByZW1vdGUgZW5kIHNheXMgaXQncyBwYXJ0IG9mIHRoaXMgcXVlcnksIGl0J3Mgbm90IGluIGxpbWJvLlxuICAgICAgICBpZiAodGhpcy5fc3luY2VkRG9jdW1lbnRzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGxvY2FsIHN0b3JlIGRvZXNuJ3QgdGhpbmsgaXQncyBhIHJlc3VsdCwgc28gaXQgc2hvdWxkbid0IGJlIGluIGxpbWJvLlxuICAgICAgICBpZiAoIXRoaXMuZG9jdW1lbnRTZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbG9jYWwgY2hhbmdlcyB0byB0aGUgZG9jLCB0aGV5IG1pZ2h0IGV4cGxhaW4gd2h5IHRoZSBzZXJ2ZXJcbiAgICAgICAgLy8gZG9lc24ndCBrbm93IHRoYXQgaXQncyBwYXJ0IG9mIHRoZSBxdWVyeS4gU28gZG9uJ3QgcHV0IGl0IGluIGxpbWJvLlxuICAgICAgICAvLyBUT0RPKGtsaW10KTogSWRlYWxseSwgd2Ugd291bGQgb25seSBjb25zaWRlciBjaGFuZ2VzIHRoYXQgbWlnaHQgYWN0dWFsbHlcbiAgICAgICAgLy8gYWZmZWN0IHRoaXMgc3BlY2lmaWMgcXVlcnkuXG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50U2V0LmdldChrZXkpLmhhc0xvY2FsTXV0YXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXZlcnl0aGluZyBlbHNlIGlzIGluIGxpbWJvLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBzeW5jZWREb2N1bWVudHMsIGN1cnJlbnQsIGFuZCBsaW1ibyBkb2NzIGJhc2VkIG9uIHRoZSBnaXZlbiBjaGFuZ2UuXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBjaGFuZ2VzIHRvIHdoaWNoIGRvY3MgYXJlIGluIGxpbWJvLlxuICAgICAqL1xuICAgIGFwcGx5VGFyZ2V0Q2hhbmdlKHRhcmdldENoYW5nZSkge1xuICAgICAgICBpZiAodGFyZ2V0Q2hhbmdlKSB7XG4gICAgICAgICAgICB0YXJnZXRDaGFuZ2UuYWRkZWREb2N1bWVudHMuZm9yRWFjaChrZXkgPT4gKHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IHRoaXMuX3N5bmNlZERvY3VtZW50cy5hZGQoa2V5KSkpO1xuICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLm1vZGlmaWVkRG9jdW1lbnRzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLnJlbW92ZWREb2N1bWVudHMuZm9yRWFjaChrZXkgPT4gKHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IHRoaXMuX3N5bmNlZERvY3VtZW50cy5kZWxldGUoa2V5KSkpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gdGFyZ2V0Q2hhbmdlLmN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlTGltYm9Eb2N1bWVudHMoKSB7XG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IGRldGVybWluZSBsaW1ibyBkb2N1bWVudHMgd2hlbiB3ZSdyZSBpbi1zeW5jIHdpdGggdGhlIHNlcnZlci5cbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPKGtsaW10KTogRG8gdGhpcyBpbmNyZW1lbnRhbGx5IHNvIHRoYXQgaXQncyBub3QgcXVhZHJhdGljIHdoZW5cbiAgICAgICAgLy8gdXBkYXRpbmcgbWFueSBkb2N1bWVudHMuXG4gICAgICAgIGNvbnN0IG9sZExpbWJvRG9jdW1lbnRzID0gdGhpcy5saW1ib0RvY3VtZW50cztcbiAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRTZXQuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkQmVJbkxpbWJvKGRvYy5rZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cyA9IHRoaXMubGltYm9Eb2N1bWVudHMuYWRkKGRvYy5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRGlmZiB0aGUgbmV3IGxpbWJvIGRvY3Mgd2l0aCB0aGUgb2xkIGxpbWJvIGRvY3MuXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgb2xkTGltYm9Eb2N1bWVudHMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxpbWJvRG9jdW1lbnRzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKG5ldyBSZW1vdmVkTGltYm9Eb2N1bWVudChrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGltYm9Eb2N1bWVudHMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKCFvbGRMaW1ib0RvY3VtZW50cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChuZXcgQWRkZWRMaW1ib0RvY3VtZW50KGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgaW4tbWVtb3J5IHN0YXRlIG9mIHRoZSBjdXJyZW50IHZpZXcgd2l0aCB0aGUgc3RhdGUgcmVhZCBmcm9tXG4gICAgICogcGVyc2lzdGVuY2UuXG4gICAgICpcbiAgICAgKiBXZSB1cGRhdGUgdGhlIHF1ZXJ5IHZpZXcgd2hlbmV2ZXIgYSBjbGllbnQncyBwcmltYXJ5IHN0YXR1cyBjaGFuZ2VzOlxuICAgICAqIC0gV2hlbiBhIGNsaWVudCB0cmFuc2l0aW9ucyBmcm9tIHByaW1hcnkgdG8gc2Vjb25kYXJ5LCBpdCBjYW4gbWlzc1xuICAgICAqICAgTG9jYWxTdG9yYWdlIHVwZGF0ZXMgYW5kIGl0cyBxdWVyeSB2aWV3cyBtYXkgdGVtcG9yYXJpbHkgbm90IGJlXG4gICAgICogICBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgc3RhdGUgb24gZGlzay5cbiAgICAgKiAtIEZvciBzZWNvbmRhcnkgdG8gcHJpbWFyeSB0cmFuc2l0aW9ucywgdGhlIGNsaWVudCBuZWVkcyB0byB1cGRhdGUgdGhlIGxpc3RcbiAgICAgKiAgIG9mIGBzeW5jZWREb2N1bWVudHNgIHNpbmNlIHNlY29uZGFyeSBjbGllbnRzIHVwZGF0ZSB0aGVpciBxdWVyeSB2aWV3c1xuICAgICAqICAgYmFzZWQgcHVyZWx5IG9uIHN5bnRoZXNpemVkIFJlbW90ZUV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWVyeVJlc3VsdC5kb2N1bWVudHMgLSBUaGUgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggdGhlIHF1ZXJ5IGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBMb2NhbFN0b3JlLlxuICAgICAqIEBwYXJhbSBxdWVyeVJlc3VsdC5yZW1vdGVLZXlzIC0gVGhlIGtleXMgb2YgdGhlIGRvY3VtZW50cyB0aGF0IG1hdGNoIHRoZVxuICAgICAqIHF1ZXJ5IGFjY29yZGluZyB0byB0aGUgYmFja2VuZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBWaWV3Q2hhbmdlIHRoYXQgcmVzdWx0ZWQgZnJvbSB0aGlzIHN5bmNocm9uaXphdGlvbi5cbiAgICAgKi9cbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxuICAgIHN5bmNocm9uaXplV2l0aFBlcnNpc3RlZFN0YXRlKHF1ZXJ5UmVzdWx0KSB7XG4gICAgICAgIHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IHF1ZXJ5UmVzdWx0LnJlbW90ZUtleXM7XG4gICAgICAgIHRoaXMubGltYm9Eb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gdGhpcy5jb21wdXRlRG9jQ2hhbmdlcyhxdWVyeVJlc3VsdC5kb2N1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseUNoYW5nZXMoZG9jQ2hhbmdlcywgLyogbGltYm9SZXNvbHV0aW9uRW5hYmxlZD0gKi8gdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB2aWV3IHNuYXBzaG90IGFzIGlmIHRoaXMgcXVlcnkgd2FzIGp1c3QgbGlzdGVuZWQgdG8uIENvbnRhaW5zXG4gICAgICogYSBkb2N1bWVudCBhZGQgZm9yIGV2ZXJ5IGV4aXN0aW5nIGRvY3VtZW50IGFuZCB0aGUgYGZyb21DYWNoZWAgYW5kXG4gICAgICogYGhhc1BlbmRpbmdXcml0ZXNgIHN0YXR1cyBvZiB0aGUgYWxyZWFkeSBlc3RhYmxpc2hlZCB2aWV3LlxuICAgICAqL1xuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkuXG4gICAgY29tcHV0ZUluaXRpYWxTbmFwc2hvdCgpIHtcbiAgICAgICAgcmV0dXJuIFZpZXdTbmFwc2hvdC5mcm9tSW5pdGlhbERvY3VtZW50cyh0aGlzLnF1ZXJ5LCB0aGlzLmRvY3VtZW50U2V0LCB0aGlzLm11dGF0ZWRLZXlzLCB0aGlzLnN5bmNTdGF0ZSA9PT0gMCAvKiBTeW5jU3RhdGUuTG9jYWwgKi8sIHRoaXMuaGFzQ2FjaGVkUmVzdWx0cyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZUNoYW5nZVR5cGUoYzEsIGMyKSB7XG4gICAgY29uc3Qgb3JkZXIgPSAoY2hhbmdlKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoY2hhbmdlKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgY2FzZSAzIC8qIENoYW5nZVR5cGUuTWV0YWRhdGEgKi86XG4gICAgICAgICAgICAgICAgLy8gQSBtZXRhZGF0YSBjaGFuZ2UgaXMgY29udmVydGVkIHRvIGEgbW9kaWZpZWQgY2hhbmdlIGF0IHRoZSBwdWJsaWNcbiAgICAgICAgICAgICAgICAvLyBhcGkgbGF5ZXIuICBTaW5jZSB3ZSBzb3J0IGJ5IGRvY3VtZW50IGtleSBhbmQgdGhlbiBjaGFuZ2UgdHlwZSxcbiAgICAgICAgICAgICAgICAvLyBtZXRhZGF0YSBhbmQgbW9kaWZpZWQgY2hhbmdlcyBtdXN0IGJlIHNvcnRlZCBlcXVpdmFsZW50bHkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICBjYXNlIDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgweDRmMzUsIHsgY2hhbmdlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gb3JkZXIoYzEpIC0gb3JkZXIoYzIpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyQzID0gJ1N5bmNFbmdpbmUnO1xuLyoqXG4gKiBRdWVyeVZpZXcgY29udGFpbnMgYWxsIG9mIHRoZSBkYXRhIHRoYXQgU3luY0VuZ2luZSBuZWVkcyB0byBrZWVwIHRyYWNrIG9mIGZvclxuICogYSBwYXJ0aWN1bGFyIHF1ZXJ5LlxuICovXG5jbGFzcyBRdWVyeVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBxdWVyeSBpdHNlbGYuXG4gICAgICovXG4gICAgcXVlcnksIFxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgbnVtYmVyIGNyZWF0ZWQgYnkgdGhlIGNsaWVudCB0aGF0IGlzIHVzZWQgaW4gdGhlIHdhdGNoXG4gICAgICogc3RyZWFtIHRvIGlkZW50aWZ5IHRoaXMgcXVlcnkuXG4gICAgICovXG4gICAgdGFyZ2V0SWQsIFxuICAgIC8qKlxuICAgICAqIFRoZSB2aWV3IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRpbmcgdGhlIGZpbmFsIG1lcmdlZCB0cnV0aCBvZiB3aGF0XG4gICAgICogZG9jcyBhcmUgaW4gdGhlIHF1ZXJ5LiBJdCBnZXRzIG5vdGlmaWVkIG9mIGxvY2FsIGFuZCByZW1vdGUgY2hhbmdlcyxcbiAgICAgKiBhbmQgYXBwbGllcyB0aGUgcXVlcnkgZmlsdGVycyBhbmQgbGltaXRzIHRvIGRldGVybWluZSB0aGUgbW9zdCBjb3JyZWN0XG4gICAgICogcG9zc2libGUgcmVzdWx0cy5cbiAgICAgKi9cbiAgICB2aWV3KSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy50YXJnZXRJZCA9IHRhcmdldElkO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIH1cbn1cbi8qKiBUcmFja3MgYSBsaW1ibyByZXNvbHV0aW9uLiAqL1xuY2xhc3MgTGltYm9SZXNvbHV0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gdHJ1ZSBvbmNlIHdlJ3ZlIHJlY2VpdmVkIGEgZG9jdW1lbnQuIFRoaXMgaXMgdXNlZCBpblxuICAgICAgICAgKiBnZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KCkgYW5kIHVsdGltYXRlbHkgdXNlZCBieSBXYXRjaENoYW5nZUFnZ3JlZ2F0b3IgdG9cbiAgICAgICAgICogZGVjaWRlIHdoZXRoZXIgaXQgbmVlZHMgdG8gbWFudWZhY3R1cmUgYSBkZWxldGUgZXZlbnQgZm9yIHRoZSB0YXJnZXQgb25jZVxuICAgICAgICAgKiB0aGUgdGFyZ2V0IGlzIENVUlJFTlQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlY2VpdmVkRG9jdW1lbnQgPSBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGBTeW5jRW5naW5lYCBjb29yZGluYXRpbmcgd2l0aCBvdGhlciBwYXJ0cyBvZiBTREsuXG4gKlxuICogVGhlIHBhcnRzIG9mIFN5bmNFbmdpbmUgdGhhdCBhY3QgYXMgYSBjYWxsYmFjayB0byBSZW1vdGVTdG9yZSBuZWVkIHRvIGJlXG4gKiByZWdpc3RlcmVkIGluZGl2aWR1YWxseS4gVGhpcyBpcyBkb25lIGluIGBzeW5jRW5naW5lV3JpdGUoKWAgYW5kXG4gKiBgc3luY0VuZ2luZUxpc3RlbigpYCAoYXMgd2VsbCBhcyBgYXBwbHlQcmltYXJ5U3RhdGUoKWApIGFzIHRoZXNlIG1ldGhvZHNcbiAqIHNlcnZlIGFzIGVudHJ5IHBvaW50cyB0byBSZW1vdGVTdG9yZSdzIGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogTm90ZTogc29tZSBmaWVsZCBkZWZpbmVkIGluIHRoaXMgY2xhc3MgbWlnaHQgaGF2ZSBwdWJsaWMgYWNjZXNzIGxldmVsLCBidXRcbiAqIHRoZSBjbGFzcyBpcyBub3QgZXhwb3J0ZWQgc28gdGhleSBhcmUgb25seSBhY2Nlc3NpYmxlIGZyb20gdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIHVzZWZ1bCB0byBpbXBsZW1lbnQgb3B0aW9uYWwgZmVhdHVyZXMgKGxpa2UgYnVuZGxlcykgaW4gZnJlZVxuICogZnVuY3Rpb25zLCBzdWNoIHRoYXQgdGhleSBhcmUgdHJlZS1zaGFrZWFibGUuXG4gKi9cbmNsYXNzIFN5bmNFbmdpbmVJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbFN0b3JlLCByZW1vdGVTdG9yZSwgZXZlbnRNYW5hZ2VyLCBcbiAgICAvLyBQT1JUSU5HIE5PVEU6IE1hbmFnZXMgc3RhdGUgc3luY2hyb25pemF0aW9uIGluIG11bHRpLXRhYiBlbnZpcm9ubWVudHMuXG4gICAgc2hhcmVkQ2xpZW50U3RhdGUsIGN1cnJlbnRVc2VyLCBtYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9ucykge1xuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xuICAgICAgICB0aGlzLnJlbW90ZVN0b3JlID0gcmVtb3RlU3RvcmU7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICB0aGlzLnNoYXJlZENsaWVudFN0YXRlID0gc2hhcmVkQ2xpZW50U3RhdGU7XG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSBjdXJyZW50VXNlcjtcbiAgICAgICAgdGhpcy5tYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9ucyA9IG1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zO1xuICAgICAgICB0aGlzLnN5bmNFbmdpbmVMaXN0ZW5lciA9IHt9O1xuICAgICAgICB0aGlzLnF1ZXJ5Vmlld3NCeVF1ZXJ5ID0gbmV3IE9iamVjdE1hcChxID0+IGNhbm9uaWZ5UXVlcnkocSksIHF1ZXJ5RXF1YWxzKTtcbiAgICAgICAgdGhpcy5xdWVyaWVzQnlUYXJnZXQgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUga2V5cyBvZiBkb2N1bWVudHMgdGhhdCBhcmUgaW4gbGltYm8gZm9yIHdoaWNoIHdlIGhhdmVuJ3QgeWV0IHN0YXJ0ZWQgYVxuICAgICAgICAgKiBsaW1ibyByZXNvbHV0aW9uIHF1ZXJ5LiBUaGUgc3RyaW5ncyBpbiB0aGlzIHNldCBhcmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nXG4gICAgICAgICAqIGBrZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKWAgd2hlcmUgYGtleWAgaXMgYSBgRG9jdW1lbnRLZXlgIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGBTZXRgIHR5cGUgd2FzIGNob3NlbiBiZWNhdXNlIGl0IHByb3ZpZGVzIGVmZmljaWVudCBsb29rdXAgYW5kIHJlbW92YWxcbiAgICAgICAgICogb2YgYXJiaXRyYXJ5IGVsZW1lbnRzIGFuZCBpdCBhbHNvIG1haW50YWlucyBpbnNlcnRpb24gb3JkZXIsIHByb3ZpZGluZyB0aGVcbiAgICAgICAgICogZGVzaXJlZCBxdWV1ZS1saWtlIEZJRk8gc2VtYW50aWNzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgdGFyZ2V0IElEIGZvciBlYWNoIGRvY3VtZW50IHRoYXQgaXMgaW4gbGltYm8gd2l0aCBhblxuICAgICAgICAgKiBhY3RpdmUgdGFyZ2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVMaW1ib1RhcmdldHNCeUtleSA9IG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgaW5mb3JtYXRpb24gYWJvdXQgYW4gYWN0aXZlIGxpbWJvIHJlc29sdXRpb24gZm9yIGVhY2hcbiAgICAgICAgICogYWN0aXZlIHRhcmdldCBJRCB0aGF0IHdhcyBzdGFydGVkIGZvciB0aGUgcHVycG9zZSBvZiBsaW1ibyByZXNvbHV0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubGltYm9Eb2N1bWVudFJlZnMgPSBuZXcgUmVmZXJlbmNlU2V0KCk7XG4gICAgICAgIC8qKiBTdG9yZXMgdXNlciBjb21wbGV0aW9uIGhhbmRsZXJzLCBpbmRleGVkIGJ5IFVzZXIgYW5kIEJhdGNoSWQuICovXG4gICAgICAgIHRoaXMubXV0YXRpb25Vc2VyQ2FsbGJhY2tzID0ge307XG4gICAgICAgIC8qKiBTdG9yZXMgdXNlciBjYWxsYmFja3Mgd2FpdGluZyBmb3IgYWxsIHBlbmRpbmcgd3JpdGVzIHRvIGJlIGFja25vd2xlZGdlZC4gKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxpbWJvVGFyZ2V0SWRHZW5lcmF0b3IgPSBUYXJnZXRJZEdlbmVyYXRvci5mb3JTeW5jRW5naW5lKCk7XG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovO1xuICAgICAgICAvLyBUaGUgcHJpbWFyeSBzdGF0ZSBpcyBzZXQgdG8gYHRydWVgIG9yIGBmYWxzZWAgaW1tZWRpYXRlbHkgYWZ0ZXIgRmlyZXN0b3JlXG4gICAgICAgIC8vIHN0YXJ0dXAuIEluIHRoZSBpbnRlcmltLCBhIGNsaWVudCBzaG91bGQgb25seSBiZSBjb25zaWRlcmVkIHByaW1hcnkgaWZcbiAgICAgICAgLy8gYGlzUHJpbWFyeWAgaXMgdHJ1ZS5cbiAgICAgICAgdGhpcy5faXNQcmltYXJ5Q2xpZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgaXNQcmltYXJ5Q2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNQcmltYXJ5Q2xpZW50ID09PSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld1N5bmNFbmdpbmUobG9jYWxTdG9yZSwgcmVtb3RlU3RvcmUsIGV2ZW50TWFuYWdlciwgXG4vLyBQT1JUSU5HIE5PVEU6IE1hbmFnZXMgc3RhdGUgc3luY2hyb25pemF0aW9uIGluIG11bHRpLXRhYiBlbnZpcm9ubWVudHMuXG5zaGFyZWRDbGllbnRTdGF0ZSwgY3VycmVudFVzZXIsIG1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zLCBpc1ByaW1hcnkpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lID0gbmV3IFN5bmNFbmdpbmVJbXBsKGxvY2FsU3RvcmUsIHJlbW90ZVN0b3JlLCBldmVudE1hbmFnZXIsIHNoYXJlZENsaWVudFN0YXRlLCBjdXJyZW50VXNlciwgbWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMpO1xuICAgIGlmIChpc1ByaW1hcnkpIHtcbiAgICAgICAgc3luY0VuZ2luZS5faXNQcmltYXJ5Q2xpZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN5bmNFbmdpbmU7XG59XG4vKipcbiAqIEluaXRpYXRlcyB0aGUgbmV3IGxpc3RlbiwgcmVzb2x2ZXMgcHJvbWlzZSB3aGVuIGxpc3RlbiBlbnF1ZXVlZCB0byB0aGVcbiAqIHNlcnZlci4gQWxsIHRoZSBzdWJzZXF1ZW50IHZpZXcgc25hcHNob3RzIG9yIGVycm9ycyBhcmUgc2VudCB0byB0aGVcbiAqIHN1YnNjcmliZWQgaGFuZGxlcnMuIFJldHVybnMgdGhlIGluaXRpYWwgc25hcHNob3QuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVMaXN0ZW4oc3luY0VuZ2luZSwgcXVlcnksIHNob3VsZExpc3RlblRvUmVtb3RlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZW5zdXJlV2F0Y2hDYWxsYmFja3Moc3luY0VuZ2luZSk7XG4gICAgbGV0IHZpZXdTbmFwc2hvdDtcbiAgICBjb25zdCBxdWVyeVZpZXcgPSBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5nZXQocXVlcnkpO1xuICAgIGlmIChxdWVyeVZpZXcpIHtcbiAgICAgICAgLy8gUE9SVElORyBOT1RFOiBXaXRoIE11bHRpLVRhYiBXZWIsIGl0IGlzIHBvc3NpYmxlIHRoYXQgYSBxdWVyeSB2aWV3XG4gICAgICAgIC8vIGFscmVhZHkgZXhpc3RzIHdoZW4gRXZlbnRNYW5hZ2VyIGNhbGxzIHVzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpc1xuICAgICAgICAvLyBoYXBwZW5zIHdoZW4gdGhlIHByaW1hcnkgdGFiIGlzIGFscmVhZHkgbGlzdGVuaW5nIHRvIHRoaXMgcXVlcnkgb25cbiAgICAgICAgLy8gYmVoYWxmIG9mIGFub3RoZXIgdGFiIGFuZCB0aGUgdXNlciBvZiB0aGUgcHJpbWFyeSBhbHNvIHN0YXJ0cyBsaXN0ZW5pbmdcbiAgICAgICAgLy8gdG8gdGhlIHF1ZXJ5LiBFdmVudE1hbmFnZXIgd2lsbCBub3QgaGF2ZSBhbiBhc3NpZ25lZCB0YXJnZXQgSUQgaW4gdGhpc1xuICAgICAgICAvLyBjYXNlIGFuZCBjYWxscyBgbGlzdGVuYCB0byBvYnRhaW4gdGhpcyBJRC5cbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuYWRkTG9jYWxRdWVyeVRhcmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICB2aWV3U25hcHNob3QgPSBxdWVyeVZpZXcudmlldy5jb21wdXRlSW5pdGlhbFNuYXBzaG90KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3U25hcHNob3QgPSBhd2FpdCBhbGxvY2F0ZVRhcmdldEFuZE1heWJlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLCBxdWVyeSwgc2hvdWxkTGlzdGVuVG9SZW1vdGUsIFxuICAgICAgICAvKiogc2hvdWxkSW5pdGlhbGl6ZVZpZXc9ICovIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmlld1NuYXBzaG90O1xufVxuLyoqIFF1ZXJ5IGhhcyBiZWVuIGxpc3RlbmluZyB0byB0aGUgY2FjaGUsIGFuZCB0cmllcyB0byBpbml0aWF0ZSB0aGUgcmVtb3RlIHN0b3JlIGxpc3RlbiAqL1xuYXN5bmMgZnVuY3Rpb24gdHJpZ2dlclJlbW90ZVN0b3JlTGlzdGVuKHN5bmNFbmdpbmUsIHF1ZXJ5KSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBlbnN1cmVXYXRjaENhbGxiYWNrcyhzeW5jRW5naW5lKTtcbiAgICBhd2FpdCBhbGxvY2F0ZVRhcmdldEFuZE1heWJlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLCBxdWVyeSwgXG4gICAgLyoqIHNob3VsZExpc3RlblRvUmVtb3RlPSAqLyB0cnVlLCBcbiAgICAvKiogc2hvdWxkSW5pdGlhbGl6ZVZpZXc9ICovIGZhbHNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFsbG9jYXRlVGFyZ2V0QW5kTWF5YmVMaXN0ZW4oc3luY0VuZ2luZUltcGwsIHF1ZXJ5LCBzaG91bGRMaXN0ZW5Ub1JlbW90ZSwgc2hvdWxkSW5pdGlhbGl6ZVZpZXcpIHtcbiAgICBjb25zdCB0YXJnZXREYXRhID0gYXdhaXQgbG9jYWxTdG9yZUFsbG9jYXRlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5VG9UYXJnZXQocXVlcnkpKTtcbiAgICBjb25zdCB0YXJnZXRJZCA9IHRhcmdldERhdGEudGFyZ2V0SWQ7XG4gICAgLy8gUE9SVElORyBOT1RFOiBXaGVuIHRoZSBxdWVyeSBpcyBsaXN0ZW5pbmcgdG8gY2FjaGUgb25seSwgd2Ugc2tpcCBzZW5kaW5nIGl0IG92ZXIgdG8gV2F0Y2ggYnlcbiAgICAvLyBub3QgcmVnaXN0ZXJpbmcgaXQgaW4gc2hhcmVkIGNsaWVudCBzdGF0ZSwgYW5kIGRpcmVjdGx5IGNhbGN1bGF0ZSBpbml0aWFsIHNuYXBzaG90cyBhbmRcbiAgICAvLyBzdWJzZXF1ZW50IHVwZGF0ZXMgZnJvbSBjYWNoZS4gT3RoZXJ3aXNlLCByZWdpc3RlciB0aGUgdGFyZ2V0IElEIHdpdGggbG9jYWwgRmlyZXN0b3JlIGNsaWVudFxuICAgIC8vIGFzIGFjdGl2ZSB3YXRjaCB0YXJnZXQuXG4gICAgY29uc3Qgc3RhdHVzID0gc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuYWRkTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCwgXG4gICAgLyogYWRkVG9BY3RpdmVUYXJnZXRJZHM9ICovIHNob3VsZExpc3RlblRvUmVtb3RlKTtcbiAgICBsZXQgdmlld1NuYXBzaG90O1xuICAgIGlmIChzaG91bGRJbml0aWFsaXplVmlldykge1xuICAgICAgICB2aWV3U25hcHNob3QgPSBhd2FpdCBpbml0aWFsaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lSW1wbCwgcXVlcnksIHRhcmdldElkLCBzdGF0dXMgPT09ICdjdXJyZW50JywgdGFyZ2V0RGF0YS5yZXN1bWVUb2tlbik7XG4gICAgfVxuICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQgJiYgc2hvdWxkTGlzdGVuVG9SZW1vdGUpIHtcbiAgICAgICAgcmVtb3RlU3RvcmVMaXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldERhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdmlld1NuYXBzaG90O1xufVxuLyoqXG4gKiBSZWdpc3RlcnMgYSB2aWV3IGZvciBhIHByZXZpb3VzbHkgdW5rbm93biBxdWVyeSBhbmQgY29tcHV0ZXMgaXRzIGluaXRpYWxcbiAqIHNuYXBzaG90LlxuICovXG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lSW1wbCwgcXVlcnksIHRhcmdldElkLCBjdXJyZW50LCByZXN1bWVUb2tlbikge1xuICAgIC8vIFBPUlRJTkcgTk9URTogT24gV2ViIG9ubHksIHdlIGluamVjdCB0aGUgY29kZSB0aGF0IHJlZ2lzdGVycyBuZXcgTGltYm9cbiAgICAvLyB0YXJnZXRzIGJhc2VkIG9uIHZpZXcgY2hhbmdlcy4gVGhpcyBhbGxvd3MgdXMgdG8gb25seSBkZXBlbmQgb24gTGltYm9cbiAgICAvLyBjaGFuZ2VzIHdoZW4gdXNlciBjb2RlIGluY2x1ZGVzIHF1ZXJpZXMuXG4gICAgc3luY0VuZ2luZUltcGwuYXBwbHlEb2NDaGFuZ2VzID0gKHF1ZXJ5VmlldywgY2hhbmdlcywgcmVtb3RlRXZlbnQpID0+IGFwcGx5RG9jQ2hhbmdlcyhzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3LCBjaGFuZ2VzLCByZW1vdGVFdmVudCk7XG4gICAgY29uc3QgcXVlcnlSZXN1bHQgPSBhd2FpdCBsb2NhbFN0b3JlRXhlY3V0ZVF1ZXJ5KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5LCBcbiAgICAvKiB1c2VQcmV2aW91c1Jlc3VsdHM9ICovIHRydWUpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgVmlldyhxdWVyeSwgcXVlcnlSZXN1bHQucmVtb3RlS2V5cyk7XG4gICAgY29uc3Qgdmlld0RvY0NoYW5nZXMgPSB2aWV3LmNvbXB1dGVEb2NDaGFuZ2VzKHF1ZXJ5UmVzdWx0LmRvY3VtZW50cyk7XG4gICAgY29uc3Qgc3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2UgPSBUYXJnZXRDaGFuZ2UuY3JlYXRlU3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2VGb3JDdXJyZW50Q2hhbmdlKHRhcmdldElkLCBjdXJyZW50ICYmIHN5bmNFbmdpbmVJbXBsLm9ubGluZVN0YXRlICE9PSBcIk9mZmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PZmZsaW5lICovLCByZXN1bWVUb2tlbik7XG4gICAgY29uc3Qgdmlld0NoYW5nZSA9IHZpZXcuYXBwbHlDaGFuZ2VzKHZpZXdEb2NDaGFuZ2VzLCBcbiAgICAvKiBsaW1ib1Jlc29sdXRpb25FbmFibGVkPSAqLyBzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQsIHN5bnRoZXNpemVkVGFyZ2V0Q2hhbmdlKTtcbiAgICB1cGRhdGVUcmFja2VkTGltYm9zKHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCwgdmlld0NoYW5nZS5saW1ib0NoYW5nZXMpO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgUXVlcnlWaWV3KHF1ZXJ5LCB0YXJnZXRJZCwgdmlldyk7XG4gICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuc2V0KHF1ZXJ5LCBkYXRhKTtcbiAgICBpZiAoc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0Lmhhcyh0YXJnZXRJZCkpIHtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCkucHVzaChxdWVyeSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuc2V0KHRhcmdldElkLCBbcXVlcnldKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdDaGFuZ2Uuc25hcHNob3Q7XG59XG4vKiogU3RvcHMgbGlzdGVuaW5nIHRvIHRoZSBxdWVyeS4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVVbmxpc3RlbihzeW5jRW5naW5lLCBxdWVyeSwgc2hvdWxkVW5saXN0ZW5Ub1JlbW90ZSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGNvbnN0IHF1ZXJ5VmlldyA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmdldChxdWVyeSk7XG4gICAgLy8gT25seSBjbGVhbiB1cCB0aGUgcXVlcnkgdmlldyBhbmQgdGFyZ2V0IGlmIHRoaXMgaXMgdGhlIG9ubHkgcXVlcnkgbWFwcGVkXG4gICAgLy8gdG8gdGhlIHRhcmdldC5cbiAgICBjb25zdCBxdWVyaWVzID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgIGlmIChxdWVyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LnNldChxdWVyeVZpZXcudGFyZ2V0SWQsIHF1ZXJpZXMuZmlsdGVyKHEgPT4gIXF1ZXJ5RXF1YWxzKHEsIHF1ZXJ5KSkpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5kZWxldGUocXVlcnkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIE5vIG90aGVyIHF1ZXJpZXMgYXJlIG1hcHBlZCB0byB0aGUgdGFyZ2V0LCBjbGVhbiB1cCB0aGUgcXVlcnkgYW5kIHRoZSB0YXJnZXQuXG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGUgbG9jYWwgcXVlcnkgdGFyZ2V0IGZpcnN0IHRvIGFsbG93IHVzIHRvIHZlcmlmeVxuICAgICAgICAvLyB3aGV0aGVyIGFueSBvdGhlciBjbGllbnQgaXMgc3RpbGwgaW50ZXJlc3RlZCBpbiB0aGlzIHRhcmdldC5cbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUucmVtb3ZlTG9jYWxRdWVyeVRhcmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICBjb25zdCB0YXJnZXRSZW1haW5zQWN0aXZlID0gc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuaXNBY3RpdmVRdWVyeVRhcmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICBpZiAoIXRhcmdldFJlbWFpbnNBY3RpdmUpIHtcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5Vmlldy50YXJnZXRJZCwgXG4gICAgICAgICAgICAvKmtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhPSovIGZhbHNlKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5jbGVhclF1ZXJ5U3RhdGUocXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkVW5saXN0ZW5Ub1JlbW90ZSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCBxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1vdmVBbmRDbGVhbnVwVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICAgICAgYXdhaXQgbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcXVlcnlWaWV3LnRhcmdldElkLCBcbiAgICAgICAgLyprZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YT0qLyB0cnVlKTtcbiAgICB9XG59XG4vKiogVW5saXN0ZW5zIHRvIHRoZSByZW1vdGUgc3RvcmUgd2hpbGUgc3RpbGwgbGlzdGVuaW5nIHRvIHRoZSBjYWNoZS4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRyaWdnZXJSZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmUsIHF1ZXJ5KSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgY29uc3QgcXVlcnlWaWV3ID0gc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZ2V0KHF1ZXJ5KTtcbiAgICBjb25zdCBxdWVyaWVzID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQgJiYgcXVlcmllcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gUE9SVElORyBOT1RFOiBVbnJlZ2lzdGVyIHRoZSB0YXJnZXQgSUQgd2l0aCBsb2NhbCBGaXJlc3RvcmUgY2xpZW50IGFzXG4gICAgICAgIC8vIHdhdGNoIHRhcmdldC5cbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUucmVtb3ZlTG9jYWxRdWVyeVRhcmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgICAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCBxdWVyeVZpZXcudGFyZ2V0SWQpO1xuICAgIH1cbn1cbi8qKlxuICogSW5pdGlhdGVzIHRoZSB3cml0ZSBvZiBsb2NhbCBtdXRhdGlvbiBiYXRjaCB3aGljaCBpbnZvbHZlcyBhZGRpbmcgdGhlXG4gKiB3cml0ZXMgdG8gdGhlIG11dGF0aW9uIHF1ZXVlLCBub3RpZnlpbmcgdGhlIHJlbW90ZSBzdG9yZSBhYm91dCBuZXdcbiAqIG11dGF0aW9ucyBhbmQgcmFpc2luZyBldmVudHMgZm9yIGFueSBjaGFuZ2VzIHRoaXMgd3JpdGUgY2F1c2VkLlxuICpcbiAqIFRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoaXMgY2FsbCBpcyByZXNvbHZlZCB3aGVuIHRoZSBhYm92ZSBzdGVwc1xuICogaGF2ZSBjb21wbGV0ZWQsICpub3QqIHdoZW4gdGhlIHdyaXRlIHdhcyBhY2tlZCBieSB0aGUgYmFja2VuZC4gVGhlXG4gKiB1c2VyQ2FsbGJhY2sgaXMgcmVzb2x2ZWQgb25jZSB0aGUgd3JpdGUgd2FzIGFja2VkL3JlamVjdGVkIGJ5IHRoZVxuICogYmFja2VuZCAob3IgZmFpbGVkIGxvY2FsbHkgZm9yIGFueSBvdGhlciByZWFzb24pLlxuICovXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lV3JpdGUoc3luY0VuZ2luZSwgYmF0Y2gsIHVzZXJDYWxsYmFjaykge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gc3luY0VuZ2luZUVuc3VyZVdyaXRlQ2FsbGJhY2tzKHN5bmNFbmdpbmUpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvY2FsU3RvcmVXcml0ZUxvY2FsbHkoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgYmF0Y2gpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5hZGRQZW5kaW5nTXV0YXRpb24ocmVzdWx0LmJhdGNoSWQpO1xuICAgICAgICBhZGRNdXRhdGlvbkNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCByZXN1bHQuYmF0Y2hJZCwgdXNlckNhbGxiYWNrKTtcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIHJlc3VsdC5jaGFuZ2VzKTtcbiAgICAgICAgYXdhaXQgZmlsbFdyaXRlUGlwZWxpbmUoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiB3ZSBjYW4ndCBwZXJzaXN0IHRoZSBtdXRhdGlvbiwgd2UgcmVqZWN0IHRoZSB1c2VyIGNhbGxiYWNrIGFuZFxuICAgICAgICAvLyBkb24ndCBzZW5kIHRoZSBtdXRhdGlvbi4gVGhlIHVzZXIgY2FuIHRoZW4gcmV0cnkgdGhlIHdyaXRlLlxuICAgICAgICBjb25zdCBlcnJvciA9IHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgYEZhaWxlZCB0byBwZXJzaXN0IHdyaXRlYCk7XG4gICAgICAgIHVzZXJDYWxsYmFjay5yZWplY3QoZXJyb3IpO1xuICAgIH1cbn1cbi8qKlxuICogQXBwbGllcyBvbmUgcmVtb3RlIGV2ZW50IHRvIHRoZSBzeW5jIGVuZ2luZSwgbm90aWZ5aW5nIGFueSB2aWV3cyBvZiB0aGVcbiAqIGNoYW5nZXMsIGFuZCByZWxlYXNpbmcgYW55IHBlbmRpbmcgbXV0YXRpb24gYmF0Y2hlcyB0aGF0IHdvdWxkIGJlY29tZVxuICogdmlzaWJsZSBiZWNhdXNlIG9mIHRoZSBzbmFwc2hvdCB2ZXJzaW9uIHRoZSByZW1vdGUgZXZlbnQgY29udGFpbnMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseVJlbW90ZUV2ZW50KHN5bmNFbmdpbmUsIHJlbW90ZUV2ZW50KSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGF3YWl0IGxvY2FsU3RvcmVBcHBseVJlbW90ZUV2ZW50VG9Mb2NhbENhY2hlKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHJlbW90ZUV2ZW50KTtcbiAgICAgICAgLy8gVXBkYXRlIGByZWNlaXZlZERvY3VtZW50YCBhcyBhcHByb3ByaWF0ZSBmb3IgYW55IGxpbWJvIHRhcmdldHMuXG4gICAgICAgIHJlbW90ZUV2ZW50LnRhcmdldENoYW5nZXMuZm9yRWFjaCgodGFyZ2V0Q2hhbmdlLCB0YXJnZXRJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGltYm9SZXNvbHV0aW9uID0gc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICBpZiAobGltYm9SZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBhIGxpbWJvIHJlc29sdXRpb24gbG9va3VwLCBpdCdzIGZvciBhIHNpbmdsZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC8vIGFuZCBpdCBjb3VsZCBiZSBhZGRlZCwgbW9kaWZpZWQsIG9yIHJlbW92ZWQsIGJ1dCBub3QgYSBjb21iaW5hdGlvbi5cbiAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KHRhcmdldENoYW5nZS5hZGRlZERvY3VtZW50cy5zaXplICtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLm1vZGlmaWVkRG9jdW1lbnRzLnNpemUgK1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDaGFuZ2UucmVtb3ZlZERvY3VtZW50cy5zaXplIDw9XG4gICAgICAgICAgICAgICAgICAgIDEsIDB4NTg1OCk7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldENoYW5nZS5hZGRlZERvY3VtZW50cy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsaW1ib1Jlc29sdXRpb24ucmVjZWl2ZWREb2N1bWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldENoYW5nZS5tb2RpZmllZERvY3VtZW50cy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KGxpbWJvUmVzb2x1dGlvbi5yZWNlaXZlZERvY3VtZW50LCAweDM5MGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRDaGFuZ2UucmVtb3ZlZERvY3VtZW50cy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KGxpbWJvUmVzb2x1dGlvbi5yZWNlaXZlZERvY3VtZW50LCAweGE0ZjMpO1xuICAgICAgICAgICAgICAgICAgICBsaW1ib1Jlc29sdXRpb24ucmVjZWl2ZWREb2N1bWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3YXMgcHJvYmFibHkganVzdCBhIENVUlJFTlQgdGFyZ2V0Q2hhbmdlIG9yIHNpbWlsYXIuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGF3YWl0IGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlcnJvcik7XG4gICAgfVxufVxuLyoqXG4gKiBBcHBsaWVzIGFuIE9ubGluZVN0YXRlIGNoYW5nZSB0byB0aGUgc3luYyBlbmdpbmUgYW5kIG5vdGlmaWVzIGFueSB2aWV3cyBvZlxuICogdGhlIGNoYW5nZS5cbiAqL1xuZnVuY3Rpb24gc3luY0VuZ2luZUFwcGx5T25saW5lU3RhdGVDaGFuZ2Uoc3luY0VuZ2luZSwgb25saW5lU3RhdGUsIHNvdXJjZSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIC8vIElmIHdlIGFyZSB0aGUgc2Vjb25kYXJ5IGNsaWVudCwgd2UgZXhwbGljaXRseSBpZ25vcmUgdGhlIHJlbW90ZSBzdG9yZSdzXG4gICAgLy8gb25saW5lIHN0YXRlICh0aGUgbG9jYWwgY2xpZW50IG1heSBnbyBvZmZsaW5lLCBldmVuIHRob3VnaCB0aGUgcHJpbWFyeVxuICAgIC8vIHRhYiByZW1haW5zIG9ubGluZSkgYW5kIG9ubHkgYXBwbHkgdGhlIHByaW1hcnkgdGFiJ3Mgb25saW5lIHN0YXRlIGZyb21cbiAgICAvLyBTaGFyZWRDbGllbnRTdGF0ZS5cbiAgICBpZiAoKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCAmJlxuICAgICAgICBzb3VyY2UgPT09IDAgLyogT25saW5lU3RhdGVTb3VyY2UuUmVtb3RlU3RvcmUgKi8pIHx8XG4gICAgICAgICghc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50ICYmXG4gICAgICAgICAgICBzb3VyY2UgPT09IDEgLyogT25saW5lU3RhdGVTb3VyY2UuU2hhcmVkQ2xpZW50U3RhdGUgKi8pKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZpZXdTbmFwc2hvdHMgPSBbXTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZm9yRWFjaCgocXVlcnksIHF1ZXJ5VmlldykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgdmlld0NoYW5nZSA9IHF1ZXJ5Vmlldy52aWV3LmFwcGx5T25saW5lU3RhdGVDaGFuZ2Uob25saW5lU3RhdGUpO1xuICAgICAgICAgICAgaWYgKHZpZXdDaGFuZ2Uuc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICBuZXdWaWV3U25hcHNob3RzLnB1c2godmlld0NoYW5nZS5zbmFwc2hvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudE1hbmFnZXJPbk9ubGluZVN0YXRlQ2hhbmdlKHN5bmNFbmdpbmVJbXBsLmV2ZW50TWFuYWdlciwgb25saW5lU3RhdGUpO1xuICAgICAgICBpZiAobmV3Vmlld1NuYXBzaG90cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLnN5bmNFbmdpbmVMaXN0ZW5lci5vbldhdGNoQ2hhbmdlKG5ld1ZpZXdTbmFwc2hvdHMpO1xuICAgICAgICB9XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLm9ubGluZVN0YXRlID0gb25saW5lU3RhdGU7XG4gICAgICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQpIHtcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnNldE9ubGluZVN0YXRlKG9ubGluZVN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUmVqZWN0cyB0aGUgbGlzdGVuIGZvciB0aGUgZ2l2ZW4gdGFyZ2V0SUQuIFRoaXMgY2FuIGJlIHRyaWdnZXJlZCBieSB0aGVcbiAqIGJhY2tlbmQgZm9yIGFueSBhY3RpdmUgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSBzeW5jRW5naW5lIC0gVGhlIHN5bmMgZW5naW5lIGltcGxlbWVudGF0aW9uLlxuICogQHBhcmFtIHRhcmdldElkIC0gVGhlIHRhcmdldElEIGNvcnJlc3BvbmRzIHRvIG9uZSBwcmV2aW91c2x5IGluaXRpYXRlZCBieSB0aGVcbiAqIHVzZXIgYXMgcGFydCBvZiBUYXJnZXREYXRhIHBhc3NlZCB0byBsaXN0ZW4oKSBvbiBSZW1vdGVTdG9yZS5cbiAqIEBwYXJhbSBlcnIgLSBBIGRlc2NyaXB0aW9uIG9mIHRoZSBjb25kaXRpb24gdGhhdCBoYXMgZm9yY2VkIHRoZSByZWplY3Rpb24uXG4gKiBOZWFybHkgYWx3YXlzIHRoaXMgd2lsbCBiZSBhbiBpbmRpY2F0aW9uIHRoYXQgdGhlIHVzZXIgaXMgbm8gbG9uZ2VyXG4gKiBhdXRob3JpemVkIHRvIHNlZSB0aGUgZGF0YSBtYXRjaGluZyB0aGUgdGFyZ2V0LlxuICovXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lUmVqZWN0TGlzdGVuKHN5bmNFbmdpbmUsIHRhcmdldElkLCBlcnIpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxuICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnVwZGF0ZVF1ZXJ5U3RhdGUodGFyZ2V0SWQsICdyZWplY3RlZCcsIGVycik7XG4gICAgY29uc3QgbGltYm9SZXNvbHV0aW9uID0gc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgY29uc3QgbGltYm9LZXkgPSBsaW1ib1Jlc29sdXRpb24gJiYgbGltYm9SZXNvbHV0aW9uLmtleTtcbiAgICBpZiAobGltYm9LZXkpIHtcbiAgICAgICAgLy8gVE9ETyhrbGltdCk6IFdlIHJlYWxseSBvbmx5IHNob3VsZCBkbyB0aGUgZm9sbG93aW5nIG9uIHBlcm1pc3Npb25cbiAgICAgICAgLy8gZGVuaWVkIGVycm9ycywgYnV0IHdlIGRvbid0IGhhdmUgdGhlIGNhdXNlIGNvZGUgaGVyZS5cbiAgICAgICAgLy8gSXQncyBhIGxpbWJvIGRvYy4gQ3JlYXRlIGEgc3ludGhldGljIGV2ZW50IHNheWluZyBpdCB3YXMgZGVsZXRlZC5cbiAgICAgICAgLy8gVGhpcyBpcyBraW5kIG9mIGEgaGFjay4gSWRlYWxseSwgd2Ugd291bGQgaGF2ZSBhIG1ldGhvZCBpbiB0aGUgbG9jYWxcbiAgICAgICAgLy8gc3RvcmUgdG8gcHVyZ2UgYSBkb2N1bWVudC4gSG93ZXZlciwgaXQgd291bGQgYmUgdHJpY2t5IHRvIGtlZXAgYWxsIG9mXG4gICAgICAgIC8vIHRoZSBsb2NhbCBzdG9yZSdzIGludmFyaWFudHMgd2l0aCBhbm90aGVyIG1ldGhvZC5cbiAgICAgICAgbGV0IGRvY3VtZW50VXBkYXRlcyA9IG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XG4gICAgICAgIC8vIFRPRE8oYi8yMTcxODkyMTYpOiBUaGlzIGxpbWJvIGRvY3VtZW50IHNob3VsZCBpZGVhbGx5IGhhdmUgYSByZWFkIHRpbWUsXG4gICAgICAgIC8vIHNvIHRoYXQgaXQgaXMgcGlja2VkIHVwIGJ5IGFueSByZWFkLXRpbWUgYmFzZWQgc2NhbnMuIFRoZSBiYWNrZW5kLFxuICAgICAgICAvLyBob3dldmVyLCBkb2VzIG5vdCBzZW5kIGEgcmVhZCB0aW1lIGZvciB0YXJnZXQgcmVtb3ZhbHMuXG4gICAgICAgIGRvY3VtZW50VXBkYXRlcyA9IGRvY3VtZW50VXBkYXRlcy5pbnNlcnQobGltYm9LZXksIE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGxpbWJvS2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRMaW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCkuYWRkKGxpbWJvS2V5KTtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgUmVtb3RlRXZlbnQoU25hcHNob3RWZXJzaW9uLm1pbigpLCBcbiAgICAgICAgLyogdGFyZ2V0Q2hhbmdlcz0gKi8gbmV3IE1hcCgpLCBcbiAgICAgICAgLyogdGFyZ2V0TWlzbWF0Y2hlcz0gKi8gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKSwgZG9jdW1lbnRVcGRhdGVzLCByZXNvbHZlZExpbWJvRG9jdW1lbnRzKTtcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUFwcGx5UmVtb3RlRXZlbnQoc3luY0VuZ2luZUltcGwsIGV2ZW50KTtcbiAgICAgICAgLy8gU2luY2UgdGhpcyBxdWVyeSBmYWlsZWQsIHdlIHdvbid0IHdhbnQgdG8gbWFudWFsbHkgdW5saXN0ZW4gdG8gaXQuXG4gICAgICAgIC8vIFdlIG9ubHkgcmVtb3ZlIGl0IGZyb20gYm9va2tlZXBpbmcgYWZ0ZXIgd2Ugc3VjY2Vzc2Z1bGx5IGFwcGxpZWQgdGhlXG4gICAgICAgIC8vIFJlbW90ZUV2ZW50LiBJZiBgYXBwbHlSZW1vdGVFdmVudCgpYCB0aHJvd3MsIHdlIHdhbnQgdG8gcmUtbGlzdGVuIHRvXG4gICAgICAgIC8vIHRoaXMgcXVlcnkgd2hlbiB0aGUgUmVtb3RlU3RvcmUgcmVzdGFydHMgdGhlIFdhdGNoIHN0cmVhbSwgd2hpY2ggc2hvdWxkXG4gICAgICAgIC8vIHJlLXRyaWdnZXIgdGhlIHRhcmdldCBmYWlsdXJlLlxuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleSA9XG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleS5yZW1vdmUobGltYm9LZXkpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuZGVsZXRlKHRhcmdldElkKTtcbiAgICAgICAgcHVtcEVucXVldWVkTGltYm9SZXNvbHV0aW9ucyhzeW5jRW5naW5lSW1wbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhd2FpdCBsb2NhbFN0b3JlUmVsZWFzZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXRJZCwgXG4gICAgICAgIC8qIGtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhICovIGZhbHNlKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQsIGVycikpXG4gICAgICAgICAgICAuY2F0Y2goaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lQXBwbHlTdWNjZXNzZnVsV3JpdGUoc3luY0VuZ2luZSwgbXV0YXRpb25CYXRjaFJlc3VsdCkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGNvbnN0IGJhdGNoSWQgPSBtdXRhdGlvbkJhdGNoUmVzdWx0LmJhdGNoLmJhdGNoSWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGF3YWl0IGxvY2FsU3RvcmVBY2tub3dsZWRnZUJhdGNoKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIG11dGF0aW9uQmF0Y2hSZXN1bHQpO1xuICAgICAgICAvLyBUaGUgbG9jYWwgc3RvcmUgbWF5IG9yIG1heSBub3QgYmUgYWJsZSB0byBhcHBseSB0aGUgd3JpdGUgcmVzdWx0IGFuZFxuICAgICAgICAvLyByYWlzZSBldmVudHMgaW1tZWRpYXRlbHkgKGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSB3YXRjaGVyIGlzIGNhdWdodFxuICAgICAgICAvLyB1cCksIHNvIHdlIHJhaXNlIHVzZXIgY2FsbGJhY2tzIGZpcnN0IHNvIHRoYXQgdGhleSBjb25zaXN0ZW50bHkgaGFwcGVuXG4gICAgICAgIC8vIGJlZm9yZSBsaXN0ZW4gZXZlbnRzLlxuICAgICAgICBwcm9jZXNzVXNlckNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkLCAvKmVycm9yPSovIG51bGwpO1xuICAgICAgICB0cmlnZ2VyUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCk7XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnVwZGF0ZU11dGF0aW9uU3RhdGUoYmF0Y2hJZCwgJ2Fja25vd2xlZGdlZCcpO1xuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lSW1wbCwgY2hhbmdlcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhd2FpdCBpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MoZXJyb3IpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVSZWplY3RGYWlsZWRXcml0ZShzeW5jRW5naW5lLCBiYXRjaElkLCBlcnJvcikge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBhd2FpdCBsb2NhbFN0b3JlUmVqZWN0QmF0Y2goc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgYmF0Y2hJZCk7XG4gICAgICAgIC8vIFRoZSBsb2NhbCBzdG9yZSBtYXkgb3IgbWF5IG5vdCBiZSBhYmxlIHRvIGFwcGx5IHRoZSB3cml0ZSByZXN1bHQgYW5kXG4gICAgICAgIC8vIHJhaXNlIGV2ZW50cyBpbW1lZGlhdGVseSAoZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIHdhdGNoZXIgaXMgY2F1Z2h0IHVwKSxcbiAgICAgICAgLy8gc28gd2UgcmFpc2UgdXNlciBjYWxsYmFja3MgZmlyc3Qgc28gdGhhdCB0aGV5IGNvbnNpc3RlbnRseSBoYXBwZW4gYmVmb3JlXG4gICAgICAgIC8vIGxpc3RlbiBldmVudHMuXG4gICAgICAgIHByb2Nlc3NVc2VyQ2FsbGJhY2soc3luY0VuZ2luZUltcGwsIGJhdGNoSWQsIGVycm9yKTtcbiAgICAgICAgdHJpZ2dlclBlbmRpbmdXcml0ZXNDYWxsYmFja3Moc3luY0VuZ2luZUltcGwsIGJhdGNoSWQpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS51cGRhdGVNdXRhdGlvblN0YXRlKGJhdGNoSWQsICdyZWplY3RlZCcsIGVycm9yKTtcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXdhaXQgaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKGVycm9yKTtcbiAgICB9XG59XG4vKipcbiAqIFJlZ2lzdGVycyBhIHVzZXIgY2FsbGJhY2sgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBwZW5kaW5nIG11dGF0aW9ucyBhdCB0aGUgbW9tZW50IG9mIGNhbGxpbmdcbiAqIGFyZSBhY2tub3dsZWRnZWQgLlxuICovXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lUmVnaXN0ZXJQZW5kaW5nV3JpdGVzQ2FsbGJhY2soc3luY0VuZ2luZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBpZiAoIWNhblVzZU5ldHdvcmsoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUpKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ1RoZSBuZXR3b3JrIGlzIGRpc2FibGVkLiBUaGUgdGFzayByZXR1cm5lZCBieSAnICtcbiAgICAgICAgICAgIFwiJ2F3YWl0UGVuZGluZ1dyaXRlcygpJyB3aWxsIG5vdCBjb21wbGV0ZSB1bnRpbCB0aGUgbmV0d29yayBpcyBlbmFibGVkLlwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaGlnaGVzdEJhdGNoSWQgPSBhd2FpdCBsb2NhbFN0b3JlR2V0SGlnaGVzdFVuYWNrbm93bGVkZ2VkQmF0Y2hJZChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlKTtcbiAgICAgICAgaWYgKGhpZ2hlc3RCYXRjaElkID09PSBCQVRDSElEX1VOS05PV04pIHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIGNhbGxiYWNrIHJpZ2h0IGF3YXkgaWYgdGhlcmUgaXMgbm8gcGVuZGluZyB3cml0ZXMgYXQgdGhlIG1vbWVudC5cbiAgICAgICAgICAgIGNhbGxiYWNrLnJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLmdldChoaWdoZXN0QmF0Y2hJZCkgfHwgW107XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucGVuZGluZ1dyaXRlc0NhbGxiYWNrcy5zZXQoaGlnaGVzdEJhdGNoSWQsIGNhbGxiYWNrcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGZpcmVzdG9yZUVycm9yID0gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCAnSW5pdGlhbGl6YXRpb24gb2Ygd2FpdEZvclBlbmRpbmdXcml0ZXMoKSBvcGVyYXRpb24gZmFpbGVkJyk7XG4gICAgICAgIGNhbGxiYWNrLnJlamVjdChmaXJlc3RvcmVFcnJvcik7XG4gICAgfVxufVxuLyoqXG4gKiBUcmlnZ2VycyB0aGUgY2FsbGJhY2tzIHRoYXQgYXJlIHdhaXRpbmcgZm9yIHRoaXMgYmF0Y2ggaWQgdG8gZ2V0IGFja25vd2xlZGdlZCBieSBzZXJ2ZXIsXG4gKiBpZiB0aGVyZSBhcmUgYW55LlxuICovXG5mdW5jdGlvbiB0cmlnZ2VyUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCkge1xuICAgIChzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLmdldChiYXRjaElkKSB8fCBbXSkuZm9yRWFjaChjYWxsYmFjayA9PiB7XG4gICAgICAgIGNhbGxiYWNrLnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICBzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLmRlbGV0ZShiYXRjaElkKTtcbn1cbi8qKiBSZWplY3QgYWxsIG91dHN0YW5kaW5nIGNhbGxiYWNrcyB3YWl0aW5nIGZvciBwZW5kaW5nIHdyaXRlcyB0byBjb21wbGV0ZS4gKi9cbmZ1bmN0aW9uIHJlamVjdE91dHN0YW5kaW5nUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgZXJyb3JNZXNzYWdlKSB7XG4gICAgc3luY0VuZ2luZUltcGwucGVuZGluZ1dyaXRlc0NhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrcyA9PiB7XG4gICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrLnJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5DQU5DRUxMRUQsIGVycm9yTWVzc2FnZSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLmNsZWFyKCk7XG59XG5mdW5jdGlvbiBhZGRNdXRhdGlvbkNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkLCBjYWxsYmFjaykge1xuICAgIGxldCBuZXdDYWxsYmFja3MgPSBzeW5jRW5naW5lSW1wbC5tdXRhdGlvblVzZXJDYWxsYmFja3Nbc3luY0VuZ2luZUltcGwuY3VycmVudFVzZXIudG9LZXkoKV07XG4gICAgaWYgKCFuZXdDYWxsYmFja3MpIHtcbiAgICAgICAgbmV3Q2FsbGJhY2tzID0gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICB9XG4gICAgbmV3Q2FsbGJhY2tzID0gbmV3Q2FsbGJhY2tzLmluc2VydChiYXRjaElkLCBjYWxsYmFjayk7XG4gICAgc3luY0VuZ2luZUltcGwubXV0YXRpb25Vc2VyQ2FsbGJhY2tzW3N5bmNFbmdpbmVJbXBsLmN1cnJlbnRVc2VyLnRvS2V5KCldID1cbiAgICAgICAgbmV3Q2FsbGJhY2tzO1xufVxuLyoqXG4gKiBSZXNvbHZlcyBvciByZWplY3RzIHRoZSB1c2VyIGNhbGxiYWNrIGZvciB0aGUgZ2l2ZW4gYmF0Y2ggYW5kIHRoZW4gZGlzY2FyZHNcbiAqIGl0LlxuICovXG5mdW5jdGlvbiBwcm9jZXNzVXNlckNhbGxiYWNrKHN5bmNFbmdpbmUsIGJhdGNoSWQsIGVycm9yKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgbGV0IG5ld0NhbGxiYWNrcyA9IHN5bmNFbmdpbmVJbXBsLm11dGF0aW9uVXNlckNhbGxiYWNrc1tzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlci50b0tleSgpXTtcbiAgICAvLyBOT1RFOiBNdXRhdGlvbnMgcmVzdG9yZWQgZnJvbSBwZXJzaXN0ZW5jZSB3b24ndCBoYXZlIGNhbGxiYWNrcywgc28gaXQnc1xuICAgIC8vIG9rYXkgZm9yIHRoZXJlIHRvIGJlIG5vIGNhbGxiYWNrIGZvciB0aGlzIElELlxuICAgIGlmIChuZXdDYWxsYmFja3MpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBuZXdDYWxsYmFja3MuZ2V0KGJhdGNoSWQpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdDYWxsYmFja3MgPSBuZXdDYWxsYmFja3MucmVtb3ZlKGJhdGNoSWQpO1xuICAgICAgICB9XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLm11dGF0aW9uVXNlckNhbGxiYWNrc1tzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlci50b0tleSgpXSA9XG4gICAgICAgICAgICBuZXdDYWxsYmFja3M7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQsIGVycm9yID0gbnVsbCkge1xuICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnJlbW92ZUxvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xuICAgIGZvciAoY29uc3QgcXVlcnkgb2Ygc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCkpIHtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZGVsZXRlKHF1ZXJ5KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zeW5jRW5naW5lTGlzdGVuZXIub25XYXRjaEVycm9yKHF1ZXJ5LCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmRlbGV0ZSh0YXJnZXRJZCk7XG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCkge1xuICAgICAgICBjb25zdCBsaW1ib0tleXMgPSBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5yZW1vdmVSZWZlcmVuY2VzRm9ySWQodGFyZ2V0SWQpO1xuICAgICAgICBsaW1ib0tleXMuZm9yRWFjaChsaW1ib0tleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1JlZmVyZW5jZWQgPSBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5jb250YWluc0tleShsaW1ib0tleSk7XG4gICAgICAgICAgICBpZiAoIWlzUmVmZXJlbmNlZCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJlbW92ZWQgdGhlIGxhc3QgcmVmZXJlbmNlIGZvciB0aGlzIGtleVxuICAgICAgICAgICAgICAgIHJlbW92ZUxpbWJvVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBsaW1ib0tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUxpbWJvVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBrZXkpIHtcbiAgICBzeW5jRW5naW5lSW1wbC5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMuZGVsZXRlKGtleS5wYXRoLmNhbm9uaWNhbFN0cmluZygpKTtcbiAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHRhcmdldCBhbHJlYWR5IGdvdCByZW1vdmVkIGJlY2F1c2UgdGhlIHF1ZXJ5IGZhaWxlZC4gSW4gdGhhdCBjYXNlLFxuICAgIC8vIHRoZSBrZXkgd29uJ3QgZXhpc3QgaW4gYGxpbWJvVGFyZ2V0c0J5S2V5YC4gT25seSBkbyB0aGUgY2xlYW51cCBpZiB3ZSBzdGlsbCBoYXZlIHRoZSB0YXJnZXQuXG4gICAgY29uc3QgbGltYm9UYXJnZXRJZCA9IHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5LmdldChrZXkpO1xuICAgIGlmIChsaW1ib1RhcmdldElkID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgdGFyZ2V0IGFscmVhZHkgZ290IHJlbW92ZWQsIGJlY2F1c2UgdGhlIHF1ZXJ5IGZhaWxlZC5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCBsaW1ib1RhcmdldElkKTtcbiAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleSA9XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5LnJlbW92ZShrZXkpO1xuICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvUmVzb2x1dGlvbnNCeVRhcmdldC5kZWxldGUobGltYm9UYXJnZXRJZCk7XG4gICAgcHVtcEVucXVldWVkTGltYm9SZXNvbHV0aW9ucyhzeW5jRW5naW5lSW1wbCk7XG59XG5mdW5jdGlvbiB1cGRhdGVUcmFja2VkTGltYm9zKHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCwgbGltYm9DaGFuZ2VzKSB7XG4gICAgZm9yIChjb25zdCBsaW1ib0NoYW5nZSBvZiBsaW1ib0NoYW5nZXMpIHtcbiAgICAgICAgaWYgKGxpbWJvQ2hhbmdlIGluc3RhbmNlb2YgQWRkZWRMaW1ib0RvY3VtZW50KSB7XG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5hZGRSZWZlcmVuY2UobGltYm9DaGFuZ2Uua2V5LCB0YXJnZXRJZCk7XG4gICAgICAgICAgICB0cmFja0xpbWJvQ2hhbmdlKHN5bmNFbmdpbmVJbXBsLCBsaW1ib0NoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGltYm9DaGFuZ2UgaW5zdGFuY2VvZiBSZW1vdmVkTGltYm9Eb2N1bWVudCkge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnRG9jdW1lbnQgbm8gbG9uZ2VyIGluIGxpbWJvOiAnICsgbGltYm9DaGFuZ2Uua2V5KTtcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLmxpbWJvRG9jdW1lbnRSZWZzLnJlbW92ZVJlZmVyZW5jZShsaW1ib0NoYW5nZS5rZXksIHRhcmdldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGlzUmVmZXJlbmNlZCA9IHN5bmNFbmdpbmVJbXBsLmxpbWJvRG9jdW1lbnRSZWZzLmNvbnRhaW5zS2V5KGxpbWJvQ2hhbmdlLmtleSk7XG4gICAgICAgICAgICBpZiAoIWlzUmVmZXJlbmNlZCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJlbW92ZWQgdGhlIGxhc3QgcmVmZXJlbmNlIGZvciB0aGlzIGtleVxuICAgICAgICAgICAgICAgIHJlbW92ZUxpbWJvVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBsaW1ib0NoYW5nZS5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmFpbCgweDRkNGYsIHsgbGltYm9DaGFuZ2UgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB0cmFja0xpbWJvQ2hhbmdlKHN5bmNFbmdpbmVJbXBsLCBsaW1ib0NoYW5nZSkge1xuICAgIGNvbnN0IGtleSA9IGxpbWJvQ2hhbmdlLmtleTtcbiAgICBjb25zdCBrZXlTdHJpbmcgPSBrZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICBpZiAoIXN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5LmdldChrZXkpICYmXG4gICAgICAgICFzeW5jRW5naW5lSW1wbC5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMuaGFzKGtleVN0cmluZykpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnTmV3IGRvY3VtZW50IGluIGxpbWJvOiAnICsga2V5KTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwuZW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zLmFkZChrZXlTdHJpbmcpO1xuICAgICAgICBwdW1wRW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zKHN5bmNFbmdpbmVJbXBsKTtcbiAgICB9XG59XG4vKipcbiAqIFN0YXJ0cyBsaXN0ZW5zIGZvciBkb2N1bWVudHMgaW4gbGltYm8gdGhhdCBhcmUgZW5xdWV1ZWQgZm9yIHJlc29sdXRpb24sXG4gKiBzdWJqZWN0IHRvIGEgbWF4aW11bSBudW1iZXIgb2YgY29uY3VycmVudCByZXNvbHV0aW9ucy5cbiAqXG4gKiBXaXRob3V0IGJvdW5kaW5nIHRoZSBudW1iZXIgb2YgY29uY3VycmVudCByZXNvbHV0aW9ucywgdGhlIHNlcnZlciBjYW4gZmFpbFxuICogd2l0aCBcInJlc291cmNlIGV4aGF1c3RlZFwiIGVycm9ycyB3aGljaCBjYW4gbGVhZCB0byBwYXRob2xvZ2ljYWwgY2xpZW50XG4gKiBiZWhhdmlvciBhcyBzZWVuIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvaXNzdWVzLzI2ODMuXG4gKi9cbmZ1bmN0aW9uIHB1bXBFbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMoc3luY0VuZ2luZUltcGwpIHtcbiAgICB3aGlsZSAoc3luY0VuZ2luZUltcGwuZW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zLnNpemUgPiAwICYmXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5LnNpemUgPFxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwubWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMpIHtcbiAgICAgICAgY29uc3Qga2V5U3RyaW5nID0gc3luY0VuZ2luZUltcGwuZW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zXG4gICAgICAgICAgICAudmFsdWVzKClcbiAgICAgICAgICAgIC5uZXh0KCkudmFsdWU7XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmVucXVldWVkTGltYm9SZXNvbHV0aW9ucy5kZWxldGUoa2V5U3RyaW5nKTtcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IERvY3VtZW50S2V5KFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKGtleVN0cmluZykpO1xuICAgICAgICBjb25zdCBsaW1ib1RhcmdldElkID0gc3luY0VuZ2luZUltcGwubGltYm9UYXJnZXRJZEdlbmVyYXRvci5uZXh0KCk7XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvUmVzb2x1dGlvbnNCeVRhcmdldC5zZXQobGltYm9UYXJnZXRJZCwgbmV3IExpbWJvUmVzb2x1dGlvbihrZXkpKTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkgPVxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkuaW5zZXJ0KGtleSwgbGltYm9UYXJnZXRJZCk7XG4gICAgICAgIHJlbW90ZVN0b3JlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCBuZXcgVGFyZ2V0RGF0YShxdWVyeVRvVGFyZ2V0KG5ld1F1ZXJ5Rm9yUGF0aChrZXkucGF0aCkpLCBsaW1ib1RhcmdldElkLCBcIlRhcmdldFB1cnBvc2VMaW1ib1Jlc29sdXRpb25cIiAvKiBUYXJnZXRQdXJwb3NlLkxpbWJvUmVzb2x1dGlvbiAqLywgTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCkpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmUsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgY29uc3QgbmV3U25hcHMgPSBbXTtcbiAgICBjb25zdCBkb2NDaGFuZ2VzSW5BbGxWaWV3cyA9IFtdO1xuICAgIGNvbnN0IHF1ZXJpZXNQcm9jZXNzZWQgPSBbXTtcbiAgICBpZiAoc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuaXNFbXB0eSgpKSB7XG4gICAgICAgIC8vIFJldHVybiBlYXJseSBzaW5jZSBgb25XYXRjaENoYW5nZSgpYCBtaWdodCBub3QgaGF2ZSBiZWVuIGFzc2lnbmVkIHlldC5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5mb3JFYWNoKChfLCBxdWVyeVZpZXcpID0+IHtcbiAgICAgICAgcXVlcmllc1Byb2Nlc3NlZC5wdXNoKHN5bmNFbmdpbmVJbXBsXG4gICAgICAgICAgICAuYXBwbHlEb2NDaGFuZ2VzKHF1ZXJ5VmlldywgY2hhbmdlcywgcmVtb3RlRXZlbnQpXG4gICAgICAgICAgICAudGhlbih2aWV3U25hcHNob3QgPT4ge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGNoYW5nZXMsIG9yIHdlIGFyZSBoYW5kbGluZyBhIGdsb2JhbCBzbmFwc2hvdCwgbm90aWZ5XG4gICAgICAgICAgICAvLyBzZWNvbmRhcnkgY2xpZW50cyB0byB1cGRhdGUgcXVlcnkgc3RhdGUuXG4gICAgICAgICAgICBpZiAodmlld1NuYXBzaG90IHx8IHJlbW90ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBRdWVyeSBzdGF0ZSBpcyBzZXQgdG8gYGN1cnJlbnRgIGlmOlxuICAgICAgICAgICAgICAgICAgICAvLyAtIFRoZXJlIGlzIGEgdmlldyBjaGFuZ2UgYW5kIGl0IGlzIHVwLXRvLWRhdGUsIG9yLFxuICAgICAgICAgICAgICAgICAgICAvLyAtIFRoZXJlIGlzIGEgZ2xvYmFsIHNuYXBzaG90LCB0aGUgVGFyZ2V0IGlzIGN1cnJlbnQsIGFuZCBubyBjaGFuZ2VzIHRvIGJlIHJlc29sdmVkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudCA9IHZpZXdTbmFwc2hvdFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAhdmlld1NuYXBzaG90LmZyb21DYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZW1vdGVFdmVudD8udGFyZ2V0Q2hhbmdlcy5nZXQocXVlcnlWaWV3LnRhcmdldElkKT8uY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUudXBkYXRlUXVlcnlTdGF0ZShxdWVyeVZpZXcudGFyZ2V0SWQsIGlzQ3VycmVudCA/ICdjdXJyZW50JyA6ICdub3QtY3VycmVudCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB2aWV3cyBpZiB0aGVyZSBhcmUgYWN0dWFsIGNoYW5nZXMuXG4gICAgICAgICAgICBpZiAoISF2aWV3U25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICBuZXdTbmFwcy5wdXNoKHZpZXdTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jQ2hhbmdlcyA9IExvY2FsVmlld0NoYW5nZXMuZnJvbVNuYXBzaG90KHF1ZXJ5Vmlldy50YXJnZXRJZCwgdmlld1NuYXBzaG90KTtcbiAgICAgICAgICAgICAgICBkb2NDaGFuZ2VzSW5BbGxWaWV3cy5wdXNoKGRvY0NoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocXVlcmllc1Byb2Nlc3NlZCk7XG4gICAgc3luY0VuZ2luZUltcGwuc3luY0VuZ2luZUxpc3RlbmVyLm9uV2F0Y2hDaGFuZ2UobmV3U25hcHMpO1xuICAgIGF3YWl0IGxvY2FsU3RvcmVOb3RpZnlMb2NhbFZpZXdDaGFuZ2VzKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIGRvY0NoYW5nZXNJbkFsbFZpZXdzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5RG9jQ2hhbmdlcyhzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3LCBjaGFuZ2VzLCByZW1vdGVFdmVudCkge1xuICAgIGxldCB2aWV3RG9jQ2hhbmdlcyA9IHF1ZXJ5Vmlldy52aWV3LmNvbXB1dGVEb2NDaGFuZ2VzKGNoYW5nZXMpO1xuICAgIGlmICh2aWV3RG9jQ2hhbmdlcy5uZWVkc1JlZmlsbCkge1xuICAgICAgICAvLyBUaGUgcXVlcnkgaGFzIGEgbGltaXQgYW5kIHNvbWUgZG9jcyB3ZXJlIHJlbW92ZWQsIHNvIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gcmUtcnVuIHRoZSBxdWVyeSBhZ2FpbnN0IHRoZSBsb2NhbCBzdG9yZSB0byBtYWtlIHN1cmUgd2VcbiAgICAgICAgLy8gZGlkbid0IGxvc2UgYW55IGdvb2QgZG9jcyB0aGF0IGhhZCBiZWVuIHBhc3QgdGhlIGxpbWl0LlxuICAgICAgICB2aWV3RG9jQ2hhbmdlcyA9IGF3YWl0IGxvY2FsU3RvcmVFeGVjdXRlUXVlcnkoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcXVlcnlWaWV3LnF1ZXJ5LCBcbiAgICAgICAgLyogdXNlUHJldmlvdXNSZXN1bHRzPSAqLyBmYWxzZSkudGhlbigoeyBkb2N1bWVudHMgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5Vmlldy52aWV3LmNvbXB1dGVEb2NDaGFuZ2VzKGRvY3VtZW50cywgdmlld0RvY0NoYW5nZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0Q2hhbmdlID0gcmVtb3RlRXZlbnQgJiYgcmVtb3RlRXZlbnQudGFyZ2V0Q2hhbmdlcy5nZXQocXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICBjb25zdCB0YXJnZXRJc1BlbmRpbmdSZXNldCA9IHJlbW90ZUV2ZW50ICYmIHJlbW90ZUV2ZW50LnRhcmdldE1pc21hdGNoZXMuZ2V0KHF1ZXJ5Vmlldy50YXJnZXRJZCkgIT0gbnVsbDtcbiAgICBjb25zdCB2aWV3Q2hhbmdlID0gcXVlcnlWaWV3LnZpZXcuYXBwbHlDaGFuZ2VzKHZpZXdEb2NDaGFuZ2VzLCBcbiAgICAvKiBsaW1ib1Jlc29sdXRpb25FbmFibGVkPSAqLyBzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQsIHRhcmdldENoYW5nZSwgdGFyZ2V0SXNQZW5kaW5nUmVzZXQpO1xuICAgIHVwZGF0ZVRyYWNrZWRMaW1ib3Moc3luY0VuZ2luZUltcGwsIHF1ZXJ5Vmlldy50YXJnZXRJZCwgdmlld0NoYW5nZS5saW1ib0NoYW5nZXMpO1xuICAgIHJldHVybiB2aWV3Q2hhbmdlLnNuYXBzaG90O1xufVxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUhhbmRsZUNyZWRlbnRpYWxDaGFuZ2Uoc3luY0VuZ2luZSwgdXNlcikge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGNvbnN0IHVzZXJDaGFuZ2VkID0gIXN5bmNFbmdpbmVJbXBsLmN1cnJlbnRVc2VyLmlzRXF1YWwodXNlcik7XG4gICAgaWYgKHVzZXJDaGFuZ2VkKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ1VzZXIgY2hhbmdlLiBOZXcgdXNlcjonLCB1c2VyLnRvS2V5KCkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2NhbFN0b3JlSGFuZGxlVXNlckNoYW5nZShzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB1c2VyKTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwuY3VycmVudFVzZXIgPSB1c2VyO1xuICAgICAgICAvLyBGYWlscyB0YXNrcyB3YWl0aW5nIGZvciBwZW5kaW5nIHdyaXRlcyByZXF1ZXN0ZWQgYnkgcHJldmlvdXMgdXNlci5cbiAgICAgICAgcmVqZWN0T3V0c3RhbmRpbmdQZW5kaW5nV3JpdGVzQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsLCBcIid3YWl0Rm9yUGVuZGluZ1dyaXRlcycgcHJvbWlzZSBpcyByZWplY3RlZCBkdWUgdG8gYSB1c2VyIGNoYW5nZS5cIik7XG4gICAgICAgIC8vIFRPRE8oYi8xMTQyMjY0MTcpOiBDb25zaWRlciBjYWxsaW5nIHRoaXMgb25seSBpbiB0aGUgcHJpbWFyeSB0YWIuXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmhhbmRsZVVzZXJDaGFuZ2UodXNlciwgcmVzdWx0LnJlbW92ZWRCYXRjaElkcywgcmVzdWx0LmFkZGVkQmF0Y2hJZHMpO1xuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lSW1wbCwgcmVzdWx0LmFmZmVjdGVkRG9jdW1lbnRzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzeW5jRW5naW5lR2V0UmVtb3RlS2V5c0ZvclRhcmdldChzeW5jRW5naW5lLCB0YXJnZXRJZCkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGNvbnN0IGxpbWJvUmVzb2x1dGlvbiA9IHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvUmVzb2x1dGlvbnNCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xuICAgIGlmIChsaW1ib1Jlc29sdXRpb24gJiYgbGltYm9SZXNvbHV0aW9uLnJlY2VpdmVkRG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50S2V5U2V0KCkuYWRkKGxpbWJvUmVzb2x1dGlvbi5rZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGtleVNldCA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuZ2V0KHRhcmdldElkKTtcbiAgICAgICAgaWYgKCFxdWVyaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5U2V0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcXVlcnkgb2YgcXVlcmllcykge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlWaWV3ID0gc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZ2V0KHF1ZXJ5KTtcbiAgICAgICAgICAgIGtleVNldCA9IGtleVNldC51bmlvbldpdGgocXVlcnlWaWV3LnZpZXcuc3luY2VkRG9jdW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5U2V0O1xuICAgIH1cbn1cbi8qKlxuICogUmVjb25jaWxlIHRoZSBsaXN0IG9mIHN5bmNlZCBkb2N1bWVudHMgaW4gYW4gZXhpc3RpbmcgdmlldyB3aXRoIHRob3NlXG4gKiBmcm9tIHBlcnNpc3RlbmNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzeW5jaHJvbml6ZVZpZXdBbmRDb21wdXRlU25hcHNob3Qoc3luY0VuZ2luZSwgcXVlcnlWaWV3KSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgY29uc3QgcXVlcnlSZXN1bHQgPSBhd2FpdCBsb2NhbFN0b3JlRXhlY3V0ZVF1ZXJ5KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5Vmlldy5xdWVyeSwgXG4gICAgLyogdXNlUHJldmlvdXNSZXN1bHRzPSAqLyB0cnVlKTtcbiAgICBjb25zdCB2aWV3U25hcHNob3QgPSBxdWVyeVZpZXcudmlldy5zeW5jaHJvbml6ZVdpdGhQZXJzaXN0ZWRTdGF0ZShxdWVyeVJlc3VsdCk7XG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCkge1xuICAgICAgICB1cGRhdGVUcmFja2VkTGltYm9zKHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcudGFyZ2V0SWQsIHZpZXdTbmFwc2hvdC5saW1ib0NoYW5nZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdmlld1NuYXBzaG90O1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgbmV3bHkgY2hhbmdlZCBkb2N1bWVudHMgZnJvbSByZW1vdGUgZG9jdW1lbnQgY2FjaGUgYW5kIHJhaXNlc1xuICogc25hcHNob3RzIGlmIG5lZWRlZC5cbiAqL1xuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVTeW5jaHJvbml6ZVdpdGhDaGFuZ2VkRG9jdW1lbnRzKHN5bmNFbmdpbmUsIGNvbGxlY3Rpb25Hcm91cCkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlR2V0TmV3RG9jdW1lbnRDaGFuZ2VzKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIGNvbGxlY3Rpb25Hcm91cCkudGhlbihjaGFuZ2VzID0+IHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmVJbXBsLCBjaGFuZ2VzKSk7XG59XG4vKiogQXBwbGllcyBhIG11dGF0aW9uIHN0YXRlIHRvIGFuIGV4aXN0aW5nIGJhdGNoLiAgKi9cbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lQXBwbHlCYXRjaFN0YXRlKHN5bmNFbmdpbmUsIGJhdGNoSWQsIGJhdGNoU3RhdGUsIGVycm9yKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgY29uc3QgZG9jdW1lbnRzID0gYXdhaXQgbG9jYWxTdG9yZUxvb2t1cE11dGF0aW9uRG9jdW1lbnRzKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIGJhdGNoSWQpO1xuICAgIGlmIChkb2N1bWVudHMgPT09IG51bGwpIHtcbiAgICAgICAgLy8gQSB0aHJvdHRsZWQgdGFiIG1heSBub3QgaGF2ZSBzZWVuIHRoZSBtdXRhdGlvbiBiZWZvcmUgaXQgd2FzIGNvbXBsZXRlZFxuICAgICAgICAvLyBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBtdXRhdGlvbiBxdWV1ZSwgaW4gd2hpY2ggY2FzZSB3ZSB3b24ndCBoYXZlIGNhY2hlZFxuICAgICAgICAvLyB0aGUgYWZmZWN0ZWQgZG9jdW1lbnRzLiBJbiB0aGlzIGNhc2Ugd2UgY2FuIHNhZmVseSBpZ25vcmUgdGhlIHVwZGF0ZVxuICAgICAgICAvLyBzaW5jZSB0aGF0IG1lYW5zIHdlIGRpZG4ndCBhcHBseSB0aGUgbXV0YXRpb24gbG9jYWxseSBhdCBhbGwgKGlmIHdlXG4gICAgICAgIC8vIGhhZCwgd2Ugd291bGQgaGF2ZSBjYWNoZWQgdGhlIGFmZmVjdGVkIGRvY3VtZW50cyksIGFuZCBzbyB3ZSB3aWxsIGp1c3RcbiAgICAgICAgLy8gc2VlIGFueSByZXN1bHRpbmcgZG9jdW1lbnQgY2hhbmdlcyB2aWEgbm9ybWFsIHJlbW90ZSBkb2N1bWVudCB1cGRhdGVzXG4gICAgICAgIC8vIGFzIGFwcGxpY2FibGUuXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ0Nhbm5vdCBhcHBseSBtdXRhdGlvbiBiYXRjaCB3aXRoIGlkOiAnICsgYmF0Y2hJZCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGJhdGNoU3RhdGUgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgdGhlIHByaW1hcnkgY2xpZW50LCB3ZSBuZWVkIHRvIHNlbmQgdGhpcyB3cml0ZSB0byB0aGVcbiAgICAgICAgLy8gYmFja2VuZC4gU2Vjb25kYXJ5IGNsaWVudHMgd2lsbCBpZ25vcmUgdGhlc2Ugd3JpdGVzIHNpbmNlIHRoZWlyIHJlbW90ZVxuICAgICAgICAvLyBjb25uZWN0aW9uIGlzIGRpc2FibGVkLlxuICAgICAgICBhd2FpdCBmaWxsV3JpdGVQaXBlbGluZShzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJhdGNoU3RhdGUgPT09ICdhY2tub3dsZWRnZWQnIHx8IGJhdGNoU3RhdGUgPT09ICdyZWplY3RlZCcpIHtcbiAgICAgICAgLy8gTk9URTogQm90aCB0aGVzZSBtZXRob2RzIGFyZSBuby1vcHMgZm9yIGJhdGNoZXMgdGhhdCBvcmlnaW5hdGVkIGZyb21cbiAgICAgICAgLy8gb3RoZXIgY2xpZW50cy5cbiAgICAgICAgcHJvY2Vzc1VzZXJDYWxsYmFjayhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCwgZXJyb3IgPyBlcnJvciA6IG51bGwpO1xuICAgICAgICB0cmlnZ2VyUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCk7XG4gICAgICAgIGxvY2FsU3RvcmVSZW1vdmVDYWNoZWRNdXRhdGlvbkJhdGNoTWV0YWRhdGEoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgYmF0Y2hJZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmYWlsKDB4MWE0MCwgYFVua25vd24gYmF0Y2hTdGF0ZWAsIHsgYmF0Y2hTdGF0ZSB9KTtcbiAgICB9XG4gICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGRvY3VtZW50cyk7XG59XG4vKiogQXBwbGllcyBhIHF1ZXJ5IHRhcmdldCBjaGFuZ2UgZnJvbSBhIGRpZmZlcmVudCB0YWIuICovXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUFwcGx5UHJpbWFyeVN0YXRlKHN5bmNFbmdpbmUsIGlzUHJpbWFyeSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGVuc3VyZVdhdGNoQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsKTtcbiAgICBzeW5jRW5naW5lRW5zdXJlV3JpdGVDYWxsYmFja3Moc3luY0VuZ2luZUltcGwpO1xuICAgIGlmIChpc1ByaW1hcnkgPT09IHRydWUgJiYgc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCAhPT0gdHJ1ZSkge1xuICAgICAgICAvLyBTZWNvbmRhcnkgdGFicyBvbmx5IG1haW50YWluIFZpZXdzIGZvciB0aGVpciBsb2NhbCBsaXN0ZW5lcnMgYW5kIHRoZVxuICAgICAgICAvLyBWaWV3cyBpbnRlcm5hbCBzdGF0ZSBtYXkgbm90IGJlIDEwMCUgcG9wdWxhdGVkIChpbiBwYXJ0aWN1bGFyXG4gICAgICAgIC8vIHNlY29uZGFyeSB0YWJzIGRvbid0IHRyYWNrIHN5bmNlZERvY3VtZW50cywgdGhlIHNldCBvZiBkb2N1bWVudHMgdGhlXG4gICAgICAgIC8vIHNlcnZlciBjb25zaWRlcnMgdG8gYmUgaW4gdGhlIHRhcmdldCkuIFNvIHdoZW4gYSBzZWNvbmRhcnkgYmVjb21lc1xuICAgICAgICAvLyBwcmltYXJ5LCB3ZSBuZWVkIHRvIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIHZpZXdzIGZvciBhbGwgdGFyZ2V0c1xuICAgICAgICAvLyBtYXRjaCB0aGUgc3RhdGUgb24gZGlzay5cbiAgICAgICAgY29uc3QgYWN0aXZlVGFyZ2V0cyA9IHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmdldEFsbEFjdGl2ZVF1ZXJ5VGFyZ2V0cygpO1xuICAgICAgICBjb25zdCBhY3RpdmVRdWVyaWVzID0gYXdhaXQgc3luY2hyb25pemVRdWVyeVZpZXdzQW5kUmFpc2VTbmFwc2hvdHMoc3luY0VuZ2luZUltcGwsIGFjdGl2ZVRhcmdldHMudG9BcnJheSgpKTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCA9IHRydWU7XG4gICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlQXBwbHlQcmltYXJ5U3RhdGUoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRydWUpO1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldERhdGEgb2YgYWN0aXZlUXVlcmllcykge1xuICAgICAgICAgICAgcmVtb3RlU3RvcmVMaXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUHJpbWFyeSA9PT0gZmFsc2UgJiYgc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlVGFyZ2V0cyA9IFtdO1xuICAgICAgICBsZXQgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuZm9yRWFjaCgoXywgdGFyZ2V0SWQpID0+IHtcbiAgICAgICAgICAgIGlmIChzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5pc0xvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlVGFyZ2V0cy5wdXNoKHRhcmdldElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSBwLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVBbmRDbGVhbnVwVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlUmVsZWFzZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXRJZCwgXG4gICAgICAgICAgICAgICAgICAgIC8qa2VlcFBlcnNpc3RlZFRhcmdldERhdGE9Ki8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0YXJnZXRJZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBwO1xuICAgICAgICBhd2FpdCBzeW5jaHJvbml6ZVF1ZXJ5Vmlld3NBbmRSYWlzZVNuYXBzaG90cyhzeW5jRW5naW5lSW1wbCwgYWN0aXZlVGFyZ2V0cyk7XG4gICAgICAgIHJlc2V0TGltYm9Eb2N1bWVudHMoc3luY0VuZ2luZUltcGwpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5faXNQcmltYXJ5Q2xpZW50ID0gZmFsc2U7XG4gICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlQXBwbHlQcmltYXJ5U3RhdGUoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIGZhbHNlKTtcbiAgICB9XG59XG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuZnVuY3Rpb24gcmVzZXRMaW1ib0RvY3VtZW50cyhzeW5jRW5naW5lKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmZvckVhY2goKF8sIHRhcmdldElkKSA9PiB7XG4gICAgICAgIHJlbW90ZVN0b3JlVW5saXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldElkKTtcbiAgICB9KTtcbiAgICBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5yZW1vdmVBbGxSZWZlcmVuY2VzKCk7XG4gICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0ID0gbmV3IE1hcCgpO1xuICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5ID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbn1cbi8qKlxuICogUmVjb25jaWxlIHRoZSBxdWVyeSB2aWV3cyBvZiB0aGUgcHJvdmlkZWQgcXVlcnkgdGFyZ2V0cyB3aXRoIHRoZSBzdGF0ZSBmcm9tXG4gKiBwZXJzaXN0ZW5jZS4gUmFpc2VzIHNuYXBzaG90cyBmb3IgYW55IGNoYW5nZXMgdGhhdCBhZmZlY3QgdGhlIGxvY2FsXG4gKiBjbGllbnQgYW5kIHJldHVybnMgdGhlIHVwZGF0ZWQgc3RhdGUgb2YgYWxsIHRhcmdldCdzIHF1ZXJ5IGRhdGEuXG4gKlxuICogQHBhcmFtIHN5bmNFbmdpbmUgLSBUaGUgc3luYyBlbmdpbmUgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB0YXJnZXRzIC0gdGhlIGxpc3Qgb2YgdGFyZ2V0cyB3aXRoIHZpZXdzIHRoYXQgbmVlZCB0byBiZSByZWNvbXB1dGVkXG4gKiBAcGFyYW0gdHJhbnNpdGlvblRvUHJpbWFyeSAtIGB0cnVlYCBpZmYgdGhlIHRhYiB0cmFuc2l0aW9ucyBmcm9tIGEgc2Vjb25kYXJ5XG4gKiB0YWIgdG8gYSBwcmltYXJ5IHRhYlxuICovXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuYXN5bmMgZnVuY3Rpb24gc3luY2hyb25pemVRdWVyeVZpZXdzQW5kUmFpc2VTbmFwc2hvdHMoc3luY0VuZ2luZSwgdGFyZ2V0cywgdHJhbnNpdGlvblRvUHJpbWFyeSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGNvbnN0IGFjdGl2ZVF1ZXJpZXMgPSBbXTtcbiAgICBjb25zdCBuZXdWaWV3U25hcHNob3RzID0gW107XG4gICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiB0YXJnZXRzKSB7XG4gICAgICAgIGxldCB0YXJnZXREYXRhO1xuICAgICAgICBjb25zdCBxdWVyaWVzID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgICAgIGlmIChxdWVyaWVzICYmIHF1ZXJpZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBGb3IgcXVlcmllcyB0aGF0IGhhdmUgYSBsb2NhbCBWaWV3LCB3ZSBmZXRjaCB0aGVpciBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgICAvLyBmcm9tIExvY2FsU3RvcmUgKGFzIHRoZSByZXN1bWUgdG9rZW4gYW5kIHRoZSBzbmFwc2hvdCB2ZXJzaW9uXG4gICAgICAgICAgICAvLyBtaWdodCBoYXZlIGNoYW5nZWQpIGFuZCByZWNvbmNpbGUgdGhlaXIgdmlld3Mgd2l0aCB0aGUgcGVyc2lzdGVkXG4gICAgICAgICAgICAvLyBzdGF0ZSAodGhlIGxpc3Qgb2Ygc3luY2VkRG9jdW1lbnRzIG1heSBoYXZlIGdvdHRlbiBvdXQgb2Ygc3luYykuXG4gICAgICAgICAgICB0YXJnZXREYXRhID0gYXdhaXQgbG9jYWxTdG9yZUFsbG9jYXRlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5VG9UYXJnZXQocXVlcmllc1swXSkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBxdWVyeSBvZiBxdWVyaWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnlWaWV3ID0gc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZ2V0KHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3Q2hhbmdlID0gYXdhaXQgc3luY2hyb25pemVWaWV3QW5kQ29tcHV0ZVNuYXBzaG90KHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcpO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3Q2hhbmdlLnNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZpZXdTbmFwc2hvdHMucHVzaCh2aWV3Q2hhbmdlLnNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgcXVlcmllcyB0aGF0IG5ldmVyIGV4ZWN1dGVkIG9uIHRoaXMgY2xpZW50LCB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBhbGxvY2F0ZSB0aGUgdGFyZ2V0IGluIExvY2FsU3RvcmUgYW5kIGluaXRpYWxpemUgYSBuZXcgVmlldy5cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGF3YWl0IGxvY2FsU3RvcmVHZXRDYWNoZWRUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0SWQpO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YSA9IGF3YWl0IGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXQpO1xuICAgICAgICAgICAgYXdhaXQgaW5pdGlhbGl6ZVZpZXdBbmRDb21wdXRlU25hcHNob3Qoc3luY0VuZ2luZUltcGwsIHN5bnRoZXNpemVUYXJnZXRUb1F1ZXJ5KHRhcmdldCksIHRhcmdldElkLCBcbiAgICAgICAgICAgIC8qY3VycmVudD0qLyBmYWxzZSwgdGFyZ2V0RGF0YS5yZXN1bWVUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlUXVlcmllcy5wdXNoKHRhcmdldERhdGEpO1xuICAgIH1cbiAgICBzeW5jRW5naW5lSW1wbC5zeW5jRW5naW5lTGlzdGVuZXIub25XYXRjaENoYW5nZShuZXdWaWV3U25hcHNob3RzKTtcbiAgICByZXR1cm4gYWN0aXZlUXVlcmllcztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBRdWVyeWAgb2JqZWN0IGZyb20gdGhlIHNwZWNpZmllZCBgVGFyZ2V0YC4gVGhlcmUgaXMgbm8gd2F5IHRvXG4gKiBvYnRhaW4gdGhlIG9yaWdpbmFsIGBRdWVyeWAsIHNvIHdlIHN5bnRoZXNpemUgYSBgUXVlcnlgIGZyb20gdGhlIGBUYXJnZXRgXG4gKiBvYmplY3QuXG4gKlxuICogVGhlIHN5bnRoZXNpemVkIHJlc3VsdCBtaWdodCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgb3JpZ2luYWwgYFF1ZXJ5YCwgYnV0XG4gKiBzaW5jZSB0aGUgc3ludGhlc2l6ZWQgYFF1ZXJ5YCBzaG91bGQgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdHMgYXMgdGhlXG4gKiBvcmlnaW5hbCBvbmUgKG9ubHkgdGhlIHByZXNlbnRhdGlvbiBvZiByZXN1bHRzIG1pZ2h0IGRpZmZlciksIHRoZSBwb3RlbnRpYWxcbiAqIGRpZmZlcmVuY2Ugd2lsbCBub3QgY2F1c2UgaXNzdWVzLlxuICovXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuZnVuY3Rpb24gc3ludGhlc2l6ZVRhcmdldFRvUXVlcnkodGFyZ2V0KSB7XG4gICAgcmV0dXJuIG5ld1F1ZXJ5KHRhcmdldC5wYXRoLCB0YXJnZXQuY29sbGVjdGlvbkdyb3VwLCB0YXJnZXQub3JkZXJCeSwgdGFyZ2V0LmZpbHRlcnMsIHRhcmdldC5saW1pdCwgXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovLCB0YXJnZXQuc3RhcnRBdCwgdGFyZ2V0LmVuZEF0KTtcbn1cbi8qKiBSZXR1cm5zIHRoZSBJRHMgb2YgdGhlIGNsaWVudHMgdGhhdCBhcmUgY3VycmVudGx5IGFjdGl2ZS4gKi9cbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXG5mdW5jdGlvbiBzeW5jRW5naW5lR2V0QWN0aXZlQ2xpZW50cyhzeW5jRW5naW5lKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVHZXRBY3RpdmVDbGllbnRzKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUpO1xufVxuLyoqIEFwcGxpZXMgYSBxdWVyeSB0YXJnZXQgY2hhbmdlIGZyb20gYSBkaWZmZXJlbnQgdGFiLiAqL1xuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseVRhcmdldFN0YXRlKHN5bmNFbmdpbmUsIHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBpZiAoc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCkge1xuICAgICAgICAvLyBJZiB3ZSByZWNlaXZlIGEgdGFyZ2V0IHN0YXRlIG5vdGlmaWNhdGlvbiB2aWEgV2ViU3RvcmFnZSwgd2UgYXJlXG4gICAgICAgIC8vIGVpdGhlciBhbHJlYWR5IHNlY29uZGFyeSBvciBhbm90aGVyIHRhYiBoYXMgdGFrZW4gdGhlIHByaW1hcnkgbGVhc2UuXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ0lnbm9yaW5nIHVuZXhwZWN0ZWQgcXVlcnkgc3RhdGUgbm90aWZpY2F0aW9uLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5ID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XG4gICAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnY3VycmVudCc6XG4gICAgICAgICAgICBjYXNlICdub3QtY3VycmVudCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gYXdhaXQgbG9jYWxTdG9yZUdldE5ld0RvY3VtZW50Q2hhbmdlcyhzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBxdWVyeUNvbGxlY3Rpb25Hcm91cChxdWVyeVswXSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bnRoZXNpemVkUmVtb3RlRXZlbnQgPSBSZW1vdGVFdmVudC5jcmVhdGVTeW50aGVzaXplZFJlbW90ZUV2ZW50Rm9yQ3VycmVudENoYW5nZSh0YXJnZXRJZCwgc3RhdGUgPT09ICdjdXJyZW50JywgQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMsIHN5bnRoZXNpemVkUmVtb3RlRXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAncmVqZWN0ZWQnOiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0SWQsIFxuICAgICAgICAgICAgICAgIC8qIGtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhICovIHRydWUpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUFuZENsZWFudXBUYXJnZXQoc3luY0VuZ2luZUltcGwsIHRhcmdldElkLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGZhaWwoMHhmYTliLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogQWRkcyBvciByZW1vdmVzIFdhdGNoIHRhcmdldHMgZm9yIHF1ZXJpZXMgZnJvbSBkaWZmZXJlbnQgdGFicy4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseUFjdGl2ZVRhcmdldHNDaGFuZ2Uoc3luY0VuZ2luZSwgYWRkZWQsIHJlbW92ZWQpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGVuc3VyZVdhdGNoQ2FsbGJhY2tzKHN5bmNFbmdpbmUpO1xuICAgIGlmICghc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgdGFyZ2V0SWQgb2YgYWRkZWQpIHtcbiAgICAgICAgLy8gQSB0YXJnZXQgaXMgYWxyZWFkeSBsaXN0ZW5pbmcgdG8gcmVtb3RlIHN0b3JlIGlmIGl0IGlzIGFscmVhZHkgcmVnaXN0ZXJlZCB0b1xuICAgICAgICAvLyBzaGFyZWRDbGllbnRTdGF0ZS5cbiAgICAgICAgY29uc3QgdGFyZ2V0QWxyZWFkeUxpc3RlbmluZ1RvUmVtb3RlU3RvcmUgPSBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuaGFzKHRhcmdldElkKSAmJlxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuaXNBY3RpdmVRdWVyeVRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgIGlmICh0YXJnZXRBbHJlYWR5TGlzdGVuaW5nVG9SZW1vdGVTdG9yZSkge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnQWRkaW5nIGFuIGFscmVhZHkgYWN0aXZlIHRhcmdldCAnICsgdGFyZ2V0SWQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXdhaXQgbG9jYWxTdG9yZUdldENhY2hlZFRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXRJZCk7XG4gICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSBhd2FpdCBsb2NhbFN0b3JlQWxsb2NhdGVUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0KTtcbiAgICAgICAgYXdhaXQgaW5pdGlhbGl6ZVZpZXdBbmRDb21wdXRlU25hcHNob3Qoc3luY0VuZ2luZUltcGwsIHN5bnRoZXNpemVUYXJnZXRUb1F1ZXJ5KHRhcmdldCksIHRhcmdldERhdGEudGFyZ2V0SWQsIFxuICAgICAgICAvKmN1cnJlbnQ9Ki8gZmFsc2UsIHRhcmdldERhdGEucmVzdW1lVG9rZW4pO1xuICAgICAgICByZW1vdGVTdG9yZUxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgdGFyZ2V0RGF0YSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdGFyZ2V0SWQgb2YgcmVtb3ZlZCkge1xuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSB0YXJnZXQgaXMgc3RpbGwgYWN0aXZlIHNpbmNlIHRoZSB0YXJnZXQgbWlnaHQgaGF2ZSBiZWVuXG4gICAgICAgIC8vIHJlbW92ZWQgaWYgaXQgaGFzIGJlZW4gcmVqZWN0ZWQgYnkgdGhlIGJhY2tlbmQuXG4gICAgICAgIGlmICghc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0Lmhhcyh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbGVhc2UgcXVlcmllcyB0aGF0IGFyZSBzdGlsbCBhY3RpdmUuXG4gICAgICAgIGF3YWl0IGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHRhcmdldElkLCBcbiAgICAgICAgLyoga2VlcFBlcnNpc3RlZFRhcmdldERhdGEgKi8gZmFsc2UpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0YXJnZXRJZCk7XG4gICAgICAgICAgICByZW1vdmVBbmRDbGVhbnVwVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnN1cmVXYXRjaENhbGxiYWNrcyhzeW5jRW5naW5lKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUucmVtb3RlU3luY2VyLmFwcGx5UmVtb3RlRXZlbnQgPVxuICAgICAgICBzeW5jRW5naW5lQXBwbHlSZW1vdGVFdmVudC5iaW5kKG51bGwsIHN5bmNFbmdpbmVJbXBsKTtcbiAgICBzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCA9XG4gICAgICAgIHN5bmNFbmdpbmVHZXRSZW1vdGVLZXlzRm9yVGFyZ2V0LmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwpO1xuICAgIHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLnJlbW90ZVN5bmNlci5yZWplY3RMaXN0ZW4gPVxuICAgICAgICBzeW5jRW5naW5lUmVqZWN0TGlzdGVuLmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwpO1xuICAgIHN5bmNFbmdpbmVJbXBsLnN5bmNFbmdpbmVMaXN0ZW5lci5vbldhdGNoQ2hhbmdlID1cbiAgICAgICAgZXZlbnRNYW5hZ2VyT25XYXRjaENoYW5nZS5iaW5kKG51bGwsIHN5bmNFbmdpbmVJbXBsLmV2ZW50TWFuYWdlcik7XG4gICAgc3luY0VuZ2luZUltcGwuc3luY0VuZ2luZUxpc3RlbmVyLm9uV2F0Y2hFcnJvciA9XG4gICAgICAgIGV2ZW50TWFuYWdlck9uV2F0Y2hFcnJvci5iaW5kKG51bGwsIHN5bmNFbmdpbmVJbXBsLmV2ZW50TWFuYWdlcik7XG4gICAgcmV0dXJuIHN5bmNFbmdpbmVJbXBsO1xufVxuZnVuY3Rpb24gc3luY0VuZ2luZUVuc3VyZVdyaXRlQ2FsbGJhY2tzKHN5bmNFbmdpbmUpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIuYXBwbHlTdWNjZXNzZnVsV3JpdGUgPVxuICAgICAgICBzeW5jRW5naW5lQXBwbHlTdWNjZXNzZnVsV3JpdGUuYmluZChudWxsLCBzeW5jRW5naW5lSW1wbCk7XG4gICAgc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUucmVtb3RlU3luY2VyLnJlamVjdEZhaWxlZFdyaXRlID1cbiAgICAgICAgc3luY0VuZ2luZVJlamVjdEZhaWxlZFdyaXRlLmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwpO1xuICAgIHJldHVybiBzeW5jRW5naW5lSW1wbDtcbn1cbi8qKlxuICogTG9hZHMgYSBGaXJlc3RvcmUgYnVuZGxlIGludG8gdGhlIFNESy4gVGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMgd2hlblxuICogdGhlIGJ1bmRsZSBmaW5pc2hlZCBsb2FkaW5nLlxuICpcbiAqIEBwYXJhbSBzeW5jRW5naW5lIC0gU3luY0VuZ2luZSB0byB1c2UuXG4gKiBAcGFyYW0gYnVuZGxlUmVhZGVyIC0gQnVuZGxlIHRvIGxvYWQgaW50byB0aGUgU0RLLlxuICogQHBhcmFtIHRhc2sgLSBMb2FkQnVuZGxlVGFzayB1c2VkIHRvIHVwZGF0ZSB0aGUgbG9hZGluZyBwcm9ncmVzcyB0byBwdWJsaWMgQVBJLlxuICovXG5mdW5jdGlvbiBzeW5jRW5naW5lTG9hZEJ1bmRsZShzeW5jRW5naW5lLCBidW5kbGVSZWFkZXIsIHRhc2spIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgbG9hZEJ1bmRsZUltcGwoc3luY0VuZ2luZUltcGwsIGJ1bmRsZVJlYWRlciwgdGFzaykudGhlbihjb2xsZWN0aW9uR3JvdXBzID0+IHtcbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUubm90aWZ5QnVuZGxlTG9hZGVkKGNvbGxlY3Rpb25Hcm91cHMpO1xuICAgIH0pO1xufVxuLyoqIExvYWRzIGEgYnVuZGxlIGFuZCByZXR1cm5zIHRoZSBsaXN0IG9mIGFmZmVjdGVkIGNvbGxlY3Rpb24gZ3JvdXBzLiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZEJ1bmRsZUltcGwoc3luY0VuZ2luZSwgcmVhZGVyLCB0YXNrKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCByZWFkZXIuZ2V0TWV0YWRhdGEoKTtcbiAgICAgICAgY29uc3Qgc2tpcCA9IGF3YWl0IGxvY2FsU3RvcmVIYXNOZXdlckJ1bmRsZShzeW5jRW5naW5lLmxvY2FsU3RvcmUsIG1ldGFkYXRhKTtcbiAgICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgICAgIGF3YWl0IHJlYWRlci5jbG9zZSgpO1xuICAgICAgICAgICAgdGFzay5fY29tcGxldGVXaXRoKGJ1bmRsZVN1Y2Nlc3NQcm9ncmVzcyhtZXRhZGF0YSkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgU2V0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRhc2suX3VwZGF0ZVByb2dyZXNzKGJ1bmRsZUluaXRpYWxQcm9ncmVzcyhtZXRhZGF0YSkpO1xuICAgICAgICBjb25zdCBsb2FkZXIgPSBuZXcgQnVuZGxlTG9hZGVyKG1ldGFkYXRhLCByZWFkZXIuc2VyaWFsaXplcik7XG4gICAgICAgIGxldCBlbGVtZW50ID0gYXdhaXQgcmVhZGVyLm5leHRFbGVtZW50KCk7XG4gICAgICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IGF3YWl0IGxvYWRlci5hZGRTaXplZEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICB0YXNrLl91cGRhdGVQcm9ncmVzcyhwcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50ID0gYXdhaXQgcmVhZGVyLm5leHRFbGVtZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZGVyLmNvbXBsZXRlQW5kU3RvcmVBc3luYyhzeW5jRW5naW5lLmxvY2FsU3RvcmUpO1xuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lLCByZXN1bHQuY2hhbmdlZERvY3MsIFxuICAgICAgICAvKiByZW1vdGVFdmVudCAqLyB1bmRlZmluZWQpO1xuICAgICAgICAvLyBTYXZlIG1ldGFkYXRhLCBzbyBsb2FkaW5nIHRoZSBzYW1lIGJ1bmRsZSB3aWxsIHNraXAuXG4gICAgICAgIGF3YWl0IGxvY2FsU3RvcmVTYXZlQnVuZGxlKHN5bmNFbmdpbmUubG9jYWxTdG9yZSwgbWV0YWRhdGEpO1xuICAgICAgICB0YXNrLl9jb21wbGV0ZVdpdGgocmVzdWx0LnByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQuY2hhbmdlZENvbGxlY3Rpb25Hcm91cHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsb2dXYXJuKExPR19UQUckMywgYExvYWRpbmcgYnVuZGxlIGZhaWxlZCB3aXRoICR7ZX1gKTtcbiAgICAgICAgdGFzay5fZmFpbFdpdGgoZSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IFNldCgpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVzIGFsbCBjb21wb25lbnRzIG5lZWRlZCBmb3IgRmlyZXN0b3JlIHdpdGggaW4tbWVtb3J5IHBlcnNpc3RlbmNlLlxuICogVXNlcyBFYWdlckdDIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAqL1xuY2xhc3MgTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5raW5kID0gJ21lbW9yeSc7XG4gICAgICAgIHRoaXMuc3luY2hyb25pemVUYWJzID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemUoY2ZnKSB7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IG5ld1NlcmlhbGl6ZXIoY2ZnLmRhdGFiYXNlSW5mby5kYXRhYmFzZUlkKTtcbiAgICAgICAgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZSA9IHRoaXMuY3JlYXRlU2hhcmVkQ2xpZW50U3RhdGUoY2ZnKTtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHRoaXMuY3JlYXRlUGVyc2lzdGVuY2UoY2ZnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5zdGFydCgpO1xuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSB0aGlzLmNyZWF0ZUxvY2FsU3RvcmUoY2ZnKTtcbiAgICAgICAgdGhpcy5nY1NjaGVkdWxlciA9IHRoaXMuY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnLCB0aGlzLmxvY2FsU3RvcmUpO1xuICAgICAgICB0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlciA9IHRoaXMuY3JlYXRlSW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyKGNmZywgdGhpcy5sb2NhbFN0b3JlKTtcbiAgICB9XG4gICAgY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnLCBsb2NhbFN0b3JlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjcmVhdGVJbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIoY2ZnLCBsb2NhbFN0b3JlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjcmVhdGVMb2NhbFN0b3JlKGNmZykge1xuICAgICAgICByZXR1cm4gbmV3TG9jYWxTdG9yZSh0aGlzLnBlcnNpc3RlbmNlLCBuZXcgUXVlcnlFbmdpbmUoKSwgY2ZnLmluaXRpYWxVc2VyLCB0aGlzLnNlcmlhbGl6ZXIpO1xuICAgIH1cbiAgICBjcmVhdGVQZXJzaXN0ZW5jZShjZmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlQZXJzaXN0ZW5jZShNZW1vcnlFYWdlckRlbGVnYXRlLmZhY3RvcnksIHRoaXMuc2VyaWFsaXplcik7XG4gICAgfVxuICAgIGNyZWF0ZVNoYXJlZENsaWVudFN0YXRlKGNmZykge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVNoYXJlZENsaWVudFN0YXRlKCk7XG4gICAgfVxuICAgIGFzeW5jIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgdGhpcy5nY1NjaGVkdWxlcj8uc3RvcCgpO1xuICAgICAgICB0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlcj8uc3RvcCgpO1xuICAgICAgICB0aGlzLnNoYXJlZENsaWVudFN0YXRlLnNodXRkb3duKCk7XG4gICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2Uuc2h1dGRvd24oKTtcbiAgICB9XG59XG5NZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIucHJvdmlkZXIgPSB7XG4gICAgYnVpbGQ6ICgpID0+IG5ldyBNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIoKVxufTtcbmNsYXNzIExydUdjTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIGV4dGVuZHMgTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWNoZVNpemVCeXRlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNhY2hlU2l6ZUJ5dGVzID0gY2FjaGVTaXplQnl0ZXM7XG4gICAgfVxuICAgIGNyZWF0ZUdhcmJhZ2VDb2xsZWN0aW9uU2NoZWR1bGVyKGNmZywgbG9jYWxTdG9yZSkge1xuICAgICAgICBoYXJkQXNzZXJ0KHRoaXMucGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGUgaW5zdGFuY2VvZiBNZW1vcnlMcnVEZWxlZ2F0ZSwgMHhiNzQzKTtcbiAgICAgICAgY29uc3QgZ2FyYmFnZUNvbGxlY3RvciA9IHRoaXMucGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGUuZ2FyYmFnZUNvbGxlY3RvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBMcnVTY2hlZHVsZXIoZ2FyYmFnZUNvbGxlY3RvciwgY2ZnLmFzeW5jUXVldWUsIGxvY2FsU3RvcmUpO1xuICAgIH1cbiAgICBjcmVhdGVQZXJzaXN0ZW5jZShjZmcpIHtcbiAgICAgICAgY29uc3QgbHJ1UGFyYW1zID0gdGhpcy5jYWNoZVNpemVCeXRlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IExydVBhcmFtcy53aXRoQ2FjaGVTaXplKHRoaXMuY2FjaGVTaXplQnl0ZXMpXG4gICAgICAgICAgICA6IExydVBhcmFtcy5ERUZBVUxUO1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVBlcnNpc3RlbmNlKHAgPT4gTWVtb3J5THJ1RGVsZWdhdGUuZmFjdG9yeShwLCBscnVQYXJhbXMpLCB0aGlzLnNlcmlhbGl6ZXIpO1xuICAgIH1cbn1cbi8qKlxuICogUHJvdmlkZXMgYWxsIGNvbXBvbmVudHMgbmVlZGVkIGZvciBGaXJlc3RvcmUgd2l0aCBJbmRleGVkREIgcGVyc2lzdGVuY2UuXG4gKi9cbmNsYXNzIEluZGV4ZWREYk9mZmxpbmVDb21wb25lbnRQcm92aWRlciBleHRlbmRzIE1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Iob25saW5lQ29tcG9uZW50UHJvdmlkZXIsIGNhY2hlU2l6ZUJ5dGVzLCBmb3JjZU93bmVyc2hpcCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gb25saW5lQ29tcG9uZW50UHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBjYWNoZVNpemVCeXRlcztcbiAgICAgICAgdGhpcy5mb3JjZU93bmVyc2hpcCA9IGZvcmNlT3duZXJzaGlwO1xuICAgICAgICB0aGlzLmtpbmQgPSAncGVyc2lzdGVudCc7XG4gICAgICAgIHRoaXMuc3luY2hyb25pemVUYWJzID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemUoY2ZnKSB7XG4gICAgICAgIGF3YWl0IHN1cGVyLmluaXRpYWxpemUoY2ZnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlci5pbml0aWFsaXplKHRoaXMsIGNmZyk7XG4gICAgICAgIC8vIEVucXVldWUgd3JpdGVzIGZyb20gYSBwcmV2aW91cyBzZXNzaW9uXG4gICAgICAgIGF3YWl0IHN5bmNFbmdpbmVFbnN1cmVXcml0ZUNhbGxiYWNrcyh0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmUpO1xuICAgICAgICBhd2FpdCBmaWxsV3JpdGVQaXBlbGluZSh0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnJlbW90ZVN0b3JlKTtcbiAgICAgICAgLy8gTk9URTogVGhpcyB3aWxsIGltbWVkaWF0ZWx5IGNhbGwgdGhlIGxpc3RlbmVyLCBzbyB3ZSBtYWtlIHN1cmUgdG9cbiAgICAgICAgLy8gc2V0IGl0IGFmdGVyIGxvY2FsU3RvcmUgLyByZW1vdGVTdG9yZSBhcmUgc3RhcnRlZC5cbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5zZXRQcmltYXJ5U3RhdGVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5nY1NjaGVkdWxlciAmJiAhdGhpcy5nY1NjaGVkdWxlci5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nY1NjaGVkdWxlci5zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlci5zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlTG9jYWxTdG9yZShjZmcpIHtcbiAgICAgICAgcmV0dXJuIG5ld0xvY2FsU3RvcmUodGhpcy5wZXJzaXN0ZW5jZSwgbmV3IFF1ZXJ5RW5naW5lKCksIGNmZy5pbml0aWFsVXNlciwgdGhpcy5zZXJpYWxpemVyKTtcbiAgICB9XG4gICAgY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnLCBsb2NhbFN0b3JlKSB7XG4gICAgICAgIGNvbnN0IGdhcmJhZ2VDb2xsZWN0b3IgPSB0aGlzLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlLmdhcmJhZ2VDb2xsZWN0b3I7XG4gICAgICAgIHJldHVybiBuZXcgTHJ1U2NoZWR1bGVyKGdhcmJhZ2VDb2xsZWN0b3IsIGNmZy5hc3luY1F1ZXVlLCBsb2NhbFN0b3JlKTtcbiAgICB9XG4gICAgY3JlYXRlSW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyKGNmZywgbG9jYWxTdG9yZSkge1xuICAgICAgICBjb25zdCBpbmRleEJhY2tmaWxsZXIgPSBuZXcgSW5kZXhCYWNrZmlsbGVyKGxvY2FsU3RvcmUsIHRoaXMucGVyc2lzdGVuY2UpO1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4QmFja2ZpbGxlclNjaGVkdWxlcihjZmcuYXN5bmNRdWV1ZSwgaW5kZXhCYWNrZmlsbGVyKTtcbiAgICB9XG4gICAgY3JlYXRlUGVyc2lzdGVuY2UoY2ZnKSB7XG4gICAgICAgIGNvbnN0IHBlcnNpc3RlbmNlS2V5ID0gaW5kZXhlZERiU3RvcmFnZVByZWZpeChjZmcuZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQsIGNmZy5kYXRhYmFzZUluZm8ucGVyc2lzdGVuY2VLZXkpO1xuICAgICAgICBjb25zdCBscnVQYXJhbXMgPSB0aGlzLmNhY2hlU2l6ZUJ5dGVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gTHJ1UGFyYW1zLndpdGhDYWNoZVNpemUodGhpcy5jYWNoZVNpemVCeXRlcylcbiAgICAgICAgICAgIDogTHJ1UGFyYW1zLkRFRkFVTFQ7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiUGVyc2lzdGVuY2UodGhpcy5zeW5jaHJvbml6ZVRhYnMsIHBlcnNpc3RlbmNlS2V5LCBjZmcuY2xpZW50SWQsIGxydVBhcmFtcywgY2ZnLmFzeW5jUXVldWUsIGdldFdpbmRvdygpLCBnZXREb2N1bWVudCgpLCB0aGlzLnNlcmlhbGl6ZXIsIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUsICEhdGhpcy5mb3JjZU93bmVyc2hpcCk7XG4gICAgfVxuICAgIGNyZWF0ZVNoYXJlZENsaWVudFN0YXRlKGNmZykge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVNoYXJlZENsaWVudFN0YXRlKCk7XG4gICAgfVxufVxuLyoqXG4gKiBQcm92aWRlcyBhbGwgY29tcG9uZW50cyBuZWVkZWQgZm9yIEZpcmVzdG9yZSB3aXRoIG11bHRpLXRhYiBJbmRleGVkREJcbiAqIHBlcnNpc3RlbmNlLlxuICpcbiAqIEluIHRoZSBsZWdhY3kgY2xpZW50LCB0aGlzIHByb3ZpZGVyIGlzIHVzZWQgdG8gcHJvdmlkZSBib3RoIG11bHRpLXRhYiBhbmRcbiAqIG5vbi1tdWx0aS10YWIgcGVyc2lzdGVuY2Ugc2luY2Ugd2UgY2Fubm90IHRlbGwgYXQgYnVpbGQgdGltZSB3aGV0aGVyXG4gKiBgc3luY2hyb25pemVUYWJzYCB3aWxsIGJlIGVuYWJsZWQuXG4gKi9cbmNsYXNzIE11bHRpVGFiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIGV4dGVuZHMgSW5kZXhlZERiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvbmxpbmVDb21wb25lbnRQcm92aWRlciwgY2FjaGVTaXplQnl0ZXMpIHtcbiAgICAgICAgc3VwZXIob25saW5lQ29tcG9uZW50UHJvdmlkZXIsIGNhY2hlU2l6ZUJ5dGVzLCAvKiBmb3JjZU93bmVyc2hpcD0gKi8gZmFsc2UpO1xuICAgICAgICB0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gb25saW5lQ29tcG9uZW50UHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBjYWNoZVNpemVCeXRlcztcbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZVRhYnMgPSB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplKGNmZykge1xuICAgICAgICBhd2FpdCBzdXBlci5pbml0aWFsaXplKGNmZyk7XG4gICAgICAgIGNvbnN0IHN5bmNFbmdpbmUgPSB0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmU7XG4gICAgICAgIGlmICh0aGlzLnNoYXJlZENsaWVudFN0YXRlIGluc3RhbmNlb2YgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNoYXJlZENsaWVudFN0YXRlLnN5bmNFbmdpbmUgPSB7XG4gICAgICAgICAgICAgICAgYXBwbHlCYXRjaFN0YXRlOiBzeW5jRW5naW5lQXBwbHlCYXRjaFN0YXRlLmJpbmQobnVsbCwgc3luY0VuZ2luZSksXG4gICAgICAgICAgICAgICAgYXBwbHlUYXJnZXRTdGF0ZTogc3luY0VuZ2luZUFwcGx5VGFyZ2V0U3RhdGUuYmluZChudWxsLCBzeW5jRW5naW5lKSxcbiAgICAgICAgICAgICAgICBhcHBseUFjdGl2ZVRhcmdldHNDaGFuZ2U6IHN5bmNFbmdpbmVBcHBseUFjdGl2ZVRhcmdldHNDaGFuZ2UuYmluZChudWxsLCBzeW5jRW5naW5lKSxcbiAgICAgICAgICAgICAgICBnZXRBY3RpdmVDbGllbnRzOiBzeW5jRW5naW5lR2V0QWN0aXZlQ2xpZW50cy5iaW5kKG51bGwsIHN5bmNFbmdpbmUpLFxuICAgICAgICAgICAgICAgIHN5bmNocm9uaXplV2l0aENoYW5nZWREb2N1bWVudHM6IHN5bmNFbmdpbmVTeW5jaHJvbml6ZVdpdGhDaGFuZ2VkRG9jdW1lbnRzLmJpbmQobnVsbCwgc3luY0VuZ2luZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNoYXJlZENsaWVudFN0YXRlLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URTogVGhpcyB3aWxsIGltbWVkaWF0ZWx5IGNhbGwgdGhlIGxpc3RlbmVyLCBzbyB3ZSBtYWtlIHN1cmUgdG9cbiAgICAgICAgLy8gc2V0IGl0IGFmdGVyIGxvY2FsU3RvcmUgLyByZW1vdGVTdG9yZSBhcmUgc3RhcnRlZC5cbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5zZXRQcmltYXJ5U3RhdGVMaXN0ZW5lcihhc3luYyAoaXNQcmltYXJ5KSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBzeW5jRW5naW5lQXBwbHlQcmltYXJ5U3RhdGUodGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlci5zeW5jRW5naW5lLCBpc1ByaW1hcnkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2NTY2hlZHVsZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmltYXJ5ICYmICF0aGlzLmdjU2NoZWR1bGVyLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nY1NjaGVkdWxlci5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNQcmltYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2NTY2hlZHVsZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByaW1hcnkgJiYgIXRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlU2hhcmVkQ2xpZW50U3RhdGUoY2ZnKSB7XG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgICBpZiAoIVdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZS5pc0F2YWlsYWJsZSh3aW5kb3cpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTklNUExFTUVOVEVELCAnSW5kZXhlZERCIHBlcnNpc3RlbmNlIGlzIG9ubHkgYXZhaWxhYmxlIG9uIHBsYXRmb3JtcyB0aGF0IHN1cHBvcnQgTG9jYWxTdG9yYWdlLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBlcnNpc3RlbmNlS2V5ID0gaW5kZXhlZERiU3RvcmFnZVByZWZpeChjZmcuZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQsIGNmZy5kYXRhYmFzZUluZm8ucGVyc2lzdGVuY2VLZXkpO1xuICAgICAgICByZXR1cm4gbmV3IFdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZSh3aW5kb3csIGNmZy5hc3luY1F1ZXVlLCBwZXJzaXN0ZW5jZUtleSwgY2ZnLmNsaWVudElkLCBjZmcuaW5pdGlhbFVzZXIpO1xuICAgIH1cbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW5kIHdpcmVzIHRoZSBjb21wb25lbnRzIHRoYXQgYXJlIG5lZWRlZCB0byBpbnRlcmZhY2Ugd2l0aCB0aGVcbiAqIG5ldHdvcmsuXG4gKi9cbmNsYXNzIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyIHtcbiAgICBhc3luYyBpbml0aWFsaXplKG9mZmxpbmVDb21wb25lbnRQcm92aWRlciwgY2ZnKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsU3RvcmUpIHtcbiAgICAgICAgICAgIC8vIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyIG1heSBnZXQgaW5pdGlhbGl6ZWQgbXVsdGlwbGUgdGltZXMgaWZcbiAgICAgICAgICAgIC8vIG11bHRpLXRhYiBwZXJzaXN0ZW5jZSBpcyB1c2VkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9jYWxTdG9yZSA9IG9mZmxpbmVDb21wb25lbnRQcm92aWRlci5sb2NhbFN0b3JlO1xuICAgICAgICB0aGlzLnNoYXJlZENsaWVudFN0YXRlID0gb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLnNoYXJlZENsaWVudFN0YXRlO1xuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IHRoaXMuY3JlYXRlRGF0YXN0b3JlKGNmZyk7XG4gICAgICAgIHRoaXMucmVtb3RlU3RvcmUgPSB0aGlzLmNyZWF0ZVJlbW90ZVN0b3JlKGNmZyk7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gdGhpcy5jcmVhdGVFdmVudE1hbmFnZXIoY2ZnKTtcbiAgICAgICAgdGhpcy5zeW5jRW5naW5lID0gdGhpcy5jcmVhdGVTeW5jRW5naW5lKGNmZywgXG4gICAgICAgIC8qIHN0YXJ0QXNQcmltYXJ5PSovICFvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY2hyb25pemVUYWJzKTtcbiAgICAgICAgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZS5vbmxpbmVTdGF0ZUhhbmRsZXIgPSBvbmxpbmVTdGF0ZSA9PiBzeW5jRW5naW5lQXBwbHlPbmxpbmVTdGF0ZUNoYW5nZSh0aGlzLnN5bmNFbmdpbmUsIG9ubGluZVN0YXRlLCAxIC8qIE9ubGluZVN0YXRlU291cmNlLlNoYXJlZENsaWVudFN0YXRlICovKTtcbiAgICAgICAgdGhpcy5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIuaGFuZGxlQ3JlZGVudGlhbENoYW5nZSA9XG4gICAgICAgICAgICBzeW5jRW5naW5lSGFuZGxlQ3JlZGVudGlhbENoYW5nZS5iaW5kKG51bGwsIHRoaXMuc3luY0VuZ2luZSk7XG4gICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlQXBwbHlQcmltYXJ5U3RhdGUodGhpcy5yZW1vdGVTdG9yZSwgdGhpcy5zeW5jRW5naW5lLmlzUHJpbWFyeUNsaWVudCk7XG4gICAgfVxuICAgIGNyZWF0ZUV2ZW50TWFuYWdlcihjZmcpIHtcbiAgICAgICAgcmV0dXJuIG5ld0V2ZW50TWFuYWdlcigpO1xuICAgIH1cbiAgICBjcmVhdGVEYXRhc3RvcmUoY2ZnKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXdTZXJpYWxpemVyKGNmZy5kYXRhYmFzZUluZm8uZGF0YWJhc2VJZCk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXdDb25uZWN0aW9uKGNmZy5kYXRhYmFzZUluZm8pO1xuICAgICAgICByZXR1cm4gbmV3RGF0YXN0b3JlKGNmZy5hdXRoQ3JlZGVudGlhbHMsIGNmZy5hcHBDaGVja0NyZWRlbnRpYWxzLCBjb25uZWN0aW9uLCBzZXJpYWxpemVyKTtcbiAgICB9XG4gICAgY3JlYXRlUmVtb3RlU3RvcmUoY2ZnKSB7XG4gICAgICAgIHJldHVybiBuZXdSZW1vdGVTdG9yZSh0aGlzLmxvY2FsU3RvcmUsIHRoaXMuZGF0YXN0b3JlLCBjZmcuYXN5bmNRdWV1ZSwgb25saW5lU3RhdGUgPT4gc3luY0VuZ2luZUFwcGx5T25saW5lU3RhdGVDaGFuZ2UodGhpcy5zeW5jRW5naW5lLCBvbmxpbmVTdGF0ZSwgMCAvKiBPbmxpbmVTdGF0ZVNvdXJjZS5SZW1vdGVTdG9yZSAqLyksIG5ld0Nvbm5lY3Rpdml0eU1vbml0b3IoKSk7XG4gICAgfVxuICAgIGNyZWF0ZVN5bmNFbmdpbmUoY2ZnLCBzdGFydEFzUHJpbWFyeSkge1xuICAgICAgICByZXR1cm4gbmV3U3luY0VuZ2luZSh0aGlzLmxvY2FsU3RvcmUsIHRoaXMucmVtb3RlU3RvcmUsIHRoaXMuZXZlbnRNYW5hZ2VyLCB0aGlzLnNoYXJlZENsaWVudFN0YXRlLCBjZmcuaW5pdGlhbFVzZXIsIGNmZy5tYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9ucywgc3RhcnRBc1ByaW1hcnkpO1xuICAgIH1cbiAgICBhc3luYyB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlU2h1dGRvd24odGhpcy5yZW1vdGVTdG9yZSk7XG4gICAgICAgIHRoaXMuZGF0YXN0b3JlPy50ZXJtaW5hdGUoKTtcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXI/LnRlcm1pbmF0ZSgpO1xuICAgIH1cbn1cbk9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnByb3ZpZGVyID0ge1xuICAgIGJ1aWxkOiAoKSA9PiBuZXcgT25saW5lQ29tcG9uZW50UHJvdmlkZXIoKVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogSG93IG1hbnkgYnl0ZXMgdG8gcmVhZCBlYWNoIHRpbWUgd2hlbiBgUmVhZGFibGVTdHJlYW1SZWFkZXIucmVhZCgpYCBpc1xuICogY2FsbGVkLiBPbmx5IGFwcGxpY2FibGUgZm9yIGJ5dGUgc3RyZWFtcyB0aGF0IHdlIGNvbnRyb2wgKGUuZy4gdGhvc2UgYmFja2VkXG4gKiBieSBhbiBVSW50OEFycmF5KS5cbiAqL1xuY29uc3QgREVGQVVMVF9CWVRFU19QRVJfUkVBRCA9IDEwMjQwO1xuLyoqXG4gKiBCdWlsZHMgYSBgQnl0ZVN0cmVhbVJlYWRlcmAgZnJvbSBhIFVJbnQ4QXJyYXkuXG4gKiBAcGFyYW0gc291cmNlIC0gVGhlIGRhdGEgc291cmNlIHRvIHVzZS5cbiAqIEBwYXJhbSBieXRlc1BlclJlYWQgLSBIb3cgbWFueSBieXRlcyBlYWNoIGByZWFkKClgIGZyb20gdGhlIHJldHVybmVkIHJlYWRlclxuICogICAgICAgIHdpbGwgcmVhZC5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlU3RyZWFtUmVhZGVySGVscGVyKHNvdXJjZSwgYnl0ZXNQZXJSZWFkID0gREVGQVVMVF9CWVRFU19QRVJfUkVBRCkge1xuICAgIGxldCByZWFkRnJvbSA9IDA7XG4gICAgLy8gVGhlIFR5cGVTY3JpcHQgZGVmaW5pdGlvbiBmb3IgUmVhZGFibGVTdHJlYW1SZWFkZXIgY2hhbmdlZC4gV2UgdXNlXG4gICAgLy8gYGFueWAgaGVyZSB0byBhbGxvdyB0aGlzIGNvZGUgdG8gY29tcGlsZSB3aXRoIGRpZmZlcmVudCB2ZXJzaW9ucy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy80Mjk3MFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3QgcmVhZGVyID0ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBhc3luYyByZWFkKCkge1xuICAgICAgICAgICAgaWYgKHJlYWRGcm9tIDwgc291cmNlLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzb3VyY2Uuc2xpY2UocmVhZEZyb20sIHJlYWRGcm9tICsgYnl0ZXNQZXJSZWFkKSxcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWRGcm9tICs9IGJ5dGVzUGVyUmVhZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBjYW5jZWwoKSB7IH0sXG4gICAgICAgIHJlbGVhc2VMb2NrKCkgeyB9LFxuICAgICAgICBjbG9zZWQ6IFByb21pc2UucmVzb2x2ZSgpXG4gICAgfTtcbiAgICByZXR1cm4gcmVhZGVyO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBPbiBOb2RlLCBvbmx5IHN1cHBvcnRlZCBkYXRhIHNvdXJjZSBpcyBhIGBVaW50OEFycmF5YCBmb3Igbm93LlxuICovXG5mdW5jdGlvbiB0b0J5dGVTdHJlYW1SZWFkZXIoc291cmNlLCBieXRlc1BlclJlYWQpIHtcbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgTm9kZVBsYXRmb3JtLnRvQnl0ZVN0cmVhbVJlYWRlciBleHBlY3RzIHNvdXJjZSB0byBiZSBVaW50OEFycmF5LCBnb3QgJHt2YWx1ZURlc2NyaXB0aW9uKHNvdXJjZSl9YCk7XG4gICAgfVxuICAgIHJldHVybiB0b0J5dGVTdHJlYW1SZWFkZXJIZWxwZXIoc291cmNlLCBieXRlc1BlclJlYWQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLypcbiAqIEEgd3JhcHBlciBpbXBsZW1lbnRhdGlvbiBvZiBPYnNlcnZlcjxUPiB0aGF0IHdpbGwgZGlzcGF0Y2ggZXZlbnRzXG4gKiBhc3luY2hyb25vdXNseS4gVG8gYWxsb3cgaW1tZWRpYXRlIHNpbGVuY2luZywgYSBtdXRlIGNhbGwgaXMgYWRkZWQgd2hpY2hcbiAqIGNhdXNlcyBldmVudHMgc2NoZWR1bGVkIHRvIG5vIGxvbmdlciBiZSByYWlzZWQuXG4gKi9cbmNsYXNzIEFzeW5jT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gc2V0IHRvIHRydWUsIHdpbGwgbm90IHJhaXNlIGZ1dHVyZSBldmVudHMuIE5lY2Vzc2FyeSB0byBkZWFsIHdpdGhcbiAgICAgICAgICogYXN5bmMgZGV0YWNobWVudCBvZiBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubXV0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgbmV4dCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5tdXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVFdmVudCh0aGlzLm9ic2VydmVyLm5leHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcnJvcihlcnJvcikge1xuICAgICAgICBpZiAodGhpcy5tdXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlRXZlbnQodGhpcy5vYnNlcnZlci5lcnJvciwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nRXJyb3IoJ1VuY2F1Z2h0IEVycm9yIGluIHNuYXBzaG90IGxpc3RlbmVyOicsIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG11dGUoKSB7XG4gICAgICAgIHRoaXMubXV0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBzY2hlZHVsZUV2ZW50KGV2ZW50SGFuZGxlciwgZXZlbnQpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubXV0ZWQpIHtcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgY29tcGxldGUgZWxlbWVudCBpbiB0aGUgYnVuZGxlIHN0cmVhbSwgdG9nZXRoZXIgd2l0aCB0aGUgYnl0ZSBsZW5ndGggaXRcbiAqIG9jY3VwaWVzIGluIHRoZSBzdHJlYW0uXG4gKi9cbmNsYXNzIFNpemVkQnVuZGxlRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IocGF5bG9hZCwgXG4gICAgLy8gSG93IG1hbnkgYnl0ZXMgdGhpcyBlbGVtZW50IHRha2VzIHRvIHN0b3JlIGluIHRoZSBidW5kbGUuXG4gICAgYnl0ZUxlbmd0aCkge1xuICAgICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBpc0J1bmRsZU1ldGFkYXRhKCkge1xuICAgICAgICByZXR1cm4gJ21ldGFkYXRhJyBpbiB0aGlzLnBheWxvYWQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIGJ1bmRsZS5cbiAqXG4gKiBUYWtlcyBhIGJ1bmRsZSBzdHJlYW0gb3IgYnVmZmVyLCBhbmQgcHJlc2VudHMgYWJzdHJhY3Rpb25zIHRvIHJlYWQgYnVuZGxlZFxuICogZWxlbWVudHMgb3V0IG9mIHRoZSB1bmRlcmx5aW5nIGNvbnRlbnQuXG4gKi9cbmNsYXNzIEJ1bmRsZVJlYWRlckltcGwge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgcmVhZGVyIHRvIHJlYWQgZnJvbSB1bmRlcmx5aW5nIGJpbmFyeSBidW5kbGUgZGF0YSBzb3VyY2UuICovXG4gICAgcmVhZGVyLCBzZXJpYWxpemVyKSB7XG4gICAgICAgIHRoaXMucmVhZGVyID0gcmVhZGVyO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICAvKiogQ2FjaGVkIGJ1bmRsZSBtZXRhZGF0YS4gKi9cbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgYnVmZmVyIHRvIGhvbGQgYnVuZGxlIGNvbnRlbnQsIGFjY3VtdWxhdGluZyBpbmNvbXBsZXRlIGVsZW1lbnRcbiAgICAgICAgICogY29udGVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgdGhpcy50ZXh0RGVjb2RlciA9IG5ld1RleHREZWNvZGVyKCk7XG4gICAgICAgIC8vIFJlYWQgdGhlIG1ldGFkYXRhICh3aGljaCBpcyB0aGUgZmlyc3QgZWxlbWVudCkuXG4gICAgICAgIHRoaXMubmV4dEVsZW1lbnRJbXBsKCkudGhlbihlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuaXNCdW5kbGVNZXRhZGF0YSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5yZXNvbHZlKGVsZW1lbnQucGF5bG9hZC5tZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnJlamVjdChuZXcgRXJyb3IoYFRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBidW5kbGUgaXMgbm90IGEgbWV0YWRhdGEsIGl0IGlzXG4gICAgICAgICAgICAgJHtKU09OLnN0cmluZ2lmeShlbGVtZW50Py5wYXlsb2FkKX1gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVycm9yID0+IHRoaXMubWV0YWRhdGEucmVqZWN0KGVycm9yKSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkZXIuY2FuY2VsKCk7XG4gICAgfVxuICAgIGFzeW5jIGdldE1ldGFkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YS5wcm9taXNlO1xuICAgIH1cbiAgICBhc3luYyBuZXh0RWxlbWVudCgpIHtcbiAgICAgICAgLy8gTWFrZXMgc3VyZSBtZXRhZGF0YSBpcyByZWFkIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAgICAgICBhd2FpdCB0aGlzLmdldE1ldGFkYXRhKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRFbGVtZW50SW1wbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBmcm9tIHRoZSBoZWFkIG9mIGludGVybmFsIGJ1ZmZlciwgYW5kIHB1bGxpbmcgbW9yZSBkYXRhIGZyb21cbiAgICAgKiB1bmRlcmx5aW5nIHN0cmVhbSBpZiBhIGNvbXBsZXRlIGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLCB1bnRpbCBhblxuICAgICAqIGVsZW1lbnQoaW5jbHVkaW5nIHRoZSBwcmVmaXhlZCBsZW5ndGggYW5kIHRoZSBKU09OIHN0cmluZykgaXMgZm91bmQuXG4gICAgICpcbiAgICAgKiBPbmNlIGEgY29tcGxldGUgZWxlbWVudCBpcyByZWFkLCBpdCBpcyBkcm9wcGVkIGZyb20gaW50ZXJuYWwgYnVmZmVyLlxuICAgICAqXG4gICAgICogUmV0dXJucyBlaXRoZXIgdGhlIGJ1bmRsZWQgZWxlbWVudCwgb3IgbnVsbCBpZiB3ZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCBvZlxuICAgICAqIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgYXN5bmMgbmV4dEVsZW1lbnRJbXBsKCkge1xuICAgICAgICBjb25zdCBsZW5ndGhCdWZmZXIgPSBhd2FpdCB0aGlzLnJlYWRMZW5ndGgoKTtcbiAgICAgICAgaWYgKGxlbmd0aEJ1ZmZlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoU3RyaW5nID0gdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUobGVuZ3RoQnVmZmVyKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aFN0cmluZyk7XG4gICAgICAgIGlmIChpc05hTihsZW5ndGgpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlRXJyb3IoYGxlbmd0aCBzdHJpbmcgKCR7bGVuZ3RoU3RyaW5nfSkgaXMgbm90IHZhbGlkIG51bWJlcmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBhd2FpdCB0aGlzLnJlYWRKc29uU3RyaW5nKGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuZXcgU2l6ZWRCdW5kbGVFbGVtZW50KEpTT04ucGFyc2UoanNvblN0cmluZyksIGxlbmd0aEJ1ZmZlci5sZW5ndGggKyBsZW5ndGgpO1xuICAgIH1cbiAgICAvKiogRmlyc3QgaW5kZXggb2YgJ3snIGZyb20gdGhlIHVuZGVybHlpbmcgYnVmZmVyLiAqL1xuICAgIGluZGV4T2ZPcGVuQnJhY2tldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmZpbmRJbmRleCh2ID0+IHYgPT09ICd7Jy5jaGFyQ29kZUF0KDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBpbnRlcm5hbCBidWZmZXIsIHVudGlsIHRoZSBmaXJzdCAneycsIGFuZFxuICAgICAqIHJldHVybiB0aGUgY29udGVudC5cbiAgICAgKlxuICAgICAqIElmIHJlYWNoZWQgZW5kIG9mIHRoZSBzdHJlYW0sIHJldHVybnMgYSBudWxsLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRMZW5ndGgoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmluZGV4T2ZPcGVuQnJhY2tldCgpIDwgMCkge1xuICAgICAgICAgICAgY29uc3QgZG9uZSA9IGF3YWl0IHRoaXMucHVsbE1vcmVEYXRhVG9CdWZmZXIoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnJva2Ugb3V0IG9mIHRoZSBsb29wIGJlY2F1c2UgdW5kZXJseWluZyBzdHJlYW0gaXMgY2xvc2VkLCBhbmQgdGhlcmVcbiAgICAgICAgLy8gaGFwcGVucyB0byBiZSBubyBtb3JlIGRhdGEgdG8gcHJvY2Vzcy5cbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmluZGV4T2ZPcGVuQnJhY2tldCgpO1xuICAgICAgICAvLyBCcm9rZSBvdXQgb2YgdGhlIGxvb3AgYmVjYXVzZSB1bmRlcmx5aW5nIHN0cmVhbSBpcyBjbG9zZWQsIGJ1dCBzdGlsbFxuICAgICAgICAvLyBjYW5ub3QgZmluZCBhbiBvcGVuIGJyYWNrZXQuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2VFcnJvcignUmVhY2hlZCB0aGUgZW5kIG9mIGJ1bmRsZSB3aGVuIGEgbGVuZ3RoIHN0cmluZyBpcyBleHBlY3RlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmJ1ZmZlci5zbGljZSgwLCBwb3NpdGlvbik7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgaW50ZXJuYWwgYnVmZmVyIHRvIGRyb3AgdGhlIHJlYWQgbGVuZ3RoLlxuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgZnJvbSBhIHNwZWNpZmllZCBwb3NpdGlvbiBmcm9tIHRoZSBpbnRlcm5hbCBidWZmZXIsIGZvciBhIHNwZWNpZmllZFxuICAgICAqIG51bWJlciBvZiBieXRlcywgcHVsbGluZyBtb3JlIGRhdGEgZnJvbSB0aGUgdW5kZXJseWluZyBzdHJlYW0gaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyBkZWNvZGVkIGZyb20gdGhlIHJlYWQgYnl0ZXMuXG4gICAgICovXG4gICAgYXN5bmMgcmVhZEpzb25TdHJpbmcobGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmJ1ZmZlci5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSBhd2FpdCB0aGlzLnB1bGxNb3JlRGF0YVRvQnVmZmVyKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmFpc2VFcnJvcignUmVhY2hlZCB0aGUgZW5kIG9mIGJ1bmRsZSB3aGVuIG1vcmUgaXMgZXhwZWN0ZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUodGhpcy5idWZmZXIuc2xpY2UoMCwgbGVuZ3RoKSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgaW50ZXJuYWwgYnVmZmVyIHRvIGRyb3AgdGhlIHJlYWQganNvbiBzdHJpbmcuXG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc2xpY2UobGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmFpc2VFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgdGhpcy5yZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBidW5kbGUgZm9ybWF0OiAke21lc3NhZ2V9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1bGxzIG1vcmUgZGF0YSBmcm9tIHVuZGVybHlpbmcgc3RyZWFtIHRvIGludGVybmFsIGJ1ZmZlci5cbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHN0cmVhbSBpcyBmaW5pc2hlZC5cbiAgICAgKi9cbiAgICBhc3luYyBwdWxsTW9yZURhdGFUb0J1ZmZlcigpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdCdWZmZXIgPSBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlci5sZW5ndGggKyByZXN1bHQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIG5ld0J1ZmZlci5zZXQodGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgbmV3QnVmZmVyLnNldChyZXN1bHQudmFsdWUsIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ld0J1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmU7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3QnVuZGxlUmVhZGVyKHJlYWRlciwgc2VyaWFsaXplcikge1xuICAgIHJldHVybiBuZXcgQnVuZGxlUmVhZGVySW1wbChyZWFkZXIsIHNlcmlhbGl6ZXIpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgY2FuIHBhcnNlIGEgYnVuZGxlIGZvcm0gdGhlIHN0cmluZyBzZXJpYWxpemF0aW9uIG9mIGEgYnVuZGxlLlxuICovXG5jbGFzcyBCdW5kbGVSZWFkZXJTeW5jSW1wbCB7XG4gICAgY29uc3RydWN0b3IoYnVuZGxlRGF0YSwgc2VyaWFsaXplcikge1xuICAgICAgICB0aGlzLmJ1bmRsZURhdGEgPSBidW5kbGVEYXRhO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICB0aGlzLmN1cnNvciA9IDA7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLm5leHRFbGVtZW50KCk7XG4gICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuaXNCdW5kbGVNZXRhZGF0YSgpKSB7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGJ1bmRsZSBpcyBub3QgYSBtZXRhZGF0YSBvYmplY3QsIGl0IGlzXG4gICAgICAgICAke0pTT04uc3RyaW5naWZ5KGVsZW1lbnQ/LnBheWxvYWQpfWApO1xuICAgICAgICB9XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLm5leHRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZWxlbWVudCAhPT0gbnVsbCk7XG4gICAgfVxuICAgIC8qIFJldHVybnMgdGhlIHBhcnNlZCBtZXRhZGF0YSBvZiB0aGUgYnVuZGxlLiAqL1xuICAgIGdldE1ldGFkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YTtcbiAgICB9XG4gICAgLyogUmV0dXJucyB0aGUgRG9jdW1lbnRTbmFwc2hvdCBvciBOYW1lZFF1ZXJ5IGVsZW1lbnRzIG9mIHRoZSBidW5kbGUuICovXG4gICAgZ2V0RWxlbWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIG5leHQgZWxlbWVudCBvZiB0aGUgYnVuZGxlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBTaXplZEJ1bmRsZUVsZW1lbnQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG5leHQgZWxlbWVudCBpbiB0aGUgYnVuZGxlLCBvciBudWxsIGlmXG4gICAgICogbm8gbW9yZSBlbGVtZW50cyBleGlzdC5cbiAgICAgKi9cbiAgICBuZXh0RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yID09PSB0aGlzLmJ1bmRsZURhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLnJlYWRMZW5ndGgoKTtcbiAgICAgICAgY29uc3QganNvblN0cmluZyA9IHRoaXMucmVhZEpzb25TdHJpbmcobGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaXplZEJ1bmRsZUVsZW1lbnQoSlNPTi5wYXJzZShqc29uU3RyaW5nKSwgbGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgZnJvbSBhIHNwZWNpZmllZCBwb3NpdGlvbiBmcm9tIHRoZSBidW5kbGVEYXRhIHN0cmluZywgZm9yIGEgc3BlY2lmaWVkXG4gICAgICogbnVtYmVyIG9mIGJ5dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxlbmd0aCAtIGhvdyBtYW55IGNoYXJhY3RlcnMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJucyBhIHN0cmluZyBwYXJzZWQgZnJvbSB0aGUgYnVuZGxlLlxuICAgICAqL1xuICAgIHJlYWRKc29uU3RyaW5nKGxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3IgKyBsZW5ndGggPiB0aGlzLmJ1bmRsZURhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlRFUk5BTCwgJ1JlYWNoZWQgdGhlIGVuZCBvZiBidW5kbGUgd2hlbiBtb3JlIGlzIGV4cGVjdGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYnVuZGxlRGF0YS5zbGljZSh0aGlzLmN1cnNvciwgKHRoaXMuY3Vyc29yICs9IGxlbmd0aCkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBmcm9tIHRoZSBjdXJyZW50IGN1cnNvciB1bnRpbCB0aGUgZmlyc3QgJ3snLlxuICAgICAqXG4gICAgICogQHJldHVybnMgIEEgc3RyaW5nIHRvIGludGVnZXIgcmVwcmVzZW50aW9uIG9mIHRoZSBwYXJzZWQgdmFsdWUuXG4gICAgICogQHRocm93cyBBbiB7QGxpbmsgRXJyb3J9IGlmIHRoZSBjdXJzb3IgaGFzIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgc3RyZWFtLCBzaW5jZSBsZW5ndGhzXG4gICAgICogcHJlZml4IGJ1bmRsZSBvYmplY3RzLlxuICAgICAqL1xuICAgIHJlYWRMZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSB0aGlzLmN1cnNvcjtcbiAgICAgICAgbGV0IGN1ckluZGV4ID0gdGhpcy5jdXJzb3I7XG4gICAgICAgIHdoaWxlIChjdXJJbmRleCA8IHRoaXMuYnVuZGxlRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1bmRsZURhdGFbY3VySW5kZXhdID09PSAneycpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VySW5kZXggPT09IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBjaGFyYWN0ZXIgaXMgYSBicmFja2V0IGFuZCBub3QgYSBudW1iZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBjdXJJbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMuYnVuZGxlRGF0YS5zbGljZShzdGFydEluZGV4LCBjdXJJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VySW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWNoZWQgdGhlIGVuZCBvZiBidW5kbGUgd2hlbiBtb3JlIGlzIGV4cGVjdGVkLicpO1xuICAgIH1cbn1cbi8qKlxuICogIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQnVuZGxlUmVhZGVyIHdpdGhvdXQgZXhwb3NpbmcgdGhlIEJ1bmRsZVJlYWRlclN5bmNJbXBsIGNsYXNzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIG5ld0J1bmRsZVJlYWRlclN5bmMoYnVuZGxlRGF0YSwgc2VyaWFsaXplcikge1xuICAgIHJldHVybiBuZXcgQnVuZGxlUmVhZGVyU3luY0ltcGwoYnVuZGxlRGF0YSwgc2VyaWFsaXplcik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEludGVybmFsIHRyYW5zYWN0aW9uIG9iamVjdCByZXNwb25zaWJsZSBmb3IgYWNjdW11bGF0aW5nIHRoZSBtdXRhdGlvbnMgdG9cbiAqIHBlcmZvcm0gYW5kIHRoZSBiYXNlIHZlcnNpb25zIGZvciBhbnkgZG9jdW1lbnRzIHJlYWQuXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhc3RvcmUpIHtcbiAgICAgICAgdGhpcy5kYXRhc3RvcmUgPSBkYXRhc3RvcmU7XG4gICAgICAgIC8vIFRoZSB2ZXJzaW9uIG9mIGVhY2ggZG9jdW1lbnQgdGhhdCB3YXMgcmVhZCBkdXJpbmcgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgICAgdGhpcy5yZWFkVmVyc2lvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubXV0YXRpb25zID0gW107XG4gICAgICAgIHRoaXMuY29tbWl0dGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGRlZmVycmVkIHVzYWdlIGVycm9yIHRoYXQgb2NjdXJyZWQgcHJldmlvdXNseSBpbiB0aGlzIHRyYW5zYWN0aW9uIHRoYXRcbiAgICAgICAgICogd2lsbCBjYXVzZSB0aGUgdHJhbnNhY3Rpb24gdG8gZmFpbCBvbmNlIGl0IGFjdHVhbGx5IGNvbW1pdHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbkVycm9yID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBvZiBkb2N1bWVudHMgdGhhdCBoYXZlIGJlZW4gd3JpdHRlbiBpbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdGhlcmUncyBtb3JlIHRoYW4gb25lIHdyaXRlIHRvIHRoZSBzYW1lIGtleSBpbiBhIHRyYW5zYWN0aW9uLCBhbnlcbiAgICAgICAgICogd3JpdGVzIGFmdGVyIHRoZSBmaXJzdCBhcmUgaGFuZGxlZCBkaWZmZXJlbnRseS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud3JpdHRlbkRvY3MgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIGFzeW5jIGxvb2t1cChrZXlzKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQ29tbWl0Tm90Q2FsbGVkKCk7XG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbkVycm9yID0gbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ZpcmVzdG9yZSB0cmFuc2FjdGlvbnMgcmVxdWlyZSBhbGwgcmVhZHMgdG8gYmUgZXhlY3V0ZWQgYmVmb3JlIGFsbCB3cml0ZXMuJyk7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmxhc3RUcmFuc2FjdGlvbkVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvY3MgPSBhd2FpdCBpbnZva2VCYXRjaEdldERvY3VtZW50c1JwYyh0aGlzLmRhdGFzdG9yZSwga2V5cyk7XG4gICAgICAgIGRvY3MuZm9yRWFjaChkb2MgPT4gdGhpcy5yZWNvcmRWZXJzaW9uKGRvYykpO1xuICAgICAgICByZXR1cm4gZG9jcztcbiAgICB9XG4gICAgc2V0KGtleSwgZGF0YSkge1xuICAgICAgICB0aGlzLndyaXRlKGRhdGEudG9NdXRhdGlvbihrZXksIHRoaXMucHJlY29uZGl0aW9uKGtleSkpKTtcbiAgICAgICAgdGhpcy53cml0dGVuRG9jcy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICB1cGRhdGUoa2V5LCBkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlKGRhdGEudG9NdXRhdGlvbihrZXksIHRoaXMucHJlY29uZGl0aW9uRm9yVXBkYXRlKGtleSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb25FcnJvciA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0dGVuRG9jcy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIHRoaXMud3JpdGUobmV3IERlbGV0ZU11dGF0aW9uKGtleSwgdGhpcy5wcmVjb25kaXRpb24oa2V5KSkpO1xuICAgICAgICB0aGlzLndyaXR0ZW5Eb2NzLmFkZChrZXkudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGFzeW5jIGNvbW1pdCgpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVDb21taXROb3RDYWxsZWQoKTtcbiAgICAgICAgaWYgKHRoaXMubGFzdFRyYW5zYWN0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMubGFzdFRyYW5zYWN0aW9uRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW53cml0dGVuID0gdGhpcy5yZWFkVmVyc2lvbnM7XG4gICAgICAgIC8vIEZvciBlYWNoIG11dGF0aW9uLCBub3RlIHRoYXQgdGhlIGRvYyB3YXMgd3JpdHRlbi5cbiAgICAgICAgdGhpcy5tdXRhdGlvbnMuZm9yRWFjaChtdXRhdGlvbiA9PiB7XG4gICAgICAgICAgICB1bndyaXR0ZW4uZGVsZXRlKG11dGF0aW9uLmtleS50b1N0cmluZygpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEZvciBlYWNoIGRvY3VtZW50IHRoYXQgd2FzIHJlYWQgYnV0IG5vdCB3cml0dGVuIHRvLCB3ZSB3YW50IHRvIHBlcmZvcm1cbiAgICAgICAgLy8gYSBgdmVyaWZ5YCBvcGVyYXRpb24uXG4gICAgICAgIHVud3JpdHRlbi5mb3JFYWNoKChfLCBwYXRoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBEb2N1bWVudEtleS5mcm9tUGF0aChwYXRoKTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zLnB1c2gobmV3IFZlcmlmeU11dGF0aW9uKGtleSwgdGhpcy5wcmVjb25kaXRpb24oa2V5KSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgaW52b2tlQ29tbWl0UnBjKHRoaXMuZGF0YXN0b3JlLCB0aGlzLm11dGF0aW9ucyk7XG4gICAgICAgIHRoaXMuY29tbWl0dGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVjb3JkVmVyc2lvbihkb2MpIHtcbiAgICAgICAgbGV0IGRvY1ZlcnNpb247XG4gICAgICAgIGlmIChkb2MuaXNGb3VuZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgIGRvY1ZlcnNpb24gPSBkb2MudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb2MuaXNOb0RvY3VtZW50KCkpIHtcbiAgICAgICAgICAgIC8vIFJlcHJlc2VudCBhIGRlbGV0ZWQgZG9jIHVzaW5nIFNuYXBzaG90VmVyc2lvbi5taW4oKS5cbiAgICAgICAgICAgIGRvY1ZlcnNpb24gPSBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBmYWlsKDB4YzU0Miwge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50TmFtZTogZG9jLmNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVmVyc2lvbiA9IHRoaXMucmVhZFZlcnNpb25zLmdldChkb2Mua2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdWZXJzaW9uKSB7XG4gICAgICAgICAgICBpZiAoIWRvY1ZlcnNpb24uaXNFcXVhbChleGlzdGluZ1ZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB0cmFuc2FjdGlvbiB3aWxsIGZhaWwgbm8gbWF0dGVyIHdoYXQuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuQUJPUlRFRCwgJ0RvY3VtZW50IHZlcnNpb24gY2hhbmdlZCBiZXR3ZWVuIHR3byByZWFkcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFZlcnNpb25zLnNldChkb2Mua2V5LnRvU3RyaW5nKCksIGRvY1ZlcnNpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZlcnNpb24gb2YgdGhpcyBkb2N1bWVudCB3aGVuIGl0IHdhcyByZWFkIGluIHRoaXMgdHJhbnNhY3Rpb24sXG4gICAgICogYXMgYSBwcmVjb25kaXRpb24sIG9yIG5vIHByZWNvbmRpdGlvbiBpZiBpdCB3YXMgbm90IHJlYWQuXG4gICAgICovXG4gICAgcHJlY29uZGl0aW9uKGtleSkge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5yZWFkVmVyc2lvbnMuZ2V0KGtleS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKCF0aGlzLndyaXR0ZW5Eb2NzLmhhcyhrZXkudG9TdHJpbmcoKSkgJiYgdmVyc2lvbikge1xuICAgICAgICAgICAgaWYgKHZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5leGlzdHMoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi51cGRhdGVUaW1lKHZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5ub25lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJlY29uZGl0aW9uIGZvciBhIGRvY3VtZW50IGlmIHRoZSBvcGVyYXRpb24gaXMgYW4gdXBkYXRlLlxuICAgICAqL1xuICAgIHByZWNvbmRpdGlvbkZvclVwZGF0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRoaXMucmVhZFZlcnNpb25zLmdldChrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIGEgZG9jdW1lbnQgaXMgd3JpdHRlbiwgd2Ugd2FudCB0byB0YWtlIGludG8gYWNjb3VudCB0aGVcbiAgICAgICAgLy8gcmVhZCB0aW1lIGFuZCBleGlzdGVuY2VcbiAgICAgICAgaWYgKCF0aGlzLndyaXR0ZW5Eb2NzLmhhcyhrZXkudG9TdHJpbmcoKSkgJiYgdmVyc2lvbikge1xuICAgICAgICAgICAgaWYgKHZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QsIHNvIGZhaWwgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFzIHRvIGJlIHZhbGlkYXRlZCBsb2NhbGx5IGJlY2F1c2UgeW91IGNhbid0IHNlbmQgYVxuICAgICAgICAgICAgICAgIC8vIHByZWNvbmRpdGlvbiB0aGF0IGEgZG9jdW1lbnQgZG9lcyBub3QgZXhpc3Qgd2l0aG91dCBjaGFuZ2luZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIGJhY2tlbmQgd3JpdGUgdG8gYmUgYW4gaW5zZXJ0LiBUaGlzIGlzIHRoZSByZXZlcnNlXG4gICAgICAgICAgICAgICAgLy8gb2Ygd2hhdCB3ZSB3YW50LCBzaW5jZSB3ZSB3YW50IHRvIGFzc2VydCB0aGF0IHRoZSBkb2N1bWVudCBkb2Vzbid0XG4gICAgICAgICAgICAgICAgLy8gZXhpc3QgYnV0IHRoZW4gc2VuZCB0aGUgdXBkYXRlIGFuZCBoYXZlIGl0IGZhaWwuIFNpbmNlIHdlIGNhbid0XG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzcyB0aGF0IHRvIHRoZSBiYWNrZW5kLCB3ZSBoYXZlIHRvIHZhbGlkYXRlIGxvY2FsbHkuXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogdGhpcyBjYW4gY2hhbmdlIG9uY2Ugd2UgY2FuIHNlbmQgc2VwYXJhdGUgdmVyaWZ5IHdyaXRlcyBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBcIkNhbid0IHVwZGF0ZSBhIGRvY3VtZW50IHRoYXQgZG9lc24ndCBleGlzdC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEb2N1bWVudCBleGlzdHMsIGJhc2UgcHJlY29uZGl0aW9uIG9uIGRvY3VtZW50IHVwZGF0ZSB0aW1lLlxuICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi51cGRhdGVUaW1lKHZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRG9jdW1lbnQgd2FzIG5vdCByZWFkLCBzbyB3ZSBqdXN0IHVzZSB0aGUgcHJlY29uZGl0aW9ucyBmb3IgYSBibGluZFxuICAgICAgICAgICAgLy8gdXBkYXRlLlxuICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5leGlzdHModHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGUobXV0YXRpb24pIHtcbiAgICAgICAgdGhpcy5lbnN1cmVDb21taXROb3RDYWxsZWQoKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbnMucHVzaChtdXRhdGlvbik7XG4gICAgfVxuICAgIGVuc3VyZUNvbW1pdE5vdENhbGxlZCgpIHtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRyYW5zYWN0aW9uUnVubmVyIGVuY2Fwc3VsYXRlcyB0aGUgbG9naWMgbmVlZGVkIHRvIHJ1biBhbmQgcmV0cnkgdHJhbnNhY3Rpb25zXG4gKiB3aXRoIGJhY2tvZmYuXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uUnVubmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihhc3luY1F1ZXVlLCBkYXRhc3RvcmUsIG9wdGlvbnMsIHVwZGF0ZUZ1bmN0aW9uLCBkZWZlcnJlZCkge1xuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSBhc3luY1F1ZXVlO1xuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IGRhdGFzdG9yZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy51cGRhdGVGdW5jdGlvbiA9IHVwZGF0ZUZ1bmN0aW9uO1xuICAgICAgICB0aGlzLmRlZmVycmVkID0gZGVmZXJyZWQ7XG4gICAgICAgIHRoaXMuYXR0ZW1wdHNSZW1haW5pbmcgPSBvcHRpb25zLm1heEF0dGVtcHRzO1xuICAgICAgICB0aGlzLmJhY2tvZmYgPSBuZXcgRXhwb25lbnRpYWxCYWNrb2ZmKHRoaXMuYXN5bmNRdWV1ZSwgXCJ0cmFuc2FjdGlvbl9yZXRyeVwiIC8qIFRpbWVySWQuVHJhbnNhY3Rpb25SZXRyeSAqLyk7XG4gICAgfVxuICAgIC8qKiBSdW5zIHRoZSB0cmFuc2FjdGlvbiBhbmQgc2V0cyB0aGUgcmVzdWx0IG9uIGRlZmVycmVkLiAqL1xuICAgIHJ1bigpIHtcbiAgICAgICAgdGhpcy5hdHRlbXB0c1JlbWFpbmluZyAtPSAxO1xuICAgICAgICB0aGlzLnJ1bldpdGhCYWNrT2ZmKCk7XG4gICAgfVxuICAgIHJ1bldpdGhCYWNrT2ZmKCkge1xuICAgICAgICB0aGlzLmJhY2tvZmYuYmFja29mZkFuZFJ1bihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbih0aGlzLmRhdGFzdG9yZSk7XG4gICAgICAgICAgICBjb25zdCB1c2VyUHJvbWlzZSA9IHRoaXMudHJ5UnVuVXBkYXRlRnVuY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHVzZXJQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgdXNlclByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbW1pdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goY29tbWl0RXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNhY3Rpb25FcnJvcihjb21taXRFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHVzZXJQcm9taXNlRXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRyYW5zYWN0aW9uRXJyb3IodXNlclByb21pc2VFcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0cnlSdW5VcGRhdGVGdW5jdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXNlclByb21pc2UgPSB0aGlzLnVwZGF0ZUZ1bmN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh1c2VyUHJvbWlzZSkgfHxcbiAgICAgICAgICAgICAgICAhdXNlclByb21pc2UuY2F0Y2ggfHxcbiAgICAgICAgICAgICAgICAhdXNlclByb21pc2UudGhlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KEVycm9yKCdUcmFuc2FjdGlvbiBjYWxsYmFjayBtdXN0IHJldHVybiBhIFByb21pc2UnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXNlclByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgcmV0cnkgZXJyb3JzIHRocm93biBieSB1c2VyIHByb3ZpZGVkIHVwZGF0ZUZ1bmN0aW9uLlxuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlVHJhbnNhY3Rpb25FcnJvcihlcnJvcikge1xuICAgICAgICBpZiAodGhpcy5hdHRlbXB0c1JlbWFpbmluZyA+IDAgJiYgdGhpcy5pc1JldHJ5YWJsZVRyYW5zYWN0aW9uRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRzUmVtYWluaW5nIC09IDE7XG4gICAgICAgICAgICB0aGlzLmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5XaXRoQmFja09mZigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzUmV0cnlhYmxlVHJhbnNhY3Rpb25FcnJvcihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3I/Lm5hbWUgPT09ICdGaXJlYmFzZUVycm9yJykge1xuICAgICAgICAgICAgLy8gSW4gdHJhbnNhY3Rpb25zLCB0aGUgYmFja2VuZCB3aWxsIGZhaWwgb3V0ZGF0ZWQgcmVhZHMgd2l0aCBGQUlMRURfUFJFQ09ORElUSU9OIGFuZFxuICAgICAgICAgICAgLy8gbm9uLW1hdGNoaW5nIGRvY3VtZW50IHZlcnNpb25zIHdpdGggQUJPUlRFRC4gVGhlc2UgZXJyb3JzIHNob3VsZCBiZSByZXRyaWVkLlxuICAgICAgICAgICAgY29uc3QgY29kZSA9IGVycm9yLmNvZGU7XG4gICAgICAgICAgICByZXR1cm4gKGNvZGUgPT09ICdhYm9ydGVkJyB8fFxuICAgICAgICAgICAgICAgIGNvZGUgPT09ICdmYWlsZWQtcHJlY29uZGl0aW9uJyB8fFxuICAgICAgICAgICAgICAgIGNvZGUgPT09ICdhbHJlYWR5LWV4aXN0cycgfHxcbiAgICAgICAgICAgICAgICAhaXNQZXJtYW5lbnRFcnJvcihjb2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckMiA9ICdGaXJlc3RvcmVDbGllbnQnO1xuY29uc3QgTUFYX0NPTkNVUlJFTlRfTElNQk9fUkVTT0xVVElPTlMgPSAxMDA7XG4vKiogRE9NRXhjZXB0aW9uIGVycm9yIGNvZGUgY29uc3RhbnRzLiAqL1xuY29uc3QgRE9NX0VYQ0VQVElPTl9JTlZBTElEX1NUQVRFID0gMTE7XG5jb25zdCBET01fRVhDRVBUSU9OX0FCT1JURUQgPSAyMDtcbmNvbnN0IERPTV9FWENFUFRJT05fUVVPVEFfRVhDRUVERUQgPSAyMjtcbi8qKlxuICogRmlyZXN0b3JlQ2xpZW50IGlzIGEgdG9wLWxldmVsIGNsYXNzIHRoYXQgY29uc3RydWN0cyBhbmQgb3ducyBhbGwgb2YgdGhlIC8vXG4gKiBwaWVjZXMgb2YgdGhlIGNsaWVudCBTREsgYXJjaGl0ZWN0dXJlLiBJdCBpcyByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhlIC8vXG4gKiBhc3luYyBxdWV1ZSB0aGF0IGlzIHNoYXJlZCBieSBhbGwgb2YgdGhlIG90aGVyIGNvbXBvbmVudHMgaW4gdGhlIHN5c3RlbS4gLy9cbiAqL1xuY2xhc3MgRmlyZXN0b3JlQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIFxuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91cyBxdWV1ZSByZXNwb25zaWJsZSBmb3IgYWxsIG9mIG91ciBpbnRlcm5hbCBwcm9jZXNzaW5nLiBXaGVuXG4gICAgICogd2UgZ2V0IGluY29taW5nIHdvcmsgZnJvbSB0aGUgdXNlciAodmlhIHB1YmxpYyBBUEkpIG9yIHRoZSBuZXR3b3JrXG4gICAgICogKGluY29taW5nIEdSUEMgbWVzc2FnZXMpLCB3ZSBzaG91bGQgYWx3YXlzIHNjaGVkdWxlIG9udG8gdGhpcyBxdWV1ZS5cbiAgICAgKiBUaGlzIGVuc3VyZXMgYWxsIG9mIG91ciB3b3JrIGlzIHByb3Blcmx5IHNlcmlhbGl6ZWQgKGUuZy4gd2UgZG9uJ3RcbiAgICAgKiBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IG9wZXJhdGlvbiB3aGlsZSB0aGUgcHJldmlvdXMgb25lIGlzIHdhaXRpbmcgZm9yXG4gICAgICogYW4gYXN5bmMgSS9PIHRvIGNvbXBsZXRlKS5cbiAgICAgKi9cbiAgICBhc3luY1F1ZXVlLCBcbiAgICAvKipcbiAgICAgKiBFeHBvc2VkIGZvciB0ZXN0aW5nXG4gICAgICovXG4gICAgX2RhdGFiYXNlSW5mbywgY29tcG9uZW50UHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMgPSBhdXRoQ3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscyA9IGFwcENoZWNrQ3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZSA9IGFzeW5jUXVldWU7XG4gICAgICAgIHRoaXMuX2RhdGFiYXNlSW5mbyA9IF9kYXRhYmFzZUluZm87XG4gICAgICAgIHRoaXMudXNlciA9IFVzZXIuVU5BVVRIRU5USUNBVEVEO1xuICAgICAgICB0aGlzLmNsaWVudElkID0gQXV0b0lkLm5ld0lkKCk7XG4gICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxMaXN0ZW5lciA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbExpc3RlbmVyID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIgPSBjb21wb25lbnRQcm92aWRlcjtcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuc3RhcnQoYXN5bmNRdWV1ZSwgYXN5bmMgKHVzZXIpID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ1JlY2VpdmVkIHVzZXI9JywgdXNlci51aWQpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoQ3JlZGVudGlhbExpc3RlbmVyKHVzZXIpO1xuICAgICAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscy5zdGFydChhc3luY1F1ZXVlLCBuZXdBcHBDaGVja1Rva2VuID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ1JlY2VpdmVkIG5ldyBhcHAgY2hlY2sgdG9rZW49JywgbmV3QXBwQ2hlY2tUb2tlbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxMaXN0ZW5lcihuZXdBcHBDaGVja1Rva2VuLCB0aGlzLnVzZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGNvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhc3luY1F1ZXVlOiB0aGlzLmFzeW5jUXVldWUsXG4gICAgICAgICAgICBkYXRhYmFzZUluZm86IHRoaXMuX2RhdGFiYXNlSW5mbyxcbiAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgICAgICAgYXV0aENyZWRlbnRpYWxzOiB0aGlzLmF1dGhDcmVkZW50aWFscyxcbiAgICAgICAgICAgIGFwcENoZWNrQ3JlZGVudGlhbHM6IHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscyxcbiAgICAgICAgICAgIGluaXRpYWxVc2VyOiB0aGlzLnVzZXIsXG4gICAgICAgICAgICBtYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9uczogTUFYX0NPTkNVUlJFTlRfTElNQk9fUkVTT0xVVElPTlNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0Q3JlZGVudGlhbENoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIH1cbiAgICBzZXRBcHBDaGVja1Rva2VuQ2hhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIH1cbiAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZS5lbnRlclJlc3RyaWN0ZWRNb2RlKCk7XG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0RXZlbldoaWxlUmVzdHJpY3RlZChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbmxpbmVDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX29ubGluZUNvbXBvbmVudHMudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vZmZsaW5lQ29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9vZmZsaW5lQ29tcG9uZW50cy50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNyZWRlbnRpYWxzIHByb3ZpZGVyIG11c3QgYmUgdGVybWluYXRlZCBhZnRlciBzaHV0dGluZyBkb3duIHRoZVxuICAgICAgICAgICAgICAgIC8vIFJlbW90ZVN0b3JlIGFzIGl0IHdpbGwgcHJldmVudCB0aGUgUmVtb3RlU3RvcmUgZnJvbSByZXRyaWV2aW5nIGF1dGhcbiAgICAgICAgICAgICAgICAvLyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuc2h1dGRvd24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuc2h1dGRvd24oKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcmVzdG9yZUVycm9yID0gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCBgRmFpbGVkIHRvIHNodXRkb3duIHBlcnNpc3RlbmNlYCk7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGZpcmVzdG9yZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNldE9mZmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIG9mZmxpbmVDb21wb25lbnRQcm92aWRlcikge1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLnZlcmlmeU9wZXJhdGlvbkluUHJvZ3Jlc3MoKTtcbiAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdJbml0aWFsaXppbmcgT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XG4gICAgY29uc3QgY29uZmlndXJhdGlvbiA9IGNsaWVudC5jb25maWd1cmF0aW9uO1xuICAgIGF3YWl0IG9mZmxpbmVDb21wb25lbnRQcm92aWRlci5pbml0aWFsaXplKGNvbmZpZ3VyYXRpb24pO1xuICAgIGxldCBjdXJyZW50VXNlciA9IGNvbmZpZ3VyYXRpb24uaW5pdGlhbFVzZXI7XG4gICAgY2xpZW50LnNldENyZWRlbnRpYWxDaGFuZ2VMaXN0ZW5lcihhc3luYyAodXNlcikgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRVc2VyLmlzRXF1YWwodXNlcikpIHtcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmVIYW5kbGVVc2VyQ2hhbmdlKG9mZmxpbmVDb21wb25lbnRQcm92aWRlci5sb2NhbFN0b3JlLCB1c2VyKTtcbiAgICAgICAgICAgIGN1cnJlbnRVc2VyID0gdXNlcjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFdoZW4gYSB1c2VyIGNhbGxzIGNsZWFyUGVyc2lzdGVuY2UoKSBpbiBvbmUgY2xpZW50LCBhbGwgb3RoZXIgY2xpZW50c1xuICAgIC8vIG5lZWQgdG8gYmUgdGVybWluYXRlZCB0byBhbGxvdyB0aGUgZGVsZXRlIHRvIHN1Y2NlZWQuXG4gICAgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLnBlcnNpc3RlbmNlLnNldERhdGFiYXNlRGVsZXRlZExpc3RlbmVyKCgpID0+IGNsaWVudC50ZXJtaW5hdGUoKSk7XG4gICAgY2xpZW50Ll9vZmZsaW5lQ29tcG9uZW50cyA9IG9mZmxpbmVDb21wb25lbnRQcm92aWRlcjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNldE9ubGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIpIHtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS52ZXJpZnlPcGVyYXRpb25JblByb2dyZXNzKCk7XG4gICAgY29uc3Qgb2ZmbGluZUNvbXBvbmVudHMgPSBhd2FpdCBlbnN1cmVPZmZsaW5lQ29tcG9uZW50cyhjbGllbnQpO1xuICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ0luaXRpYWxpemluZyBPbmxpbmVDb21wb25lbnRQcm92aWRlcicpO1xuICAgIGF3YWl0IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLmluaXRpYWxpemUob2ZmbGluZUNvbXBvbmVudHMsIGNsaWVudC5jb25maWd1cmF0aW9uKTtcbiAgICAvLyBUaGUgQ3JlZGVudGlhbENoYW5nZUxpc3RlbmVyIG9mIHRoZSBvbmxpbmUgY29tcG9uZW50IHByb3ZpZGVyIHRha2VzXG4gICAgLy8gcHJlY2VkZW5jZSBvdmVyIHRoZSBvZmZsaW5lIGNvbXBvbmVudCBwcm92aWRlci5cbiAgICBjbGllbnQuc2V0Q3JlZGVudGlhbENoYW5nZUxpc3RlbmVyKHVzZXIgPT4gcmVtb3RlU3RvcmVIYW5kbGVDcmVkZW50aWFsQ2hhbmdlKG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnJlbW90ZVN0b3JlLCB1c2VyKSk7XG4gICAgY2xpZW50LnNldEFwcENoZWNrVG9rZW5DaGFuZ2VMaXN0ZW5lcigoXywgdXNlcikgPT4gcmVtb3RlU3RvcmVIYW5kbGVDcmVkZW50aWFsQ2hhbmdlKG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnJlbW90ZVN0b3JlLCB1c2VyKSk7XG4gICAgY2xpZW50Ll9vbmxpbmVDb21wb25lbnRzID0gb25saW5lQ29tcG9uZW50UHJvdmlkZXI7XG59XG4vKipcbiAqIERlY2lkZXMgd2hldGhlciB0aGUgcHJvdmlkZWQgZXJyb3IgYWxsb3dzIHVzIHRvIGdyYWNlZnVsbHkgZGlzYWJsZVxuICogcGVyc2lzdGVuY2UgKGFzIG9wcG9zZWQgdG8gY3Jhc2hpbmcgdGhlIGNsaWVudCkuXG4gKi9cbmZ1bmN0aW9uIGNhbkZhbGxiYWNrRnJvbUluZGV4ZWREYkVycm9yKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLm5hbWUgPT09ICdGaXJlYmFzZUVycm9yJykge1xuICAgICAgICByZXR1cm4gKGVycm9yLmNvZGUgPT09IENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiB8fFxuICAgICAgICAgICAgZXJyb3IuY29kZSA9PT0gQ29kZS5VTklNUExFTUVOVEVEKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIERPTUV4Y2VwdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBET01FeGNlcHRpb24pIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIGEgZmV3IGtub3duIGNpcmN1bXN0YW5jZXMgd2hlcmUgd2UgY2FuIG9wZW4gSW5kZXhlZERiIGJ1dFxuICAgICAgICAvLyB0cnlpbmcgdG8gcmVhZC93cml0ZSB3aWxsIGZhaWwgKGUuZy4gcXVvdGEgZXhjZWVkZWQpLiBGb3JcbiAgICAgICAgLy8gd2VsbC11bmRlcnN0b29kIGNhc2VzLCB3ZSBhdHRlbXB0IHRvIGRldGVjdCB0aGVzZSBhbmQgdGhlbiBncmFjZWZ1bGx5XG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIC8vIE5PVEU6IFJhdGhlciB0aGFuIGNvbnRpbnVlIHRvIGFkZCB0byB0aGlzIGxpc3QsIHdlIGNvdWxkIGRlY2lkZSB0b1xuICAgICAgICAvLyBhbHdheXMgZmFsbCBiYWNrLCB3aXRoIHRoZSByaXNrIHRoYXQgd2UgbWlnaHQgYWNjaWRlbnRhbGx5IGhpZGUgZXJyb3JzXG4gICAgICAgIC8vIHJlcHJlc2VudGluZyBhY3R1YWwgU0RLIGJ1Z3MuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIFdoZW4gdGhlIGJyb3dzZXIgaXMgb3V0IG9mIHF1b3RhIHdlIGNvdWxkIGdldCBlaXRoZXIgcXVvdGEgZXhjZWVkZWRcbiAgICAgICAgLy8gb3IgYW4gYWJvcnRlZCBlcnJvciBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZXJyb3IgaGFwcGVuZWQgZHVyaW5nXG4gICAgICAgIC8vIHNjaGVtYSBtaWdyYXRpb24uXG4gICAgICAgIGVycm9yLmNvZGUgPT09IERPTV9FWENFUFRJT05fUVVPVEFfRVhDRUVERUQgfHxcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPT09IERPTV9FWENFUFRJT05fQUJPUlRFRCB8fFxuICAgICAgICAgICAgLy8gRmlyZWZveCBQcml2YXRlIEJyb3dzaW5nIG1vZGUgZGlzYWJsZXMgSW5kZXhlZERiIGFuZCByZXR1cm5zXG4gICAgICAgICAgICAvLyBJTlZBTElEX1NUQVRFIGZvciBhbnkgdXNhZ2UuXG4gICAgICAgICAgICBlcnJvci5jb2RlID09PSBET01fRVhDRVBUSU9OX0lOVkFMSURfU1RBVEUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZU9mZmxpbmVDb21wb25lbnRzKGNsaWVudCkge1xuICAgIGlmICghY2xpZW50Ll9vZmZsaW5lQ29tcG9uZW50cykge1xuICAgICAgICBpZiAoY2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdVc2luZyB1c2VyIHByb3ZpZGVkIE9mZmxpbmVDb21wb25lbnRQcm92aWRlcicpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzZXRPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIuX29mZmxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5GYWxsYmFja0Zyb21JbmRleGVkRGJFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZ1dhcm4oJ0Vycm9yIHVzaW5nIHVzZXIgcHJvdmlkZWQgY2FjaGUuIEZhbGxpbmcgYmFjayB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgJ21lbW9yeSBjYWNoZTogJyArXG4gICAgICAgICAgICAgICAgICAgIGVycm9yKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzZXRPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBuZXcgTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQyLCAnVXNpbmcgZGVmYXVsdCBPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXInKTtcbiAgICAgICAgICAgIGF3YWl0IHNldE9mZmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIG5ldyBMcnVHY01lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlcih1bmRlZmluZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xpZW50Ll9vZmZsaW5lQ29tcG9uZW50cztcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZU9ubGluZUNvbXBvbmVudHMoY2xpZW50KSB7XG4gICAgaWYgKCFjbGllbnQuX29ubGluZUNvbXBvbmVudHMpIHtcbiAgICAgICAgaWYgKGNsaWVudC5fdW5pbml0aWFsaXplZENvbXBvbmVudHNQcm92aWRlcikge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQyLCAnVXNpbmcgdXNlciBwcm92aWRlZCBPbmxpbmVDb21wb25lbnRQcm92aWRlcicpO1xuICAgICAgICAgICAgYXdhaXQgc2V0T25saW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIuX29ubGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdVc2luZyBkZWZhdWx0IE9ubGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XG4gICAgICAgICAgICBhd2FpdCBzZXRPbmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIG5ldyBPbmxpbmVDb21wb25lbnRQcm92aWRlcigpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xpZW50Ll9vbmxpbmVDb21wb25lbnRzO1xufVxuZnVuY3Rpb24gZ2V0UGVyc2lzdGVuY2UoY2xpZW50KSB7XG4gICAgcmV0dXJuIGVuc3VyZU9mZmxpbmVDb21wb25lbnRzKGNsaWVudCkudGhlbihjID0+IGMucGVyc2lzdGVuY2UpO1xufVxuZnVuY3Rpb24gZ2V0TG9jYWxTdG9yZShjbGllbnQpIHtcbiAgICByZXR1cm4gZW5zdXJlT2ZmbGluZUNvbXBvbmVudHMoY2xpZW50KS50aGVuKGMgPT4gYy5sb2NhbFN0b3JlKTtcbn1cbmZ1bmN0aW9uIGdldFJlbW90ZVN0b3JlKGNsaWVudCkge1xuICAgIHJldHVybiBlbnN1cmVPbmxpbmVDb21wb25lbnRzKGNsaWVudCkudGhlbihjID0+IGMucmVtb3RlU3RvcmUpO1xufVxuZnVuY3Rpb24gZ2V0U3luY0VuZ2luZShjbGllbnQpIHtcbiAgICByZXR1cm4gZW5zdXJlT25saW5lQ29tcG9uZW50cyhjbGllbnQpLnRoZW4oYyA9PiBjLnN5bmNFbmdpbmUpO1xufVxuZnVuY3Rpb24gZ2V0RGF0YXN0b3JlJDEoY2xpZW50KSB7XG4gICAgcmV0dXJuIGVuc3VyZU9ubGluZUNvbXBvbmVudHMoY2xpZW50KS50aGVuKGMgPT4gYy5kYXRhc3RvcmUpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCkge1xuICAgIGNvbnN0IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gYXdhaXQgZW5zdXJlT25saW5lQ29tcG9uZW50cyhjbGllbnQpO1xuICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLmV2ZW50TWFuYWdlcjtcbiAgICBldmVudE1hbmFnZXIub25MaXN0ZW4gPSBzeW5jRW5naW5lTGlzdGVuLmJpbmQobnVsbCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY0VuZ2luZSk7XG4gICAgZXZlbnRNYW5hZ2VyLm9uVW5saXN0ZW4gPSBzeW5jRW5naW5lVW5saXN0ZW4uYmluZChudWxsLCBvbmxpbmVDb21wb25lbnRQcm92aWRlci5zeW5jRW5naW5lKTtcbiAgICBldmVudE1hbmFnZXIub25GaXJzdFJlbW90ZVN0b3JlTGlzdGVuID0gdHJpZ2dlclJlbW90ZVN0b3JlTGlzdGVuLmJpbmQobnVsbCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY0VuZ2luZSk7XG4gICAgZXZlbnRNYW5hZ2VyLm9uTGFzdFJlbW90ZVN0b3JlVW5saXN0ZW4gPSB0cmlnZ2VyUmVtb3RlU3RvcmVVbmxpc3Rlbi5iaW5kKG51bGwsIG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmUpO1xuICAgIHJldHVybiBldmVudE1hbmFnZXI7XG59XG4vKiogRW5hYmxlcyB0aGUgbmV0d29yayBjb25uZWN0aW9uIGFuZCByZS1lbnF1ZXVlcyBhbGwgcGVuZGluZyBvcGVyYXRpb25zLiAqL1xuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50RW5hYmxlTmV0d29yayhjbGllbnQpIHtcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlcnNpc3RlbmNlID0gYXdhaXQgZ2V0UGVyc2lzdGVuY2UoY2xpZW50KTtcbiAgICAgICAgY29uc3QgcmVtb3RlU3RvcmUgPSBhd2FpdCBnZXRSZW1vdGVTdG9yZShjbGllbnQpO1xuICAgICAgICBwZXJzaXN0ZW5jZS5zZXROZXR3b3JrRW5hYmxlZCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZVN0b3JlRW5hYmxlTmV0d29yayhyZW1vdGVTdG9yZSk7XG4gICAgfSk7XG59XG4vKiogRGlzYWJsZXMgdGhlIG5ldHdvcmsgY29ubmVjdGlvbi4gUGVuZGluZyBvcGVyYXRpb25zIHdpbGwgbm90IGNvbXBsZXRlLiAqL1xuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50RGlzYWJsZU5ldHdvcmsoY2xpZW50KSB7XG4gICAgcmV0dXJuIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBwZXJzaXN0ZW5jZSA9IGF3YWl0IGdldFBlcnNpc3RlbmNlKGNsaWVudCk7XG4gICAgICAgIGNvbnN0IHJlbW90ZVN0b3JlID0gYXdhaXQgZ2V0UmVtb3RlU3RvcmUoY2xpZW50KTtcbiAgICAgICAgcGVyc2lzdGVuY2Uuc2V0TmV0d29ya0VuYWJsZWQoZmFsc2UpO1xuICAgICAgICByZXR1cm4gcmVtb3RlU3RvcmVEaXNhYmxlTmV0d29yayhyZW1vdGVTdG9yZSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgd3JpdGVzIHRoYXQgd2VyZSBwZW5kaW5nIGF0IHRoZSB0aW1lXG4gKiB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkIHJlY2VpdmVkIHNlcnZlciBhY2tub3dsZWRnZW1lbnQuIEFuIGFja25vd2xlZGdlbWVudFxuICogY2FuIGJlIGVpdGhlciBhY2NlcHRhbmNlIG9yIHJlamVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50V2FpdEZvclBlbmRpbmdXcml0ZXMoY2xpZW50KSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3luY0VuZ2luZSA9IGF3YWl0IGdldFN5bmNFbmdpbmUoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIHN5bmNFbmdpbmVSZWdpc3RlclBlbmRpbmdXcml0ZXNDYWxsYmFjayhzeW5jRW5naW5lLCBkZWZlcnJlZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRMaXN0ZW4oY2xpZW50LCBxdWVyeSwgb3B0aW9ucywgb2JzZXJ2ZXIpIHtcbiAgICBjb25zdCB3cmFwcGVkT2JzZXJ2ZXIgPSBuZXcgQXN5bmNPYnNlcnZlcihvYnNlcnZlcik7XG4gICAgY29uc3QgbGlzdGVuZXIgPSBuZXcgUXVlcnlMaXN0ZW5lcihxdWVyeSwgd3JhcHBlZE9ic2VydmVyLCBvcHRpb25zKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gYXdhaXQgZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCk7XG4gICAgICAgIHJldHVybiBldmVudE1hbmFnZXJMaXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd3JhcHBlZE9ic2VydmVyLm11dGUoKTtcbiAgICAgICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcbiAgICAgICAgICAgIHJldHVybiBldmVudE1hbmFnZXJVbmxpc3RlbihldmVudE1hbmFnZXIsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50RnJvbUxvY2FsQ2FjaGUoY2xpZW50LCBkb2NLZXkpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBsb2NhbFN0b3JlID0gYXdhaXQgZ2V0TG9jYWxTdG9yZShjbGllbnQpO1xuICAgICAgICByZXR1cm4gcmVhZERvY3VtZW50RnJvbUNhY2hlKGxvY2FsU3RvcmUsIGRvY0tleSwgZGVmZXJyZWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRWaWFTbmFwc2hvdExpc3RlbmVyKGNsaWVudCwga2V5LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIHJlYWREb2N1bWVudFZpYVNuYXBzaG90TGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCBjbGllbnQuYXN5bmNRdWV1ZSwga2V5LCBvcHRpb25zLCBkZWZlcnJlZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNGcm9tTG9jYWxDYWNoZShjbGllbnQsIHF1ZXJ5KSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbG9jYWxTdG9yZSA9IGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGVRdWVyeUZyb21DYWNoZShsb2NhbFN0b3JlLCBxdWVyeSwgZGVmZXJyZWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRzVmlhU25hcHNob3RMaXN0ZW5lcihjbGllbnQsIHF1ZXJ5LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGVRdWVyeVZpYVNuYXBzaG90TGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCBjbGllbnQuYXN5bmNRdWV1ZSwgcXVlcnksIG9wdGlvbnMsIGRlZmVycmVkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudFJ1bkFnZ3JlZ2F0ZVF1ZXJ5KGNsaWVudCwgcXVlcnksIGFnZ3JlZ2F0ZXMpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBJbXBsZW1lbnQgYW5kIGNhbGwgZXhlY3V0ZUFnZ3JlZ2F0ZVF1ZXJ5VmlhU25hcHNob3RMaXN0ZW5lciwgc2ltaWxhclxuICAgICAgICAvLyB0byB0aGUgaW1wbGVtZW50YXRpb24gaW4gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRzVmlhU25hcHNob3RMaXN0ZW5lclxuICAgICAgICAvLyBhYm92ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVE9ETyhiLzI3NzYyODM4NCk6IGNoZWNrIGBjYW5Vc2VOZXR3b3JrKClgIGFuZCBoYW5kbGUgbXVsdGktdGFiLlxuICAgICAgICAgICAgY29uc3QgZGF0YXN0b3JlID0gYXdhaXQgZ2V0RGF0YXN0b3JlJDEoY2xpZW50KTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoaW52b2tlUnVuQWdncmVnYXRpb25RdWVyeVJwYyhkYXRhc3RvcmUsIHF1ZXJ5LCBhZ2dyZWdhdGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50RXhlY3V0ZVBpcGVsaW5lKGNsaWVudCwgcGlwZWxpbmUpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXN0b3JlID0gYXdhaXQgZ2V0RGF0YXN0b3JlJDEoY2xpZW50KTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoaW52b2tlRXhlY3V0ZVBpcGVsaW5lKGRhdGFzdG9yZSwgcGlwZWxpbmUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRXcml0ZShjbGllbnQsIG11dGF0aW9ucykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bmNFbmdpbmUgPSBhd2FpdCBnZXRTeW5jRW5naW5lKGNsaWVudCk7XG4gICAgICAgIHJldHVybiBzeW5jRW5naW5lV3JpdGUoc3luY0VuZ2luZSwgbXV0YXRpb25zLCBkZWZlcnJlZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRBZGRTbmFwc2hvdHNJblN5bmNMaXN0ZW5lcihjbGllbnQsIG9ic2VydmVyKSB7XG4gICAgY29uc3Qgd3JhcHBlZE9ic2VydmVyID0gbmV3IEFzeW5jT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIGFkZFNuYXBzaG90c0luU3luY0xpc3RlbmVyKGV2ZW50TWFuYWdlciwgd3JhcHBlZE9ic2VydmVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3cmFwcGVkT2JzZXJ2ZXIubXV0ZSgpO1xuICAgICAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IGF3YWl0IGdldEV2ZW50TWFuYWdlcihjbGllbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVNuYXBzaG90c0luU3luY0xpc3RlbmVyKGV2ZW50TWFuYWdlciwgd3JhcHBlZE9ic2VydmVyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogVGFrZXMgYW4gdXBkYXRlRnVuY3Rpb24gaW4gd2hpY2ggYSBzZXQgb2YgcmVhZHMgYW5kIHdyaXRlcyBjYW4gYmUgcGVyZm9ybWVkXG4gKiBhdG9taWNhbGx5LiBJbiB0aGUgdXBkYXRlRnVuY3Rpb24sIHRoZSBjbGllbnQgY2FuIHJlYWQgYW5kIHdyaXRlIHZhbHVlc1xuICogdXNpbmcgdGhlIHN1cHBsaWVkIHRyYW5zYWN0aW9uIG9iamVjdC4gQWZ0ZXIgdGhlIHVwZGF0ZUZ1bmN0aW9uLCBhbGxcbiAqIGNoYW5nZXMgd2lsbCBiZSBjb21taXR0ZWQuIElmIGEgcmV0cnlhYmxlIGVycm9yIG9jY3VycyAoZXg6IHNvbWUgb3RoZXJcbiAqIGNsaWVudCBoYXMgY2hhbmdlZCBhbnkgb2YgdGhlIGRhdGEgcmVmZXJlbmNlZCksIHRoZW4gdGhlIHVwZGF0ZUZ1bmN0aW9uXG4gKiB3aWxsIGJlIGNhbGxlZCBhZ2FpbiBhZnRlciBhIGJhY2tvZmYuIElmIHRoZSB1cGRhdGVGdW5jdGlvbiBzdGlsbCBmYWlsc1xuICogYWZ0ZXIgYWxsIHJldHJpZXMsIHRoZW4gdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgcmVqZWN0ZWQuXG4gKlxuICogVGhlIHRyYW5zYWN0aW9uIG9iamVjdCBwYXNzZWQgdG8gdGhlIHVwZGF0ZUZ1bmN0aW9uIGNvbnRhaW5zIG1ldGhvZHMgZm9yXG4gKiBhY2Nlc3NpbmcgZG9jdW1lbnRzIGFuZCBjb2xsZWN0aW9ucy4gVW5saWtlIG90aGVyIGRhdGFzdG9yZSBhY2Nlc3MsIGRhdGFcbiAqIGFjY2Vzc2VkIHdpdGggdGhlIHRyYW5zYWN0aW9uIHdpbGwgbm90IHJlZmxlY3QgbG9jYWwgY2hhbmdlcyB0aGF0IGhhdmUgbm90XG4gKiBiZWVuIGNvbW1pdHRlZC4gRm9yIHRoaXMgcmVhc29uLCBpdCBpcyByZXF1aXJlZCB0aGF0IGFsbCByZWFkcyBhcmVcbiAqIHBlcmZvcm1lZCBiZWZvcmUgYW55IHdyaXRlcy4gVHJhbnNhY3Rpb25zIG11c3QgYmUgcGVyZm9ybWVkIHdoaWxlIG9ubGluZS5cbiAqL1xuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50VHJhbnNhY3Rpb24oY2xpZW50LCB1cGRhdGVGdW5jdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGFzdG9yZSA9IGF3YWl0IGdldERhdGFzdG9yZSQxKGNsaWVudCk7XG4gICAgICAgIG5ldyBUcmFuc2FjdGlvblJ1bm5lcihjbGllbnQuYXN5bmNRdWV1ZSwgZGF0YXN0b3JlLCBvcHRpb25zLCB1cGRhdGVGdW5jdGlvbiwgZGVmZXJyZWQpLnJ1bigpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVhZERvY3VtZW50RnJvbUNhY2hlKGxvY2FsU3RvcmUsIGRvY0tleSwgcmVzdWx0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBhd2FpdCBsb2NhbFN0b3JlUmVhZERvY3VtZW50KGxvY2FsU3RvcmUsIGRvY0tleSk7XG4gICAgICAgIGlmIChkb2N1bWVudC5pc0ZvdW5kRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LmlzTm9Eb2N1bWVudCgpKSB7XG4gICAgICAgICAgICByZXN1bHQucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsICdGYWlsZWQgdG8gZ2V0IGRvY3VtZW50IGZyb20gY2FjaGUuIChIb3dldmVyLCB0aGlzIGRvY3VtZW50IG1heSAnICtcbiAgICAgICAgICAgICAgICBcImV4aXN0IG9uIHRoZSBzZXJ2ZXIuIFJ1biBhZ2FpbiB3aXRob3V0IHNldHRpbmcgJ3NvdXJjZScgaW4gXCIgK1xuICAgICAgICAgICAgICAgICd0aGUgR2V0T3B0aW9ucyB0byBhdHRlbXB0IHRvIHJldHJpZXZlIHRoZSBkb2N1bWVudCBmcm9tIHRoZSAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLiknKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZmlyZXN0b3JlRXJyb3IgPSB3cmFwSW5Vc2VyRXJyb3JJZlJlY292ZXJhYmxlKGUsIGBGYWlsZWQgdG8gZ2V0IGRvY3VtZW50ICcke2RvY0tleX0gZnJvbSBjYWNoZWApO1xuICAgICAgICByZXN1bHQucmVqZWN0KGZpcmVzdG9yZUVycm9yKTtcbiAgICB9XG59XG4vKipcbiAqIFJldHJpZXZlcyBhIGxhdGVuY3ktY29tcGVuc2F0ZWQgZG9jdW1lbnQgZnJvbSB0aGUgYmFja2VuZCB2aWEgYVxuICogU25hcHNob3RMaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gcmVhZERvY3VtZW50VmlhU25hcHNob3RMaXN0ZW5lcihldmVudE1hbmFnZXIsIGFzeW5jUXVldWUsIGtleSwgb3B0aW9ucywgcmVzdWx0KSB7XG4gICAgY29uc3Qgd3JhcHBlZE9ic2VydmVyID0gbmV3IEFzeW5jT2JzZXJ2ZXIoe1xuICAgICAgICBuZXh0OiAoc25hcCkgPT4ge1xuICAgICAgICAgICAgLy8gTXV0ZSBhbmQgcmVtb3ZlIHF1ZXJ5IGZpcnN0IGJlZm9yZSBwYXNzaW5nIGV2ZW50IHRvIHVzZXIgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIHVzZXIgYWN0aW9ucyBhZmZlY3RpbmcgdGhlIG5vdyBzdGFsZSBxdWVyeS5cbiAgICAgICAgICAgIHdyYXBwZWRPYnNlcnZlci5tdXRlKCk7XG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4gZXZlbnRNYW5hZ2VyVW5saXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcikpO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RzID0gc25hcC5kb2NzLmhhcyhrZXkpO1xuICAgICAgICAgICAgaWYgKCFleGlzdHMgJiYgc25hcC5mcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGRpbW9uZCk6IElmIHdlJ3JlIG9ubGluZSBhbmQgdGhlIGRvY3VtZW50IGRvZXNuJ3RcbiAgICAgICAgICAgICAgICAvLyBleGlzdCB0aGVuIHdlIHJlc29sdmUgd2l0aCBhIGRvYy5leGlzdHMgc2V0IHRvIGZhbHNlLiBJZlxuICAgICAgICAgICAgICAgIC8vIHdlJ3JlIG9mZmxpbmUgaG93ZXZlciwgd2UgcmVqZWN0IHRoZSBQcm9taXNlIGluIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBjYXNlLiBUd28gb3B0aW9uczogMSkgQ2FjaGUgdGhlIG5lZ2F0aXZlIHJlc3BvbnNlIGZyb21cbiAgICAgICAgICAgICAgICAvLyB0aGUgc2VydmVyIHNvIHdlIGNhbiBkZWxpdmVyIHRoYXQgZXZlbiB3aGVuIHlvdSdyZVxuICAgICAgICAgICAgICAgIC8vIG9mZmxpbmUgMikgQWN0dWFsbHkgcmVqZWN0IHRoZSBQcm9taXNlIGluIHRoZSBvbmxpbmUgY2FzZVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsICdGYWlsZWQgdG8gZ2V0IGRvY3VtZW50IGJlY2F1c2UgdGhlIGNsaWVudCBpcyBvZmZsaW5lLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4aXN0cyAmJlxuICAgICAgICAgICAgICAgIHNuYXAuZnJvbUNhY2hlICYmXG4gICAgICAgICAgICAgICAgb3B0aW9ucyAmJlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc291cmNlID09PSAnc2VydmVyJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsICdGYWlsZWQgdG8gZ2V0IGRvY3VtZW50IGZyb20gc2VydmVyLiAoSG93ZXZlciwgdGhpcyAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2RvY3VtZW50IGRvZXMgZXhpc3QgaW4gdGhlIGxvY2FsIGNhY2hlLiBSdW4gYWdhaW4gJyArXG4gICAgICAgICAgICAgICAgICAgICd3aXRob3V0IHNldHRpbmcgc291cmNlIHRvIFwic2VydmVyXCIgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICdyZXRyaWV2ZSB0aGUgY2FjaGVkIGRvY3VtZW50LiknKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVzb2x2ZShzbmFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGUgPT4gcmVzdWx0LnJlamVjdChlKVxuICAgIH0pO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gbmV3IFF1ZXJ5TGlzdGVuZXIobmV3UXVlcnlGb3JQYXRoKGtleS5wYXRoKSwgd3JhcHBlZE9ic2VydmVyLCB7XG4gICAgICAgIGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM6IHRydWUsXG4gICAgICAgIHdhaXRGb3JTeW5jV2hlbk9ubGluZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBldmVudE1hbmFnZXJMaXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcik7XG59XG5hc3luYyBmdW5jdGlvbiBleGVjdXRlUXVlcnlGcm9tQ2FjaGUobG9jYWxTdG9yZSwgcXVlcnksIHJlc3VsdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UmVzdWx0ID0gYXdhaXQgbG9jYWxTdG9yZUV4ZWN1dGVRdWVyeShsb2NhbFN0b3JlLCBxdWVyeSwgXG4gICAgICAgIC8qIHVzZVByZXZpb3VzUmVzdWx0cz0gKi8gdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVmlldyhxdWVyeSwgcXVlcnlSZXN1bHQucmVtb3RlS2V5cyk7XG4gICAgICAgIGNvbnN0IHZpZXdEb2NDaGFuZ2VzID0gdmlldy5jb21wdXRlRG9jQ2hhbmdlcyhxdWVyeVJlc3VsdC5kb2N1bWVudHMpO1xuICAgICAgICBjb25zdCB2aWV3Q2hhbmdlID0gdmlldy5hcHBseUNoYW5nZXModmlld0RvY0NoYW5nZXMsIFxuICAgICAgICAvKiBsaW1ib1Jlc29sdXRpb25FbmFibGVkPSAqLyBmYWxzZSk7XG4gICAgICAgIHJlc3VsdC5yZXNvbHZlKHZpZXdDaGFuZ2Uuc25hcHNob3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBmaXJlc3RvcmVFcnJvciA9IHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgYEZhaWxlZCB0byBleGVjdXRlIHF1ZXJ5ICcke3F1ZXJ5fSBhZ2FpbnN0IGNhY2hlYCk7XG4gICAgICAgIHJlc3VsdC5yZWplY3QoZmlyZXN0b3JlRXJyb3IpO1xuICAgIH1cbn1cbi8qKlxuICogUmV0cmlldmVzIGEgbGF0ZW5jeS1jb21wZW5zYXRlZCBxdWVyeSBzbmFwc2hvdCBmcm9tIHRoZSBiYWNrZW5kIHZpYSBhXG4gKiBTbmFwc2hvdExpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBleGVjdXRlUXVlcnlWaWFTbmFwc2hvdExpc3RlbmVyKGV2ZW50TWFuYWdlciwgYXN5bmNRdWV1ZSwgcXVlcnksIG9wdGlvbnMsIHJlc3VsdCkge1xuICAgIGNvbnN0IHdyYXBwZWRPYnNlcnZlciA9IG5ldyBBc3luY09ic2VydmVyKHtcbiAgICAgICAgbmV4dDogc25hcHNob3QgPT4ge1xuICAgICAgICAgICAgLy8gTXV0ZSBhbmQgcmVtb3ZlIHF1ZXJ5IGZpcnN0IGJlZm9yZSBwYXNzaW5nIGV2ZW50IHRvIHVzZXIgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIHVzZXIgYWN0aW9ucyBhZmZlY3RpbmcgdGhlIG5vdyBzdGFsZSBxdWVyeS5cbiAgICAgICAgICAgIHdyYXBwZWRPYnNlcnZlci5tdXRlKCk7XG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4gZXZlbnRNYW5hZ2VyVW5saXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcikpO1xuICAgICAgICAgICAgaWYgKHNuYXBzaG90LmZyb21DYWNoZSAmJiBvcHRpb25zLnNvdXJjZSA9PT0gJ3NlcnZlcicpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOQVZBSUxBQkxFLCAnRmFpbGVkIHRvIGdldCBkb2N1bWVudHMgZnJvbSBzZXJ2ZXIuIChIb3dldmVyLCB0aGVzZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2RvY3VtZW50cyBtYXkgZXhpc3QgaW4gdGhlIGxvY2FsIGNhY2hlLiBSdW4gYWdhaW4gJyArXG4gICAgICAgICAgICAgICAgICAgICd3aXRob3V0IHNldHRpbmcgc291cmNlIHRvIFwic2VydmVyXCIgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICdyZXRyaWV2ZSB0aGUgY2FjaGVkIGRvY3VtZW50cy4pJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoc25hcHNob3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZSA9PiByZXN1bHQucmVqZWN0KGUpXG4gICAgfSk7XG4gICAgY29uc3QgbGlzdGVuZXIgPSBuZXcgUXVlcnlMaXN0ZW5lcihxdWVyeSwgd3JhcHBlZE9ic2VydmVyLCB7XG4gICAgICAgIGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM6IHRydWUsXG4gICAgICAgIHdhaXRGb3JTeW5jV2hlbk9ubGluZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBldmVudE1hbmFnZXJMaXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcik7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRMb2FkQnVuZGxlKGNsaWVudCwgZGF0YWJhc2VJZCwgZGF0YSwgcmVzdWx0VGFzaykge1xuICAgIGNvbnN0IHJlYWRlciA9IGNyZWF0ZUJ1bmRsZVJlYWRlcihkYXRhLCBuZXdTZXJpYWxpemVyKGRhdGFiYXNlSWQpKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgc3luY0VuZ2luZUxvYWRCdW5kbGUoYXdhaXQgZ2V0U3luY0VuZ2luZShjbGllbnQpLCByZWFkZXIsIHJlc3VsdFRhc2spO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50R2V0TmFtZWRRdWVyeShjbGllbnQsIHF1ZXJ5TmFtZSkge1xuICAgIHJldHVybiBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IGxvY2FsU3RvcmVHZXROYW1lZFF1ZXJ5KGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KSwgcXVlcnlOYW1lKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVCdW5kbGVSZWFkZXIoZGF0YSwgc2VyaWFsaXplcikge1xuICAgIGxldCBjb250ZW50O1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29udGVudCA9IG5ld1RleHRFbmNvZGVyKCkuZW5jb2RlKGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udGVudCA9IGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBuZXdCdW5kbGVSZWFkZXIodG9CeXRlU3RyZWFtUmVhZGVyKGNvbnRlbnQpLCBzZXJpYWxpemVyKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJ1bmRsZVJlYWRlclN5bmMoYnVuZGxlRGF0YSwgc2VyaWFsaXplcikge1xuICAgIHJldHVybiBuZXdCdW5kbGVSZWFkZXJTeW5jKGJ1bmRsZURhdGEsIHNlcmlhbGl6ZXIpO1xufVxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50U2V0SW5kZXhDb25maWd1cmF0aW9uKGNsaWVudCwgaW5kZXhlcykge1xuICAgIHJldHVybiBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVDb25maWd1cmVGaWVsZEluZGV4ZXMoYXdhaXQgZ2V0TG9jYWxTdG9yZShjbGllbnQpLCBpbmRleGVzKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudFNldFBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZChjbGllbnQsIGlzRW5hYmxlZCkge1xuICAgIHJldHVybiBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVTZXRJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQoYXdhaXQgZ2V0TG9jYWxTdG9yZShjbGllbnQpLCBpc0VuYWJsZWQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50RGVsZXRlQWxsRmllbGRJbmRleGVzKGNsaWVudCkge1xuICAgIHJldHVybiBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVEZWxldGVBbGxGaWVsZEluZGV4ZXMoYXdhaXQgZ2V0TG9jYWxTdG9yZShjbGllbnQpKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ29tcGFyZXMgdHdvIGBFeHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnNgIG9iamVjdHMgZm9yIGVxdWFsaXR5LlxuICovXG5mdW5jdGlvbiBsb25nUG9sbGluZ09wdGlvbnNFcXVhbChvcHRpb25zMSwgb3B0aW9uczIpIHtcbiAgICByZXR1cm4gb3B0aW9uczEudGltZW91dFNlY29uZHMgPT09IG9wdGlvbnMyLnRpbWVvdXRTZWNvbmRzO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IGBFeHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnNgIHdpdGggdGhlIHNhbWVcbiAqIG9wdGlvbiB2YWx1ZXMgYXMgdGhlIGdpdmVuIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBjbG9uZUxvbmdQb2xsaW5nT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgY2xvbmUgPSB7fTtcbiAgICBpZiAob3B0aW9ucy50aW1lb3V0U2Vjb25kcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNsb25lLnRpbWVvdXRTZWNvbmRzID0gb3B0aW9ucy50aW1lb3V0U2Vjb25kcztcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyQxID0gJ0NvbXBvbmVudFByb3ZpZGVyJztcbi8qKlxuICogQW4gaW5zdGFuY2UgbWFwIHRoYXQgZW5zdXJlcyBvbmx5IG9uZSBEYXRhc3RvcmUgZXhpc3RzIHBlciBGaXJlc3RvcmVcbiAqIGluc3RhbmNlLlxuICovXG5jb25zdCBkYXRhc3RvcmVJbnN0YW5jZXMgPSBuZXcgTWFwKCk7XG4vKipcbiAqIFJldHVybnMgYW4gaW5pdGlhbGl6ZWQgYW5kIHN0YXJ0ZWQgRGF0YXN0b3JlIGZvciB0aGUgZ2l2ZW4gRmlyZXN0b3JlXG4gKiBpbnN0YW5jZS4gQ2FsbGVycyBtdXN0IGludm9rZSByZW1vdmVDb21wb25lbnRzKCkgd2hlbiB0aGUgRmlyZXN0b3JlXG4gKiBpbnN0YW5jZSBpcyB0ZXJtaW5hdGVkLlxuICovXG5mdW5jdGlvbiBnZXREYXRhc3RvcmUoZmlyZXN0b3JlKSB7XG4gICAgaWYgKGZpcmVzdG9yZS5fdGVybWluYXRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnVGhlIGNsaWVudCBoYXMgYWxyZWFkeSBiZWVuIHRlcm1pbmF0ZWQuJyk7XG4gICAgfVxuICAgIGlmICghZGF0YXN0b3JlSW5zdGFuY2VzLmhhcyhmaXJlc3RvcmUpKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMSwgJ0luaXRpYWxpemluZyBEYXRhc3RvcmUnKTtcbiAgICAgICAgY29uc3QgZGF0YWJhc2VJbmZvID0gbWFrZURhdGFiYXNlSW5mbyhmaXJlc3RvcmUuX2RhdGFiYXNlSWQsIGZpcmVzdG9yZS5hcHAub3B0aW9ucy5hcHBJZCB8fCAnJywgZmlyZXN0b3JlLl9wZXJzaXN0ZW5jZUtleSwgZmlyZXN0b3JlLmFwcC5vcHRpb25zLmFwaUtleSwgZmlyZXN0b3JlLl9mcmVlemVTZXR0aW5ncygpKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IG5ld0Nvbm5lY3Rpb24oZGF0YWJhc2VJbmZvKTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplciA9IG5ld1NlcmlhbGl6ZXIoZmlyZXN0b3JlLl9kYXRhYmFzZUlkKTtcbiAgICAgICAgY29uc3QgZGF0YXN0b3JlID0gbmV3RGF0YXN0b3JlKGZpcmVzdG9yZS5fYXV0aENyZWRlbnRpYWxzLCBmaXJlc3RvcmUuX2FwcENoZWNrQ3JlZGVudGlhbHMsIGNvbm5lY3Rpb24sIHNlcmlhbGl6ZXIpO1xuICAgICAgICBkYXRhc3RvcmVJbnN0YW5jZXMuc2V0KGZpcmVzdG9yZSwgZGF0YXN0b3JlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFzdG9yZUluc3RhbmNlcy5nZXQoZmlyZXN0b3JlKTtcbn1cbi8qKlxuICogUmVtb3ZlcyBhbGwgY29tcG9uZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIGluc3RhbmNlLiBNdXN0IGJlIGNhbGxlZFxuICogd2hlbiB0aGUgYEZpcmVzdG9yZWAgaW5zdGFuY2UgaXMgdGVybWluYXRlZC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ29tcG9uZW50cyhmaXJlc3RvcmUpIHtcbiAgICBjb25zdCBkYXRhc3RvcmUgPSBkYXRhc3RvcmVJbnN0YW5jZXMuZ2V0KGZpcmVzdG9yZSk7XG4gICAgaWYgKGRhdGFzdG9yZSkge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDEsICdSZW1vdmluZyBEYXRhc3RvcmUnKTtcbiAgICAgICAgZGF0YXN0b3JlSW5zdGFuY2VzLmRlbGV0ZShmaXJlc3RvcmUpO1xuICAgICAgICBkYXRhc3RvcmUudGVybWluYXRlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZURhdGFiYXNlSW5mbyhkYXRhYmFzZUlkLCBhcHBJZCwgcGVyc2lzdGVuY2VLZXksIGFwaUtleSwgc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IERhdGFiYXNlSW5mbyhkYXRhYmFzZUlkLCBhcHBJZCwgcGVyc2lzdGVuY2VLZXksIHNldHRpbmdzLmhvc3QsIHNldHRpbmdzLnNzbCwgc2V0dGluZ3MuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZywgc2V0dGluZ3MuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nLCBjbG9uZUxvbmdQb2xsaW5nT3B0aW9ucyhzZXR0aW5ncy5leHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMpLCBzZXR0aW5ncy51c2VGZXRjaFN0cmVhbXMsIHNldHRpbmdzLmlzVXNpbmdFbXVsYXRvciwgYXBpS2V5KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIHNldHRpbmdzKCkgZGVmYXVsdHM6XG5jb25zdCBERUZBVUxUX0hPU1QgPSAnZmlyZXN0b3JlLmdvb2dsZWFwaXMuY29tJztcbmNvbnN0IERFRkFVTFRfU1NMID0gdHJ1ZTtcbi8vIFRoZSBtaW5pbXVtIGxvbmctcG9sbGluZyB0aW1lb3V0IGlzIGhhcmRjb2RlZCBvbiB0aGUgc2VydmVyLiBUaGUgdmFsdWUgaGVyZVxuLy8gc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSB2YWx1ZSB1c2VkIGJ5IHRoZSBzZXJ2ZXIsIGFzIHRoZSBzZXJ2ZXIgd2lsbFxuLy8gc2lsZW50bHkgaWdub3JlIGEgdmFsdWUgYmVsb3cgdGhlIG1pbmltdW0gYW5kIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdC5cbi8vIEdvb2dsZXJzIHNlZSBiLzI2Njg2ODg3MSBmb3IgcmVsZXZhbnQgZGlzY3Vzc2lvbi5cbmNvbnN0IE1JTl9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTID0gNTtcbi8vIE5vIG1heGltdW0gbG9uZy1wb2xsaW5nIHRpbWVvdXQgaXMgY29uZmlndXJlZCBpbiB0aGUgc2VydmVyLCBhbmQgZGVmYXVsdHMgdG9cbi8vIDMwIHNlY29uZHMsIHdoaWNoIGlzIHdoYXQgV2F0Y2ggYXBwZWFycyB0byB1c2UuXG4vLyBHb29nbGVycyBzZWUgYi8yNjY4Njg4NzEgZm9yIHJlbGV2YW50IGRpc2N1c3Npb24uXG5jb25zdCBNQVhfTE9OR19QT0xMSU5HX1RJTUVPVVRfU0VDT05EUyA9IDMwO1xuLy8gV2hldGhlciBsb25nLXBvbGxpbmcgYXV0by1kZXRlY3RlZCBpcyBlbmFibGVkIGJ5IGRlZmF1bHQuXG5jb25zdCBERUZBVUxUX0FVVE9fREVURUNUX0xPTkdfUE9MTElORyA9IHRydWU7XG4vKipcbiAqIEEgY29uY3JldGUgdHlwZSBkZXNjcmliaW5nIGFsbCB0aGUgdmFsdWVzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdmlhIGFcbiAqIHVzZXItc3VwcGxpZWQgYEZpcmVzdG9yZVNldHRpbmdzYCBvYmplY3QuIFRoaXMgaXMgYSBzZXBhcmF0ZSB0eXBlIHNvIHRoYXRcbiAqIGRlZmF1bHRzIGNhbiBiZSBzdXBwbGllZCBhbmQgdGhlIHZhbHVlIGNhbiBiZSBjaGVja2VkIGZvciBlcXVhbGl0eS5cbiAqL1xuY2xhc3MgRmlyZXN0b3JlU2V0dGluZ3NJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBpZiAoc2V0dGluZ3MuaG9zdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Muc3NsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBcIkNhbid0IHByb3ZpZGUgc3NsIG9wdGlvbiBpZiBob3N0IG9wdGlvbiBpcyBub3Qgc2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0ID0gREVGQVVMVF9IT1NUO1xuICAgICAgICAgICAgdGhpcy5zc2wgPSBERUZBVUxUX1NTTDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaG9zdCA9IHNldHRpbmdzLmhvc3Q7XG4gICAgICAgICAgICB0aGlzLnNzbCA9IHNldHRpbmdzLnNzbCA/PyBERUZBVUxUX1NTTDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzVXNpbmdFbXVsYXRvciA9IHNldHRpbmdzLmVtdWxhdG9yT3B0aW9ucyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gc2V0dGluZ3MuY3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyA9ICEhc2V0dGluZ3MuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcztcbiAgICAgICAgdGhpcy5sb2NhbENhY2hlID0gc2V0dGluZ3MubG9jYWxDYWNoZTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBMUlVfREVGQVVMVF9DQUNIRV9TSVpFX0JZVEVTO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzICE9PSBMUlVfQ09MTEVDVElPTl9ESVNBQkxFRCAmJlxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzIDwgTFJVX01JTklNVU1fQ0FDSEVfU0laRV9CWVRFUykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBjYWNoZVNpemVCeXRlcyBtdXN0IGJlIGF0IGxlYXN0ICR7TFJVX01JTklNVU1fQ0FDSEVfU0laRV9CWVRFU31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZUlzTm90VXNlZFRvZ2V0aGVyKCdleHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nJywgc2V0dGluZ3MuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZywgJ2V4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZycsIHNldHRpbmdzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyk7XG4gICAgICAgIHRoaXMuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZyA9ICEhc2V0dGluZ3MuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZztcbiAgICAgICAgaWYgKHRoaXMuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZykge1xuICAgICAgICAgICAgdGhpcy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZXR0aW5ncy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPSBERUZBVUxUX0FVVE9fREVURUNUX0xPTkdfUE9MTElORztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgY29lcmNlIHRoZSB2YWx1ZSB0byBib29sZWFuIGV2ZW4gdGhvdWdoXG4gICAgICAgICAgICAvLyB0aGUgVHlwZVNjcmlwdCBjb21waWxlciBoYXMgbmFycm93ZWQgdGhlIHR5cGUgdG8gYm9vbGVhbiBhbHJlYWR5LlxuICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFBvaW50bGVzc0Jvb2xlYW5FeHByZXNzaW9uSlNcbiAgICAgICAgICAgIHRoaXMuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nID1cbiAgICAgICAgICAgICAgICAhIXNldHRpbmdzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucyA9IGNsb25lTG9uZ1BvbGxpbmdPcHRpb25zKHNldHRpbmdzLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucyA/PyB7fSk7XG4gICAgICAgIHZhbGlkYXRlTG9uZ1BvbGxpbmdPcHRpb25zKHRoaXMuZXhwZXJpbWVudGFsTG9uZ1BvbGxpbmdPcHRpb25zKTtcbiAgICAgICAgdGhpcy51c2VGZXRjaFN0cmVhbXMgPSAhIXNldHRpbmdzLnVzZUZldGNoU3RyZWFtcztcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKHRoaXMuaG9zdCA9PT0gb3RoZXIuaG9zdCAmJlxuICAgICAgICAgICAgdGhpcy5zc2wgPT09IG90aGVyLnNzbCAmJlxuICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9PT0gb3RoZXIuY3JlZGVudGlhbHMgJiZcbiAgICAgICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPT09IG90aGVyLmNhY2hlU2l6ZUJ5dGVzICYmXG4gICAgICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmcgPT09XG4gICAgICAgICAgICAgICAgb3RoZXIuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZyAmJlxuICAgICAgICAgICAgdGhpcy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgPT09XG4gICAgICAgICAgICAgICAgb3RoZXIuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nICYmXG4gICAgICAgICAgICBsb25nUG9sbGluZ09wdGlvbnNFcXVhbCh0aGlzLmV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9ucywgb3RoZXIuZXhwZXJpbWVudGFsTG9uZ1BvbGxpbmdPcHRpb25zKSAmJlxuICAgICAgICAgICAgdGhpcy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzID09PSBvdGhlci5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzICYmXG4gICAgICAgICAgICB0aGlzLnVzZUZldGNoU3RyZWFtcyA9PT0gb3RoZXIudXNlRmV0Y2hTdHJlYW1zKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUxvbmdQb2xsaW5nT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMudGltZW91dFNlY29uZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNOYU4ob3B0aW9ucy50aW1lb3V0U2Vjb25kcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBpbnZhbGlkIGxvbmcgcG9sbGluZyB0aW1lb3V0OiBgICtcbiAgICAgICAgICAgICAgICBgJHtvcHRpb25zLnRpbWVvdXRTZWNvbmRzfSAobXVzdCBub3QgYmUgTmFOKWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXRTZWNvbmRzIDwgTUlOX0xPTkdfUE9MTElOR19USU1FT1VUX1NFQ09ORFMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBpbnZhbGlkIGxvbmcgcG9sbGluZyB0aW1lb3V0OiAke29wdGlvbnMudGltZW91dFNlY29uZHN9IGAgK1xuICAgICAgICAgICAgICAgIGAobWluaW11bSBhbGxvd2VkIHZhbHVlIGlzICR7TUlOX0xPTkdfUE9MTElOR19USU1FT1VUX1NFQ09ORFN9KWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXRTZWNvbmRzID4gTUFYX0xPTkdfUE9MTElOR19USU1FT1VUX1NFQ09ORFMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBpbnZhbGlkIGxvbmcgcG9sbGluZyB0aW1lb3V0OiAke29wdGlvbnMudGltZW91dFNlY29uZHN9IGAgK1xuICAgICAgICAgICAgICAgIGAobWF4aW11bSBhbGxvd2VkIHZhbHVlIGlzICR7TUFYX0xPTkdfUE9MTElOR19USU1FT1VUX1NFQ09ORFN9KWApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgQ2xvdWQgRmlyZXN0b3JlIHNlcnZpY2UgaW50ZXJmYWNlLlxuICpcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIHVzZSB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0uXG4gKi9cbmNsYXNzIEZpcmVzdG9yZSQxIHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xuICAgIGNvbnN0cnVjdG9yKF9hdXRoQ3JlZGVudGlhbHMsIF9hcHBDaGVja0NyZWRlbnRpYWxzLCBfZGF0YWJhc2VJZCwgX2FwcCkge1xuICAgICAgICB0aGlzLl9hdXRoQ3JlZGVudGlhbHMgPSBfYXV0aENyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLl9hcHBDaGVja0NyZWRlbnRpYWxzID0gX2FwcENoZWNrQ3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuX2RhdGFiYXNlSWQgPSBfZGF0YWJhc2VJZDtcbiAgICAgICAgdGhpcy5fYXBwID0gX2FwcDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgaXQncyBhIEZpcmVzdG9yZSBvciBGaXJlc3RvcmUgTGl0ZSBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9ICdmaXJlc3RvcmUtbGl0ZSc7XG4gICAgICAgIHRoaXMuX3BlcnNpc3RlbmNlS2V5ID0gJyhsaXRlKSc7XG4gICAgICAgIHRoaXMuX3NldHRpbmdzID0gbmV3IEZpcmVzdG9yZVNldHRpbmdzSW1wbCh7fSk7XG4gICAgICAgIHRoaXMuX3NldHRpbmdzRnJvemVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2VtdWxhdG9yT3B0aW9ucyA9IHt9O1xuICAgICAgICAvLyBBIHRhc2sgdGhhdCBpcyBhc3NpZ25lZCB3aGVuIHRoZSB0ZXJtaW5hdGUoKSBpcyBpbnZva2VkIGFuZCByZXNvbHZlZCB3aGVuXG4gICAgICAgIC8vIGFsbCBjb21wb25lbnRzIGhhdmUgc2h1dCBkb3duLiBPdGhlcndpc2UsIEZpcmVzdG9yZSBpcyBub3QgdGVybWluYXRlZCxcbiAgICAgICAgLy8gd2hpY2ggY2FuIG1lYW4gZWl0aGVyIHRoZSBGaXJlc3RvcmVDbGllbnQgaXMgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcsXG4gICAgICAgIC8vIG9yIHJlc3RhcnRpbmcuXG4gICAgICAgIHRoaXMuX3Rlcm1pbmF0ZVRhc2sgPSAnbm90VGVybWluYXRlZCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgYEZpcmVzdG9yZWAgc2VydmljZVxuICAgICAqIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldCBhcHAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYXBwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCBcIkZpcmVzdG9yZSB3YXMgbm90IGluaXRpYWxpemVkIHVzaW5nIHRoZSBGaXJlYmFzZSBTREsuICdhcHAnIGlzIFwiICtcbiAgICAgICAgICAgICAgICAnbm90IGF2YWlsYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHA7XG4gICAgfVxuICAgIGdldCBfaW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5nc0Zyb3plbjtcbiAgICB9XG4gICAgZ2V0IF90ZXJtaW5hdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGVybWluYXRlVGFzayAhPT0gJ25vdFRlcm1pbmF0ZWQnO1xuICAgIH1cbiAgICBfc2V0U2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzRnJvemVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnRmlyZXN0b3JlIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCBhbmQgaXRzIHNldHRpbmdzIGNhbiBubyBsb25nZXIgJyArXG4gICAgICAgICAgICAgICAgJ2JlIGNoYW5nZWQuIFlvdSBjYW4gb25seSBtb2RpZnkgc2V0dGluZ3MgYmVmb3JlIGNhbGxpbmcgYW55IG90aGVyICcgK1xuICAgICAgICAgICAgICAgICdtZXRob2RzIG9uIGEgRmlyZXN0b3JlIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IG5ldyBGaXJlc3RvcmVTZXR0aW5nc0ltcGwoc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLl9lbXVsYXRvck9wdGlvbnMgPSBzZXR0aW5ncy5lbXVsYXRvck9wdGlvbnMgfHwge307XG4gICAgICAgIGlmIChzZXR0aW5ncy5jcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9hdXRoQ3JlZGVudGlhbHMgPSBtYWtlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXIoc2V0dGluZ3MuY3JlZGVudGlhbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzO1xuICAgIH1cbiAgICBfZ2V0RW11bGF0b3JPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW11bGF0b3JPcHRpb25zO1xuICAgIH1cbiAgICBfZnJlZXplU2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuX3NldHRpbmdzRnJvemVuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzO1xuICAgIH1cbiAgICBfZGVsZXRlKCkge1xuICAgICAgICAvLyBUaGUgYF90ZXJtaW5hdGVUYXNrYCBtdXN0IGJlIGFzc2lnbmVkIGZ1dHVyZSB0aGF0IGNvbXBsZXRlcyB3aGVuXG4gICAgICAgIC8vIHRlcm1pbmF0ZSBpcyBjb21wbGV0ZS4gVGhlIGV4aXN0ZW5jZSBvZiB0aGlzIGZ1dHVyZSBwdXRzIFNESyBpbiBzdGF0ZVxuICAgICAgICAvLyB0aGF0IHdpbGwgbm90IGFjY2VwdCBmdXJ0aGVyIEFQSSBpbnRlcmFjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuX3Rlcm1pbmF0ZVRhc2sgPT09ICdub3RUZXJtaW5hdGVkJykge1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYXRlVGFzayA9IHRoaXMuX3Rlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXJtaW5hdGVUYXNrO1xuICAgIH1cbiAgICBhc3luYyBfcmVzdGFydCgpIHtcbiAgICAgICAgLy8gVGhlIGBfdGVybWluYXRlVGFza2AgbXVzdCBlcXVhbCAnbm90VGVybWluYXRlZCcgYWZ0ZXIgcmVzdGFydCB0b1xuICAgICAgICAvLyBzaWduYWwgdGhhdCBjbGllbnQgaXMgaW4gYSBzdGF0ZSB0aGF0IGFjY2VwdHMgQVBJIGNhbGxzLlxuICAgICAgICBpZiAodGhpcy5fdGVybWluYXRlVGFzayA9PT0gJ25vdFRlcm1pbmF0ZWQnKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl90ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmF0ZVRhc2sgPSAnbm90VGVybWluYXRlZCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGBGaXJlc3RvcmVgIGluc3RhbmNlLiAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFwcDogdGhpcy5fYXBwLFxuICAgICAgICAgICAgZGF0YWJhc2VJZDogdGhpcy5fZGF0YWJhc2VJZCxcbiAgICAgICAgICAgIHNldHRpbmdzOiB0aGlzLl9zZXR0aW5nc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXJtaW5hdGVzIGFsbCBjb21wb25lbnRzIHVzZWQgYnkgdGhpcyBjbGllbnQuIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlXG4gICAgICogdGhpcyBtZXRob2QgdG8gY2xlYW4gdXAgdGhlaXIgb3duIGRlcGVuZGVuY2llcywgYnV0IG11c3QgYWxzbyBjYWxsIHRoaXNcbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiBPbmx5IGV2ZXIgY2FsbGVkIG9uY2UuXG4gICAgICovXG4gICAgX3Rlcm1pbmF0ZSgpIHtcbiAgICAgICAgcmVtb3ZlQ29tcG9uZW50cyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbn1cbi8qKlxuICogTW9kaWZ5IHRoaXMgaW5zdGFuY2UgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgQ2xvdWQgRmlyZXN0b3JlIGVtdWxhdG9yLlxuICpcbiAqIE5vdGU6IFRoaXMgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHRoaXMgaW5zdGFuY2UgaGFzIGJlZW4gdXNlZCB0byBkbyBhbnlcbiAqIG9wZXJhdGlvbnMuXG4gKlxuICogQHBhcmFtIGZpcmVzdG9yZSAtIFRoZSBgRmlyZXN0b3JlYCBpbnN0YW5jZSB0byBjb25maWd1cmUgdG8gY29ubmVjdCB0byB0aGVcbiAqIGVtdWxhdG9yLlxuICogQHBhcmFtIGhvc3QgLSB0aGUgZW11bGF0b3IgaG9zdCAoZXg6IGxvY2FsaG9zdCkuXG4gKiBAcGFyYW0gcG9ydCAtIHRoZSBlbXVsYXRvciBwb3J0IChleDogOTAwMCkuXG4gKiBAcGFyYW0gb3B0aW9ucy5tb2NrVXNlclRva2VuIC0gdGhlIG1vY2sgYXV0aCB0b2tlbiB0byB1c2UgZm9yIHVuaXQgdGVzdGluZ1xuICogU2VjdXJpdHkgUnVsZXMuXG4gKi9cbmZ1bmN0aW9uIGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvcihmaXJlc3RvcmUsIGhvc3QsIHBvcnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUkMSk7XG4gICAgY29uc3QgdXNlU3NsID0gaXNDbG91ZFdvcmtzdGF0aW9uKGhvc3QpO1xuICAgIGNvbnN0IHNldHRpbmdzID0gZmlyZXN0b3JlLl9nZXRTZXR0aW5ncygpO1xuICAgIGNvbnN0IGV4aXN0aW5nQ29uZmlnID0ge1xuICAgICAgICAuLi5zZXR0aW5ncyxcbiAgICAgICAgZW11bGF0b3JPcHRpb25zOiBmaXJlc3RvcmUuX2dldEVtdWxhdG9yT3B0aW9ucygpXG4gICAgfTtcbiAgICBjb25zdCBuZXdIb3N0U2V0dGluZyA9IGAke2hvc3R9OiR7cG9ydH1gO1xuICAgIGlmICh1c2VTc2wpIHtcbiAgICAgICAgdm9pZCBwaW5nU2VydmVyKGBodHRwczovLyR7bmV3SG9zdFNldHRpbmd9YCk7XG4gICAgICAgIHVwZGF0ZUVtdWxhdG9yQmFubmVyKCdGaXJlc3RvcmUnLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHNldHRpbmdzLmhvc3QgIT09IERFRkFVTFRfSE9TVCAmJiBzZXR0aW5ncy5ob3N0ICE9PSBuZXdIb3N0U2V0dGluZykge1xuICAgICAgICBsb2dXYXJuKCdIb3N0IGhhcyBiZWVuIHNldCBpbiBib3RoIHNldHRpbmdzKCkgYW5kIGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvcigpLCBlbXVsYXRvciBob3N0ICcgK1xuICAgICAgICAgICAgJ3dpbGwgYmUgdXNlZC4nKTtcbiAgICB9XG4gICAgY29uc3QgbmV3Q29uZmlnID0ge1xuICAgICAgICAuLi5zZXR0aW5ncyxcbiAgICAgICAgaG9zdDogbmV3SG9zdFNldHRpbmcsXG4gICAgICAgIHNzbDogdXNlU3NsLFxuICAgICAgICBlbXVsYXRvck9wdGlvbnM6IG9wdGlvbnNcbiAgICB9O1xuICAgIC8vIE5vLW9wIGlmIHRoZSBuZXcgY29uZmlndXJhdGlvbiBtYXRjaGVzIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24uIFRoaXMgc3VwcG9ydHMgU1NSXG4gICAgLy8gZW52aW9ybm1lbnRzIHdoaWNoIG1pZ2h0IGNhbGwgYGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvcmAgbXVsdGlwbGUgdGltZXMgYXMgYSBzdGFuZGFyZCBwcmFjdGljZS5cbiAgICBpZiAoZGVlcEVxdWFsKG5ld0NvbmZpZywgZXhpc3RpbmdDb25maWcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmlyZXN0b3JlLl9zZXRTZXR0aW5ncyhuZXdDb25maWcpO1xuICAgIGlmIChvcHRpb25zLm1vY2tVc2VyVG9rZW4pIHtcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICBsZXQgdXNlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1vY2tVc2VyVG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IG9wdGlvbnMubW9ja1VzZXJUb2tlbjtcbiAgICAgICAgICAgIHVzZXIgPSBVc2VyLk1PQ0tfVVNFUjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIExldCBjcmVhdGVNb2NrVXNlclRva2VuIHZhbGlkYXRlIGZpcnN0IChjYXRjaGVzIGNvbW1vbiBtaXN0YWtlcyBsaWtlXG4gICAgICAgICAgICAvLyBpbnZhbGlkIGZpZWxkIFwidWlkXCIgYW5kIG1pc3NpbmcgZmllbGQgXCJzdWJcIiAvIFwidXNlcl9pZFwiLilcbiAgICAgICAgICAgIHRva2VuID0gY3JlYXRlTW9ja1VzZXJUb2tlbihvcHRpb25zLm1vY2tVc2VyVG9rZW4sIGZpcmVzdG9yZS5fYXBwPy5vcHRpb25zLnByb2plY3RJZCk7XG4gICAgICAgICAgICBjb25zdCB1aWQgPSBvcHRpb25zLm1vY2tVc2VyVG9rZW4uc3ViIHx8IG9wdGlvbnMubW9ja1VzZXJUb2tlbi51c2VyX2lkO1xuICAgICAgICAgICAgaWYgKCF1aWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBcIm1vY2tVc2VyVG9rZW4gbXVzdCBjb250YWluICdzdWInIG9yICd1c2VyX2lkJyBmaWVsZCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1c2VyID0gbmV3IFVzZXIodWlkKTtcbiAgICAgICAgfVxuICAgICAgICBmaXJlc3RvcmUuX2F1dGhDcmVkZW50aWFscyA9IG5ldyBFbXVsYXRvckF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKG5ldyBPQXV0aFRva2VuKHRva2VuLCB1c2VyKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGBRdWVyeWAgcmVmZXJzIHRvIGEgcXVlcnkgd2hpY2ggeW91IGNhbiByZWFkIG9yIGxpc3RlbiB0by4gWW91IGNhbiBhbHNvXG4gKiBjb25zdHJ1Y3QgcmVmaW5lZCBgUXVlcnlgIG9iamVjdHMgYnkgYWRkaW5nIGZpbHRlcnMgYW5kIG9yZGVyaW5nLlxuICovXG5jbGFzcyBRdWVyeSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgbGl0ZSB2ZXJzaW9uIG9mIHRoZSBRdWVyeSBjbGFzcyBpbiB0aGUgbWFpbiBTREsuXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgcHJvdGVjdGVkICovXG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlLCBcbiAgICAvKipcbiAgICAgKiBJZiBwcm92aWRlZCwgdGhlIGBGaXJlc3RvcmVEYXRhQ29udmVydGVyYCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjb252ZXJ0ZXIsIF9xdWVyeSkge1xuICAgICAgICB0aGlzLmNvbnZlcnRlciA9IGNvbnZlcnRlcjtcbiAgICAgICAgdGhpcy5fcXVlcnkgPSBfcXVlcnk7XG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIEZpcmVzdG9yZSByZWZlcmVuY2UuICovXG4gICAgICAgIHRoaXMudHlwZSA9ICdxdWVyeSc7XG4gICAgICAgIHRoaXMuZmlyZXN0b3JlID0gZmlyZXN0b3JlO1xuICAgIH1cbiAgICB3aXRoQ29udmVydGVyKGNvbnZlcnRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMuZmlyZXN0b3JlLCBjb252ZXJ0ZXIsIHRoaXMuX3F1ZXJ5KTtcbiAgICB9XG59XG4vKipcbiAqIEEgYERvY3VtZW50UmVmZXJlbmNlYCByZWZlcnMgdG8gYSBkb2N1bWVudCBsb2NhdGlvbiBpbiBhIEZpcmVzdG9yZSBkYXRhYmFzZVxuICogYW5kIGNhbiBiZSB1c2VkIHRvIHdyaXRlLCByZWFkLCBvciBsaXN0ZW4gdG8gdGhlIGxvY2F0aW9uLiBUaGUgZG9jdW1lbnQgYXRcbiAqIHRoZSByZWZlcmVuY2VkIGxvY2F0aW9uIG1heSBvciBtYXkgbm90IGV4aXN0LlxuICovXG5jbGFzcyBEb2N1bWVudFJlZmVyZW5jZSB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihmaXJlc3RvcmUsIFxuICAgIC8qKlxuICAgICAqIElmIHByb3ZpZGVkLCB0aGUgYEZpcmVzdG9yZURhdGFDb252ZXJ0ZXJgIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNvbnZlcnRlciwgX2tleSkge1xuICAgICAgICB0aGlzLmNvbnZlcnRlciA9IGNvbnZlcnRlcjtcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcbiAgICAgICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgRmlyZXN0b3JlIHJlZmVyZW5jZS4gKi9cbiAgICAgICAgdGhpcy50eXBlID0gJ2RvY3VtZW50JztcbiAgICAgICAgdGhpcy5maXJlc3RvcmUgPSBmaXJlc3RvcmU7XG4gICAgfVxuICAgIGdldCBfcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleS5wYXRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZG9jdW1lbnQncyBpZGVudGlmaWVyIHdpdGhpbiBpdHMgY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXkucGF0aC5sYXN0U2VnbWVudCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHBhdGggb2YgdGhlIHJlZmVyZW5jZWQgZG9jdW1lbnQgKHJlbGF0aXZlXG4gICAgICogdG8gdGhlIHJvb3Qgb2YgdGhlIGRhdGFiYXNlKS5cbiAgICAgKi9cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleS5wYXRoLmNhbm9uaWNhbFN0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29sbGVjdGlvbiB0aGlzIGBEb2N1bWVudFJlZmVyZW5jZWAgYmVsb25ncyB0by5cbiAgICAgKi9cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWZlcmVuY2UodGhpcy5maXJlc3RvcmUsIHRoaXMuY29udmVydGVyLCB0aGlzLl9rZXkucGF0aC5wb3BMYXN0KCkpO1xuICAgIH1cbiAgICB3aXRoQ29udmVydGVyKGNvbnZlcnRlcikge1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHRoaXMuZmlyZXN0b3JlLCBjb252ZXJ0ZXIsIHRoaXMuX2tleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGBEb2N1bWVudFJlZmVyZW5jZWAgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogRG9jdW1lbnRSZWZlcmVuY2UuX2pzb25TY2hlbWFWZXJzaW9uLFxuICAgICAgICAgICAgcmVmZXJlbmNlUGF0aDogdGhpcy5fa2V5LnRvU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKGZpcmVzdG9yZSwganNvbiwgY29udmVydGVyKSB7XG4gICAgICAgIGlmICh2YWxpZGF0ZUpTT04oanNvbiwgRG9jdW1lbnRSZWZlcmVuY2UuX2pzb25TY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKGZpcmVzdG9yZSwgY29udmVydGVyID8gY29udmVydGVyIDogbnVsbCwgbmV3IERvY3VtZW50S2V5KFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKGpzb24ucmVmZXJlbmNlUGF0aCkpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkRvY3VtZW50UmVmZXJlbmNlLl9qc29uU2NoZW1hVmVyc2lvbiA9ICdmaXJlc3RvcmUvZG9jdW1lbnRSZWZlcmVuY2UvMS4wJztcbkRvY3VtZW50UmVmZXJlbmNlLl9qc29uU2NoZW1hID0ge1xuICAgIHR5cGU6IHByb3BlcnR5KCdzdHJpbmcnLCBEb2N1bWVudFJlZmVyZW5jZS5fanNvblNjaGVtYVZlcnNpb24pLFxuICAgIHJlZmVyZW5jZVBhdGg6IHByb3BlcnR5KCdzdHJpbmcnKVxufTtcbi8qKlxuICogQSBgQ29sbGVjdGlvblJlZmVyZW5jZWAgb2JqZWN0IGNhbiBiZSB1c2VkIGZvciBhZGRpbmcgZG9jdW1lbnRzLCBnZXR0aW5nXG4gKiBkb2N1bWVudCByZWZlcmVuY2VzLCBhbmQgcXVlcnlpbmcgZm9yIGRvY3VtZW50cyAodXNpbmcge0BsaW5rIChxdWVyeToxKX0pLlxuICovXG5jbGFzcyBDb2xsZWN0aW9uUmVmZXJlbmNlIGV4dGVuZHMgUXVlcnkge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlLCBjb252ZXJ0ZXIsIF9wYXRoKSB7XG4gICAgICAgIHN1cGVyKGZpcmVzdG9yZSwgY29udmVydGVyLCBuZXdRdWVyeUZvclBhdGgoX3BhdGgpKTtcbiAgICAgICAgdGhpcy5fcGF0aCA9IF9wYXRoO1xuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBGaXJlc3RvcmUgcmVmZXJlbmNlLiAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnY29sbGVjdGlvbic7XG4gICAgfVxuICAgIC8qKiBUaGUgY29sbGVjdGlvbidzIGlkZW50aWZpZXIuICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnkucGF0aC5sYXN0U2VnbWVudCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHBhdGggb2YgdGhlIHJlZmVyZW5jZWQgY29sbGVjdGlvbiAocmVsYXRpdmVcbiAgICAgKiB0byB0aGUgcm9vdCBvZiB0aGUgZGF0YWJhc2UpLlxuICAgICAqL1xuICAgIGdldCBwYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnkucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGNvbnRhaW5pbmcgYERvY3VtZW50UmVmZXJlbmNlYCBpZiB0aGlzIGlzIGFcbiAgICAgKiBzdWJjb2xsZWN0aW9uLiBJZiB0aGlzIGlzbid0IGEgc3ViY29sbGVjdGlvbiwgdGhlIHJlZmVyZW5jZSBpcyBudWxsLlxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSB0aGlzLl9wYXRoLnBvcExhc3QoKTtcbiAgICAgICAgaWYgKHBhcmVudFBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UodGhpcy5maXJlc3RvcmUsIFxuICAgICAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsLCBuZXcgRG9jdW1lbnRLZXkocGFyZW50UGF0aCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhDb252ZXJ0ZXIoY29udmVydGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvblJlZmVyZW5jZSh0aGlzLmZpcmVzdG9yZSwgY29udmVydGVyLCB0aGlzLl9wYXRoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0NvbGxlY3Rpb25SZWZlcmVuY2UodmFsKSB7XG4gICAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIENvbGxlY3Rpb25SZWZlcmVuY2U7XG59XG5mdW5jdGlvbiBjb2xsZWN0aW9uKHBhcmVudCwgcGF0aCwgLi4ucGF0aFNlZ21lbnRzKSB7XG4gICAgcGFyZW50ID0gZ2V0TW9kdWxhckluc3RhbmNlKHBhcmVudCk7XG4gICAgdmFsaWRhdGVOb25FbXB0eUFyZ3VtZW50KCdjb2xsZWN0aW9uJywgJ3BhdGgnLCBwYXRoKTtcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgRmlyZXN0b3JlJDEpIHtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCwgLi4ucGF0aFNlZ21lbnRzKTtcbiAgICAgICAgdmFsaWRhdGVDb2xsZWN0aW9uUGF0aChhYnNvbHV0ZVBhdGgpO1xuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWZlcmVuY2UocGFyZW50LCAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIGFic29sdXRlUGF0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkgJiZcbiAgICAgICAgICAgICEocGFyZW50IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBjb2xsZWN0aW9uKCkgdG8gYmUgYSBDb2xsZWN0aW9uUmVmZXJlbmNlLCAnICtcbiAgICAgICAgICAgICAgICAnYSBEb2N1bWVudFJlZmVyZW5jZSBvciBGaXJlYmFzZUZpcmVzdG9yZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHBhcmVudC5fcGF0aC5jaGlsZChSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhwYXRoLCAuLi5wYXRoU2VnbWVudHMpKTtcbiAgICAgICAgdmFsaWRhdGVDb2xsZWN0aW9uUGF0aChhYnNvbHV0ZVBhdGgpO1xuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWZlcmVuY2UocGFyZW50LmZpcmVzdG9yZSwgXG4gICAgICAgIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwgYWJzb2x1dGVQYXRoKTtcbiAgICB9XG59XG4vLyBUT0RPKGZpcmVzdG9yZWxpdGUpOiBDb25zaWRlciB1c2luZyBFcnJvckZhY3RvcnkgLVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9ibG9iLzAxMzFlMWYvcGFja2FnZXMvdXRpbC9zcmMvZXJyb3JzLnRzI0wxMDZcbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBgUXVlcnlgIGluc3RhbmNlIHRoYXQgaW5jbHVkZXMgYWxsIGRvY3VtZW50cyBpbiB0aGVcbiAqIGRhdGFiYXNlIHRoYXQgYXJlIGNvbnRhaW5lZCBpbiBhIGNvbGxlY3Rpb24gb3Igc3ViY29sbGVjdGlvbiB3aXRoIHRoZVxuICogZ2l2ZW4gYGNvbGxlY3Rpb25JZGAuXG4gKlxuICogQHBhcmFtIGZpcmVzdG9yZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSByb290IGBGaXJlc3RvcmVgIGluc3RhbmNlLlxuICogQHBhcmFtIGNvbGxlY3Rpb25JZCAtIElkZW50aWZpZXMgdGhlIGNvbGxlY3Rpb25zIHRvIHF1ZXJ5IG92ZXIuIEV2ZXJ5XG4gKiBjb2xsZWN0aW9uIG9yIHN1YmNvbGxlY3Rpb24gd2l0aCB0aGlzIElEIGFzIHRoZSBsYXN0IHNlZ21lbnQgb2YgaXRzIHBhdGhcbiAqIHdpbGwgYmUgaW5jbHVkZWQuIENhbm5vdCBjb250YWluIGEgc2xhc2guXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBgUXVlcnlgLlxuICovXG5mdW5jdGlvbiBjb2xsZWN0aW9uR3JvdXAoZmlyZXN0b3JlLCBjb2xsZWN0aW9uSWQpIHtcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlJDEpO1xuICAgIHZhbGlkYXRlTm9uRW1wdHlBcmd1bWVudCgnY29sbGVjdGlvbkdyb3VwJywgJ2NvbGxlY3Rpb24gaWQnLCBjb2xsZWN0aW9uSWQpO1xuICAgIGlmIChjb2xsZWN0aW9uSWQuaW5kZXhPZignLycpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgY29sbGVjdGlvbiBJRCAnJHtjb2xsZWN0aW9uSWR9JyBwYXNzZWQgdG8gZnVuY3Rpb24gYCArXG4gICAgICAgICAgICBgY29sbGVjdGlvbkdyb3VwKCkuIENvbGxlY3Rpb24gSURzIG11c3Qgbm90IGNvbnRhaW4gJy8nLmApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFF1ZXJ5KGZpcmVzdG9yZSwgXG4gICAgLyogY29udmVydGVyPSAqLyBudWxsLCBuZXdRdWVyeUZvckNvbGxlY3Rpb25Hcm91cChjb2xsZWN0aW9uSWQpKTtcbn1cbmZ1bmN0aW9uIGRvYyhwYXJlbnQsIHBhdGgsIC4uLnBhdGhTZWdtZW50cykge1xuICAgIHBhcmVudCA9IGdldE1vZHVsYXJJbnN0YW5jZShwYXJlbnQpO1xuICAgIC8vIFdlIGFsbG93IG9taXNzaW9uIG9mICdwYXRoU3RyaW5nJyBidXQgZXhwbGljaXRseSBwcm9oaWJpdCBwYXNzaW5nIGluIGJvdGhcbiAgICAvLyAndW5kZWZpbmVkJyBhbmQgJ251bGwnLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBhdGggPSBBdXRvSWQubmV3SWQoKTtcbiAgICB9XG4gICAgdmFsaWRhdGVOb25FbXB0eUFyZ3VtZW50KCdkb2MnLCAncGF0aCcsIHBhdGgpO1xuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBGaXJlc3RvcmUkMSkge1xuICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhwYXRoLCAuLi5wYXRoU2VnbWVudHMpO1xuICAgICAgICB2YWxpZGF0ZURvY3VtZW50UGF0aChhYnNvbHV0ZVBhdGgpO1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHBhcmVudCwgXG4gICAgICAgIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwgbmV3IERvY3VtZW50S2V5KGFic29sdXRlUGF0aCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpICYmXG4gICAgICAgICAgICAhKHBhcmVudCBpbnN0YW5jZW9mIENvbGxlY3Rpb25SZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gZG9jKCkgdG8gYmUgYSBDb2xsZWN0aW9uUmVmZXJlbmNlLCAnICtcbiAgICAgICAgICAgICAgICAnYSBEb2N1bWVudFJlZmVyZW5jZSBvciBGaXJlYmFzZUZpcmVzdG9yZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHBhcmVudC5fcGF0aC5jaGlsZChSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhwYXRoLCAuLi5wYXRoU2VnbWVudHMpKTtcbiAgICAgICAgdmFsaWRhdGVEb2N1bWVudFBhdGgoYWJzb2x1dGVQYXRoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFJlZmVyZW5jZShwYXJlbnQuZmlyZXN0b3JlLCBwYXJlbnQgaW5zdGFuY2VvZiBDb2xsZWN0aW9uUmVmZXJlbmNlID8gcGFyZW50LmNvbnZlcnRlciA6IG51bGwsIG5ldyBEb2N1bWVudEtleShhYnNvbHV0ZVBhdGgpKTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgcmVmZXJlbmNlcyBhcmUgZXF1YWwuXG4gKlxuICogQHBhcmFtIGxlZnQgLSBBIHJlZmVyZW5jZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHJpZ2h0IC0gQSByZWZlcmVuY2UgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHJlZmVyZW5jZXMgcG9pbnQgdG8gdGhlIHNhbWUgbG9jYXRpb24gaW4gdGhlIHNhbWVcbiAqIEZpcmVzdG9yZSBkYXRhYmFzZS5cbiAqL1xuZnVuY3Rpb24gcmVmRXF1YWwobGVmdCwgcmlnaHQpIHtcbiAgICBsZWZ0ID0gZ2V0TW9kdWxhckluc3RhbmNlKGxlZnQpO1xuICAgIHJpZ2h0ID0gZ2V0TW9kdWxhckluc3RhbmNlKHJpZ2h0KTtcbiAgICBpZiAoKGxlZnQgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSB8fFxuICAgICAgICBsZWZ0IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSkgJiZcbiAgICAgICAgKHJpZ2h0IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UgfHwgcmlnaHQgaW5zdGFuY2VvZiBDb2xsZWN0aW9uUmVmZXJlbmNlKSkge1xuICAgICAgICByZXR1cm4gKGxlZnQuZmlyZXN0b3JlID09PSByaWdodC5maXJlc3RvcmUgJiZcbiAgICAgICAgICAgIGxlZnQucGF0aCA9PT0gcmlnaHQucGF0aCAmJlxuICAgICAgICAgICAgbGVmdC5jb252ZXJ0ZXIgPT09IHJpZ2h0LmNvbnZlcnRlcik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBxdWVyaWVzIHBvaW50IHRvIHRoZSBzYW1lIGNvbGxlY3Rpb24gYW5kIGFwcGx5XG4gKiB0aGUgc2FtZSBjb25zdHJhaW50cy5cbiAqXG4gKiBAcGFyYW0gbGVmdCAtIEEgYFF1ZXJ5YCB0byBjb21wYXJlLlxuICogQHBhcmFtIHJpZ2h0IC0gQSBgUXVlcnlgIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSByZWZlcmVuY2VzIHBvaW50IHRvIHRoZSBzYW1lIGxvY2F0aW9uIGluIHRoZSBzYW1lXG4gKiBGaXJlc3RvcmUgZGF0YWJhc2UuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5RXF1YWwobGVmdCwgcmlnaHQpIHtcbiAgICBsZWZ0ID0gZ2V0TW9kdWxhckluc3RhbmNlKGxlZnQpO1xuICAgIHJpZ2h0ID0gZ2V0TW9kdWxhckluc3RhbmNlKHJpZ2h0KTtcbiAgICBpZiAobGVmdCBpbnN0YW5jZW9mIFF1ZXJ5ICYmIHJpZ2h0IGluc3RhbmNlb2YgUXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIChsZWZ0LmZpcmVzdG9yZSA9PT0gcmlnaHQuZmlyZXN0b3JlICYmXG4gICAgICAgICAgICBxdWVyeUVxdWFscyhsZWZ0Ll9xdWVyeSwgcmlnaHQuX3F1ZXJ5KSAmJlxuICAgICAgICAgICAgbGVmdC5jb252ZXJ0ZXIgPT09IHJpZ2h0LmNvbnZlcnRlcik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUcgPSAnQXN5bmNRdWV1ZSc7XG5jbGFzcyBBc3luY1F1ZXVlSW1wbCB7XG4gICAgY29uc3RydWN0b3IodGFpbCA9IFByb21pc2UucmVzb2x2ZSgpKSB7XG4gICAgICAgIC8vIEEgbGlzdCBvZiByZXRyeWFibGUgb3BlcmF0aW9ucy4gUmV0cnlhYmxlIG9wZXJhdGlvbnMgYXJlIHJ1biBpbiBvcmRlciBhbmRcbiAgICAgICAgLy8gcmV0cmllZCB3aXRoIGJhY2tvZmYuXG4gICAgICAgIHRoaXMucmV0cnlhYmxlT3BzID0gW107XG4gICAgICAgIC8vIElzIHRoaXMgQXN5bmNRdWV1ZSBiZWluZyBzaHV0IGRvd24/IE9uY2UgaXQgaXMgc2V0IHRvIHRydWUsIGl0IHdpbGwgbm90XG4gICAgICAgIC8vIGJlIGNoYW5nZWQgYWdhaW4uXG4gICAgICAgIHRoaXMuX2lzU2h1dHRpbmdEb3duID0gZmFsc2U7XG4gICAgICAgIC8vIE9wZXJhdGlvbnMgc2NoZWR1bGVkIHRvIGJlIHF1ZXVlZCBpbiB0aGUgZnV0dXJlLiBPcGVyYXRpb25zIGFyZVxuICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgYWZ0ZXIgdGhleSBhcmUgcnVuIG9yIGNhbmNlbGVkLlxuICAgICAgICB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zID0gW107XG4gICAgICAgIC8vIHZpc2libGUgZm9yIHRlc3RpbmdcbiAgICAgICAgdGhpcy5mYWlsdXJlID0gbnVsbDtcbiAgICAgICAgLy8gRmxhZyBzZXQgd2hpbGUgdGhlcmUncyBhbiBvdXRzdGFuZGluZyBBc3luY1F1ZXVlIG9wZXJhdGlvbiwgdXNlZCBmb3JcbiAgICAgICAgLy8gYXNzZXJ0aW9uIHNhbml0eS1jaGVja3MuXG4gICAgICAgIHRoaXMub3BlcmF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAvLyBFbmFibGVkIGR1cmluZyBzaHV0ZG93biBvbiBTYWZhcmkgdG8gcHJldmVudCBmdXR1cmUgYWNjZXNzIHRvIEluZGV4ZWREQi5cbiAgICAgICAgdGhpcy5za2lwTm9uUmVzdHJpY3RlZFRhc2tzID0gZmFsc2U7XG4gICAgICAgIC8vIExpc3Qgb2YgVGltZXJJZHMgdG8gZmFzdC1mb3J3YXJkIGRlbGF5cyBmb3IuXG4gICAgICAgIHRoaXMudGltZXJJZHNUb1NraXAgPSBbXTtcbiAgICAgICAgLy8gQmFja29mZiB0aW1lciB1c2VkIHRvIHNjaGVkdWxlIHJldHJpZXMgZm9yIHJldHJ5YWJsZSBvcGVyYXRpb25zXG4gICAgICAgIHRoaXMuYmFja29mZiA9IG5ldyBFeHBvbmVudGlhbEJhY2tvZmYodGhpcywgXCJhc3luY19xdWV1ZV9yZXRyeVwiIC8qIFRpbWVySWQuQXN5bmNRdWV1ZVJldHJ5ICovKTtcbiAgICAgICAgLy8gVmlzaWJpbGl0eSBoYW5kbGVyIHRoYXQgdHJpZ2dlcnMgYW4gaW1tZWRpYXRlIHJldHJ5IG9mIGFsbCByZXRyeWFibGVcbiAgICAgICAgLy8gb3BlcmF0aW9ucy4gTWVhbnQgdG8gc3BlZWQgdXAgcmVjb3Zlcnkgd2hlbiB3ZSByZWdhaW4gZmlsZSBzeXN0ZW0gYWNjZXNzXG4gICAgICAgIC8vIGFmdGVyIHBhZ2UgY29tZXMgaW50byBmb3JlZ3JvdW5kLlxuICAgICAgICB0aGlzLnZpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnNraXBCYWNrb2ZmKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgfVxuICAgIGdldCBpc1NodXR0aW5nRG93bigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2h1dHRpbmdEb3duO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IG9wZXJhdGlvbiB0byB0aGUgcXVldWUgd2l0aG91dCB3YWl0aW5nIGZvciBpdCB0byBjb21wbGV0ZSAoaS5lLlxuICAgICAqIHdlIGlnbm9yZSB0aGUgUHJvbWlzZSByZXN1bHQpLlxuICAgICAqL1xuICAgIGVucXVldWVBbmRGb3JnZXQob3ApIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICB0aGlzLmVucXVldWUob3ApO1xuICAgIH1cbiAgICBlbnF1ZXVlQW5kRm9yZ2V0RXZlbldoaWxlUmVzdHJpY3RlZChvcCkge1xuICAgICAgICB0aGlzLnZlcmlmeU5vdEZhaWxlZCgpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgIHRoaXMuZW5xdWV1ZUludGVybmFsKG9wKTtcbiAgICB9XG4gICAgZW50ZXJSZXN0cmljdGVkTW9kZShwdXJnZUV4aXN0aW5nVGFza3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1NodXR0aW5nRG93bikge1xuICAgICAgICAgICAgdGhpcy5faXNTaHV0dGluZ0Rvd24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5za2lwTm9uUmVzdHJpY3RlZFRhc2tzID0gcHVyZ2VFeGlzdGluZ1Rhc2tzIHx8IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVucXVldWUob3ApIHtcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RGYWlsZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2h1dHRpbmdEb3duKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gYSBQcm9taXNlIHdoaWNoIG5ldmVyIHJlc29sdmVzLlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgZGVmZXJyZWQgUHJvbWlzZSB0aGF0IHdlIGNhbiByZXR1cm4gdG8gdGhlIGNhbGxlZS4gVGhpc1xuICAgICAgICAvLyBhbGxvd3MgdXMgdG8gcmV0dXJuIGEgXCJoYW5naW5nIFByb21pc2VcIiBvbmx5IHRvIHRoZSBjYWxsZWUgYW5kIHN0aWxsXG4gICAgICAgIC8vIGFkdmFuY2UgdGhlIHF1ZXVlIGV2ZW4gd2hlbiB0aGUgb3BlcmF0aW9uIGlzIG5vdCBydW4uXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5xdWV1ZUludGVybmFsKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1NodXR0aW5nRG93biAmJiB0aGlzLnNraXBOb25SZXN0cmljdGVkVGFza3MpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkbyBub3QgcmVzb2x2ZSAndGFzaydcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCgpLnRoZW4odGFzay5yZXNvbHZlLCB0YXNrLnJlamVjdCk7XG4gICAgICAgICAgICByZXR1cm4gdGFzay5wcm9taXNlO1xuICAgICAgICB9KS50aGVuKCgpID0+IHRhc2sucHJvbWlzZSk7XG4gICAgfVxuICAgIGVucXVldWVSZXRyeWFibGUob3ApIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmV0cnlhYmxlT3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0cnlOZXh0T3AoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIG5leHQgb3BlcmF0aW9uIGZyb20gdGhlIHJldHJ5YWJsZSBxdWV1ZS4gSWYgdGhlIG9wZXJhdGlvbiBmYWlscyxcbiAgICAgKiByZXNjaGVkdWxlcyB3aXRoIGJhY2tvZmYuXG4gICAgICovXG4gICAgYXN5bmMgcmV0cnlOZXh0T3AoKSB7XG4gICAgICAgIGlmICh0aGlzLnJldHJ5YWJsZU9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZXRyeWFibGVPcHNbMF0oKTtcbiAgICAgICAgICAgIHRoaXMucmV0cnlhYmxlT3BzLnNoaWZ0KCk7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUcsICdPcGVyYXRpb24gZmFpbGVkIHdpdGggcmV0cnlhYmxlIGVycm9yOiAnICsgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlOyAvLyBGYWlsdXJlIHdpbGwgYmUgaGFuZGxlZCBieSBBc3luY1F1ZXVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmV0cnlhYmxlT3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhZGRpdGlvbmFsIG9wZXJhdGlvbnMsIHdlIHJlLXNjaGVkdWxlIGByZXRyeU5leHRPcCgpYC5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHJ1biByZXRyeWFibGUgb3BlcmF0aW9ucyB0aGF0IGZhaWxlZCBkdXJpbmdcbiAgICAgICAgICAgIC8vIHRoZWlyIGluaXRpYWwgYXR0ZW1wdCBzaW5jZSB3ZSBkb24ndCBrbm93IHdoZXRoZXIgdGhleSBhcmUgYWxyZWFkeVxuICAgICAgICAgICAgLy8gZW5xdWV1ZWQuIElmLCBmb3IgZXhhbXBsZSwgYG9wMWAsIGBvcDJgLCBgb3AzYCBhcmUgZW5xdWV1ZWQgYW5kIGBvcDFgXG4gICAgICAgICAgICAvLyBuZWVkcyB0byAgYmUgcmUtcnVuLCB3ZSB3aWxsIHJ1biBgb3AxYCwgYG9wMWAsIGBvcDJgIHVzaW5nIHRoZVxuICAgICAgICAgICAgLy8gYWxyZWFkeSBlbnF1ZXVlZCBjYWxscyB0byBgcmV0cnlOZXh0T3AoKWAuIGBvcDMoKWAgd2lsbCB0aGVuIHJ1biBpbiB0aGVcbiAgICAgICAgICAgIC8vIGNhbGwgc2NoZWR1bGVkIGhlcmUuXG4gICAgICAgICAgICAvLyBTaW5jZSBgYmFja29mZkFuZFJ1bigpYCBjYW5jZWxzIGFuIGV4aXN0aW5nIGJhY2tvZmYgYW5kIHNjaGVkdWxlcyBhXG4gICAgICAgICAgICAvLyBuZXcgYmFja29mZiBvbiBldmVyeSBjYWxsLCB0aGVyZSBpcyBvbmx5IGV2ZXIgYSBzaW5nbGUgYWRkaXRpb25hbFxuICAgICAgICAgICAgLy8gb3BlcmF0aW9uIGluIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5iYWNrb2ZmQW5kUnVuKCgpID0+IHRoaXMucmV0cnlOZXh0T3AoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5xdWV1ZUludGVybmFsKG9wKSB7XG4gICAgICAgIGNvbnN0IG5ld1RhaWwgPSB0aGlzLnRhaWwudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbkluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIG9wKClcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsdXJlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25JblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdldE1lc3NhZ2VPclN0YWNrKGVycm9yKTtcbiAgICAgICAgICAgICAgICBsb2dFcnJvcignSU5URVJOQUwgVU5IQU5ETEVEIEVSUk9SOiAnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGUgZXJyb3Igc28gdGhhdCB0aGlzLnRhaWwgYmVjb21lcyBhIHJlamVjdGVkIFByb21pc2UgYW5kXG4gICAgICAgICAgICAgICAgLy8gYWxsIGZ1cnRoZXIgYXR0ZW1wdHMgdG8gY2hhaW4gKHZpYSAudGhlbikgd2lsbCBqdXN0IHNob3J0LWNpcmN1aXRcbiAgICAgICAgICAgICAgICAvLyBhbmQgcmV0dXJuIHRoZSByZWplY3RlZCBQcm9taXNlLlxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub3BlcmF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGFpbCA9IG5ld1RhaWw7XG4gICAgICAgIHJldHVybiBuZXdUYWlsO1xuICAgIH1cbiAgICBlbnF1ZXVlQWZ0ZXJEZWxheSh0aW1lcklkLCBkZWxheU1zLCBvcCkge1xuICAgICAgICB0aGlzLnZlcmlmeU5vdEZhaWxlZCgpO1xuICAgICAgICAvLyBGYXN0LWZvcndhcmQgZGVsYXlzIGZvciB0aW1lcklkcyB0aGF0IGhhdmUgYmVlbiBvdmVycmlkZGVuLlxuICAgICAgICBpZiAodGhpcy50aW1lcklkc1RvU2tpcC5pbmRleE9mKHRpbWVySWQpID4gLTEpIHtcbiAgICAgICAgICAgIGRlbGF5TXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbGF5ZWRPcCA9IERlbGF5ZWRPcGVyYXRpb24uY3JlYXRlQW5kU2NoZWR1bGUodGhpcywgdGltZXJJZCwgZGVsYXlNcywgb3AsIHJlbW92ZWRPcCA9PiB0aGlzLnJlbW92ZURlbGF5ZWRPcGVyYXRpb24ocmVtb3ZlZE9wKSk7XG4gICAgICAgIHRoaXMuZGVsYXllZE9wZXJhdGlvbnMucHVzaChkZWxheWVkT3ApO1xuICAgICAgICByZXR1cm4gZGVsYXllZE9wO1xuICAgIH1cbiAgICB2ZXJpZnlOb3RGYWlsZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmZhaWx1cmUpIHtcbiAgICAgICAgICAgIGZhaWwoMHhiODE1LCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZU9yU3RhY2s6IGdldE1lc3NhZ2VPclN0YWNrKHRoaXMuZmFpbHVyZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZlcmlmeU9wZXJhdGlvbkluUHJvZ3Jlc3MoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXRzIHVudGlsIGFsbCBjdXJyZW50bHkgcXVldWVkIHRhc2tzIGFyZSBmaW5pc2hlZCBleGVjdXRpbmcuIERlbGF5ZWRcbiAgICAgKiBvcGVyYXRpb25zIGFyZSBub3QgcnVuLlxuICAgICAqL1xuICAgIGFzeW5jIGRyYWluKCkge1xuICAgICAgICAvLyBPcGVyYXRpb25zIGluIHRoZSBxdWV1ZSBwcmlvciB0byBkcmFpbmluZyBtYXkgaGF2ZSBlbnF1ZXVlZCBhZGRpdGlvbmFsXG4gICAgICAgIC8vIG9wZXJhdGlvbnMuIEtlZXAgZHJhaW5pbmcgdGhlIHF1ZXVlIHVudGlsIHRoZSB0YWlsIGlzIG5vIGxvbmdlciBhZHZhbmNlZCxcbiAgICAgICAgLy8gd2hpY2ggaW5kaWNhdGVzIHRoYXQgbm8gbW9yZSBuZXcgb3BlcmF0aW9ucyB3ZXJlIGVucXVldWVkIGFuZCB0aGF0IGFsbFxuICAgICAgICAvLyBvcGVyYXRpb25zIHdlcmUgZXhlY3V0ZWQuXG4gICAgICAgIGxldCBjdXJyZW50VGFpbDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY3VycmVudFRhaWwgPSB0aGlzLnRhaWw7XG4gICAgICAgICAgICBhd2FpdCBjdXJyZW50VGFpbDtcbiAgICAgICAgfSB3aGlsZSAoY3VycmVudFRhaWwgIT09IHRoaXMudGFpbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBUZXN0czogRGV0ZXJtaW5lIGlmIGEgZGVsYXllZCBvcGVyYXRpb24gd2l0aCBhIHBhcnRpY3VsYXIgVGltZXJJZFxuICAgICAqIGV4aXN0cy5cbiAgICAgKi9cbiAgICBjb250YWluc0RlbGF5ZWRPcGVyYXRpb24odGltZXJJZCkge1xuICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIHRoaXMuZGVsYXllZE9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcC50aW1lcklkID09PSB0aW1lcklkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgVGVzdHM6IFJ1bnMgc29tZSBvciBhbGwgZGVsYXllZCBvcGVyYXRpb25zIGVhcmx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhc3RUaW1lcklkIC0gRGVsYXllZCBvcGVyYXRpb25zIHVwIHRvIGFuZCBpbmNsdWRpbmcgdGhpcyBUaW1lcklkXG4gICAgICogd2lsbCBiZSBkcmFpbmVkLiBQYXNzIFRpbWVySWQuQWxsIHRvIHJ1biBhbGwgZGVsYXllZCBvcGVyYXRpb25zLlxuICAgICAqIEByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgYWxsIG9wZXJhdGlvbnMgaGF2ZSBiZWVuIHJ1bi5cbiAgICAgKi9cbiAgICBydW5BbGxEZWxheWVkT3BlcmF0aW9uc1VudGlsKGxhc3RUaW1lcklkKSB7XG4gICAgICAgIC8vIE5vdGUgdGhhdCBkcmFpbmluZyBtYXkgZ2VuZXJhdGUgbW9yZSBkZWxheWVkIG9wcywgc28gd2UgZG8gdGhhdCBmaXJzdC5cbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhaW4oKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFJ1biBvcHMgaW4gdGhlIHNhbWUgb3JkZXIgdGhleSdkIHJ1biBpZiB0aGV5IHJhbiBuYXR1cmFsbHkuXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzICovXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zLnNvcnQoKGEsIGIpID0+IGEudGFyZ2V0VGltZU1zIC0gYi50YXJnZXRUaW1lTXMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcCBvZiB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3Auc2tpcERlbGF5KCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUaW1lcklkICE9PSBcImFsbFwiIC8qIFRpbWVySWQuQWxsICovICYmIG9wLnRpbWVySWQgPT09IGxhc3RUaW1lcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyYWluKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgVGVzdHM6IFNraXAgYWxsIHN1YnNlcXVlbnQgZGVsYXlzIGZvciBhIHRpbWVyIGlkLlxuICAgICAqL1xuICAgIHNraXBEZWxheXNGb3JUaW1lcklkKHRpbWVySWQpIHtcbiAgICAgICAgdGhpcy50aW1lcklkc1RvU2tpcC5wdXNoKHRpbWVySWQpO1xuICAgIH1cbiAgICAvKiogQ2FsbGVkIG9uY2UgYSBEZWxheWVkT3BlcmF0aW9uIGlzIHJ1biBvciBjYW5jZWxlZC4gKi9cbiAgICByZW1vdmVEZWxheWVkT3BlcmF0aW9uKG9wKSB7XG4gICAgICAgIC8vIE5PVEU6IGluZGV4T2YgLyBzbGljZSBhcmUgTyhuKSwgYnV0IGRlbGF5ZWRPcGVyYXRpb25zIGlzIGV4cGVjdGVkIHRvIGJlIHNtYWxsLlxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZGVsYXllZE9wZXJhdGlvbnMuaW5kZXhPZihvcCk7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXMgKi9cbiAgICAgICAgdGhpcy5kZWxheWVkT3BlcmF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbn1cbi8qKlxuICogQ2hyb21lIGluY2x1ZGVzIEVycm9yLm1lc3NhZ2UgaW4gRXJyb3Iuc3RhY2suIE90aGVyIGJyb3dzZXJzIGRvIG5vdC5cbiAqIFRoaXMgcmV0dXJucyBleHBlY3RlZCBvdXRwdXQgb2YgbWVzc2FnZSArIHN0YWNrIHdoZW4gYXZhaWxhYmxlLlxuICogQHBhcmFtIGVycm9yIC0gRXJyb3Igb3IgRmlyZXN0b3JlRXJyb3JcbiAqL1xuZnVuY3Rpb24gZ2V0TWVzc2FnZU9yU3RhY2soZXJyb3IpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHwgJyc7XG4gICAgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgICAgIGlmIChlcnJvci5zdGFjay5pbmNsdWRlcyhlcnJvci5tZXNzYWdlKSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLnN0YWNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgKyAnXFxuJyArIGVycm9yLnN0YWNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB0YXNrIG9mIGxvYWRpbmcgYSBGaXJlc3RvcmUgYnVuZGxlLiBJdCBwcm92aWRlcyBwcm9ncmVzcyBvZiBidW5kbGVcbiAqIGxvYWRpbmcsIGFzIHdlbGwgYXMgdGFzayBjb21wbGV0aW9uIGFuZCBlcnJvciBldmVudHMuXG4gKlxuICogVGhlIEFQSSBpcyBjb21wYXRpYmxlIHdpdGggYFByb21pc2U8TG9hZEJ1bmRsZVRhc2tQcm9ncmVzcz5gLlxuICovXG5jbGFzcyBMb2FkQnVuZGxlVGFzayB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIgPSB7fTtcbiAgICAgICAgdGhpcy5fdGFza0NvbXBsZXRpb25SZXNvbHZlciA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgICB0YXNrU3RhdGU6ICdSdW5uaW5nJyxcbiAgICAgICAgICAgIHRvdGFsQnl0ZXM6IDAsXG4gICAgICAgICAgICB0b3RhbERvY3VtZW50czogMCxcbiAgICAgICAgICAgIGJ5dGVzTG9hZGVkOiAwLFxuICAgICAgICAgICAgZG9jdW1lbnRzTG9hZGVkOiAwXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBmdW5jdGlvbnMgdG8gbGlzdGVuIHRvIGJ1bmRsZSBsb2FkaW5nIHByb2dyZXNzIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gbmV4dCAtIENhbGxlZCB3aGVuIHRoZXJlIGlzIGEgcHJvZ3Jlc3MgdXBkYXRlIGZyb20gYnVuZGxlIGxvYWRpbmcuIFR5cGljYWxseSBgbmV4dGAgY2FsbHMgb2NjdXJcbiAgICAgKiAgIGVhY2ggdGltZSBhIEZpcmVzdG9yZSBkb2N1bWVudCBpcyBsb2FkZWQgZnJvbSB0aGUgYnVuZGxlLlxuICAgICAqIEBwYXJhbSBlcnJvciAtIENhbGxlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgYnVuZGxlIGxvYWRpbmcuIFRoZSB0YXNrIGFib3J0cyBhZnRlciByZXBvcnRpbmcgdGhlXG4gICAgICogICBlcnJvciwgYW5kIHRoZXJlIHNob3VsZCBiZSBubyBtb3JlIHVwZGF0ZXMgYWZ0ZXIgdGhpcy5cbiAgICAgKiBAcGFyYW0gY29tcGxldGUgLSBDYWxsZWQgd2hlbiB0aGUgbG9hZGluZyB0YXNrIGlzIGNvbXBsZXRlLlxuICAgICAqL1xuICAgIG9uUHJvZ3Jlc3MobmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIgPSB7XG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBjb21wbGV0ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIHRoZSBgUHJvbWlzZTxMb2FkQnVuZGxlVGFza1Byb2dyZXNzPi5jYXRjaGAgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9uUmVqZWN0ZWQgLSBDYWxsZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgZHVyaW5nIGJ1bmRsZSBsb2FkaW5nLlxuICAgICAqL1xuICAgIGNhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rhc2tDb21wbGV0aW9uUmVzb2x2ZXIucHJvbWlzZS5jYXRjaChvblJlamVjdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyB0aGUgYFByb21pc2U8TG9hZEJ1bmRsZVRhc2tQcm9ncmVzcz4udGhlbmAgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9uRnVsZmlsbGVkIC0gQ2FsbGVkIG9uIHRoZSBjb21wbGV0aW9uIG9mIHRoZSBsb2FkaW5nIHRhc2sgd2l0aCBhIGZpbmFsIGBMb2FkQnVuZGxlVGFza1Byb2dyZXNzYCB1cGRhdGUuXG4gICAgICogICBUaGUgdXBkYXRlIHdpbGwgYWx3YXlzIGhhdmUgaXRzIGB0YXNrU3RhdGVgIHNldCB0byBgXCJTdWNjZXNzXCJgLlxuICAgICAqIEBwYXJhbSBvblJlamVjdGVkIC0gQ2FsbGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGR1cmluZyBidW5kbGUgbG9hZGluZy5cbiAgICAgKi9cbiAgICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YXNrQ29tcGxldGlvblJlc29sdmVyLnByb21pc2UudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIGFsbCBvYnNlcnZlcnMgdGhhdCBidW5kbGUgbG9hZGluZyBoYXMgY29tcGxldGVkLCB3aXRoIGEgcHJvdmlkZWRcbiAgICAgKiBgTG9hZEJ1bmRsZVRhc2tQcm9ncmVzc2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY29tcGxldGVXaXRoKHByb2dyZXNzKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVByb2dyZXNzKHByb2dyZXNzKTtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIuY29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YXNrQ29tcGxldGlvblJlc29sdmVyLnJlc29sdmUocHJvZ3Jlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyBhbGwgb2JzZXJ2ZXJzIHRoYXQgYnVuZGxlIGxvYWRpbmcgaGFzIGZhaWxlZCwgd2l0aCBhIHByb3ZpZGVkXG4gICAgICogYEVycm9yYCBhcyB0aGUgcmVhc29uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmFpbFdpdGgoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzLnRhc2tTdGF0ZSA9ICdFcnJvcic7XG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc09ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIubmV4dCh0aGlzLl9sYXN0UHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc09ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc09ic2VydmVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YXNrQ29tcGxldGlvblJlc29sdmVyLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIGEgcHJvZ3Jlc3MgdXBkYXRlIG9mIGxvYWRpbmcgYSBidW5kbGUuXG4gICAgICogQHBhcmFtIHByb2dyZXNzIC0gVGhlIG5ldyBwcm9ncmVzcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVByb2dyZXNzKHByb2dyZXNzKSB7XG4gICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc09ic2VydmVyLm5leHQocHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDb25zdGFudCB1c2VkIHRvIGluZGljYXRlIHRoZSBMUlUgZ2FyYmFnZSBjb2xsZWN0aW9uIHNob3VsZCBiZSBkaXNhYmxlZC5cbiAqIFNldCB0aGlzIHZhbHVlIGFzIHRoZSBgY2FjaGVTaXplQnl0ZXNgIG9uIHRoZSBzZXR0aW5ncyBwYXNzZWQgdG8gdGhlXG4gKiB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZS5cbiAqL1xuY29uc3QgQ0FDSEVfU0laRV9VTkxJTUlURUQgPSBMUlVfQ09MTEVDVElPTl9ESVNBQkxFRDtcbi8qKlxuICogVGhlIENsb3VkIEZpcmVzdG9yZSBzZXJ2aWNlIGludGVyZmFjZS5cbiAqXG4gKiBEbyBub3QgY2FsbCB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBJbnN0ZWFkLCB1c2Uge0BsaW5rIChnZXRGaXJlc3RvcmU6MSl9LlxuICovXG5jbGFzcyBGaXJlc3RvcmUgZXh0ZW5kcyBGaXJlc3RvcmUkMSB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihhdXRoQ3JlZGVudGlhbHNQcm92aWRlciwgYXBwQ2hlY2tDcmVkZW50aWFsc1Byb3ZpZGVyLCBkYXRhYmFzZUlkLCBhcHApIHtcbiAgICAgICAgc3VwZXIoYXV0aENyZWRlbnRpYWxzUHJvdmlkZXIsIGFwcENoZWNrQ3JlZGVudGlhbHNQcm92aWRlciwgZGF0YWJhc2VJZCwgYXBwKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgaXQncyBhIHtAbGluayBGaXJlc3RvcmV9IG9yIEZpcmVzdG9yZSBMaXRlIGluc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gJ2ZpcmVzdG9yZSc7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gbmV3IEFzeW5jUXVldWVJbXBsKCk7XG4gICAgICAgIHRoaXMuX3BlcnNpc3RlbmNlS2V5ID0gYXBwPy5uYW1lIHx8ICdbREVGQVVMVF0nO1xuICAgIH1cbiAgICBhc3luYyBfdGVybWluYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5fZmlyZXN0b3JlQ2xpZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0ZXJtaW5hdGUgPSB0aGlzLl9maXJlc3RvcmVDbGllbnQudGVybWluYXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyBBc3luY1F1ZXVlSW1wbCh0ZXJtaW5hdGUpO1xuICAgICAgICAgICAgdGhpcy5fZmlyZXN0b3JlQ2xpZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYXdhaXQgdGVybWluYXRlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgRmlyZXN0b3JlfSB3aXRoIHRoZSBwcm92aWRlZCBzZXR0aW5ncy5cbiAqIENhbiBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgYW55IG90aGVyIGZ1bmN0aW9uLCBpbmNsdWRpbmdcbiAqIHtAbGluayAoZ2V0RmlyZXN0b3JlOjEpfS4gSWYgdGhlIGN1c3RvbSBzZXR0aW5ncyBhcmUgZW1wdHksIHRoaXMgZnVuY3Rpb24gaXNcbiAqIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0uXG4gKlxuICogQHBhcmFtIGFwcCAtIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gd2l0aCB3aGljaCB0aGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2Ugd2lsbFxuICogYmUgYXNzb2NpYXRlZC5cbiAqIEBwYXJhbSBzZXR0aW5ncyAtIEEgc2V0dGluZ3Mgb2JqZWN0IHRvIGNvbmZpZ3VyZSB0aGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZGF0YWJhc2VJZCAtIFRoZSBuYW1lIG9mIHRoZSBkYXRhYmFzZS5cbiAqIEByZXR1cm5zIEEgbmV3bHkgaW5pdGlhbGl6ZWQge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVGaXJlc3RvcmUoYXBwLCBzZXR0aW5ncywgZGF0YWJhc2VJZCkge1xuICAgIGlmICghZGF0YWJhc2VJZCkge1xuICAgICAgICBkYXRhYmFzZUlkID0gREVGQVVMVF9EQVRBQkFTRV9OQU1FO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsICdmaXJlc3RvcmUnKTtcbiAgICBpZiAocHJvdmlkZXIuaXNJbml0aWFsaXplZChkYXRhYmFzZUlkKSkge1xuICAgICAgICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gcHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGRhdGFiYXNlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxTZXR0aW5ncyA9IHByb3ZpZGVyLmdldE9wdGlvbnMoZGF0YWJhc2VJZCk7XG4gICAgICAgIGlmIChkZWVwRXF1YWwoaW5pdGlhbFNldHRpbmdzLCBzZXR0aW5ncykpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0luc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ2luaXRpYWxpemVGaXJlc3RvcmUoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCB3aXRoICcgK1xuICAgICAgICAgICAgICAgICdkaWZmZXJlbnQgb3B0aW9ucy4gVG8gYXZvaWQgdGhpcyBlcnJvciwgY2FsbCBpbml0aWFsaXplRmlyZXN0b3JlKCkgd2l0aCB0aGUgJyArXG4gICAgICAgICAgICAgICAgJ3NhbWUgb3B0aW9ucyBhcyB3aGVuIGl0IHdhcyBvcmlnaW5hbGx5IGNhbGxlZCwgb3IgY2FsbCBnZXRGaXJlc3RvcmUoKSB0byByZXR1cm4gdGhlJyArXG4gICAgICAgICAgICAgICAgJyBhbHJlYWR5IGluaXRpYWxpemVkIGluc3RhbmNlLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHNldHRpbmdzLmxvY2FsQ2FjaGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgY2FjaGUgYW5kIGNhY2hlU2l6ZUJ5dGVzIGNhbm5vdCBiZSBzcGVjaWZpZWQgYXQgdGhlIHNhbWUgdGltZSBhcyBjYWNoZVNpemVCeXRlcyB3aWxsYCArXG4gICAgICAgICAgICBgYmUgZGVwcmVjYXRlZC4gSW5zdGVhZCwgc3BlY2lmeSB0aGUgY2FjaGUgc2l6ZSBpbiB0aGUgY2FjaGUgb2JqZWN0YCk7XG4gICAgfVxuICAgIGlmIChzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzICE9PSBDQUNIRV9TSVpFX1VOTElNSVRFRCAmJlxuICAgICAgICBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyA8IExSVV9NSU5JTVVNX0NBQ0hFX1NJWkVfQllURVMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYGNhY2hlU2l6ZUJ5dGVzIG11c3QgYmUgYXQgbGVhc3QgJHtMUlVfTUlOSU1VTV9DQUNIRV9TSVpFX0JZVEVTfWApO1xuICAgIH1cbiAgICAvLyBXb3JrYXJvdW5kIHRvIGdldCBjb29raWVzIGluIEZpcmViYXNlIFN0dWRpb1xuICAgIGlmIChzZXR0aW5ncy5ob3N0ICYmIGlzQ2xvdWRXb3Jrc3RhdGlvbihzZXR0aW5ncy5ob3N0KSkge1xuICAgICAgICB2b2lkIHBpbmdTZXJ2ZXIoc2V0dGluZ3MuaG9zdCk7XG4gICAgfVxuICAgIHJldHVybiBwcm92aWRlci5pbml0aWFsaXplKHtcbiAgICAgICAgb3B0aW9uczogc2V0dGluZ3MsXG4gICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogZGF0YWJhc2VJZFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RmlyZXN0b3JlKGFwcE9yRGF0YWJhc2VJZCwgb3B0aW9uYWxEYXRhYmFzZUlkKSB7XG4gICAgY29uc3QgYXBwID0gdHlwZW9mIGFwcE9yRGF0YWJhc2VJZCA9PT0gJ29iamVjdCcgPyBhcHBPckRhdGFiYXNlSWQgOiBnZXRBcHAoKTtcbiAgICBjb25zdCBkYXRhYmFzZUlkID0gdHlwZW9mIGFwcE9yRGF0YWJhc2VJZCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBhcHBPckRhdGFiYXNlSWRcbiAgICAgICAgOiBvcHRpb25hbERhdGFiYXNlSWQgfHwgREVGQVVMVF9EQVRBQkFTRV9OQU1FO1xuICAgIGNvbnN0IGRiID0gX2dldFByb3ZpZGVyKGFwcCwgJ2ZpcmVzdG9yZScpLmdldEltbWVkaWF0ZSh7XG4gICAgICAgIGlkZW50aWZpZXI6IGRhdGFiYXNlSWRcbiAgICB9KTtcbiAgICBpZiAoIWRiLl9pbml0aWFsaXplZCkge1xuICAgICAgICBjb25zdCBlbXVsYXRvciA9IGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCgnZmlyZXN0b3JlJyk7XG4gICAgICAgIGlmIChlbXVsYXRvcikge1xuICAgICAgICAgICAgY29ubmVjdEZpcmVzdG9yZUVtdWxhdG9yKGRiLCAuLi5lbXVsYXRvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRiO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpIHtcbiAgICBpZiAoZmlyZXN0b3JlLl90ZXJtaW5hdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdUaGUgY2xpZW50IGhhcyBhbHJlYWR5IGJlZW4gdGVybWluYXRlZC4nKTtcbiAgICB9XG4gICAgaWYgKCFmaXJlc3RvcmUuX2ZpcmVzdG9yZUNsaWVudCkge1xuICAgICAgICBjb25maWd1cmVGaXJlc3RvcmUoZmlyZXN0b3JlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpcmVzdG9yZS5fZmlyZXN0b3JlQ2xpZW50O1xufVxuZnVuY3Rpb24gY29uZmlndXJlRmlyZXN0b3JlKGZpcmVzdG9yZSkge1xuICAgIGNvbnN0IHNldHRpbmdzID0gZmlyZXN0b3JlLl9mcmVlemVTZXR0aW5ncygpO1xuICAgIGNvbnN0IGRhdGFiYXNlSW5mbyA9IG1ha2VEYXRhYmFzZUluZm8oZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCBmaXJlc3RvcmUuX2FwcD8ub3B0aW9ucy5hcHBJZCB8fCAnJywgZmlyZXN0b3JlLl9wZXJzaXN0ZW5jZUtleSwgZmlyZXN0b3JlLl9hcHA/Lm9wdGlvbnMuYXBpS2V5LCBzZXR0aW5ncyk7XG4gICAgaWYgKCFmaXJlc3RvcmUuX2NvbXBvbmVudHNQcm92aWRlcikge1xuICAgICAgICBpZiAoc2V0dGluZ3MubG9jYWxDYWNoZT8uX29mZmxpbmVDb21wb25lbnRQcm92aWRlciAmJlxuICAgICAgICAgICAgc2V0dGluZ3MubG9jYWxDYWNoZT8uX29ubGluZUNvbXBvbmVudFByb3ZpZGVyKSB7XG4gICAgICAgICAgICBmaXJlc3RvcmUuX2NvbXBvbmVudHNQcm92aWRlciA9IHtcbiAgICAgICAgICAgICAgICBfb2ZmbGluZTogc2V0dGluZ3MubG9jYWxDYWNoZS5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIF9vbmxpbmU6IHNldHRpbmdzLmxvY2FsQ2FjaGUuX29ubGluZUNvbXBvbmVudFByb3ZpZGVyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpcmVzdG9yZS5fZmlyZXN0b3JlQ2xpZW50ID0gbmV3IEZpcmVzdG9yZUNsaWVudChmaXJlc3RvcmUuX2F1dGhDcmVkZW50aWFscywgZmlyZXN0b3JlLl9hcHBDaGVja0NyZWRlbnRpYWxzLCBmaXJlc3RvcmUuX3F1ZXVlLCBkYXRhYmFzZUluZm8sIGZpcmVzdG9yZS5fY29tcG9uZW50c1Byb3ZpZGVyICYmXG4gICAgICAgIGJ1aWxkQ29tcG9uZW50UHJvdmlkZXIoZmlyZXN0b3JlLl9jb21wb25lbnRzUHJvdmlkZXIpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ29tcG9uZW50UHJvdmlkZXIoY29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgY29uc3Qgb25saW5lID0gY29tcG9uZW50c1Byb3ZpZGVyPy5fb25saW5lLmJ1aWxkKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX29mZmxpbmU6IGNvbXBvbmVudHNQcm92aWRlcj8uX29mZmxpbmUuYnVpbGQob25saW5lKSxcbiAgICAgICAgX29ubGluZTogb25saW5lXG4gICAgfTtcbn1cbi8qKlxuICogQXR0ZW1wdHMgdG8gZW5hYmxlIHBlcnNpc3RlbnQgc3RvcmFnZSwgaWYgcG9zc2libGUuXG4gKlxuICogT24gZmFpbHVyZSwgYGVuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlKClgIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlIG9yXG4gKiB0aHJvdyBhbiBleGNlcHRpb24uIFRoZXJlIGFyZSBzZXZlcmFsIHJlYXNvbnMgd2h5IHRoaXMgY2FuIGZhaWwsIHdoaWNoIGNhbiBiZVxuICogaWRlbnRpZmllZCBieSB0aGUgYGNvZGVgIG9uIHRoZSBlcnJvci5cbiAqXG4gKiAgICogZmFpbGVkLXByZWNvbmRpdGlvbjogVGhlIGFwcCBpcyBhbHJlYWR5IG9wZW4gaW4gYW5vdGhlciBicm93c2VyIHRhYi5cbiAqICAgKiB1bmltcGxlbWVudGVkOiBUaGUgYnJvd3NlciBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgb2ZmbGluZSBwZXJzaXN0ZW5jZVxuICogICAgIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCBldmVuIGFmdGVyIGEgZmFpbHVyZSwgdGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHdpbGwgcmVtYWluXG4gKiB1c2FibGUsIGhvd2V2ZXIgb2ZmbGluZSBwZXJzaXN0ZW5jZSB3aWxsIGJlIGRpc2FibGVkLlxuICpcbiAqIE5vdGU6IGBlbmFibGVJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgYW55IG90aGVyIGZ1bmN0aW9uc1xuICogKG90aGVyIHRoYW4ge0BsaW5rIGluaXRpYWxpemVGaXJlc3RvcmV9LCB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0gb3JcbiAqIHtAbGluayBjbGVhckluZGV4ZWREYlBlcnNpc3RlbmNlfS5cbiAqXG4gKiBQZXJzaXN0ZW5jZSBjYW5ub3QgYmUgdXNlZCBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gKlxuICogQHBhcmFtIGZpcmVzdG9yZSAtIFRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSB0byBlbmFibGUgcGVyc2lzdGVuY2UgZm9yLlxuICogQHBhcmFtIHBlcnNpc3RlbmNlU2V0dGluZ3MgLSBPcHRpb25hbCBzZXR0aW5ncyBvYmplY3QgdG8gY29uZmlndXJlXG4gKiBwZXJzaXN0ZW5jZS5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVwcmVzZW50cyBzdWNjZXNzZnVsbHkgZW5hYmxpbmcgcGVyc2lzdGVudCBzdG9yYWdlLlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gSW5zdGVhZCwgc2V0XG4gKiBgRmlyZXN0b3JlU2V0dGluZ3MubG9jYWxDYWNoZWAgdG8gYW4gaW5zdGFuY2Ugb2YgYFBlcnNpc3RlbnRMb2NhbENhY2hlYCB0b1xuICogdHVybiBvbiBJbmRleGVkRGIgY2FjaGUuIENhbGxpbmcgdGhpcyBmdW5jdGlvbiB3aGVuIGBGaXJlc3RvcmVTZXR0aW5ncy5sb2NhbENhY2hlYFxuICogaXMgYWxyZWFkeSBzcGVjaWZpZWQgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlKGZpcmVzdG9yZSwgcGVyc2lzdGVuY2VTZXR0aW5ncykge1xuICAgIGxvZ1dhcm4oJ2VuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlKCkgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUsICcgK1xuICAgICAgICAneW91IGNhbiB1c2UgYEZpcmVzdG9yZVNldHRpbmdzLmNhY2hlYCBpbnN0ZWFkLicpO1xuICAgIGNvbnN0IHNldHRpbmdzID0gZmlyZXN0b3JlLl9mcmVlemVTZXR0aW5ncygpO1xuICAgIHNldFBlcnNpc3RlbmNlUHJvdmlkZXJzKGZpcmVzdG9yZSwgT25saW5lQ29tcG9uZW50UHJvdmlkZXIucHJvdmlkZXIsIHtcbiAgICAgICAgYnVpbGQ6IChvbmxpbmVDb21wb25lbnRzKSA9PiBuZXcgSW5kZXhlZERiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKG9ubGluZUNvbXBvbmVudHMsIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzLCBwZXJzaXN0ZW5jZVNldHRpbmdzPy5mb3JjZU93bmVyc2hpcClcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59XG4vKipcbiAqIEF0dGVtcHRzIHRvIGVuYWJsZSBtdWx0aS10YWIgcGVyc2lzdGVudCBzdG9yYWdlLCBpZiBwb3NzaWJsZS4gSWYgZW5hYmxlZFxuICogYWNyb3NzIGFsbCB0YWJzLCBhbGwgb3BlcmF0aW9ucyBzaGFyZSBhY2Nlc3MgdG8gbG9jYWwgcGVyc2lzdGVuY2UsIGluY2x1ZGluZ1xuICogc2hhcmVkIGV4ZWN1dGlvbiBvZiBxdWVyaWVzIGFuZCBsYXRlbmN5LWNvbXBlbnNhdGVkIGxvY2FsIGRvY3VtZW50IHVwZGF0ZXNcbiAqIGFjcm9zcyBhbGwgY29ubmVjdGVkIGluc3RhbmNlcy5cbiAqXG4gKiBPbiBmYWlsdXJlLCBgZW5hYmxlTXVsdGlUYWJJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZSBvclxuICogdGhyb3cgYW4gZXhjZXB0aW9uLiBUaGVyZSBhcmUgc2V2ZXJhbCByZWFzb25zIHdoeSB0aGlzIGNhbiBmYWlsLCB3aGljaCBjYW4gYmVcbiAqIGlkZW50aWZpZWQgYnkgdGhlIGBjb2RlYCBvbiB0aGUgZXJyb3IuXG4gKlxuICogICAqIGZhaWxlZC1wcmVjb25kaXRpb246IFRoZSBhcHAgaXMgYWxyZWFkeSBvcGVuIGluIGFub3RoZXIgYnJvd3NlciB0YWIgYW5kXG4gKiAgICAgbXVsdGktdGFiIGlzIG5vdCBlbmFibGVkLlxuICogICAqIHVuaW1wbGVtZW50ZWQ6IFRoZSBicm93c2VyIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBvZmZsaW5lIHBlcnNpc3RlbmNlXG4gKiAgICAgaW1wbGVtZW50YXRpb24uXG4gKlxuICogTm90ZSB0aGF0IGV2ZW4gYWZ0ZXIgYSBmYWlsdXJlLCB0aGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2Ugd2lsbCByZW1haW5cbiAqIHVzYWJsZSwgaG93ZXZlciBvZmZsaW5lIHBlcnNpc3RlbmNlIHdpbGwgYmUgZGlzYWJsZWQuXG4gKlxuICogQHBhcmFtIGZpcmVzdG9yZSAtIFRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSB0byBlbmFibGUgcGVyc2lzdGVuY2UgZm9yLlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXByZXNlbnRzIHN1Y2Nlc3NmdWxseSBlbmFibGluZyBwZXJzaXN0ZW50XG4gKiBzdG9yYWdlLlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gSW5zdGVhZCwgc2V0XG4gKiBgRmlyZXN0b3JlU2V0dGluZ3MubG9jYWxDYWNoZWAgdG8gYW4gaW5zdGFuY2Ugb2YgYFBlcnNpc3RlbnRMb2NhbENhY2hlYCB0b1xuICogdHVybiBvbiBpbmRleGVkZGIgY2FjaGUuIENhbGxpbmcgdGhpcyBmdW5jdGlvbiB3aGVuIGBGaXJlc3RvcmVTZXR0aW5ncy5sb2NhbENhY2hlYFxuICogaXMgYWxyZWFkeSBzcGVjaWZpZWQgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGVuYWJsZU11bHRpVGFiSW5kZXhlZERiUGVyc2lzdGVuY2UoZmlyZXN0b3JlKSB7XG4gICAgbG9nV2FybignZW5hYmxlTXVsdGlUYWJJbmRleGVkRGJQZXJzaXN0ZW5jZSgpIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLCAnICtcbiAgICAgICAgJ3lvdSBjYW4gdXNlIGBGaXJlc3RvcmVTZXR0aW5ncy5jYWNoZWAgaW5zdGVhZC4nKTtcbiAgICBjb25zdCBzZXR0aW5ncyA9IGZpcmVzdG9yZS5fZnJlZXplU2V0dGluZ3MoKTtcbiAgICBzZXRQZXJzaXN0ZW5jZVByb3ZpZGVycyhmaXJlc3RvcmUsIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnByb3ZpZGVyLCB7XG4gICAgICAgIGJ1aWxkOiAob25saW5lQ29tcG9uZW50cykgPT4gbmV3IE11bHRpVGFiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKG9ubGluZUNvbXBvbmVudHMsIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzKVxuICAgIH0pO1xufVxuLyoqXG4gKiBSZWdpc3RlcnMgYm90aCB0aGUgYE9mZmxpbmVDb21wb25lbnRQcm92aWRlcmAgYW5kIGBPbmxpbmVDb21wb25lbnRQcm92aWRlcmAuXG4gKiBJZiB0aGUgb3BlcmF0aW9uIGZhaWxzIHdpdGggYSByZWNvdmVyYWJsZSBlcnJvciAoc2VlXG4gKiBgY2FuUmVjb3ZlckZyb21JbmRleGVkRGJFcnJvcigpYCBiZWxvdyksIHRoZSByZXR1cm5lZCBQcm9taXNlIGlzIHJlamVjdGVkXG4gKiBidXQgdGhlIGNsaWVudCByZW1haW5zIHVzYWJsZS5cbiAqL1xuZnVuY3Rpb24gc2V0UGVyc2lzdGVuY2VQcm92aWRlcnMoZmlyZXN0b3JlLCBvbmxpbmVDb21wb25lbnRQcm92aWRlciwgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgaWYgKGZpcmVzdG9yZS5fZmlyZXN0b3JlQ2xpZW50IHx8IGZpcmVzdG9yZS5fdGVybWluYXRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnRmlyZXN0b3JlIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCBhbmQgcGVyc2lzdGVuY2UgY2FuIG5vIGxvbmdlciBiZSAnICtcbiAgICAgICAgICAgICdlbmFibGVkLiBZb3UgY2FuIG9ubHkgZW5hYmxlIHBlcnNpc3RlbmNlIGJlZm9yZSBjYWxsaW5nIGFueSBvdGhlciAnICtcbiAgICAgICAgICAgICdtZXRob2RzIG9uIGEgRmlyZXN0b3JlIG9iamVjdC4nKTtcbiAgICB9XG4gICAgaWYgKGZpcmVzdG9yZS5fY29tcG9uZW50c1Byb3ZpZGVyIHx8IGZpcmVzdG9yZS5fZ2V0U2V0dGluZ3MoKS5sb2NhbENhY2hlKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdTREsgY2FjaGUgaXMgYWxyZWFkeSBzcGVjaWZpZWQuJyk7XG4gICAgfVxuICAgIGZpcmVzdG9yZS5fY29tcG9uZW50c1Byb3ZpZGVyID0ge1xuICAgICAgICBfb25saW5lOiBvbmxpbmVDb21wb25lbnRQcm92aWRlcixcbiAgICAgICAgX29mZmxpbmU6IG9mZmxpbmVDb21wb25lbnRQcm92aWRlclxuICAgIH07XG4gICAgY29uZmlndXJlRmlyZXN0b3JlKGZpcmVzdG9yZSk7XG59XG4vKipcbiAqIENsZWFycyB0aGUgcGVyc2lzdGVudCBzdG9yYWdlLiBUaGlzIGluY2x1ZGVzIHBlbmRpbmcgd3JpdGVzIGFuZCBjYWNoZWRcbiAqIGRvY3VtZW50cy5cbiAqXG4gKiBNdXN0IGJlIGNhbGxlZCB3aGlsZSB0aGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgaXMgbm90IHN0YXJ0ZWQgKGFmdGVyIHRoZSBhcHAgaXNcbiAqIHRlcm1pbmF0ZWQgb3Igd2hlbiB0aGUgYXBwIGlzIGZpcnN0IGluaXRpYWxpemVkKS4gT24gc3RhcnR1cCwgdGhpcyBmdW5jdGlvblxuICogbXVzdCBiZSBjYWxsZWQgYmVmb3JlIG90aGVyIGZ1bmN0aW9ucyAob3RoZXIgdGhhbiB7QGxpbmtcbiAqIGluaXRpYWxpemVGaXJlc3RvcmV9IG9yIHtAbGluayAoZ2V0RmlyZXN0b3JlOjEpfSkpLiBJZiB0aGUge0BsaW5rIEZpcmVzdG9yZX1cbiAqIGluc3RhbmNlIGlzIHN0aWxsIHJ1bm5pbmcsIHRoZSBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgZXJyb3IgY29kZVxuICogb2YgYGZhaWxlZC1wcmVjb25kaXRpb25gLlxuICpcbiAqIE5vdGU6IGBjbGVhckluZGV4ZWREYlBlcnNpc3RlbmNlKClgIGlzIHByaW1hcmlseSBpbnRlbmRlZCB0byBoZWxwIHdyaXRlXG4gKiByZWxpYWJsZSB0ZXN0cyB0aGF0IHVzZSBDbG91ZCBGaXJlc3RvcmUuIEl0IHVzZXMgYW4gZWZmaWNpZW50IG1lY2hhbmlzbSBmb3JcbiAqIGRyb3BwaW5nIGV4aXN0aW5nIGRhdGEgYnV0IGRvZXMgbm90IGF0dGVtcHQgdG8gc2VjdXJlbHkgb3ZlcndyaXRlIG9yXG4gKiBvdGhlcndpc2UgbWFrZSBjYWNoZWQgZGF0YSB1bnJlY292ZXJhYmxlLiBGb3IgYXBwbGljYXRpb25zIHRoYXQgYXJlIHNlbnNpdGl2ZVxuICogdG8gdGhlIGRpc2Nsb3N1cmUgb2YgY2FjaGVkIGRhdGEgaW4gYmV0d2VlbiB1c2VyIHNlc3Npb25zLCB3ZSBzdHJvbmdseVxuICogcmVjb21tZW5kIG5vdCBlbmFibGluZyBwZXJzaXN0ZW5jZSBhdCBhbGwuXG4gKlxuICogQHBhcmFtIGZpcmVzdG9yZSAtIFRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSB0byBjbGVhciBwZXJzaXN0ZW5jZSBmb3IuXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIHBlcnNpc3RlbnQgc3RvcmFnZSBpc1xuICogY2xlYXJlZC4gT3RoZXJ3aXNlLCB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxuICovXG5mdW5jdGlvbiBjbGVhckluZGV4ZWREYlBlcnNpc3RlbmNlKGZpcmVzdG9yZSkge1xuICAgIGlmIChmaXJlc3RvcmUuX2luaXRpYWxpemVkICYmICFmaXJlc3RvcmUuX3Rlcm1pbmF0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ1BlcnNpc3RlbmNlIGNhbiBvbmx5IGJlIGNsZWFyZWQgYmVmb3JlIGEgRmlyZXN0b3JlIGluc3RhbmNlIGlzICcgK1xuICAgICAgICAgICAgJ2luaXRpYWxpemVkIG9yIGFmdGVyIGl0IGlzIHRlcm1pbmF0ZWQuJyk7XG4gICAgfVxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgZmlyZXN0b3JlLl9xdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0RXZlbldoaWxlUmVzdHJpY3RlZChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBpbmRleGVkRGJDbGVhclBlcnNpc3RlbmNlKGluZGV4ZWREYlN0b3JhZ2VQcmVmaXgoZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCBmaXJlc3RvcmUuX3BlcnNpc3RlbmNlS2V5KSk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuLyoqXG4gKiBXYWl0cyB1bnRpbCBhbGwgY3VycmVudGx5IHBlbmRpbmcgd3JpdGVzIGZvciB0aGUgYWN0aXZlIHVzZXIgaGF2ZSBiZWVuXG4gKiBhY2tub3dsZWRnZWQgYnkgdGhlIGJhY2tlbmQuXG4gKlxuICogVGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMgaW1tZWRpYXRlbHkgaWYgdGhlcmUgYXJlIG5vIG91dHN0YW5kaW5nIHdyaXRlcy5cbiAqIE90aGVyd2lzZSwgdGhlIHByb21pc2Ugd2FpdHMgZm9yIGFsbCBwcmV2aW91c2x5IGlzc3VlZCB3cml0ZXMgKGluY2x1ZGluZ1xuICogdGhvc2Ugd3JpdHRlbiBpbiBhIHByZXZpb3VzIGFwcCBzZXNzaW9uKSwgYnV0IGl0IGRvZXMgbm90IHdhaXQgZm9yIHdyaXRlc1xuICogdGhhdCB3ZXJlIGFkZGVkIGFmdGVyIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQuIElmIHlvdSB3YW50IHRvIHdhaXQgZm9yXG4gKiBhZGRpdGlvbmFsIHdyaXRlcywgY2FsbCBgd2FpdEZvclBlbmRpbmdXcml0ZXMoKWAgYWdhaW4uXG4gKlxuICogQW55IG91dHN0YW5kaW5nIGB3YWl0Rm9yUGVuZGluZ1dyaXRlcygpYCBwcm9taXNlcyBhcmUgcmVqZWN0ZWQgZHVyaW5nIHVzZXJcbiAqIGNoYW5nZXMuXG4gKlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgd2hpY2ggcmVzb2x2ZXMgd2hlbiBhbGwgY3VycmVudGx5IHBlbmRpbmcgd3JpdGVzIGhhdmUgYmVlblxuICogYWNrbm93bGVkZ2VkIGJ5IHRoZSBiYWNrZW5kLlxuICovXG5mdW5jdGlvbiB3YWl0Rm9yUGVuZGluZ1dyaXRlcyhmaXJlc3RvcmUpIHtcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudFdhaXRGb3JQZW5kaW5nV3JpdGVzKGNsaWVudCk7XG59XG4vKipcbiAqIFJlLWVuYWJsZXMgdXNlIG9mIHRoZSBuZXR3b3JrIGZvciB0aGlzIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIGFmdGVyIGEgcHJpb3JcbiAqIGNhbGwgdG8ge0BsaW5rIGRpc2FibGVOZXR3b3JrfS5cbiAqXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IGlzIHJlc29sdmVkIG9uY2UgdGhlIG5ldHdvcmsgaGFzIGJlZW4gZW5hYmxlZC5cbiAqL1xuZnVuY3Rpb24gZW5hYmxlTmV0d29yayhmaXJlc3RvcmUpIHtcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEVuYWJsZU5ldHdvcmsoY2xpZW50KTtcbn1cbi8qKlxuICogRGlzYWJsZXMgbmV0d29yayB1c2FnZSBmb3IgdGhpcyBpbnN0YW5jZS4gSXQgY2FuIGJlIHJlLWVuYWJsZWQgdmlhIHtAbGlua1xuICogZW5hYmxlTmV0d29ya30uIFdoaWxlIHRoZSBuZXR3b3JrIGlzIGRpc2FibGVkLCBhbnkgc25hcHNob3QgbGlzdGVuZXJzLFxuICogYGdldERvYygpYCBvciBgZ2V0RG9jcygpYCBjYWxscyB3aWxsIHJldHVybiByZXN1bHRzIGZyb20gY2FjaGUsIGFuZCBhbnkgd3JpdGVcbiAqIG9wZXJhdGlvbnMgd2lsbCBiZSBxdWV1ZWQgdW50aWwgdGhlIG5ldHdvcmsgaXMgcmVzdG9yZWQuXG4gKlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCBvbmNlIHRoZSBuZXR3b3JrIGhhcyBiZWVuIGRpc2FibGVkLlxuICovXG5mdW5jdGlvbiBkaXNhYmxlTmV0d29yayhmaXJlc3RvcmUpIHtcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudERpc2FibGVOZXR3b3JrKGNsaWVudCk7XG59XG4vKipcbiAqIFRlcm1pbmF0ZXMgdGhlIHByb3ZpZGVkIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlLlxuICpcbiAqIEFmdGVyIGNhbGxpbmcgYHRlcm1pbmF0ZSgpYCBvbmx5IHRoZSBgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCBmdW5jdGlvblxuICogbWF5IGJlIHVzZWQuIEFueSBvdGhlciBmdW5jdGlvbiB3aWxsIHRocm93IGEgYEZpcmVzdG9yZUVycm9yYC5cbiAqXG4gKiBUbyByZXN0YXJ0IGFmdGVyIHRlcm1pbmF0aW9uLCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgRmlyZWJhc2VGaXJlc3RvcmUgd2l0aFxuICoge0BsaW5rIChnZXRGaXJlc3RvcmU6MSl9LlxuICpcbiAqIFRlcm1pbmF0aW9uIGRvZXMgbm90IGNhbmNlbCBhbnkgcGVuZGluZyB3cml0ZXMsIGFuZCBhbnkgcHJvbWlzZXMgdGhhdCBhcmVcbiAqIGF3YWl0aW5nIGEgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyIHdpbGwgbm90IGJlIHJlc29sdmVkLiBJZiB5b3UgaGF2ZVxuICogcGVyc2lzdGVuY2UgZW5hYmxlZCwgdGhlIG5leHQgdGltZSB5b3Ugc3RhcnQgdGhpcyBpbnN0YW5jZSwgaXQgd2lsbCByZXN1bWVcbiAqIHNlbmRpbmcgdGhlc2Ugd3JpdGVzIHRvIHRoZSBzZXJ2ZXIuXG4gKlxuICogTm90ZTogVW5kZXIgbm9ybWFsIGNpcmN1bXN0YW5jZXMsIGNhbGxpbmcgYHRlcm1pbmF0ZSgpYCBpcyBub3QgcmVxdWlyZWQuIFRoaXNcbiAqIGZ1bmN0aW9uIGlzIHVzZWZ1bCBvbmx5IHdoZW4geW91IHdhbnQgdG8gZm9yY2UgdGhpcyBpbnN0YW5jZSB0byByZWxlYXNlIGFsbFxuICogb2YgaXRzIHJlc291cmNlcyBvciBpbiBjb21iaW5hdGlvbiB3aXRoIGBjbGVhckluZGV4ZWREYlBlcnNpc3RlbmNlKClgIHRvXG4gKiBlbnN1cmUgdGhhdCBhbGwgbG9jYWwgc3RhdGUgaXMgZGVzdHJveWVkIGJldHdlZW4gdGVzdCBydW5zLlxuICpcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgaW5zdGFuY2UgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5XG4gKiB0ZXJtaW5hdGVkLlxuICovXG5mdW5jdGlvbiB0ZXJtaW5hdGUoZmlyZXN0b3JlKSB7XG4gICAgX3JlbW92ZVNlcnZpY2VJbnN0YW5jZShmaXJlc3RvcmUuYXBwLCAnZmlyZXN0b3JlJywgZmlyZXN0b3JlLl9kYXRhYmFzZUlkLmRhdGFiYXNlKTtcbiAgICByZXR1cm4gZmlyZXN0b3JlLl9kZWxldGUoKTtcbn1cbi8qKlxuICogTG9hZHMgYSBGaXJlc3RvcmUgYnVuZGxlIGludG8gdGhlIGxvY2FsIGNhY2hlLlxuICpcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gbG9hZCBidW5kbGVzIGZvci5cbiAqIEBwYXJhbSBidW5kbGVEYXRhIC0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYnVuZGxlIHRvIGJlIGxvYWRlZC4gVmFsaWRcbiAqIG9iamVjdHMgYXJlIGBBcnJheUJ1ZmZlcmAsIGBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PmAgb3IgYHN0cmluZ2AuXG4gKlxuICogQHJldHVybnMgQSBgTG9hZEJ1bmRsZVRhc2tgIG9iamVjdCwgd2hpY2ggbm90aWZpZXMgY2FsbGVycyB3aXRoIHByb2dyZXNzXG4gKiB1cGRhdGVzLCBhbmQgY29tcGxldGlvbiBvciBlcnJvciBldmVudHMuIEl0IGNhbiBiZSB1c2VkIGFzIGFcbiAqIGBQcm9taXNlPExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3M+YC5cbiAqL1xuZnVuY3Rpb24gbG9hZEJ1bmRsZShmaXJlc3RvcmUsIGJ1bmRsZURhdGEpIHtcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgY29uc3QgcmVzdWx0VGFzayA9IG5ldyBMb2FkQnVuZGxlVGFzaygpO1xuICAgIGZpcmVzdG9yZUNsaWVudExvYWRCdW5kbGUoY2xpZW50LCBmaXJlc3RvcmUuX2RhdGFiYXNlSWQsIGJ1bmRsZURhdGEsIHJlc3VsdFRhc2spO1xuICAgIHJldHVybiByZXN1bHRUYXNrO1xufVxuLyoqXG4gKiBSZWFkcyBhIEZpcmVzdG9yZSB7QGxpbmsgUXVlcnl9IGZyb20gbG9jYWwgY2FjaGUsIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuXG4gKiBuYW1lLlxuICpcbiAqIFRoZSBuYW1lZCBxdWVyaWVzIGFyZSBwYWNrYWdlZCAgaW50byBidW5kbGVzIG9uIHRoZSBzZXJ2ZXIgc2lkZSAoYWxvbmdcbiAqIHdpdGggcmVzdWx0aW5nIGRvY3VtZW50cyksIGFuZCBsb2FkZWQgdG8gbG9jYWwgY2FjaGUgdXNpbmcgYGxvYWRCdW5kbGVgLiBPbmNlXG4gKiBpbiBsb2NhbCBjYWNoZSwgdXNlIHRoaXMgbWV0aG9kIHRvIGV4dHJhY3QgYSB7QGxpbmsgUXVlcnl9IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIGZpcmVzdG9yZSAtIFRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSB0byByZWFkIHRoZSBxdWVyeSBmcm9tLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcXVlcnkuXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IGlzIHJlc29sdmVkIHdpdGggdGhlIFF1ZXJ5IG9yIGBudWxsYC5cbiAqL1xuZnVuY3Rpb24gbmFtZWRRdWVyeShmaXJlc3RvcmUsIG5hbWUpIHtcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEdldE5hbWVkUXVlcnkoY2xpZW50LCBuYW1lKS50aGVuKG5hbWVkUXVlcnkgPT4ge1xuICAgICAgICBpZiAoIW5hbWVkUXVlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkoZmlyZXN0b3JlLCBudWxsLCBuYW1lZFF1ZXJ5LnF1ZXJ5KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIEFnZ3JlZ2F0ZSB0eXBlLlxuICovXG5jbGFzcyBBZ2dyZWdhdGVJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihhbGlhcywgYWdncmVnYXRlVHlwZSwgZmllbGRQYXRoKSB7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVUeXBlID0gYWdncmVnYXRlVHlwZTtcbiAgICAgICAgdGhpcy5maWVsZFBhdGggPSBmaWVsZFBhdGg7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBpbW11dGFibGUgb2JqZWN0IHJlcHJlc2VudGluZyBhbiBhcnJheSBvZiBieXRlcy5cbiAqL1xuY2xhc3MgQnl0ZXMge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoYnl0ZVN0cmluZykge1xuICAgICAgICB0aGlzLl9ieXRlU3RyaW5nID0gYnl0ZVN0cmluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgQnl0ZXNgIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBCYXNlNjQgc3RyaW5nLCBjb252ZXJ0aW5nIGl0IHRvXG4gICAgICogYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmFzZTY0IC0gVGhlIEJhc2U2NCBzdHJpbmcgdXNlZCB0byBjcmVhdGUgdGhlIGBCeXRlc2Agb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQmFzZTY0U3RyaW5nKGJhc2U2NCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCeXRlcyhCeXRlU3RyaW5nLmZyb21CYXNlNjRTdHJpbmcoYmFzZTY0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdGYWlsZWQgdG8gY29uc3RydWN0IGRhdGEgZnJvbSBCYXNlNjQgc3RyaW5nOiAnICsgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgQnl0ZXNgIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBVaW50OEFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFycmF5IC0gVGhlIFVpbnQ4QXJyYXkgdXNlZCB0byBjcmVhdGUgdGhlIGBCeXRlc2Agb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVWludDhBcnJheShhcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IEJ5dGVzKEJ5dGVTdHJpbmcuZnJvbVVpbnQ4QXJyYXkoYXJyYXkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBieXRlcyBhcyBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBCYXNlNjQtZW5jb2RlZCBzdHJpbmcgY3JlYXRlZCBmcm9tIHRoZSBgQnl0ZXNgIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b0Jhc2U2NCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVTdHJpbmcudG9CYXNlNjQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBieXRlcyBpbiBhIG5ldyBgVWludDhBcnJheWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVWludDhBcnJheSBjcmVhdGVkIGZyb20gdGhlIGBCeXRlc2Agb2JqZWN0LlxuICAgICAqL1xuICAgIHRvVWludDhBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVTdHJpbmcudG9VaW50OEFycmF5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGBCeXRlc2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGBCeXRlc2Agb2JqZWN0LlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ0J5dGVzKGJhc2U2NDogJyArIHRoaXMudG9CYXNlNjQoKSArICcpJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYEJ5dGVzYCBvYmplY3QgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBgQnl0ZXNgIG9iamVjdCB0byBjb21wYXJlIGFnYWluc3QuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGBCeXRlc2Agb2JqZWN0IGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICovXG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZVN0cmluZy5pc0VxdWFsKG90aGVyLl9ieXRlU3RyaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgYEJ5dGVzYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBCeXRlcy5fanNvblNjaGVtYVZlcnNpb24sXG4gICAgICAgICAgICBieXRlczogdGhpcy50b0Jhc2U2NCgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIGBCeXRlc2AgaW5zdGFuY2UgZnJvbSBhIEpTT04gb2JqZWN0IGNyZWF0ZWQgYnkge0BsaW5rIEJ5dGVzLnRvSlNPTn0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ganNvbiAtIGEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW9uIG9mIGEgYEJ5dGVzYCBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIGFuIGluc3RhbmNlIG9mIHtAbGluayBCeXRlc30gaWYgdGhlIEpTT04gb2JqZWN0IGNvdWxkIGJlIHBhcnNlZC4gVGhyb3dzIGFcbiAgICAgKiB7QGxpbmsgRmlyZXN0b3JlRXJyb3J9IGlmIGFuIGVycm9yIG9jY3Vycy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAodmFsaWRhdGVKU09OKGpzb24sIEJ5dGVzLl9qc29uU2NoZW1hKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJ5dGVzLmZyb21CYXNlNjRTdHJpbmcoanNvbi5ieXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5CeXRlcy5fanNvblNjaGVtYVZlcnNpb24gPSAnZmlyZXN0b3JlL2J5dGVzLzEuMCc7XG5CeXRlcy5fanNvblNjaGVtYSA9IHtcbiAgICB0eXBlOiBwcm9wZXJ0eSgnc3RyaW5nJywgQnl0ZXMuX2pzb25TY2hlbWFWZXJzaW9uKSxcbiAgICBieXRlczogcHJvcGVydHkoJ3N0cmluZycpXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGBGaWVsZFBhdGhgIHJlZmVycyB0byBhIGZpZWxkIGluIGEgZG9jdW1lbnQuIFRoZSBwYXRoIG1heSBjb25zaXN0IG9mIGFcbiAqIHNpbmdsZSBmaWVsZCBuYW1lIChyZWZlcnJpbmcgdG8gYSB0b3AtbGV2ZWwgZmllbGQgaW4gdGhlIGRvY3VtZW50KSwgb3IgYVxuICogbGlzdCBvZiBmaWVsZCBuYW1lcyAocmVmZXJyaW5nIHRvIGEgbmVzdGVkIGZpZWxkIGluIHRoZSBkb2N1bWVudCkuXG4gKlxuICogQ3JlYXRlIGEgYEZpZWxkUGF0aGAgYnkgcHJvdmlkaW5nIGZpZWxkIG5hbWVzLiBJZiBtb3JlIHRoYW4gb25lIGZpZWxkXG4gKiBuYW1lIGlzIHByb3ZpZGVkLCB0aGUgcGF0aCB3aWxsIHBvaW50IHRvIGEgbmVzdGVkIGZpZWxkIGluIGEgZG9jdW1lbnQuXG4gKi9cbmNsYXNzIEZpZWxkUGF0aCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBGaWVsZFBhdGhgIGZyb20gdGhlIHByb3ZpZGVkIGZpZWxkIG5hbWVzLiBJZiBtb3JlIHRoYW4gb25lIGZpZWxkXG4gICAgICogbmFtZSBpcyBwcm92aWRlZCwgdGhlIHBhdGggd2lsbCBwb2ludCB0byBhIG5lc3RlZCBmaWVsZCBpbiBhIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpZWxkTmFtZXMgLSBBIGxpc3Qgb2YgZmllbGQgbmFtZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoLi4uZmllbGROYW1lcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWVzW2ldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIGZpZWxkIG5hbWUgYXQgYXJndW1lbnQgJChpICsgMSkuIGAgK1xuICAgICAgICAgICAgICAgICAgICAnRmllbGQgbmFtZXMgbXVzdCBub3QgYmUgZW1wdHkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJuYWxQYXRoID0gbmV3IEZpZWxkUGF0aCQxKGZpZWxkTmFtZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgRmllbGRQYXRoYCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG90aGVyIC0gVGhlIGBGaWVsZFBhdGhgIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYEZpZWxkUGF0aGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKi9cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFBhdGguaXNFcXVhbChvdGhlci5faW50ZXJuYWxQYXRoKTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgYSBzcGVjaWFsIHNlbnRpbmVsIGBGaWVsZFBhdGhgIHRvIHJlZmVyIHRvIHRoZSBJRCBvZiBhIGRvY3VtZW50LlxuICogSXQgY2FuIGJlIHVzZWQgaW4gcXVlcmllcyB0byBzb3J0IG9yIGZpbHRlciBieSB0aGUgZG9jdW1lbnQgSUQuXG4gKi9cbmZ1bmN0aW9uIGRvY3VtZW50SWQoKSB7XG4gICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgoRE9DVU1FTlRfS0VZX05BTUUpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBTZW50aW5lbCB2YWx1ZXMgdGhhdCBjYW4gYmUgdXNlZCB3aGVuIHdyaXRpbmcgZG9jdW1lbnQgZmllbGRzIHdpdGggYHNldCgpYFxuICogb3IgYHVwZGF0ZSgpYC5cbiAqL1xuY2xhc3MgRmllbGRWYWx1ZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIF9tZXRob2ROYW1lIC0gVGhlIHB1YmxpYyBBUEkgZW5kcG9pbnQgdGhhdCByZXR1cm5zIHRoaXMgY2xhc3MuXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9tZXRob2ROYW1lKSB7XG4gICAgICAgIHRoaXMuX21ldGhvZE5hbWUgPSBfbWV0aG9kTmFtZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGltbXV0YWJsZSBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ2VvZ3JhcGhpYyBsb2NhdGlvbiBpbiBGaXJlc3RvcmUuIFRoZVxuICogbG9jYXRpb24gaXMgcmVwcmVzZW50ZWQgYXMgbGF0aXR1ZGUvbG9uZ2l0dWRlIHBhaXIuXG4gKlxuICogTGF0aXR1ZGUgdmFsdWVzIGFyZSBpbiB0aGUgcmFuZ2Ugb2YgWy05MCwgOTBdLlxuICogTG9uZ2l0dWRlIHZhbHVlcyBhcmUgaW4gdGhlIHJhbmdlIG9mIFstMTgwLCAxODBdLlxuICovXG5jbGFzcyBHZW9Qb2ludCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbW11dGFibGUgYEdlb1BvaW50YCBvYmplY3Qgd2l0aCB0aGUgcHJvdmlkZWQgbGF0aXR1ZGUgYW5kXG4gICAgICogbG9uZ2l0dWRlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gbGF0aXR1ZGUgLSBUaGUgbGF0aXR1ZGUgYXMgbnVtYmVyIGJldHdlZW4gLTkwIGFuZCA5MC5cbiAgICAgKiBAcGFyYW0gbG9uZ2l0dWRlIC0gVGhlIGxvbmdpdHVkZSBhcyBudW1iZXIgYmV0d2VlbiAtMTgwIGFuZCAxODAuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGF0aXR1ZGUsIGxvbmdpdHVkZSkge1xuICAgICAgICBpZiAoIWlzRmluaXRlKGxhdGl0dWRlKSB8fCBsYXRpdHVkZSA8IC05MCB8fCBsYXRpdHVkZSA+IDkwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnTGF0aXR1ZGUgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIC05MCBhbmQgOTAsIGJ1dCB3YXM6ICcgKyBsYXRpdHVkZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0Zpbml0ZShsb25naXR1ZGUpIHx8IGxvbmdpdHVkZSA8IC0xODAgfHwgbG9uZ2l0dWRlID4gMTgwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnTG9uZ2l0dWRlIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAtMTgwIGFuZCAxODAsIGJ1dCB3YXM6ICcgKyBsb25naXR1ZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhdCA9IGxhdGl0dWRlO1xuICAgICAgICB0aGlzLl9sb25nID0gbG9uZ2l0dWRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbGF0aXR1ZGUgb2YgdGhpcyBgR2VvUG9pbnRgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldCBsYXRpdHVkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxvbmdpdHVkZSBvZiB0aGlzIGBHZW9Qb2ludGAgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZ2V0IGxvbmdpdHVkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGBHZW9Qb2ludGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBgR2VvUG9pbnRgIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYEdlb1BvaW50YCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxuICAgICAqL1xuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhdCA9PT0gb3RoZXIuX2xhdCAmJiB0aGlzLl9sb25nID09PSBvdGhlci5fbG9uZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWN0dWFsbHkgcHJpdmF0ZSB0byBKUyBjb25zdW1lcnMgb2Ygb3VyIEFQSSwgc28gdGhpcyBmdW5jdGlvbiBpcyBwcmVmaXhlZFxuICAgICAqIHdpdGggYW4gdW5kZXJzY29yZS5cbiAgICAgKi9cbiAgICBfY29tcGFyZVRvKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAocHJpbWl0aXZlQ29tcGFyYXRvcih0aGlzLl9sYXQsIG90aGVyLl9sYXQpIHx8XG4gICAgICAgICAgICBwcmltaXRpdmVDb21wYXJhdG9yKHRoaXMuX2xvbmcsIG90aGVyLl9sb25nKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGBHZW9Qb2ludGAgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGF0aXR1ZGU6IHRoaXMuX2xhdCxcbiAgICAgICAgICAgIGxvbmdpdHVkZTogdGhpcy5fbG9uZyxcbiAgICAgICAgICAgIHR5cGU6IEdlb1BvaW50Ll9qc29uU2NoZW1hVmVyc2lvblxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYSBgR2VvUG9pbnRgIGluc3RhbmNlIGZyb20gYSBKU09OIG9iamVjdCBjcmVhdGVkIGJ5IHtAbGluayBHZW9Qb2ludC50b0pTT059LlxuICAgICAqXG4gICAgICogQHBhcmFtIGpzb24gLSBhIEpTT04gb2JqZWN0IHJlcHJlc2VudGlvbiBvZiBhIGBHZW9Qb2ludGAgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgR2VvUG9pbnR9IGlmIHRoZSBKU09OIG9iamVjdCBjb3VsZCBiZSBwYXJzZWQuIFRocm93cyBhXG4gICAgICoge0BsaW5rIEZpcmVzdG9yZUVycm9yfSBpZiBhbiBlcnJvciBvY2N1cnMuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKHZhbGlkYXRlSlNPTihqc29uLCBHZW9Qb2ludC5fanNvblNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgR2VvUG9pbnQoanNvbi5sYXRpdHVkZSwganNvbi5sb25naXR1ZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuR2VvUG9pbnQuX2pzb25TY2hlbWFWZXJzaW9uID0gJ2ZpcmVzdG9yZS9nZW9Qb2ludC8xLjAnO1xuR2VvUG9pbnQuX2pzb25TY2hlbWEgPSB7XG4gICAgdHlwZTogcHJvcGVydHkoJ3N0cmluZycsIEdlb1BvaW50Ll9qc29uU2NoZW1hVmVyc2lvbiksXG4gICAgbGF0aXR1ZGU6IHByb3BlcnR5KCdudW1iZXInKSxcbiAgICBsb25naXR1ZGU6IHByb3BlcnR5KCdudW1iZXInKVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmVwcmVzZW50cyBhIHZlY3RvciB0eXBlIGluIEZpcmVzdG9yZSBkb2N1bWVudHMuXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugd2l0aCA8Y29kZT57QGxpbmsgdmVjdG9yfTwvY29kZT4uXG4gKi9cbmNsYXNzIFZlY3RvclZhbHVlIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgICAgICAvLyBNYWtpbmcgYSBjb3B5IG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9ICh2YWx1ZXMgfHwgW10pLm1hcChuID0+IG4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgcmF3IG51bWJlciBhcnJheSBmb3JtIG9mIHRoZSB2ZWN0b3IuXG4gICAgICovXG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5tYXAobiA9PiBuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHR3byBgVmVjdG9yVmFsdWVgIHZhbHVlcyBoYXZlIHRoZSBzYW1lIHJhdyBudW1iZXIgYXJyYXlzLCByZXR1cm5zIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGlzUHJpbWl0aXZlQXJyYXlFcXVhbCh0aGlzLl92YWx1ZXMsIG90aGVyLl92YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBgVmVjdG9yVmFsdWVgIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFZlY3RvclZhbHVlLl9qc29uU2NoZW1hVmVyc2lvbixcbiAgICAgICAgICAgIHZlY3RvclZhbHVlczogdGhpcy5fdmFsdWVzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIGBWZWN0b3JWYWx1ZWAgaW5zdGFuY2UgZnJvbSBhIEpTT04gb2JqZWN0IGNyZWF0ZWQgYnkge0BsaW5rIFZlY3RvclZhbHVlLnRvSlNPTn0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ganNvbiAtIGEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW9uIG9mIGEgYFZlY3RvclZhbHVlYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgVmVjdG9yVmFsdWV9IGlmIHRoZSBKU09OIG9iamVjdCBjb3VsZCBiZSBwYXJzZWQuIFRocm93cyBhXG4gICAgICoge0BsaW5rIEZpcmVzdG9yZUVycm9yfSBpZiBhbiBlcnJvciBvY2N1cnMuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKHZhbGlkYXRlSlNPTihqc29uLCBWZWN0b3JWYWx1ZS5fanNvblNjaGVtYSkpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24udmVjdG9yVmFsdWVzKSAmJlxuICAgICAgICAgICAgICAgIGpzb24udmVjdG9yVmFsdWVzLmV2ZXJ5KGVsZW1lbnQgPT4gdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yVmFsdWUoanNvbi52ZWN0b3JWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgXCJFeHBlY3RlZCAndmVjdG9yVmFsdWVzJyBmaWVsZCB0byBiZSBhIG51bWJlciBhcnJheVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblZlY3RvclZhbHVlLl9qc29uU2NoZW1hVmVyc2lvbiA9ICdmaXJlc3RvcmUvdmVjdG9yVmFsdWUvMS4wJztcblZlY3RvclZhbHVlLl9qc29uU2NoZW1hID0ge1xuICAgIHR5cGU6IHByb3BlcnR5KCdzdHJpbmcnLCBWZWN0b3JWYWx1ZS5fanNvblNjaGVtYVZlcnNpb24pLFxuICAgIHZlY3RvclZhbHVlczogcHJvcGVydHkoJ29iamVjdCcpXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgUkVTRVJWRURfRklFTERfUkVHRVggPSAvXl9fLipfXyQvO1xuLyoqIFRoZSByZXN1bHQgb2YgcGFyc2luZyBkb2N1bWVudCBkYXRhIChlLmcuIGZvciBhIHNldERhdGEgY2FsbCkuICovXG5jbGFzcyBQYXJzZWRTZXREYXRhIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBmaWVsZE1hc2ssIGZpZWxkVHJhbnNmb3Jtcykge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmZpZWxkTWFzayA9IGZpZWxkTWFzaztcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXM7XG4gICAgfVxuICAgIHRvTXV0YXRpb24oa2V5LCBwcmVjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuZmllbGRNYXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhdGNoTXV0YXRpb24oa2V5LCB0aGlzLmRhdGEsIHRoaXMuZmllbGRNYXNrLCBwcmVjb25kaXRpb24sIHRoaXMuZmllbGRUcmFuc2Zvcm1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0TXV0YXRpb24oa2V5LCB0aGlzLmRhdGEsIHByZWNvbmRpdGlvbiwgdGhpcy5maWVsZFRyYW5zZm9ybXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqIFRoZSByZXN1bHQgb2YgcGFyc2luZyBcInVwZGF0ZVwiIGRhdGEgKGkuZS4gZm9yIGFuIHVwZGF0ZURhdGEgY2FsbCkuICovXG5jbGFzcyBQYXJzZWRVcGRhdGVEYXRhIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBcbiAgICAvLyBUaGUgZmllbGRNYXNrIGRvZXMgbm90IGluY2x1ZGUgZG9jdW1lbnQgdHJhbnNmb3Jtcy5cbiAgICBmaWVsZE1hc2ssIGZpZWxkVHJhbnNmb3Jtcykge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmZpZWxkTWFzayA9IGZpZWxkTWFzaztcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXM7XG4gICAgfVxuICAgIHRvTXV0YXRpb24oa2V5LCBwcmVjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXRjaE11dGF0aW9uKGtleSwgdGhpcy5kYXRhLCB0aGlzLmZpZWxkTWFzaywgcHJlY29uZGl0aW9uLCB0aGlzLmZpZWxkVHJhbnNmb3Jtcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNXcml0ZShkYXRhU291cmNlKSB7XG4gICAgc3dpdGNoIChkYXRhU291cmNlKSB7XG4gICAgICAgIGNhc2UgMCAvKiBVc2VyRGF0YVNvdXJjZS5TZXQgKi86IC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICBjYXNlIDIgLyogVXNlckRhdGFTb3VyY2UuTWVyZ2VTZXQgKi86IC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICBjYXNlIDEgLyogVXNlckRhdGFTb3VyY2UuVXBkYXRlICovOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgMyAvKiBVc2VyRGF0YVNvdXJjZS5Bcmd1bWVudCAqLzpcbiAgICAgICAgY2FzZSA0IC8qIFVzZXJEYXRhU291cmNlLkFycmF5QXJndW1lbnQgKi86XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBmYWlsKDB4OWM0Yiwge1xuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2VcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBBIFwiY29udGV4dFwiIG9iamVjdCBwYXNzZWQgYXJvdW5kIHdoaWxlIHBhcnNpbmcgdXNlciBkYXRhLiAqL1xuY2xhc3MgUGFyc2VDb250ZXh0SW1wbCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBQYXJzZUNvbnRleHQgd2l0aCB0aGUgZ2l2ZW4gc291cmNlIGFuZCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNldHRpbmdzIC0gVGhlIHNldHRpbmdzIGZvciB0aGUgcGFyc2VyLlxuICAgICAqIEBwYXJhbSBkYXRhYmFzZUlkIC0gVGhlIGRhdGFiYXNlIElEIG9mIHRoZSBGaXJlc3RvcmUgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHNlcmlhbGl6ZXIgLSBUaGUgc2VyaWFsaXplciB0byB1c2UgdG8gZ2VuZXJhdGUgdGhlIFZhbHVlIHByb3RvLlxuICAgICAqIEBwYXJhbSBpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzIC0gV2hldGhlciB0byBpZ25vcmUgdW5kZWZpbmVkIHByb3BlcnRpZXNcbiAgICAgKiByYXRoZXIgdGhhbiB0aHJvdy5cbiAgICAgKiBAcGFyYW0gZmllbGRUcmFuc2Zvcm1zIC0gQSBtdXRhYmxlIGxpc3Qgb2YgZmllbGQgdHJhbnNmb3JtcyBlbmNvdW50ZXJlZFxuICAgICAqIHdoaWxlIHBhcnNpbmcgdGhlIGRhdGEuXG4gICAgICogQHBhcmFtIGZpZWxkTWFzayAtIEEgbXV0YWJsZSBsaXN0IG9mIGZpZWxkIHBhdGhzIGVuY291bnRlcmVkIHdoaWxlIHBhcnNpbmdcbiAgICAgKiB0aGUgZGF0YS5cbiAgICAgKlxuICAgICAqIFRPRE8oYi8zNDg3MTEzMSk6IFdlIGRvbid0IHN1cHBvcnQgYXJyYXkgcGF0aHMgcmlnaHQgbm93LCBzbyBwYXRoIGNhbiBiZVxuICAgICAqIG51bGwgdG8gaW5kaWNhdGUgdGhlIGNvbnRleHQgcmVwcmVzZW50cyBhbnkgbG9jYXRpb24gd2l0aGluIGFuIGFycmF5IChpblxuICAgICAqIHdoaWNoIGNhc2UgY2VydGFpbiBmZWF0dXJlcyB3aWxsIG5vdCB3b3JrIGFuZCBlcnJvcnMgd2lsbCBiZSBzb21ld2hhdFxuICAgICAqIGNvbXByb21pc2VkKS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncywgZGF0YWJhc2VJZCwgc2VyaWFsaXplciwgaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcywgZmllbGRUcmFuc2Zvcm1zLCBmaWVsZE1hc2spIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBkYXRhYmFzZUlkO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgPSBpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzO1xuICAgICAgICAvLyBNaW5vciBoYWNrOiBJZiBmaWVsZFRyYW5zZm9ybXMgaXMgdW5kZWZpbmVkLCB3ZSBhc3N1bWUgdGhpcyBpcyBhblxuICAgICAgICAvLyBleHRlcm5hbCBjYWxsIGFuZCB3ZSBuZWVkIHRvIHZhbGlkYXRlIHRoZSBlbnRpcmUgcGF0aC5cbiAgICAgICAgaWYgKGZpZWxkVHJhbnNmb3JtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gZmllbGRUcmFuc2Zvcm1zIHx8IFtdO1xuICAgICAgICB0aGlzLmZpZWxkTWFzayA9IGZpZWxkTWFzayB8fCBbXTtcbiAgICB9XG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnBhdGg7XG4gICAgfVxuICAgIGdldCBkYXRhU291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5kYXRhU291cmNlO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIG5ldyBjb250ZXh0IHdpdGggdGhlIHNwZWNpZmllZCBzZXR0aW5ncyBvdmVyd3JpdHRlbi4gKi9cbiAgICBjb250ZXh0V2l0aChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0SW1wbCh7IC4uLnRoaXMuc2V0dGluZ3MsIC4uLmNvbmZpZ3VyYXRpb24gfSwgdGhpcy5kYXRhYmFzZUlkLCB0aGlzLnNlcmlhbGl6ZXIsIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcywgdGhpcy5maWVsZFRyYW5zZm9ybXMsIHRoaXMuZmllbGRNYXNrKTtcbiAgICB9XG4gICAgY2hpbGRDb250ZXh0Rm9yRmllbGQoZmllbGQpIHtcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gdGhpcy5wYXRoPy5jaGlsZChmaWVsZCk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRXaXRoKHsgcGF0aDogY2hpbGRQYXRoLCBhcnJheUVsZW1lbnQ6IGZhbHNlIH0pO1xuICAgICAgICBjb250ZXh0LnZhbGlkYXRlUGF0aFNlZ21lbnQoZmllbGQpO1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgY2hpbGRDb250ZXh0Rm9yRmllbGRQYXRoKGZpZWxkKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHRoaXMucGF0aD8uY2hpbGQoZmllbGQpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0V2l0aCh7IHBhdGg6IGNoaWxkUGF0aCwgYXJyYXlFbGVtZW50OiBmYWxzZSB9KTtcbiAgICAgICAgY29udGV4dC52YWxpZGF0ZVBhdGgoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIGNoaWxkQ29udGV4dEZvckFycmF5KGluZGV4KSB7XG4gICAgICAgIC8vIFRPRE8oYi8zNDg3MTEzMSk6IFdlIGRvbid0IHN1cHBvcnQgYXJyYXkgcGF0aHMgcmlnaHQgbm93OyBzbyBtYWtlIHBhdGhcbiAgICAgICAgLy8gdW5kZWZpbmVkLlxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0V2l0aCh7IHBhdGg6IHVuZGVmaW5lZCwgYXJyYXlFbGVtZW50OiB0cnVlIH0pO1xuICAgIH1cbiAgICBjcmVhdGVFcnJvcihyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVycm9yKHJlYXNvbiwgdGhpcy5zZXR0aW5ncy5tZXRob2ROYW1lLCB0aGlzLnNldHRpbmdzLmhhc0NvbnZlcnRlciB8fCBmYWxzZSwgdGhpcy5wYXRoLCB0aGlzLnNldHRpbmdzLnRhcmdldERvYyk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zICd0cnVlJyBpZiAnZmllbGRQYXRoJyB3YXMgdHJhdmVyc2VkIHdoZW4gY3JlYXRpbmcgdGhpcyBjb250ZXh0LiAqL1xuICAgIGNvbnRhaW5zKGZpZWxkUGF0aCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmllbGRNYXNrLmZpbmQoZmllbGQgPT4gZmllbGRQYXRoLmlzUHJlZml4T2YoZmllbGQpKSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3Jtcy5maW5kKHRyYW5zZm9ybSA9PiBmaWVsZFBhdGguaXNQcmVmaXhPZih0cmFuc2Zvcm0uZmllbGQpKSAhPT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgdmFsaWRhdGVQYXRoKCkge1xuICAgICAgICAvLyBUT0RPKGIvMzQ4NzExMzEpOiBSZW1vdmUgbnVsbCBjaGVjayBvbmNlIHdlIGhhdmUgcHJvcGVyIHBhdGhzIGZvciBmaWVsZHNcbiAgICAgICAgLy8gd2l0aGluIGFycmF5cy5cbiAgICAgICAgaWYgKCF0aGlzLnBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBhdGhTZWdtZW50KHRoaXMucGF0aC5nZXQoaSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbGlkYXRlUGF0aFNlZ21lbnQoc2VnbWVudCkge1xuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IoJ0RvY3VtZW50IGZpZWxkcyBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1dyaXRlKHRoaXMuZGF0YVNvdXJjZSkgJiYgUkVTRVJWRURfRklFTERfUkVHRVgudGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcignRG9jdW1lbnQgZmllbGRzIGNhbm5vdCBiZWdpbiBhbmQgZW5kIHdpdGggXCJfX1wiJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciBmb3IgcGFyc2luZyByYXcgdXNlciBpbnB1dCAocHJvdmlkZWQgdmlhIHRoZSBBUEkpIGludG8gaW50ZXJuYWwgbW9kZWxcbiAqIGNsYXNzZXMuXG4gKi9cbmNsYXNzIFVzZXJEYXRhUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhYmFzZUlkLCBpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzLCBzZXJpYWxpemVyKSB7XG4gICAgICAgIHRoaXMuZGF0YWJhc2VJZCA9IGRhdGFiYXNlSWQ7XG4gICAgICAgIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyA9IGlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXIgfHwgbmV3U2VyaWFsaXplcihkYXRhYmFzZUlkKTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgdG9wLWxldmVsIHBhcnNlIGNvbnRleHQuICovXG4gICAgY3JlYXRlQ29udGV4dChkYXRhU291cmNlLCBtZXRob2ROYW1lLCB0YXJnZXREb2MsIGhhc0NvbnZlcnRlciA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0SW1wbCh7XG4gICAgICAgICAgICBkYXRhU291cmNlLFxuICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgIHRhcmdldERvYyxcbiAgICAgICAgICAgIHBhdGg6IEZpZWxkUGF0aCQxLmVtcHR5UGF0aCgpLFxuICAgICAgICAgICAgYXJyYXlFbGVtZW50OiBmYWxzZSxcbiAgICAgICAgICAgIGhhc0NvbnZlcnRlclxuICAgICAgICB9LCB0aGlzLmRhdGFiYXNlSWQsIHRoaXMuc2VyaWFsaXplciwgdGhpcy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdVc2VyRGF0YVJlYWRlcihmaXJlc3RvcmUpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IGZpcmVzdG9yZS5fZnJlZXplU2V0dGluZ3MoKTtcbiAgICBjb25zdCBzZXJpYWxpemVyID0gbmV3U2VyaWFsaXplcihmaXJlc3RvcmUuX2RhdGFiYXNlSWQpO1xuICAgIHJldHVybiBuZXcgVXNlckRhdGFSZWFkZXIoZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCAhIXNldHRpbmdzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMsIHNlcmlhbGl6ZXIpO1xufVxuLyoqIFBhcnNlIGRvY3VtZW50IGRhdGEgZnJvbSBhIHNldCgpIGNhbGwuICovXG5mdW5jdGlvbiBwYXJzZVNldERhdGEodXNlckRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIHRhcmdldERvYywgaW5wdXQsIGhhc0NvbnZlcnRlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZXJEYXRhUmVhZGVyLmNyZWF0ZUNvbnRleHQob3B0aW9ucy5tZXJnZSB8fCBvcHRpb25zLm1lcmdlRmllbGRzXG4gICAgICAgID8gMiAvKiBVc2VyRGF0YVNvdXJjZS5NZXJnZVNldCAqL1xuICAgICAgICA6IDAgLyogVXNlckRhdGFTb3VyY2UuU2V0ICovLCBtZXRob2ROYW1lLCB0YXJnZXREb2MsIGhhc0NvbnZlcnRlcik7XG4gICAgdmFsaWRhdGVQbGFpbk9iamVjdCgnRGF0YSBtdXN0IGJlIGFuIG9iamVjdCwgYnV0IGl0IHdhczonLCBjb250ZXh0LCBpbnB1dCk7XG4gICAgY29uc3QgdXBkYXRlRGF0YSA9IHBhcnNlT2JqZWN0KGlucHV0LCBjb250ZXh0KTtcbiAgICBsZXQgZmllbGRNYXNrO1xuICAgIGxldCBmaWVsZFRyYW5zZm9ybXM7XG4gICAgaWYgKG9wdGlvbnMubWVyZ2UpIHtcbiAgICAgICAgZmllbGRNYXNrID0gbmV3IEZpZWxkTWFzayhjb250ZXh0LmZpZWxkTWFzayk7XG4gICAgICAgIGZpZWxkVHJhbnNmb3JtcyA9IGNvbnRleHQuZmllbGRUcmFuc2Zvcm1zO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLm1lcmdlRmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZEZpZWxkUGF0aHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzdHJpbmdPckZpZWxkUGF0aCBvZiBvcHRpb25zLm1lcmdlRmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFBhdGggPSBmaWVsZFBhdGhGcm9tQXJndW1lbnQobWV0aG9kTmFtZSwgc3RyaW5nT3JGaWVsZFBhdGgsIHRhcmdldERvYyk7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuY29udGFpbnMoZmllbGRQYXRoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBGaWVsZCAnJHtmaWVsZFBhdGh9JyBpcyBzcGVjaWZpZWQgaW4geW91ciBmaWVsZCBtYXNrIGJ1dCBtaXNzaW5nIGZyb20geW91ciBpbnB1dCBkYXRhLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmaWVsZE1hc2tDb250YWlucyh2YWxpZGF0ZWRGaWVsZFBhdGhzLCBmaWVsZFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVkRmllbGRQYXRocy5wdXNoKGZpZWxkUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRNYXNrID0gbmV3IEZpZWxkTWFzayh2YWxpZGF0ZWRGaWVsZFBhdGhzKTtcbiAgICAgICAgZmllbGRUcmFuc2Zvcm1zID0gY29udGV4dC5maWVsZFRyYW5zZm9ybXMuZmlsdGVyKHRyYW5zZm9ybSA9PiBmaWVsZE1hc2suY292ZXJzKHRyYW5zZm9ybS5maWVsZCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmllbGRNYXNrID0gbnVsbDtcbiAgICAgICAgZmllbGRUcmFuc2Zvcm1zID0gY29udGV4dC5maWVsZFRyYW5zZm9ybXM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUGFyc2VkU2V0RGF0YShuZXcgT2JqZWN0VmFsdWUodXBkYXRlRGF0YSksIGZpZWxkTWFzaywgZmllbGRUcmFuc2Zvcm1zKTtcbn1cbmNsYXNzIERlbGV0ZUZpZWxkVmFsdWVJbXBsIGV4dGVuZHMgRmllbGRWYWx1ZSB7XG4gICAgX3RvRmllbGRUcmFuc2Zvcm0oY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dC5kYXRhU291cmNlID09PSAyIC8qIFVzZXJEYXRhU291cmNlLk1lcmdlU2V0ICovKSB7XG4gICAgICAgICAgICAvLyBObyB0cmFuc2Zvcm0gdG8gYWRkIGZvciBhIGRlbGV0ZSwgYnV0IHdlIG5lZWQgdG8gYWRkIGl0IHRvIG91clxuICAgICAgICAgICAgLy8gZmllbGRNYXNrIHNvIGl0IGdldHMgZGVsZXRlZC5cbiAgICAgICAgICAgIGNvbnRleHQuZmllbGRNYXNrLnB1c2goY29udGV4dC5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZXh0LmRhdGFTb3VyY2UgPT09IDEgLyogVXNlckRhdGFTb3VyY2UuVXBkYXRlICovKSB7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGAke3RoaXMuX21ldGhvZE5hbWV9KCkgY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWwgYCArXG4gICAgICAgICAgICAgICAgJ29mIHlvdXIgdXBkYXRlIGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZG4ndCBlbmNvdW50ZXIgZGVsZXRlIHNlbnRpbmVscyBmb3IgcXVlcmllcyBvciBub24tbWVyZ2Ugc2V0KCkgY2FsbHMuXG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGAke3RoaXMuX21ldGhvZE5hbWV9KCkgY2Fubm90IGJlIHVzZWQgd2l0aCBzZXQoKSB1bmxlc3MgeW91IHBhc3MgYCArXG4gICAgICAgICAgICAgICAgJ3ttZXJnZTp0cnVlfScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIERlbGV0ZUZpZWxkVmFsdWVJbXBsO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIGNoaWxkIGNvbnRleHQgZm9yIHBhcnNpbmcgU2VyaWFsaXphYmxlRmllbGRWYWx1ZXMuXG4gKlxuICogVGhpcyBpcyBkaWZmZXJlbnQgdGhhbiBjYWxsaW5nIGBQYXJzZUNvbnRleHQuY29udGV4dFdpdGhgIGJlY2F1c2UgaXQga2VlcHNcbiAqIHRoZSBmaWVsZFRyYW5zZm9ybXMgYW5kIGZpZWxkTWFzayBzZXBhcmF0ZS5cbiAqXG4gKiBUaGUgY3JlYXRlZCBjb250ZXh0IGhhcyBpdHMgYGRhdGFTb3VyY2VgIHNldCB0byBgVXNlckRhdGFTb3VyY2UuQXJndW1lbnRgLlxuICogQWx0aG91Z2ggdGhlc2UgdmFsdWVzIGFyZSB1c2VkIHdpdGggd3JpdGVzLCBhbnkgZWxlbWVudHMgaW4gdGhlc2UgRmllbGRWYWx1ZXNcbiAqIGFyZSBub3QgY29uc2lkZXJlZCB3cml0ZXMgc2luY2UgdGhleSBjYW5ub3QgY29udGFpbiBhbnkgRmllbGRWYWx1ZSBzZW50aW5lbHMsXG4gKiBldGMuXG4gKlxuICogQHBhcmFtIGZpZWxkVmFsdWUgLSBUaGUgc2VudGluZWwgRmllbGRWYWx1ZSBmb3Igd2hpY2ggdG8gY3JlYXRlIGEgY2hpbGRcbiAqICAgICBjb250ZXh0LlxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgcGFyZW50IGNvbnRleHQuXG4gKiBAcGFyYW0gYXJyYXlFbGVtZW50IC0gV2hldGhlciBvciBub3QgdGhlIEZpZWxkVmFsdWUgaGFzIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiBjcmVhdGVTZW50aW5lbENoaWxkQ29udGV4dChmaWVsZFZhbHVlLCBjb250ZXh0LCBhcnJheUVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dEltcGwoe1xuICAgICAgICBkYXRhU291cmNlOiAzIC8qIFVzZXJEYXRhU291cmNlLkFyZ3VtZW50ICovLFxuICAgICAgICB0YXJnZXREb2M6IGNvbnRleHQuc2V0dGluZ3MudGFyZ2V0RG9jLFxuICAgICAgICBtZXRob2ROYW1lOiBmaWVsZFZhbHVlLl9tZXRob2ROYW1lLFxuICAgICAgICBhcnJheUVsZW1lbnRcbiAgICB9LCBjb250ZXh0LmRhdGFiYXNlSWQsIGNvbnRleHQuc2VyaWFsaXplciwgY29udGV4dC5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzKTtcbn1cbmNsYXNzIFNlcnZlclRpbWVzdGFtcEZpZWxkVmFsdWVJbXBsIGV4dGVuZHMgRmllbGRWYWx1ZSB7XG4gICAgX3RvRmllbGRUcmFuc2Zvcm0oY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkVHJhbnNmb3JtKGNvbnRleHQucGF0aCwgbmV3IFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSgpKTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBTZXJ2ZXJUaW1lc3RhbXBGaWVsZFZhbHVlSW1wbDtcbiAgICB9XG59XG5jbGFzcyBBcnJheVVuaW9uRmllbGRWYWx1ZUltcGwgZXh0ZW5kcyBGaWVsZFZhbHVlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lLCBfZWxlbWVudHMpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kTmFtZSk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzID0gX2VsZW1lbnRzO1xuICAgIH1cbiAgICBfdG9GaWVsZFRyYW5zZm9ybShjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlQ29udGV4dCA9IGNyZWF0ZVNlbnRpbmVsQ2hpbGRDb250ZXh0KHRoaXMsIGNvbnRleHQsIFxuICAgICAgICAvKmFycmF5PSovIHRydWUpO1xuICAgICAgICBjb25zdCBwYXJzZWRFbGVtZW50cyA9IHRoaXMuX2VsZW1lbnRzLm1hcChlbGVtZW50ID0+IHBhcnNlRGF0YShlbGVtZW50LCBwYXJzZUNvbnRleHQpKTtcbiAgICAgICAgY29uc3QgYXJyYXlVbmlvbiA9IG5ldyBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKHBhcnNlZEVsZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFRyYW5zZm9ybShjb250ZXh0LnBhdGgsIGFycmF5VW5pb24pO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBBcnJheVVuaW9uRmllbGRWYWx1ZUltcGwgJiZcbiAgICAgICAgICAgIGRlZXBFcXVhbCh0aGlzLl9lbGVtZW50cywgb3RoZXIuX2VsZW1lbnRzKSk7XG4gICAgfVxufVxuY2xhc3MgQXJyYXlSZW1vdmVGaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZE5hbWUsIF9lbGVtZW50cykge1xuICAgICAgICBzdXBlcihtZXRob2ROYW1lKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBfZWxlbWVudHM7XG4gICAgfVxuICAgIF90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VDb250ZXh0ID0gY3JlYXRlU2VudGluZWxDaGlsZENvbnRleHQodGhpcywgY29udGV4dCwgXG4gICAgICAgIC8qYXJyYXk9Ki8gdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZEVsZW1lbnRzID0gdGhpcy5fZWxlbWVudHMubWFwKGVsZW1lbnQgPT4gcGFyc2VEYXRhKGVsZW1lbnQsIHBhcnNlQ29udGV4dCkpO1xuICAgICAgICBjb25zdCBhcnJheVVuaW9uID0gbmV3IEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKHBhcnNlZEVsZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFRyYW5zZm9ybShjb250ZXh0LnBhdGgsIGFycmF5VW5pb24pO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBBcnJheVJlbW92ZUZpZWxkVmFsdWVJbXBsICYmXG4gICAgICAgICAgICBkZWVwRXF1YWwodGhpcy5fZWxlbWVudHMsIG90aGVyLl9lbGVtZW50cykpO1xuICAgIH1cbn1cbmNsYXNzIE51bWVyaWNJbmNyZW1lbnRGaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZE5hbWUsIF9vcGVyYW5kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZE5hbWUpO1xuICAgICAgICB0aGlzLl9vcGVyYW5kID0gX29wZXJhbmQ7XG4gICAgfVxuICAgIF90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgbnVtZXJpY0luY3JlbWVudCA9IG5ldyBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uKGNvbnRleHQuc2VyaWFsaXplciwgdG9OdW1iZXIoY29udGV4dC5zZXJpYWxpemVyLCB0aGlzLl9vcGVyYW5kKSk7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRUcmFuc2Zvcm0oY29udGV4dC5wYXRoLCBudW1lcmljSW5jcmVtZW50KTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKG90aGVyIGluc3RhbmNlb2YgTnVtZXJpY0luY3JlbWVudEZpZWxkVmFsdWVJbXBsICYmXG4gICAgICAgICAgICB0aGlzLl9vcGVyYW5kID09PSBvdGhlci5fb3BlcmFuZCk7XG4gICAgfVxufVxuLyoqIFBhcnNlIHVwZGF0ZSBkYXRhIGZyb20gYW4gdXBkYXRlKCkgY2FsbC4gKi9cbmZ1bmN0aW9uIHBhcnNlVXBkYXRlRGF0YSh1c2VyRGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jLCBpbnB1dCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VyRGF0YVJlYWRlci5jcmVhdGVDb250ZXh0KDEgLyogVXNlckRhdGFTb3VyY2UuVXBkYXRlICovLCBtZXRob2ROYW1lLCB0YXJnZXREb2MpO1xuICAgIHZhbGlkYXRlUGxhaW5PYmplY3QoJ0RhdGEgbXVzdCBiZSBhbiBvYmplY3QsIGJ1dCBpdCB3YXM6JywgY29udGV4dCwgaW5wdXQpO1xuICAgIGNvbnN0IGZpZWxkTWFza1BhdGhzID0gW107XG4gICAgY29uc3QgdXBkYXRlRGF0YSA9IE9iamVjdFZhbHVlLmVtcHR5KCk7XG4gICAgZm9yRWFjaChpbnB1dCwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcobWV0aG9kTmFtZSwga2V5LCB0YXJnZXREb2MpO1xuICAgICAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxuICAgICAgICAvLyBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXG4gICAgICAgIHZhbHVlID0gZ2V0TW9kdWxhckluc3RhbmNlKHZhbHVlKTtcbiAgICAgICAgY29uc3QgY2hpbGRDb250ZXh0ID0gY29udGV4dC5jaGlsZENvbnRleHRGb3JGaWVsZFBhdGgocGF0aCk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERlbGV0ZUZpZWxkVmFsdWVJbXBsKSB7XG4gICAgICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGZpZWxkIG1hc2ssIGJ1dCBkb24ndCBhZGQgYW55dGhpbmcgdG8gdXBkYXRlRGF0YS5cbiAgICAgICAgICAgIGZpZWxkTWFza1BhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlRGF0YSh2YWx1ZSwgY2hpbGRDb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZmllbGRNYXNrUGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVEYXRhLnNldChwYXRoLCBwYXJzZWRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBtYXNrID0gbmV3IEZpZWxkTWFzayhmaWVsZE1hc2tQYXRocyk7XG4gICAgcmV0dXJuIG5ldyBQYXJzZWRVcGRhdGVEYXRhKHVwZGF0ZURhdGEsIG1hc2ssIGNvbnRleHQuZmllbGRUcmFuc2Zvcm1zKTtcbn1cbi8qKiBQYXJzZSB1cGRhdGUgZGF0YSBmcm9tIGEgbGlzdCBvZiBmaWVsZC92YWx1ZSBhcmd1bWVudHMuICovXG5mdW5jdGlvbiBwYXJzZVVwZGF0ZVZhcmFyZ3ModXNlckRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIHRhcmdldERvYywgZmllbGQsIHZhbHVlLCBtb3JlRmllbGRzQW5kVmFsdWVzKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZXJEYXRhUmVhZGVyLmNyZWF0ZUNvbnRleHQoMSAvKiBVc2VyRGF0YVNvdXJjZS5VcGRhdGUgKi8sIG1ldGhvZE5hbWUsIHRhcmdldERvYyk7XG4gICAgY29uc3Qga2V5cyA9IFtmaWVsZFBhdGhGcm9tQXJndW1lbnQobWV0aG9kTmFtZSwgZmllbGQsIHRhcmdldERvYyldO1xuICAgIGNvbnN0IHZhbHVlcyA9IFt2YWx1ZV07XG4gICAgaWYgKG1vcmVGaWVsZHNBbmRWYWx1ZXMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRnVuY3Rpb24gJHttZXRob2ROYW1lfSgpIG5lZWRzIHRvIGJlIGNhbGxlZCB3aXRoIGFuIGV2ZW4gbnVtYmVyIGAgK1xuICAgICAgICAgICAgJ29mIGFyZ3VtZW50cyB0aGF0IGFsdGVybmF0ZSBiZXR3ZWVuIGZpZWxkIG5hbWVzIGFuZCB2YWx1ZXMuJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9yZUZpZWxkc0FuZFZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBrZXlzLnB1c2goZmllbGRQYXRoRnJvbUFyZ3VtZW50KG1ldGhvZE5hbWUsIG1vcmVGaWVsZHNBbmRWYWx1ZXNbaV0pKTtcbiAgICAgICAgdmFsdWVzLnB1c2gobW9yZUZpZWxkc0FuZFZhbHVlc1tpICsgMV0pO1xuICAgIH1cbiAgICBjb25zdCBmaWVsZE1hc2tQYXRocyA9IFtdO1xuICAgIGNvbnN0IHVwZGF0ZURhdGEgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xuICAgIC8vIFdlIGl0ZXJhdGUgaW4gcmV2ZXJzZSBvcmRlciB0byBwaWNrIHRoZSBsYXN0IHZhbHVlIGZvciBhIGZpZWxkIGlmIHRoZVxuICAgIC8vIHVzZXIgc3BlY2lmaWVkIHRoZSBmaWVsZCBtdWx0aXBsZSB0aW1lcy5cbiAgICBmb3IgKGxldCBpID0ga2V5cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAoIWZpZWxkTWFza0NvbnRhaW5zKGZpZWxkTWFza1BhdGhzLCBrZXlzW2ldKSkge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGtleXNbaV07XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxuICAgICAgICAgICAgLy8gcGVyZm9ybWluZyB2YWxpZGF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBnZXRNb2R1bGFySW5zdGFuY2UodmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDb250ZXh0ID0gY29udGV4dC5jaGlsZENvbnRleHRGb3JGaWVsZFBhdGgocGF0aCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEZWxldGVGaWVsZFZhbHVlSW1wbCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBpdCB0byB0aGUgZmllbGQgbWFzaywgYnV0IGRvbid0IGFkZCBhbnl0aGluZyB0byB1cGRhdGVEYXRhLlxuICAgICAgICAgICAgICAgIGZpZWxkTWFza1BhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlRGF0YSh2YWx1ZSwgY2hpbGRDb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZE1hc2tQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVEYXRhLnNldChwYXRoLCBwYXJzZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1hc2sgPSBuZXcgRmllbGRNYXNrKGZpZWxkTWFza1BhdGhzKTtcbiAgICByZXR1cm4gbmV3IFBhcnNlZFVwZGF0ZURhdGEodXBkYXRlRGF0YSwgbWFzaywgY29udGV4dC5maWVsZFRyYW5zZm9ybXMpO1xufVxuLyoqXG4gKiBQYXJzZSBhIFwicXVlcnkgdmFsdWVcIiAoZS5nLiB2YWx1ZSBpbiBhIHdoZXJlIGZpbHRlciBvciBhIHZhbHVlIGluIGEgY3Vyc29yXG4gKiBib3VuZCkuXG4gKlxuICogQHBhcmFtIGFsbG93QXJyYXlzIC0gV2hldGhlciB0aGUgcXVlcnkgdmFsdWUgaXMgYW4gYXJyYXkgdGhhdCBtYXkgZGlyZWN0bHlcbiAqIGNvbnRhaW4gYWRkaXRpb25hbCBhcnJheXMgKGUuZy4gdGhlIG9wZXJhbmQgb2YgYW4gYGluYCBxdWVyeSkuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUXVlcnlWYWx1ZSh1c2VyRGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgaW5wdXQsIGFsbG93QXJyYXlzID0gZmFsc2UpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlckRhdGFSZWFkZXIuY3JlYXRlQ29udGV4dChhbGxvd0FycmF5cyA/IDQgLyogVXNlckRhdGFTb3VyY2UuQXJyYXlBcmd1bWVudCAqLyA6IDMgLyogVXNlckRhdGFTb3VyY2UuQXJndW1lbnQgKi8sIG1ldGhvZE5hbWUpO1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlRGF0YShpbnB1dCwgY29udGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlZDtcbn1cbi8qKlxuICogUGFyc2VzIHVzZXIgZGF0YSB0byBQcm90b2J1ZiBWYWx1ZXMuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gRGF0YSB0byBiZSBwYXJzZWQuXG4gKiBAcGFyYW0gY29udGV4dCAtIEEgY29udGV4dCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHBhdGggYmVpbmcgcGFyc2VkLFxuICogdGhlIHNvdXJjZSBvZiB0aGUgZGF0YSBiZWluZyBwYXJzZWQsIGV0Yy5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgdmFsdWUsIG9yIG51bGwgaWYgdGhlIHZhbHVlIHdhcyBhIEZpZWxkVmFsdWUgc2VudGluZWxcbiAqIHRoYXQgc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIHBhcnNlZCBkYXRhLlxuICovXG5mdW5jdGlvbiBwYXJzZURhdGEoaW5wdXQsIGNvbnRleHQpIHtcbiAgICAvLyBVbndyYXAgdGhlIEFQSSB0eXBlIGZyb20gdGhlIENvbXBhdCBTREsuIFRoaXMgd2lsbCByZXR1cm4gdGhlIEFQSSB0eXBlXG4gICAgLy8gZnJvbSBmaXJlc3RvcmUtZXhwLlxuICAgIGlucHV0ID0gZ2V0TW9kdWxhckluc3RhbmNlKGlucHV0KTtcbiAgICBpZiAobG9va3NMaWtlSnNvbk9iamVjdChpbnB1dCkpIHtcbiAgICAgICAgdmFsaWRhdGVQbGFpbk9iamVjdCgnVW5zdXBwb3J0ZWQgZmllbGQgdmFsdWU6JywgY29udGV4dCwgaW5wdXQpO1xuICAgICAgICByZXR1cm4gcGFyc2VPYmplY3QoaW5wdXQsIGNvbnRleHQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIEZpZWxkVmFsdWUpIHtcbiAgICAgICAgLy8gRmllbGRWYWx1ZXMgdXN1YWxseSBwYXJzZSBpbnRvIHRyYW5zZm9ybXMgKGV4Y2VwdCBkZWxldGVGaWVsZCgpKVxuICAgICAgICAvLyBpbiB3aGljaCBjYXNlIHdlIGRvIG5vdCB3YW50IHRvIGluY2x1ZGUgdGhpcyBmaWVsZCBpbiBvdXIgcGFyc2VkIGRhdGFcbiAgICAgICAgLy8gKGFzIGRvaW5nIHNvIHdpbGwgb3ZlcndyaXRlIHRoZSBmaWVsZCBkaXJlY3RseSBwcmlvciB0byB0aGUgdHJhbnNmb3JtXG4gICAgICAgIC8vIHRyeWluZyB0byB0cmFuc2Zvcm0gaXQpLiBTbyB3ZSBkb24ndCBhZGQgdGhpcyBsb2NhdGlvbiB0b1xuICAgICAgICAvLyBjb250ZXh0LmZpZWxkTWFzayBhbmQgd2UgcmV0dXJuIG51bGwgYXMgb3VyIHBhcnNpbmcgcmVzdWx0LlxuICAgICAgICBwYXJzZVNlbnRpbmVsRmllbGRWYWx1ZShpbnB1dCwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkICYmIGNvbnRleHQuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcykge1xuICAgICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgdW5kZWZpbmVkIGl0IGNhbiBuZXZlciBwYXJ0aWNpcGF0ZSBpbiB0aGUgZmllbGRNYXNrLCBzb1xuICAgICAgICAvLyBkb24ndCBoYW5kbGUgdGhpcyBiZWxvdy4gSWYgYGlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXNgIGlzIGZhbHNlLFxuICAgICAgICAvLyBgcGFyc2VTY2FsYXJWYWx1ZWAgd2lsbCByZWplY3QgYW4gdW5kZWZpbmVkIHZhbHVlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIGNvbnRleHQucGF0aCBpcyBudWxsIHdlIGFyZSBpbnNpZGUgYW4gYXJyYXkgYW5kIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgICAgLy8gZmllbGQgbWFzayBwYXRocyBtb3JlIGdyYW51bGFyIHRoYW4gdGhlIHRvcC1sZXZlbCBhcnJheS5cbiAgICAgICAgaWYgKGNvbnRleHQucGF0aCkge1xuICAgICAgICAgICAgY29udGV4dC5maWVsZE1hc2sucHVzaChjb250ZXh0LnBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAvLyBUT0RPKGIvMzQ4NzExMzEpOiBJbmNsdWRlIHRoZSBwYXRoIGNvbnRhaW5pbmcgdGhlIGFycmF5IGluIHRoZSBlcnJvclxuICAgICAgICAgICAgLy8gbWVzc2FnZS5cbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIElOIHF1ZXJpZXMsIHRoZSBwYXJzZWQgZGF0YSBpcyBhbiBhcnJheSAocmVwcmVzZW50aW5nXG4gICAgICAgICAgICAvLyB0aGUgc2V0IG9mIHZhbHVlcyB0byBiZSBpbmNsdWRlZCBmb3IgdGhlIElOIHF1ZXJ5KSB0aGF0IG1heSBkaXJlY3RseVxuICAgICAgICAgICAgLy8gY29udGFpbiBhZGRpdGlvbmFsIGFycmF5cyAoZWFjaCByZXByZXNlbnRpbmcgYW4gaW5kaXZpZHVhbCBmaWVsZFxuICAgICAgICAgICAgLy8gdmFsdWUpLCBzbyB3ZSBkaXNhYmxlIHRoaXMgdmFsaWRhdGlvbi5cbiAgICAgICAgICAgIGlmIChjb250ZXh0LnNldHRpbmdzLmFycmF5RWxlbWVudCAmJlxuICAgICAgICAgICAgICAgIGNvbnRleHQuZGF0YVNvdXJjZSAhPT0gNCAvKiBVc2VyRGF0YVNvdXJjZS5BcnJheUFyZ3VtZW50ICovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcignTmVzdGVkIGFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXkoaW5wdXQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU2NhbGFyVmFsdWUoaW5wdXQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VPYmplY3Qob2JqLCBjb250ZXh0KSB7XG4gICAgY29uc3QgZmllbGRzID0ge307XG4gICAgaWYgKGlzRW1wdHkob2JqKSkge1xuICAgICAgICAvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZW1wdHkgb2JqZWN0LCB3ZSBleHBsaWNpdGx5IGFkZCBpdCB0byB0aGUgdXBkYXRlXG4gICAgICAgIC8vIG1hc2sgdG8gZW5zdXJlIHRoYXQgdGhlIHNlcnZlciBjcmVhdGVzIGEgbWFwIGVudHJ5LlxuICAgICAgICBpZiAoY29udGV4dC5wYXRoICYmIGNvbnRleHQucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpZWxkTWFzay5wdXNoKGNvbnRleHQucGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvckVhY2gob2JqLCAoa2V5LCB2YWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VEYXRhKHZhbCwgY29udGV4dC5jaGlsZENvbnRleHRGb3JGaWVsZChrZXkpKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzW2tleV0gPSBwYXJzZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IG1hcFZhbHVlOiB7IGZpZWxkcyB9IH07XG59XG5mdW5jdGlvbiBwYXJzZUFycmF5KGFycmF5LCBjb250ZXh0KSB7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgbGV0IGVudHJ5SW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgYXJyYXkpIHtcbiAgICAgICAgbGV0IHBhcnNlZEVudHJ5ID0gcGFyc2VEYXRhKGVudHJ5LCBjb250ZXh0LmNoaWxkQ29udGV4dEZvckFycmF5KGVudHJ5SW5kZXgpKTtcbiAgICAgICAgaWYgKHBhcnNlZEVudHJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEp1c3QgaW5jbHVkZSBudWxscyBpbiB0aGUgYXJyYXkgZm9yIGZpZWxkcyBiZWluZyByZXBsYWNlZCB3aXRoIGFcbiAgICAgICAgICAgIC8vIHNlbnRpbmVsLlxuICAgICAgICAgICAgcGFyc2VkRW50cnkgPSB7IG51bGxWYWx1ZTogJ05VTExfVkFMVUUnIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzLnB1c2gocGFyc2VkRW50cnkpO1xuICAgICAgICBlbnRyeUluZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiB7IGFycmF5VmFsdWU6IHsgdmFsdWVzIH0gfTtcbn1cbi8qKlxuICogXCJQYXJzZXNcIiB0aGUgcHJvdmlkZWQgRmllbGRWYWx1ZUltcGwsIGFkZGluZyBhbnkgbmVjZXNzYXJ5IHRyYW5zZm9ybXMgdG9cbiAqIGNvbnRleHQuZmllbGRUcmFuc2Zvcm1zLlxuICovXG5mdW5jdGlvbiBwYXJzZVNlbnRpbmVsRmllbGRWYWx1ZSh2YWx1ZSwgY29udGV4dCkge1xuICAgIC8vIFNlbnRpbmVscyBhcmUgb25seSBzdXBwb3J0ZWQgd2l0aCB3cml0ZXMsIGFuZCBub3Qgd2l0aGluIGFycmF5cy5cbiAgICBpZiAoIWlzV3JpdGUoY29udGV4dC5kYXRhU291cmNlKSkge1xuICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGAke3ZhbHVlLl9tZXRob2ROYW1lfSgpIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCB1cGRhdGUoKSBhbmQgc2V0KClgKTtcbiAgICB9XG4gICAgaWYgKCFjb250ZXh0LnBhdGgpIHtcbiAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihgJHt2YWx1ZS5fbWV0aG9kTmFtZX0oKSBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBpbnNpZGUgYXJyYXlzYCk7XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkVHJhbnNmb3JtID0gdmFsdWUuX3RvRmllbGRUcmFuc2Zvcm0oY29udGV4dCk7XG4gICAgaWYgKGZpZWxkVHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnRleHQuZmllbGRUcmFuc2Zvcm1zLnB1c2goZmllbGRUcmFuc2Zvcm0pO1xuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIHRvIHBhcnNlIGEgc2NhbGFyIHZhbHVlIChpLmUuIG5vdCBhbiBPYmplY3QsIEFycmF5LCBvciBGaWVsZFZhbHVlKVxuICpcbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gcGFyc2VTY2FsYXJWYWx1ZSh2YWx1ZSwgY29udGV4dCkge1xuICAgIHZhbHVlID0gZ2V0TW9kdWxhckluc3RhbmNlKHZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHsgbnVsbFZhbHVlOiAnTlVMTF9WQUxVRScgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdG9OdW1iZXIoY29udGV4dC5zZXJpYWxpemVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiB7IGJvb2xlYW5WYWx1ZTogdmFsdWUgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4geyBzdHJpbmdWYWx1ZTogdmFsdWUgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IFRpbWVzdGFtcC5mcm9tRGF0ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0aW1lc3RhbXBWYWx1ZTogdG9UaW1lc3RhbXAoY29udGV4dC5zZXJpYWxpemVyLCB0aW1lc3RhbXApXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgVGltZXN0YW1wKSB7XG4gICAgICAgIC8vIEZpcmVzdG9yZSBiYWNrZW5kIHRydW5jYXRlcyBwcmVjaXNpb24gZG93biB0byBtaWNyb3NlY29uZHMuIFRvIGVuc3VyZVxuICAgICAgICAvLyBvZmZsaW5lIG1vZGUgd29ya3MgdGhlIHNhbWUgd2l0aCByZWdhcmRzIHRvIHRydW5jYXRpb24sIHBlcmZvcm0gdGhlXG4gICAgICAgIC8vIHRydW5jYXRpb24gaW1tZWRpYXRlbHkgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgYmFja2VuZCB0byBkbyB0aGF0LlxuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgVGltZXN0YW1wKHZhbHVlLnNlY29uZHMsIE1hdGguZmxvb3IodmFsdWUubmFub3NlY29uZHMgLyAxMDAwKSAqIDEwMDApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGltZXN0YW1wVmFsdWU6IHRvVGltZXN0YW1wKGNvbnRleHQuc2VyaWFsaXplciwgdGltZXN0YW1wKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEdlb1BvaW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZW9Qb2ludFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgbGF0aXR1ZGU6IHZhbHVlLmxhdGl0dWRlLFxuICAgICAgICAgICAgICAgIGxvbmdpdHVkZTogdmFsdWUubG9uZ2l0dWRlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHsgYnl0ZXNWYWx1ZTogdG9CeXRlcyhjb250ZXh0LnNlcmlhbGl6ZXIsIHZhbHVlLl9ieXRlU3RyaW5nKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERvY3VtZW50UmVmZXJlbmNlKSB7XG4gICAgICAgIGNvbnN0IHRoaXNEYiA9IGNvbnRleHQuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3Qgb3RoZXJEYiA9IHZhbHVlLmZpcmVzdG9yZS5fZGF0YWJhc2VJZDtcbiAgICAgICAgaWYgKCFvdGhlckRiLmlzRXF1YWwodGhpc0RiKSkge1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcignRG9jdW1lbnQgcmVmZXJlbmNlIGlzIGZvciBkYXRhYmFzZSAnICtcbiAgICAgICAgICAgICAgICBgJHtvdGhlckRiLnByb2plY3RJZH0vJHtvdGhlckRiLmRhdGFiYXNlfSBidXQgc2hvdWxkIGJlIGAgK1xuICAgICAgICAgICAgICAgIGBmb3IgZGF0YWJhc2UgJHt0aGlzRGIucHJvamVjdElkfS8ke3RoaXNEYi5kYXRhYmFzZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVmFsdWU6IHRvUmVzb3VyY2VOYW1lKHZhbHVlLmZpcmVzdG9yZS5fZGF0YWJhc2VJZCB8fCBjb250ZXh0LmRhdGFiYXNlSWQsIHZhbHVlLl9rZXkucGF0aClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBWZWN0b3JWYWx1ZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VWZWN0b3JWYWx1ZSh2YWx1ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUHJvdG9WYWx1ZVNlcmlhbGl6YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLl90b1Byb3RvKGNvbnRleHQuc2VyaWFsaXplcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGBVbnN1cHBvcnRlZCBmaWVsZCB2YWx1ZTogJHt2YWx1ZURlc2NyaXB0aW9uKHZhbHVlKX1gKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVmVjdG9yVmFsdWUgcHJvdG8gdmFsdWUgKHVzaW5nIHRoZSBpbnRlcm5hbCBmb3JtYXQpLlxuICovXG5mdW5jdGlvbiBwYXJzZVZlY3RvclZhbHVlKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgdmFsdWVzID0gdmFsdWUgaW5zdGFuY2VvZiBWZWN0b3JWYWx1ZSA/IHZhbHVlLnRvQXJyYXkoKSA6IHZhbHVlO1xuICAgIGNvbnN0IG1hcFZhbHVlID0ge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIFtUWVBFX0tFWV06IHtcbiAgICAgICAgICAgICAgICBzdHJpbmdWYWx1ZTogVkVDVE9SX1ZBTFVFX1NFTlRJTkVMXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1ZFQ1RPUl9NQVBfVkVDVE9SU19LRVldOiB7XG4gICAgICAgICAgICAgICAgYXJyYXlWYWx1ZToge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHZhbHVlcy5tYXAodmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKCdWZWN0b3JWYWx1ZXMgbXVzdCBvbmx5IGNvbnRhaW4gbnVtZXJpYyB2YWx1ZXMuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9Eb3VibGUoY29udGV4dC5zZXJpYWxpemVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4geyBtYXBWYWx1ZSB9O1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhbiBvYmplY3QgbG9va3MgbGlrZSBhIEpTT04gb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICogaW50byBhIHN0cnVjdC4gTm9ybWFsIGNsYXNzL3Byb3RvdHlwZSBpbnN0YW5jZXMgYXJlIGNvbnNpZGVyZWQgdG8gbG9vayBsaWtlXG4gKiBKU09OIG9iamVjdHMgc2luY2UgdGhleSBzaG91bGQgYmUgY29udmVydGVkIHRvIGEgc3RydWN0IHZhbHVlLiBBcnJheXMsIERhdGVzLFxuICogR2VvUG9pbnRzLCBldGMuIGFyZSBub3QgY29uc2lkZXJlZCB0byBsb29rIGxpa2UgSlNPTiBvYmplY3RzIHNpbmNlIHRoZXkgbWFwXG4gKiB0byBzcGVjaWZpYyBGaWVsZFZhbHVlIHR5cGVzIG90aGVyIHRoYW4gT2JqZWN0VmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxvb2tzTGlrZUpzb25PYmplY3QoaW5wdXQpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgaW5wdXQgIT09IG51bGwgJiZcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIEFycmF5KSAmJlxuICAgICAgICAhKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkgJiZcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIFRpbWVzdGFtcCkgJiZcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIEdlb1BvaW50KSAmJlxuICAgICAgICAhKGlucHV0IGluc3RhbmNlb2YgQnl0ZXMpICYmXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkgJiZcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIEZpZWxkVmFsdWUpICYmXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBWZWN0b3JWYWx1ZSkgJiZcbiAgICAgICAgIWlzUHJvdG9WYWx1ZVNlcmlhbGl6YWJsZShpbnB1dCkpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQbGFpbk9iamVjdChtZXNzYWdlLCBjb250ZXh0LCBpbnB1dCkge1xuICAgIGlmICghbG9va3NMaWtlSnNvbk9iamVjdChpbnB1dCkgfHwgIWlzUGxhaW5PYmplY3QoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsdWVEZXNjcmlwdGlvbihpbnB1dCk7XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gJ2FuIG9iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIE1hc3NhZ2UgdGhlIGVycm9yIGlmIGl0IHdhcyBhbiBvYmplY3QuXG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKG1lc3NhZ2UgKyAnIGEgY3VzdG9tIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihtZXNzYWdlICsgJyAnICsgZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdGhhdCBjYWxscyBmcm9tRG90U2VwYXJhdGVkU3RyaW5nKCkgYnV0IHdyYXBzIGFueSBlcnJvciB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIGZpZWxkUGF0aEZyb21Bcmd1bWVudChtZXRob2ROYW1lLCBwYXRoLCB0YXJnZXREb2MpIHtcbiAgICAvLyBJZiByZXF1aXJlZCwgcmVwbGFjZSB0aGUgRmllbGRQYXRoIENvbXBhdCBjbGFzcyB3aXRoIHRoZSBmaXJlc3RvcmUtZXhwXG4gICAgLy8gRmllbGRQYXRoLlxuICAgIHBhdGggPSBnZXRNb2R1bGFySW5zdGFuY2UocGF0aCk7XG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBGaWVsZFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGguX2ludGVybmFsUGF0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmaWVsZFBhdGhGcm9tRG90U2VwYXJhdGVkU3RyaW5nKG1ldGhvZE5hbWUsIHBhdGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdGaWVsZCBwYXRoIGFyZ3VtZW50cyBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nIG9yICc7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKG1lc3NhZ2UsIG1ldGhvZE5hbWUsIFxuICAgICAgICAvKiBoYXNDb252ZXJ0ZXI9ICovIGZhbHNlLCBcbiAgICAgICAgLyogcGF0aD0gKi8gdW5kZWZpbmVkLCB0YXJnZXREb2MpO1xuICAgIH1cbn1cbi8qKlxuICogTWF0Y2hlcyBhbnkgY2hhcmFjdGVycyBpbiBhIGZpZWxkIHBhdGggc3RyaW5nIHRoYXQgYXJlIHJlc2VydmVkLlxuICovXG5jb25zdCBGSUVMRF9QQVRIX1JFU0VSVkVEID0gbmV3IFJlZ0V4cCgnW35cXFxcKi9cXFxcW1xcXFxdXScpO1xuLyoqXG4gKiBXcmFwcyBmcm9tRG90U2VwYXJhdGVkU3RyaW5nIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBhYm91dCB0aGUgbWV0aG9kIHRoYXRcbiAqIHdhcyB0aHJvd24uXG4gKiBAcGFyYW0gbWV0aG9kTmFtZSAtIFRoZSBwdWJsaWNseSB2aXNpYmxlIG1ldGhvZCBuYW1lXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBkb3Qtc2VwYXJhdGVkIHN0cmluZyBmb3JtIG9mIGEgZmllbGQgcGF0aCB3aGljaCB3aWxsIGJlXG4gKiBzcGxpdCBvbiBkb3RzLlxuICogQHBhcmFtIHRhcmdldERvYyAtIFRoZSBkb2N1bWVudCBhZ2FpbnN0IHdoaWNoIHRoZSBmaWVsZCBwYXRoIHdpbGwgYmVcbiAqIGV2YWx1YXRlZC5cbiAqL1xuZnVuY3Rpb24gZmllbGRQYXRoRnJvbURvdFNlcGFyYXRlZFN0cmluZyhtZXRob2ROYW1lLCBwYXRoLCB0YXJnZXREb2MpIHtcbiAgICBjb25zdCBmb3VuZCA9IHBhdGguc2VhcmNoKEZJRUxEX1BBVEhfUkVTRVJWRUQpO1xuICAgIGlmIChmb3VuZCA+PSAwKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGBJbnZhbGlkIGZpZWxkIHBhdGggKCR7cGF0aH0pLiBQYXRocyBtdXN0IG5vdCBjb250YWluIGAgK1xuICAgICAgICAgICAgYCd+JywgJyonLCAnLycsICdbJywgb3IgJ10nYCwgbWV0aG9kTmFtZSwgXG4gICAgICAgIC8qIGhhc0NvbnZlcnRlcj0gKi8gZmFsc2UsIFxuICAgICAgICAvKiBwYXRoPSAqLyB1bmRlZmluZWQsIHRhcmdldERvYyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRQYXRoKC4uLnBhdGguc3BsaXQoJy4nKSkuX2ludGVybmFsUGF0aDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoYEludmFsaWQgZmllbGQgcGF0aCAoJHtwYXRofSkuIFBhdGhzIG11c3Qgbm90IGJlIGVtcHR5LCBgICtcbiAgICAgICAgICAgIGBiZWdpbiB3aXRoICcuJywgZW5kIHdpdGggJy4nLCBvciBjb250YWluICcuLidgLCBtZXRob2ROYW1lLCBcbiAgICAgICAgLyogaGFzQ29udmVydGVyPSAqLyBmYWxzZSwgXG4gICAgICAgIC8qIHBhdGg9ICovIHVuZGVmaW5lZCwgdGFyZ2V0RG9jKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFcnJvcihyZWFzb24sIG1ldGhvZE5hbWUsIGhhc0NvbnZlcnRlciwgcGF0aCwgdGFyZ2V0RG9jKSB7XG4gICAgY29uc3QgaGFzUGF0aCA9IHBhdGggJiYgIXBhdGguaXNFbXB0eSgpO1xuICAgIGNvbnN0IGhhc0RvY3VtZW50ID0gdGFyZ2V0RG9jICE9PSB1bmRlZmluZWQ7XG4gICAgbGV0IG1lc3NhZ2UgPSBgRnVuY3Rpb24gJHttZXRob2ROYW1lfSgpIGNhbGxlZCB3aXRoIGludmFsaWQgZGF0YWA7XG4gICAgaWYgKGhhc0NvbnZlcnRlcikge1xuICAgICAgICBtZXNzYWdlICs9ICcgKHZpYSBgdG9GaXJlc3RvcmUoKWApJztcbiAgICB9XG4gICAgbWVzc2FnZSArPSAnLiAnO1xuICAgIGxldCBkZXNjcmlwdGlvbiA9ICcnO1xuICAgIGlmIChoYXNQYXRoIHx8IGhhc0RvY3VtZW50KSB7XG4gICAgICAgIGRlc2NyaXB0aW9uICs9ICcgKGZvdW5kJztcbiAgICAgICAgaWYgKGhhc1BhdGgpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uICs9IGAgaW4gZmllbGQgJHtwYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0RvY3VtZW50KSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiArPSBgIGluIGRvY3VtZW50ICR7dGFyZ2V0RG9jfWA7XG4gICAgICAgIH1cbiAgICAgICAgZGVzY3JpcHRpb24gKz0gJyknO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgbWVzc2FnZSArIHJlYXNvbiArIGRlc2NyaXB0aW9uKTtcbn1cbi8qKiBDaGVja3MgYGhheXN0YWNrYCBpZiBGaWVsZFBhdGggYG5lZWRsZWAgaXMgcHJlc2VudC4gUnVucyBpbiBPKG4pLiAqL1xuZnVuY3Rpb24gZmllbGRNYXNrQ29udGFpbnMoaGF5c3RhY2ssIG5lZWRsZSkge1xuICAgIHJldHVybiBoYXlzdGFjay5zb21lKHYgPT4gdi5pc0VxdWFsKG5lZWRsZSkpO1xufVxuZnVuY3Rpb24gaXNVc2VyRGF0YSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUuX3JlYWRVc2VyRGF0YSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ29udmVydHMgRmlyZXN0b3JlJ3MgaW50ZXJuYWwgdHlwZXMgdG8gdGhlIEphdmFTY3JpcHQgdHlwZXMgdGhhdCB3ZSBleHBvc2VcbiAqIHRvIHRoZSB1c2VyLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBBYnN0cmFjdFVzZXJEYXRhV3JpdGVyIHtcbiAgICBjb252ZXJ0VmFsdWUodmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yID0gJ25vbmUnKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZU9yZGVyKHZhbHVlKSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIFR5cGVPcmRlci5OdWxsVmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlIDEgLyogVHlwZU9yZGVyLkJvb2xlYW5WYWx1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYm9vbGVhblZhbHVlO1xuICAgICAgICAgICAgY2FzZSAyIC8qIFR5cGVPcmRlci5OdW1iZXJWYWx1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplTnVtYmVyKHZhbHVlLmludGVnZXJWYWx1ZSB8fCB2YWx1ZS5kb3VibGVWYWx1ZSk7XG4gICAgICAgICAgICBjYXNlIDMgLyogVHlwZU9yZGVyLlRpbWVzdGFtcFZhbHVlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRUaW1lc3RhbXAodmFsdWUudGltZXN0YW1wVmFsdWUpO1xuICAgICAgICAgICAgY2FzZSA0IC8qIFR5cGVPcmRlci5TZXJ2ZXJUaW1lc3RhbXBWYWx1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2VydmVyVGltZXN0YW1wKHZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcik7XG4gICAgICAgICAgICBjYXNlIDUgLyogVHlwZU9yZGVyLlN0cmluZ1ZhbHVlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgIGNhc2UgNiAvKiBUeXBlT3JkZXIuQmxvYlZhbHVlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRCeXRlcyhub3JtYWxpemVCeXRlU3RyaW5nKHZhbHVlLmJ5dGVzVmFsdWUpKTtcbiAgICAgICAgICAgIGNhc2UgNyAvKiBUeXBlT3JkZXIuUmVmVmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFJlZmVyZW5jZSh2YWx1ZS5yZWZlcmVuY2VWYWx1ZSk7XG4gICAgICAgICAgICBjYXNlIDggLyogVHlwZU9yZGVyLkdlb1BvaW50VmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydEdlb1BvaW50KHZhbHVlLmdlb1BvaW50VmFsdWUpO1xuICAgICAgICAgICAgY2FzZSA5IC8qIFR5cGVPcmRlci5BcnJheVZhbHVlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRBcnJheSh2YWx1ZS5hcnJheVZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcik7XG4gICAgICAgICAgICBjYXNlIDExIC8qIFR5cGVPcmRlci5PYmplY3RWYWx1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0T2JqZWN0KHZhbHVlLm1hcFZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcik7XG4gICAgICAgICAgICBjYXNlIDEwIC8qIFR5cGVPcmRlci5WZWN0b3JWYWx1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VmVjdG9yVmFsdWUodmFsdWUubWFwVmFsdWUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBmYWlsKDB4ZjJhMiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnZlcnRPYmplY3QobWFwVmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRPYmplY3RNYXAobWFwVmFsdWUuZmllbGRzLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnZlcnRPYmplY3RNYXAoZmllbGRzLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvciA9ICdub25lJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yRWFjaChmaWVsZHMsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHRoaXMuY29udmVydFZhbHVlKHZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb252ZXJ0VmVjdG9yVmFsdWUobWFwVmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gbWFwVmFsdWUuZmllbGRzPy5bVkVDVE9SX01BUF9WRUNUT1JTX0tFWV0uYXJyYXlWYWx1ZT8udmFsdWVzPy5tYXAodmFsdWUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5kb3VibGVWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvclZhbHVlKHZhbHVlcyk7XG4gICAgfVxuICAgIGNvbnZlcnRHZW9Qb2ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEdlb1BvaW50KG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5sYXRpdHVkZSksIG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5sb25naXR1ZGUpKTtcbiAgICB9XG4gICAgY29udmVydEFycmF5KGFycmF5VmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKSB7XG4gICAgICAgIHJldHVybiAoYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pLm1hcCh2YWx1ZSA9PiB0aGlzLmNvbnZlcnRWYWx1ZSh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpKTtcbiAgICB9XG4gICAgY29udmVydFNlcnZlclRpbWVzdGFtcCh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpIHtcbiAgICAgICAgc3dpdGNoIChzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcikge1xuICAgICAgICAgICAgY2FzZSAncHJldmlvdXMnOlxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBnZXRQcmV2aW91c1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VmFsdWUocHJldmlvdXNWYWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xuICAgICAgICAgICAgY2FzZSAnZXN0aW1hdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRUaW1lc3RhbXAoZ2V0TG9jYWxXcml0ZVRpbWUodmFsdWUpKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29udmVydFRpbWVzdGFtcCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSBub3JtYWxpemVUaW1lc3RhbXAodmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChub3JtYWxpemVkVmFsdWUuc2Vjb25kcywgbm9ybWFsaXplZFZhbHVlLm5hbm9zKTtcbiAgICB9XG4gICAgY29udmVydERvY3VtZW50S2V5KG5hbWUsIGV4cGVjdGVkRGF0YWJhc2VJZCkge1xuICAgICAgICBjb25zdCByZXNvdXJjZVBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhuYW1lKTtcbiAgICAgICAgaGFyZEFzc2VydChpc1ZhbGlkUmVzb3VyY2VOYW1lKHJlc291cmNlUGF0aCksIDB4MjVkOCwgeyBuYW1lIH0pO1xuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gbmV3IERhdGFiYXNlSWQocmVzb3VyY2VQYXRoLmdldCgxKSwgcmVzb3VyY2VQYXRoLmdldCgzKSk7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBEb2N1bWVudEtleShyZXNvdXJjZVBhdGgucG9wRmlyc3QoNSkpO1xuICAgICAgICBpZiAoIWRhdGFiYXNlSWQuaXNFcXVhbChleHBlY3RlZERhdGFiYXNlSWQpKSB7XG4gICAgICAgICAgICAvLyBUT0RPKGIvNjQxMzAyMDIpOiBTb21laG93IHN1cHBvcnQgZm9yZWlnbiByZWZlcmVuY2VzLlxuICAgICAgICAgICAgbG9nRXJyb3IoYERvY3VtZW50ICR7a2V5fSBjb250YWlucyBhIGRvY3VtZW50IGAgK1xuICAgICAgICAgICAgICAgIGByZWZlcmVuY2Ugd2l0aGluIGEgZGlmZmVyZW50IGRhdGFiYXNlIChgICtcbiAgICAgICAgICAgICAgICBgJHtkYXRhYmFzZUlkLnByb2plY3RJZH0vJHtkYXRhYmFzZUlkLmRhdGFiYXNlfSkgd2hpY2ggaXMgbm90IGAgK1xuICAgICAgICAgICAgICAgIGBzdXBwb3J0ZWQuIEl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHJlZmVyZW5jZSBpbiB0aGUgY3VycmVudCBgICtcbiAgICAgICAgICAgICAgICBgZGF0YWJhc2UgKCR7ZXhwZWN0ZWREYXRhYmFzZUlkLnByb2plY3RJZH0vJHtleHBlY3RlZERhdGFiYXNlSWQuZGF0YWJhc2V9KSBgICtcbiAgICAgICAgICAgICAgICBgaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEV4cFVzZXJEYXRhV3JpdGVyIGV4dGVuZHMgQWJzdHJhY3RVc2VyRGF0YVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmlyZXN0b3JlID0gZmlyZXN0b3JlO1xuICAgIH1cbiAgICBjb252ZXJ0Qnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlcyhieXRlcyk7XG4gICAgfVxuICAgIGNvbnZlcnRSZWZlcmVuY2UobmFtZSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmNvbnZlcnREb2N1bWVudEtleShuYW1lLCB0aGlzLmZpcmVzdG9yZS5fZGF0YWJhc2VJZCk7XG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UodGhpcy5maXJlc3RvcmUsIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwga2V5KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJldHVybnMgYSBzZW50aW5lbCBmb3IgdXNlIHdpdGgge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSModXBkYXRlRG9jOjEpfSBvclxuICoge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSMoc2V0RG9jOjEpfSB3aXRoIGB7bWVyZ2U6IHRydWV9YCB0byBtYXJrIGEgZmllbGQgZm9yIGRlbGV0aW9uLlxuICovXG5mdW5jdGlvbiBkZWxldGVGaWVsZCgpIHtcbiAgICByZXR1cm4gbmV3IERlbGV0ZUZpZWxkVmFsdWVJbXBsKCdkZWxldGVGaWVsZCcpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc2VudGluZWwgdXNlZCB3aXRoIHtAbGluayBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHNldERvYzoxKX0gb3Ige0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSModXBkYXRlRG9jOjEpfSB0b1xuICogaW5jbHVkZSBhIHNlcnZlci1nZW5lcmF0ZWQgdGltZXN0YW1wIGluIHRoZSB3cml0dGVuIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHNlcnZlclRpbWVzdGFtcCgpIHtcbiAgICByZXR1cm4gbmV3IFNlcnZlclRpbWVzdGFtcEZpZWxkVmFsdWVJbXBsKCdzZXJ2ZXJUaW1lc3RhbXAnKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNwZWNpYWwgdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHtAbGluayBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHNldERvYzoxKX0gb3Ige0BsaW5rXG4gKiBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHVwZGF0ZURvYzoxKX0gdGhhdCB0ZWxscyB0aGUgc2VydmVyIHRvIHVuaW9uIHRoZSBnaXZlbiBlbGVtZW50cyB3aXRoIGFueSBhcnJheVxuICogdmFsdWUgdGhhdCBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgc2VydmVyLiBFYWNoIHNwZWNpZmllZCBlbGVtZW50IHRoYXQgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdCBpbiB0aGUgYXJyYXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgZW5kLiBJZiB0aGUgZmllbGQgYmVpbmdcbiAqIG1vZGlmaWVkIGlzIG5vdCBhbHJlYWR5IGFuIGFycmF5IGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCBhbiBhcnJheVxuICogY29udGFpbmluZyBleGFjdGx5IHRoZSBzcGVjaWZpZWQgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIGVsZW1lbnRzIC0gVGhlIGVsZW1lbnRzIHRvIHVuaW9uIGludG8gdGhlIGFycmF5LlxuICogQHJldHVybnMgVGhlIGBGaWVsZFZhbHVlYCBzZW50aW5lbCBmb3IgdXNlIGluIGEgY2FsbCB0byBgc2V0RG9jKClgIG9yXG4gKiBgdXBkYXRlRG9jKClgLlxuICovXG5mdW5jdGlvbiBhcnJheVVuaW9uKC4uLmVsZW1lbnRzKSB7XG4gICAgLy8gTk9URTogV2UgZG9uJ3QgYWN0dWFsbHkgcGFyc2UgdGhlIGRhdGEgdW50aWwgaXQncyB1c2VkIGluIHNldCgpIG9yXG4gICAgLy8gdXBkYXRlKCkgc2luY2Ugd2UnZCBuZWVkIHRoZSBGaXJlc3RvcmUgaW5zdGFuY2UgdG8gZG8gdGhpcy5cbiAgICByZXR1cm4gbmV3IEFycmF5VW5pb25GaWVsZFZhbHVlSW1wbCgnYXJyYXlVbmlvbicsIGVsZW1lbnRzKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNwZWNpYWwgdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHtAbGluayAoc2V0RG9jOjEpfSBvciB7QGxpbmtcbiAqIHVwZGF0ZURvYzoxfSB0aGF0IHRlbGxzIHRoZSBzZXJ2ZXIgdG8gcmVtb3ZlIHRoZSBnaXZlbiBlbGVtZW50cyBmcm9tIGFueVxuICogYXJyYXkgdmFsdWUgdGhhdCBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgc2VydmVyLiBBbGwgaW5zdGFuY2VzIG9mIGVhY2ggZWxlbWVudFxuICogc3BlY2lmaWVkIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBhcnJheS4gSWYgdGhlIGZpZWxkIGJlaW5nIG1vZGlmaWVkIGlzIG5vdFxuICogYWxyZWFkeSBhbiBhcnJheSBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggYW4gZW1wdHkgYXJyYXkuXG4gKlxuICogQHBhcmFtIGVsZW1lbnRzIC0gVGhlIGVsZW1lbnRzIHRvIHJlbW92ZSBmcm9tIHRoZSBhcnJheS5cbiAqIEByZXR1cm5zIFRoZSBgRmllbGRWYWx1ZWAgc2VudGluZWwgZm9yIHVzZSBpbiBhIGNhbGwgdG8gYHNldERvYygpYCBvclxuICogYHVwZGF0ZURvYygpYFxuICovXG5mdW5jdGlvbiBhcnJheVJlbW92ZSguLi5lbGVtZW50cykge1xuICAgIC8vIE5PVEU6IFdlIGRvbid0IGFjdHVhbGx5IHBhcnNlIHRoZSBkYXRhIHVudGlsIGl0J3MgdXNlZCBpbiBzZXQoKSBvclxuICAgIC8vIHVwZGF0ZSgpIHNpbmNlIHdlJ2QgbmVlZCB0aGUgRmlyZXN0b3JlIGluc3RhbmNlIHRvIGRvIHRoaXMuXG4gICAgcmV0dXJuIG5ldyBBcnJheVJlbW92ZUZpZWxkVmFsdWVJbXBsKCdhcnJheVJlbW92ZScsIGVsZW1lbnRzKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNwZWNpYWwgdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHtAbGluayBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHNldERvYzoxKX0gb3Ige0BsaW5rXG4gKiBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHVwZGF0ZURvYzoxKX0gdGhhdCB0ZWxscyB0aGUgc2VydmVyIHRvIGluY3JlbWVudCB0aGUgZmllbGQncyBjdXJyZW50IHZhbHVlIGJ5XG4gKiB0aGUgZ2l2ZW4gdmFsdWUuXG4gKlxuICogSWYgZWl0aGVyIHRoZSBvcGVyYW5kIG9yIHRoZSBjdXJyZW50IGZpZWxkIHZhbHVlIHVzZXMgZmxvYXRpbmcgcG9pbnRcbiAqIHByZWNpc2lvbiwgYWxsIGFyaXRobWV0aWMgZm9sbG93cyBJRUVFIDc1NCBzZW1hbnRpY3MuIElmIGJvdGggdmFsdWVzIGFyZVxuICogaW50ZWdlcnMsIHZhbHVlcyBvdXRzaWRlIG9mIEphdmFTY3JpcHQncyBzYWZlIG51bWJlciByYW5nZVxuICogKGBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUmAgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYCkgYXJlIGFsc28gc3ViamVjdCB0b1xuICogcHJlY2lzaW9uIGxvc3MuIEZ1cnRoZXJtb3JlLCBvbmNlIHByb2Nlc3NlZCBieSB0aGUgRmlyZXN0b3JlIGJhY2tlbmQsIGFsbFxuICogaW50ZWdlciBvcGVyYXRpb25zIGFyZSBjYXBwZWQgYmV0d2VlbiAtMl42MyBhbmQgMl42My0xLlxuICpcbiAqIElmIHRoZSBjdXJyZW50IGZpZWxkIHZhbHVlIGlzIG5vdCBvZiB0eXBlIGBudW1iZXJgLCBvciBpZiB0aGUgZmllbGQgZG9lcyBub3RcbiAqIHlldCBleGlzdCwgdGhlIHRyYW5zZm9ybWF0aW9uIHNldHMgdGhlIGZpZWxkIHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gbiAtIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgYnkuXG4gKiBAcmV0dXJucyBUaGUgYEZpZWxkVmFsdWVgIHNlbnRpbmVsIGZvciB1c2UgaW4gYSBjYWxsIHRvIGBzZXREb2MoKWAgb3JcbiAqIGB1cGRhdGVEb2MoKWBcbiAqL1xuZnVuY3Rpb24gaW5jcmVtZW50KG4pIHtcbiAgICByZXR1cm4gbmV3IE51bWVyaWNJbmNyZW1lbnRGaWVsZFZhbHVlSW1wbCgnaW5jcmVtZW50Jywgbik7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYFZlY3RvclZhbHVlYCBjb25zdHJ1Y3RlZCB3aXRoIGEgY29weSBvZiB0aGUgZ2l2ZW4gYXJyYXkgb2YgbnVtYmVycy5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gQ3JlYXRlIGEgYFZlY3RvclZhbHVlYCBpbnN0YW5jZSB3aXRoIGEgY29weSBvZiB0aGlzIGFycmF5IG9mIG51bWJlcnMuXG4gKlxuICogQHJldHVybnMgQSBuZXcgYFZlY3RvclZhbHVlYCBjb25zdHJ1Y3RlZCB3aXRoIGEgY29weSBvZiB0aGUgZ2l2ZW4gYXJyYXkgb2YgbnVtYmVycy5cbiAqL1xuZnVuY3Rpb24gdmVjdG9yKHZhbHVlcykge1xuICAgIHJldHVybiBuZXcgVmVjdG9yVmFsdWUodmFsdWVzKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE9wdGlvbnNVdGlsIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25EZWZpbml0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbkRlZmluaXRpb25zID0gb3B0aW9uRGVmaW5pdGlvbnM7XG4gICAgfVxuICAgIF9nZXRLbm93bk9wdGlvbnMob3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICBjb25zdCBrbm93bk9wdGlvbnMgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xuICAgICAgICAvLyBTRVJJQUxJWkUgS05PV04gT1BUSU9OU1xuICAgICAgICBmb3IgKGNvbnN0IGtub3duT3B0aW9uS2V5IGluIHRoaXMub3B0aW9uRGVmaW5pdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbkRlZmluaXRpb25zLmhhc093blByb3BlcnR5KGtub3duT3B0aW9uS2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbkRlZmluaXRpb24gPSB0aGlzLm9wdGlvbkRlZmluaXRpb25zW2tub3duT3B0aW9uS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoa25vd25PcHRpb25LZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25WYWx1ZSA9IG9wdGlvbnNba25vd25PcHRpb25LZXldO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJvdG9WYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbkRlZmluaXRpb24ubmVzdGVkT3B0aW9ucyAmJiBpc1BsYWluT2JqZWN0KG9wdGlvblZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVzdGVkVXRpbCA9IG5ldyBPcHRpb25zVXRpbChvcHRpb25EZWZpbml0aW9uLm5lc3RlZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdG9WYWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBWYWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IG5lc3RlZFV0aWwuZ2V0T3B0aW9uc1Byb3RvKGNvbnRleHQsIG9wdGlvblZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3RvVmFsdWUgPSBwYXJzZURhdGEob3B0aW9uVmFsdWUsIGNvbnRleHQpID8/IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvdG9WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga25vd25PcHRpb25zLnNldChGaWVsZFBhdGgkMS5mcm9tU2VydmVyRm9ybWF0KG9wdGlvbkRlZmluaXRpb24uc2VydmVyTmFtZSksIHByb3RvVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrbm93bk9wdGlvbnM7XG4gICAgfVxuICAgIGdldE9wdGlvbnNQcm90byhjb250ZXh0LCBrbm93bk9wdGlvbnMsIG9wdGlvbnNPdmVycmlkZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9nZXRLbm93bk9wdGlvbnMoa25vd25PcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgLy8gQVBQTFkgT1BUSU9OUyBPVkVSUklERVNcbiAgICAgICAgaWYgKG9wdGlvbnNPdmVycmlkZSkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uc01hcCA9IG5ldyBNYXAobWFwVG9BcnJheShvcHRpb25zT3ZlcnJpZGUsICh2YWx1ZSwga2V5KSA9PiBbXG4gICAgICAgICAgICAgICAgRmllbGRQYXRoJDEuZnJvbVNlcnZlckZvcm1hdChrZXkpLFxuICAgICAgICAgICAgICAgIHZhbHVlICE9PSB1bmRlZmluZWQgPyBwYXJzZURhdGEodmFsdWUsIGNvbnRleHQpIDogbnVsbFxuICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgcmVzdWx0LnNldEFsbChvcHRpb25zTWFwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gTWFwVmFsdWUgZnJvbSBgcmVzdWx0YCBvciBlbXB0eSBtYXAgdmFsdWVcbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZS5tYXBWYWx1ZS5maWVsZHMgPz8ge307XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgU3RydWN0dXJlZFBpcGVsaW5lT3B0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoX3VzZXJPcHRpb25zID0ge30sIF9vcHRpb25zT3ZlcnJpZGUgPSB7fSkge1xuICAgICAgICB0aGlzLl91c2VyT3B0aW9ucyA9IF91c2VyT3B0aW9ucztcbiAgICAgICAgdGhpcy5fb3B0aW9uc092ZXJyaWRlID0gX29wdGlvbnNPdmVycmlkZTtcbiAgICAgICAgdGhpcy5vcHRpb25zVXRpbCA9IG5ldyBPcHRpb25zVXRpbCh7XG4gICAgICAgICAgICBpbmRleE1vZGU6IHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJOYW1lOiAnaW5kZXhfbW9kZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9yZWFkVXNlckRhdGEoY29udGV4dCkge1xuICAgICAgICB0aGlzLnByb3RvID0gdGhpcy5vcHRpb25zVXRpbC5nZXRPcHRpb25zUHJvdG8oY29udGV4dCwgdGhpcy5fdXNlck9wdGlvbnMsIHRoaXMuX29wdGlvbnNPdmVycmlkZSk7XG4gICAgfVxufVxuY2xhc3MgU3RydWN0dXJlZFBpcGVsaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihwaXBlbGluZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnBpcGVsaW5lID0gcGlwZWxpbmU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIF90b1Byb3RvKHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpcGVsaW5lOiB0aGlzLnBpcGVsaW5lLl90b1Byb3RvKHNlcmlhbGl6ZXIpLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLnByb3RvXG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBwcml2YXRlXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gKlxuICogUmV0dXJucyB0aGUgYFF1ZXJ5VGFyZ2V0YCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gcXVlcnkuIFJldHVybnMgYG51bGxgXG4gKiBpZiB0aGUgRmlyZXN0b3JlIGNsaWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHF1ZXJ5IGhhcyBub3QgYmVlblxuICogaW5pdGlhbGl6ZWQgb3IgaGFzIGJlZW4gdGVybWluYXRlZC5cbiAqXG4gKiBAcGFyYW0gcXVlcnkgLSBUaGUgUXVlcnkgdG8gY29udmVydCB0byBwcm90byByZXByZXNlbnRhdGlvbi5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIF9pbnRlcm5hbFF1ZXJ5VG9Qcm90b1F1ZXJ5VGFyZ2V0KHF1ZXJ5KSB7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBjbGllbnQuX29ubGluZUNvbXBvbmVudHM/LmRhdGFzdG9yZS5zZXJpYWxpemVyO1xuICAgIGlmIChzZXJpYWxpemVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0b1F1ZXJ5VGFyZ2V0KHNlcmlhbGl6ZXIsIHF1ZXJ5VG9UYXJnZXQocXVlcnkuX3F1ZXJ5KSkucXVlcnlUYXJnZXQ7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHByaXZhdGVcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBSZXR1cm5zIGBSdW5BZ2dyZWdhdGlvblF1ZXJ5UmVxdWVzdGAgd2hpY2ggY29udGFpbnMgdGhlIHByb3RvIHJlcHJlc2VudGF0aW9uXG4gKiBvZiB0aGUgZ2l2ZW4gYWdncmVnYXRpb24gcXVlcnkgcmVxdWVzdC4gUmV0dXJucyBudWxsIGlmIHRoZSBGaXJlc3RvcmUgY2xpZW50XG4gKiBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHF1ZXJ5IGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCBvciBoYXMgYmVlblxuICogdGVybWluYXRlZC5cbiAqXG4gKiBAcGFyYW0gcXVlcnkgLSBUaGUgUXVlcnkgdG8gY29udmVydCB0byBwcm90byByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSBhZ2dyZWdhdGVTcGVjIC0gVGhlIHNldCBvZiBhZ2dyZWdhdGlvbnMgYW5kIHRoZWlyIGFsaWFzZXMuXG4gKi9cbmZ1bmN0aW9uIF9pbnRlcm5hbEFnZ3JlZ2F0aW9uUXVlcnlUb1Byb3RvUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3QocXVlcnksIGFnZ3JlZ2F0ZVNwZWMpIHtcbiAgICBjb25zdCBhZ2dyZWdhdGVzID0gbWFwVG9BcnJheShhZ2dyZWdhdGVTcGVjLCAoYWdncmVnYXRlLCBhbGlhcykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0ZUltcGwoYWxpYXMsIGFnZ3JlZ2F0ZS5hZ2dyZWdhdGVUeXBlLCBhZ2dyZWdhdGUuX2ludGVybmFsRmllbGRQYXRoKTtcbiAgICB9KTtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHF1ZXJ5LmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgY29uc3Qgc2VyaWFsaXplciA9IGNsaWVudC5fb25saW5lQ29tcG9uZW50cz8uZGF0YXN0b3JlLnNlcmlhbGl6ZXI7XG4gICAgaWYgKHNlcmlhbGl6ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRvUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3Qoc2VyaWFsaXplciwgcXVlcnlUb0FnZ3JlZ2F0ZVRhcmdldChxdWVyeS5fcXVlcnkpLCBhZ2dyZWdhdGVzLCBcbiAgICAvKiBza2lwQWxpYXNpbmc9ICovIHRydWUpLnJlcXVlc3Q7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHByaXZhdGVcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBSZXR1cm5zIHRoZSBgRXhlY3V0ZVBpcGVsaW5lUmVxdWVzdGAgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHF1ZXJ5LlxuICogUmV0dXJucyBgbnVsbGAgaWYgdGhlIEZpcmVzdG9yZSBjbGllbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBxdWVyeSBoYXNcbiAqIG5vdCBiZWVuIGluaXRpYWxpemVkIG9yIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gKlxuICogQHBhcmFtIHBpcGVsaW5lIC0gVGhlIFBpcGVsaW5lIHRvIGNvbnZlcnQgdG8gcHJvdG8gcmVwcmVzZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIF9pbnRlcm5hbFBpcGVsaW5lVG9FeGVjdXRlUGlwZWxpbmVSZXF1ZXN0UHJvdG8ocGlwZWxpbmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHBpcGVsaW5lLl9kYiwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBkYXRhc3RvcmUgPSBnZXREYXRhc3RvcmUoZmlyZXN0b3JlKTtcbiAgICBjb25zdCBzZXJpYWxpemVyID0gZGF0YXN0b3JlLnNlcmlhbGl6ZXI7XG4gICAgaWYgKHNlcmlhbGl6ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RydWN0dXJlZFBpcGVsaW5lID0gbmV3IFN0cnVjdHVyZWRQaXBlbGluZShwaXBlbGluZSwgbmV3IFN0cnVjdHVyZWRQaXBlbGluZU9wdGlvbnMoKSk7XG4gICAgY29uc3QgZXhlY3V0ZVBpcGVsaW5lUmVxdWVzdCA9IHtcbiAgICAgICAgZGF0YWJhc2U6IGdldEVuY29kZWREYXRhYmFzZUlkKHNlcmlhbGl6ZXIpLFxuICAgICAgICBzdHJ1Y3R1cmVkUGlwZWxpbmU6IHN0cnVjdHVyZWRQaXBlbGluZS5fdG9Qcm90byhzZXJpYWxpemVyKVxuICAgIH07XG4gICAgcmV0dXJuIGV4ZWN1dGVQaXBlbGluZVJlcXVlc3Q7XG59XG5cbmV4cG9ydCB7IHBhcnNlVXBkYXRlVmFyYXJncyBhcyAkLCBBYnN0cmFjdFVzZXJEYXRhV3JpdGVyIGFzIEEsIEJ5dGVzIGFzIEIsIENvbXBvc2l0ZUZpbHRlciBhcyBDLCBEb2N1bWVudFJlZmVyZW5jZSBhcyBELCBjYXN0IGFzIEUsIEZpcmVzdG9yZSBhcyBGLCBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkIGFzIEcsIG1hcFRvQXJyYXkgYXMgSCwgZmlyZXN0b3JlQ2xpZW50UnVuQWdncmVnYXRlUXVlcnkgYXMgSSwgRXhwVXNlckRhdGFXcml0ZXIgYXMgSiwgdmFsaWRhdGVKU09OIGFzIEssIG5ld1NlcmlhbGl6ZXIgYXMgTCwgY3JlYXRlQnVuZGxlUmVhZGVyU3luYyBhcyBNLCBCdW5kbGVMb2FkZXIgYXMgTiwgT2JqZWN0VmFsdWUgYXMgTywgZnJvbURvY3VtZW50IGFzIFAsIFF1ZXJ5IGFzIFEsIFJlc291cmNlUGF0aCBhcyBSLCBBdXRvSWQgYXMgUywgZnJvbUJ1bmRsZWRRdWVyeSBhcyBULCBEb2N1bWVudFNldCBhcyBVLCBWaWV3U25hcHNob3QgYXMgViwgZG9jdW1lbnRLZXlTZXQgYXMgVywgZmFpbCBhcyBYLCBwYXJzZVNldERhdGEgYXMgWSwgUHJlY29uZGl0aW9uIGFzIFosIEZpZWxkUGF0aCBhcyBfLCBGaXJlYmFzZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIGFzIGEsIGRpc2FibGVOZXR3b3JrIGFzIGEkLCBwYXJzZVVwZGF0ZURhdGEgYXMgYTAsIERlbGV0ZU11dGF0aW9uIGFzIGExLCBmaXJlc3RvcmVDbGllbnRUcmFuc2FjdGlvbiBhcyBhMiwgZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRWaWFTbmFwc2hvdExpc3RlbmVyIGFzIGEzLCBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudEZyb21Mb2NhbENhY2hlIGFzIGE0LCBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNWaWFTbmFwc2hvdExpc3RlbmVyIGFzIGE1LCBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNGcm9tTG9jYWxDYWNoZSBhcyBhNiwgZG9jIGFzIGE3LCBuZXdRdWVyeUZvclBhdGggYXMgYTgsIGZpcmVzdG9yZUNsaWVudExpc3RlbiBhcyBhOSwgdG9UaW1lc3RhbXAgYXMgYUEsIHRvUXVlcnlUYXJnZXQgYXMgYUIsIHF1ZXJ5VG9UYXJnZXQgYXMgYUMsIHBhcnNlT2JqZWN0IGFzIGFELCBDQUNIRV9TSVpFX1VOTElNSVRFRCBhcyBhRSwgQ29sbGVjdGlvblJlZmVyZW5jZSBhcyBhRiwgRmllbGRWYWx1ZSBhcyBhRywgR2VvUG9pbnQgYXMgYUgsIExvYWRCdW5kbGVUYXNrIGFzIGFJLCBWZWN0b3JWYWx1ZSBhcyBhSiwgQnl0ZVN0cmluZyBhcyBhSywgRGF0YWJhc2VJZCBhcyBhTCwgRW1wdHlBcHBDaGVja1Rva2VuUHJvdmlkZXIgYXMgYU0sIEVtcHR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIgYXMgYU4sIEZpZWxkUGF0aCQxIGFzIGFPLCBkZWJ1Z0Fzc2VydCBhcyBhUCwgX2ludGVybmFsQWdncmVnYXRpb25RdWVyeVRvUHJvdG9SdW5BZ2dyZWdhdGlvblF1ZXJ5UmVxdWVzdCBhcyBhUSwgX2ludGVybmFsUXVlcnlUb1Byb3RvUXVlcnlUYXJnZXQgYXMgYVIsIGlzQmFzZTY0QXZhaWxhYmxlIGFzIGFTLCB2YWxpZGF0ZUlzTm90VXNlZFRvZ2V0aGVyIGFzIGFULCBhcnJheVJlbW92ZSBhcyBhVSwgYXJyYXlVbmlvbiBhcyBhViwgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZSBhcyBhVywgY29sbGVjdGlvbiBhcyBhWCwgY29sbGVjdGlvbkdyb3VwIGFzIGFZLCBjb25uZWN0RmlyZXN0b3JlRW11bGF0b3IgYXMgYVosIGRlbGV0ZUZpZWxkIGFzIGFfLCBmaXJlc3RvcmVDbGllbnRBZGRTbmFwc2hvdHNJblN5bmNMaXN0ZW5lciBhcyBhYSwgZmlyZXN0b3JlQ2xpZW50V3JpdGUgYXMgYWIsIGxvZ1dhcm4gYXMgYWMsIGZpcmVzdG9yZUNsaWVudFNldEluZGV4Q29uZmlndXJhdGlvbiBhcyBhZCwgZmllbGRQYXRoRnJvbURvdFNlcGFyYXRlZFN0cmluZyBhcyBhZSwgRmllbGRJbmRleCBhcyBhZiwgSW5kZXhTdGF0ZSBhcyBhZywgZmlyZXN0b3JlQ2xpZW50RGVsZXRlQWxsRmllbGRJbmRleGVzIGFzIGFoLCBsb2dEZWJ1ZyBhcyBhaSwgZmlyZXN0b3JlQ2xpZW50U2V0UGVyc2lzdGVudENhY2hlSW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkIGFzIGFqLCBPcmRlckJ5IGFzIGFrLCBBZ2dyZWdhdGVJbXBsIGFzIGFsLCBPbmxpbmVDb21wb25lbnRQcm92aWRlciBhcyBhbSwgTHJ1R2NNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgYXMgYW4sIE1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlciBhcyBhbywgSW5kZXhlZERiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIGFzIGFwLCBNdWx0aVRhYk9mZmxpbmVDb21wb25lbnRQcm92aWRlciBhcyBhcSwgbG9hZEJ1bmRsZSBhcyBhciwgbmFtZWRRdWVyeSBhcyBhcywgSW5kZXhTZWdtZW50IGFzIGF0LCBzZXRUZXN0aW5nSG9va3NTcGkgYXMgYXUsIFRpbWVzdGFtcCBhcyBhdiwgSnNvblByb3RvU2VyaWFsaXplciBhcyBhdywgVXNlckRhdGFSZWFkZXIgYXMgYXgsIGZyb21UaW1lc3RhbXAgYXMgYXksIHRvTmFtZSBhcyBheiwgRmlyZWJhc2VBcHBDaGVja1Rva2VuUHJvdmlkZXIgYXMgYiwgZG9jdW1lbnRJZCBhcyBiMCwgZW5hYmxlSW5kZXhlZERiUGVyc2lzdGVuY2UgYXMgYjEsIGVuYWJsZU11bHRpVGFiSW5kZXhlZERiUGVyc2lzdGVuY2UgYXMgYjIsIGVuYWJsZU5ldHdvcmsgYXMgYjMsIGdldEZpcmVzdG9yZSBhcyBiNCwgaW5jcmVtZW50IGFzIGI1LCBpbml0aWFsaXplRmlyZXN0b3JlIGFzIGI2LCByZWZFcXVhbCBhcyBiNywgc2VydmVyVGltZXN0YW1wIGFzIGI4LCBzZXRMb2dMZXZlbCBhcyBiOSwgdGVybWluYXRlIGFzIGJhLCB2ZWN0b3IgYXMgYmIsIHdhaXRGb3JQZW5kaW5nV3JpdGVzIGFzIGJjLCBpc1N0cmluZyBhcyBiZCwgRE9DVU1FTlRfS0VZX05BTUUgYXMgYmUsIGhhcmRBc3NlcnQgYXMgYmYsIHBhcnNlRGF0YSBhcyBiZywgdG9TdHJpbmdWYWx1ZSBhcyBiaCwgaXNDb2xsZWN0aW9uUmVmZXJlbmNlIGFzIGJpLCBpc09wdGlvbmFsRXF1YWwgYXMgYmosIGZpcmVzdG9yZUNsaWVudEV4ZWN1dGVQaXBlbGluZSBhcyBiaywgaXNQbGFpbk9iamVjdCBhcyBibCwgaXNEb2N1bWVudFF1ZXJ5JDEgYXMgYm0sIE9wdGlvbnNVdGlsIGFzIGJuLCBpc051bWJlciQxIGFzIGJvLCBTdHJ1Y3R1cmVkUGlwZWxpbmVPcHRpb25zIGFzIGJwLCB0b01hcFZhbHVlIGFzIGJxLCB0b051bWJlciBhcyBiciwgdG9QaXBlbGluZVZhbHVlIGFzIGJzLCBpc1VzZXJEYXRhIGFzIGJ0LCBTdHJ1Y3R1cmVkUGlwZWxpbmUgYXMgYnUsIF9pbnRlcm5hbFBpcGVsaW5lVG9FeGVjdXRlUGlwZWxpbmVSZXF1ZXN0UHJvdG8gYXMgYnYsIG5ld1VzZXJEYXRhUmVhZGVyIGFzIGMsIGRhdGFiYXNlSWRGcm9tQXBwIGFzIGQsIHF1ZXJ5V2l0aEFkZGVkT3JkZXJCeSBhcyBlLCBmaWVsZFBhdGhGcm9tQXJndW1lbnQgYXMgZiwgcXVlcnlXaXRoTGltaXQgYXMgZywgcXVlcnlXaXRoU3RhcnRBdCBhcyBoLCBxdWVyeVdpdGhFbmRBdCBhcyBpLCBGaXJlc3RvcmVFcnJvciBhcyBqLCBDb2RlIGFzIGssIHBhcnNlUXVlcnlWYWx1ZSBhcyBsLCBGaWVsZEZpbHRlciBhcyBtLCBuZXdUZXh0RW5jb2RlciBhcyBuLCBxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5IGFzIG8sIHByb3BlcnR5IGFzIHAsIHF1ZXJ5V2l0aEFkZGVkRmlsdGVyIGFzIHEsIHJlZlZhbHVlIGFzIHIsIHNldFNES1ZlcnNpb24gYXMgcywgaXNTZXJ2ZXJUaW1lc3RhbXAgYXMgdCwgQm91bmQgYXMgdSwgdmFsaWRhdGVQb3NpdGl2ZU51bWJlciBhcyB2LCBpc0NvbGxlY3Rpb25Hcm91cFF1ZXJ5IGFzIHcsIERvY3VtZW50S2V5IGFzIHgsIHZhbHVlRGVzY3JpcHRpb24gYXMgeSwgcXVlcnlFcXVhbCBhcyB6IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24tMjcwZTZhNTAubm9kZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@firebase+firestore@4.11.0_@firebase+app@0.14.8/node_modules/@firebase/firestore/dist/common-270e6a50.node.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@firebase+firestore@4.11.0_@firebase+app@0.14.8/node_modules/@firebase/firestore/dist/index.node.mjs":
/*!*************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@firebase+firestore@4.11.0_@firebase+app@0.14.8/node_modules/@firebase/firestore/dist/index.node.mjs ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractUserDataWriter: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.A),\n/* harmony export */   AggregateField: () => (/* binding */ AggregateField),\n/* harmony export */   AggregateQuerySnapshot: () => (/* binding */ AggregateQuerySnapshot),\n/* harmony export */   Bytes: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.B),\n/* harmony export */   CACHE_SIZE_UNLIMITED: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aE),\n/* harmony export */   CollectionReference: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aF),\n/* harmony export */   DocumentReference: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.D),\n/* harmony export */   DocumentSnapshot: () => (/* binding */ DocumentSnapshot),\n/* harmony export */   FieldPath: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__._),\n/* harmony export */   FieldValue: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aG),\n/* harmony export */   Firestore: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F),\n/* harmony export */   FirestoreError: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j),\n/* harmony export */   GeoPoint: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aH),\n/* harmony export */   LoadBundleTask: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aI),\n/* harmony export */   PersistentCacheIndexManager: () => (/* binding */ PersistentCacheIndexManager),\n/* harmony export */   Query: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Q),\n/* harmony export */   QueryCompositeFilterConstraint: () => (/* binding */ QueryCompositeFilterConstraint),\n/* harmony export */   QueryConstraint: () => (/* binding */ QueryConstraint),\n/* harmony export */   QueryDocumentSnapshot: () => (/* binding */ QueryDocumentSnapshot),\n/* harmony export */   QueryEndAtConstraint: () => (/* binding */ QueryEndAtConstraint),\n/* harmony export */   QueryFieldFilterConstraint: () => (/* binding */ QueryFieldFilterConstraint),\n/* harmony export */   QueryLimitConstraint: () => (/* binding */ QueryLimitConstraint),\n/* harmony export */   QueryOrderByConstraint: () => (/* binding */ QueryOrderByConstraint),\n/* harmony export */   QuerySnapshot: () => (/* binding */ QuerySnapshot),\n/* harmony export */   QueryStartAtConstraint: () => (/* binding */ QueryStartAtConstraint),\n/* harmony export */   SnapshotMetadata: () => (/* binding */ SnapshotMetadata),\n/* harmony export */   Timestamp: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.av),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   VectorValue: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aJ),\n/* harmony export */   WriteBatch: () => (/* binding */ WriteBatch),\n/* harmony export */   _AutoId: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.S),\n/* harmony export */   _ByteString: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aK),\n/* harmony export */   _DatabaseId: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aL),\n/* harmony export */   _DocumentKey: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.x),\n/* harmony export */   _EmptyAppCheckTokenProvider: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aM),\n/* harmony export */   _EmptyAuthCredentialsProvider: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aN),\n/* harmony export */   _FieldPath: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aO),\n/* harmony export */   _TestingHooks: () => (/* binding */ TestingHooks),\n/* harmony export */   _cast: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E),\n/* harmony export */   _debugAssert: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aP),\n/* harmony export */   _internalAggregationQueryToProtoRunAggregationQueryRequest: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aQ),\n/* harmony export */   _internalQueryToProtoQueryTarget: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aR),\n/* harmony export */   _isBase64Available: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aS),\n/* harmony export */   _logWarn: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ac),\n/* harmony export */   _validateIsNotUsedTogether: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aT),\n/* harmony export */   addDoc: () => (/* binding */ addDoc),\n/* harmony export */   aggregateFieldEqual: () => (/* binding */ aggregateFieldEqual),\n/* harmony export */   aggregateQuerySnapshotEqual: () => (/* binding */ aggregateQuerySnapshotEqual),\n/* harmony export */   and: () => (/* binding */ and),\n/* harmony export */   arrayRemove: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aU),\n/* harmony export */   arrayUnion: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aV),\n/* harmony export */   average: () => (/* binding */ average),\n/* harmony export */   clearIndexedDbPersistence: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aW),\n/* harmony export */   collection: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aX),\n/* harmony export */   collectionGroup: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aY),\n/* harmony export */   connectFirestoreEmulator: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aZ),\n/* harmony export */   count: () => (/* binding */ count),\n/* harmony export */   deleteAllPersistentCacheIndexes: () => (/* binding */ deleteAllPersistentCacheIndexes),\n/* harmony export */   deleteDoc: () => (/* binding */ deleteDoc),\n/* harmony export */   deleteField: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a_),\n/* harmony export */   disableNetwork: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a$),\n/* harmony export */   disablePersistentCacheIndexAutoCreation: () => (/* binding */ disablePersistentCacheIndexAutoCreation),\n/* harmony export */   doc: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a7),\n/* harmony export */   documentId: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.b0),\n/* harmony export */   documentSnapshotFromJSON: () => (/* binding */ documentSnapshotFromJSON),\n/* harmony export */   enableIndexedDbPersistence: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.b1),\n/* harmony export */   enableMultiTabIndexedDbPersistence: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.b2),\n/* harmony export */   enableNetwork: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.b3),\n/* harmony export */   enablePersistentCacheIndexAutoCreation: () => (/* binding */ enablePersistentCacheIndexAutoCreation),\n/* harmony export */   endAt: () => (/* binding */ endAt),\n/* harmony export */   endBefore: () => (/* binding */ endBefore),\n/* harmony export */   ensureFirestoreConfigured: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G),\n/* harmony export */   executeWrite: () => (/* binding */ executeWrite),\n/* harmony export */   getAggregateFromServer: () => (/* binding */ getAggregateFromServer),\n/* harmony export */   getCountFromServer: () => (/* binding */ getCountFromServer),\n/* harmony export */   getDoc: () => (/* binding */ getDoc),\n/* harmony export */   getDocFromCache: () => (/* binding */ getDocFromCache),\n/* harmony export */   getDocFromServer: () => (/* binding */ getDocFromServer),\n/* harmony export */   getDocs: () => (/* binding */ getDocs),\n/* harmony export */   getDocsFromCache: () => (/* binding */ getDocsFromCache),\n/* harmony export */   getDocsFromServer: () => (/* binding */ getDocsFromServer),\n/* harmony export */   getFirestore: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.b4),\n/* harmony export */   getPersistentCacheIndexManager: () => (/* binding */ getPersistentCacheIndexManager),\n/* harmony export */   increment: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.b5),\n/* harmony export */   initializeFirestore: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.b6),\n/* harmony export */   limit: () => (/* binding */ limit),\n/* harmony export */   limitToLast: () => (/* binding */ limitToLast),\n/* harmony export */   loadBundle: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ar),\n/* harmony export */   memoryEagerGarbageCollector: () => (/* binding */ memoryEagerGarbageCollector),\n/* harmony export */   memoryLocalCache: () => (/* binding */ memoryLocalCache),\n/* harmony export */   memoryLruGarbageCollector: () => (/* binding */ memoryLruGarbageCollector),\n/* harmony export */   namedQuery: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.as),\n/* harmony export */   onSnapshot: () => (/* binding */ onSnapshot),\n/* harmony export */   onSnapshotResume: () => (/* binding */ onSnapshotResume),\n/* harmony export */   onSnapshotsInSync: () => (/* binding */ onSnapshotsInSync),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   orderBy: () => (/* binding */ orderBy),\n/* harmony export */   persistentLocalCache: () => (/* binding */ persistentLocalCache),\n/* harmony export */   persistentMultipleTabManager: () => (/* binding */ persistentMultipleTabManager),\n/* harmony export */   persistentSingleTabManager: () => (/* binding */ persistentSingleTabManager),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   queryEqual: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.z),\n/* harmony export */   querySnapshotFromJSON: () => (/* binding */ querySnapshotFromJSON),\n/* harmony export */   refEqual: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.b7),\n/* harmony export */   runTransaction: () => (/* binding */ runTransaction),\n/* harmony export */   serverTimestamp: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.b8),\n/* harmony export */   setDoc: () => (/* binding */ setDoc),\n/* harmony export */   setIndexConfiguration: () => (/* binding */ setIndexConfiguration),\n/* harmony export */   setLogLevel: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.b9),\n/* harmony export */   snapshotEqual: () => (/* binding */ snapshotEqual),\n/* harmony export */   startAfter: () => (/* binding */ startAfter),\n/* harmony export */   startAt: () => (/* binding */ startAt),\n/* harmony export */   sum: () => (/* binding */ sum),\n/* harmony export */   terminate: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ba),\n/* harmony export */   updateDoc: () => (/* binding */ updateDoc),\n/* harmony export */   vector: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.bb),\n/* harmony export */   waitForPendingWrites: () => (/* reexport safe */ _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.bc),\n/* harmony export */   where: () => (/* binding */ where),\n/* harmony export */   writeBatch: () => (/* binding */ writeBatch)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/../../node_modules/.pnpm/@firebase+app@0.14.8/node_modules/@firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/../../node_modules/.pnpm/@firebase+component@0.7.0/node_modules/@firebase/component/dist/esm/index.esm.js\");\n/* harmony import */ var _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common-270e6a50.node.mjs */ \"(ssr)/../../node_modules/.pnpm/@firebase+firestore@4.11.0_@firebase+app@0.14.8/node_modules/@firebase/firestore/dist/common-270e6a50.node.mjs\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/../../node_modules/.pnpm/@firebase+util@1.13.0/node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/webchannel-wrapper/bloom-blob */ \"(ssr)/../../node_modules/.pnpm/@firebase+webchannel-wrapper@1.0.5/node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/../../node_modules/.pnpm/@firebase+logger@0.5.0/node_modules/@firebase/logger/dist/esm/index.esm.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @grpc/grpc-js */ \"(ssr)/../../node_modules/.pnpm/@grpc+grpc-js@1.9.15/node_modules/@grpc/grpc-js/build/src/index.js\");\n/* harmony import */ var _grpc_proto_loader__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @grpc/proto-loader */ \"(ssr)/../../node_modules/.pnpm/@grpc+proto-loader@0.7.15/node_modules/@grpc/proto-loader/build/src/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst name$1 = \"@firebase/firestore\";\nconst version = \"4.11.0\";\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction registerFirestore(variant, useFetchStreams = true) {\n    (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.s)(_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION);\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component('firestore', (container, { instanceIdentifier: databaseId, options: settings }) => {\n        const app = container.getProvider('app').getImmediate();\n        const firestoreInstance = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F(new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a(container.getProvider('auth-internal')), new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.b(app, container.getProvider('app-check-internal')), (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.d)(app, databaseId), app);\n        settings = { useFetchStreams, ...settings };\n        firestoreInstance._setSettings(settings);\n        return firestoreInstance;\n    }, 'PUBLIC').setMultipleInstances(true));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name$1, version, variant);\n    // BUILD_TARGET will be replaced by values like esm, cjs, etc during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name$1, version, 'esm2020');\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents an aggregation that can be performed by Firestore.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nclass AggregateField {\n    /**\n     * Create a new AggregateField<T>\n     * @param aggregateType - Specifies the type of aggregation operation to perform.\n     * @param _internalFieldPath - Optionally specifies the field that is aggregated.\n     * @internal\n     */\n    constructor(aggregateType = 'count', _internalFieldPath) {\n        this._internalFieldPath = _internalFieldPath;\n        /** A type string to uniquely identify instances of this class. */\n        this.type = 'AggregateField';\n        this.aggregateType = aggregateType;\n    }\n}\n/**\n * The results of executing an aggregation query.\n */\nclass AggregateQuerySnapshot {\n    /** @hideconstructor */\n    constructor(query, _userDataWriter, _data) {\n        this._userDataWriter = _userDataWriter;\n        this._data = _data;\n        /** A type string to uniquely identify instances of this class. */\n        this.type = 'AggregateQuerySnapshot';\n        this.query = query;\n    }\n    /**\n     * Returns the results of the aggregations performed over the underlying\n     * query.\n     *\n     * The keys of the returned object will be the same as those of the\n     * `AggregateSpec` object specified to the aggregation method, and the values\n     * will be the corresponding aggregation result.\n     *\n     * @returns The results of the aggregations performed over the underlying\n     * query.\n     */\n    data() {\n        return this._userDataWriter.convertObjectMap(this._data);\n    }\n    /**\n     * @internal\n     * @private\n     *\n     * Retrieves all fields in the snapshot as a proto value.\n     *\n     * @returns An `Object` containing all fields in the snapshot.\n     */\n    _fieldsProto() {\n        // Wrap data in an ObjectValue to clone it.\n        const dataClone = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.O({\n            mapValue: { fields: this._data }\n        }).clone();\n        // Return the cloned value to prevent manipulation of the Snapshot's data\n        return dataClone.value.mapValue.fields;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `DocumentSnapshot` contains data read from a document in your Firestore\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\n * get a specific field.\n *\n * For a `DocumentSnapshot` that points to a non-existing document, any data\n * access will return 'undefined'. You can use the `exists()` method to\n * explicitly verify a document's existence.\n */\nclass DocumentSnapshot$1 {\n    // Note: This class is stripped down version of the DocumentSnapshot in\n    // the legacy SDK. The changes are:\n    // - No support for SnapshotMetadata.\n    // - No support for SnapshotOptions.\n    /** @hideconstructor protected */\n    constructor(_firestore, _userDataWriter, _key, _document, _converter) {\n        this._firestore = _firestore;\n        this._userDataWriter = _userDataWriter;\n        this._key = _key;\n        this._document = _document;\n        this._converter = _converter;\n    }\n    /** Property of the `DocumentSnapshot` that provides the document's ID. */\n    get id() {\n        return this._key.path.lastSegment();\n    }\n    /**\n     * The `DocumentReference` for the document included in the `DocumentSnapshot`.\n     */\n    get ref() {\n        return new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.D(this._firestore, this._converter, this._key);\n    }\n    /**\n     * Signals whether or not the document at the snapshot's location exists.\n     *\n     * @returns true if the document exists.\n     */\n    exists() {\n        return this._document !== null;\n    }\n    /**\n     * Retrieves all fields in the document as an `Object`. Returns `undefined` if\n     * the document doesn't exist.\n     *\n     * @returns An `Object` containing all fields in the document or `undefined`\n     * if the document doesn't exist.\n     */\n    data() {\n        if (!this._document) {\n            return undefined;\n        }\n        else if (this._converter) {\n            // We only want to use the converter and create a new DocumentSnapshot\n            // if a converter has been provided.\n            const snapshot = new QueryDocumentSnapshot$1(this._firestore, this._userDataWriter, this._key, this._document, \n            /* converter= */ null);\n            return this._converter.fromFirestore(snapshot);\n        }\n        else {\n            return this._userDataWriter.convertValue(this._document.data.value);\n        }\n    }\n    /**\n     * @internal\n     * @private\n     *\n     * Retrieves all fields in the document as a proto Value. Returns `undefined` if\n     * the document doesn't exist.\n     *\n     * @returns An `Object` containing all fields in the document or `undefined`\n     * if the document doesn't exist.\n     */\n    _fieldsProto() {\n        // Return a cloned value to prevent manipulation of the Snapshot's data\n        return this._document?.data.clone().value.mapValue.fields ?? undefined;\n    }\n    /**\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\n     * document or field doesn't exist.\n     *\n     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\n     * field.\n     * @returns The data at the specified field location or undefined if no such\n     * field exists in the document.\n     */\n    // We are using `any` here to avoid an explicit cast by our users.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(fieldPath) {\n        if (this._document) {\n            const value = this._document.data.field((0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.f)('DocumentSnapshot.get', fieldPath));\n            if (value !== null) {\n                return this._userDataWriter.convertValue(value);\n            }\n        }\n        return undefined;\n    }\n}\n/**\n * A `QueryDocumentSnapshot` contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\n * specific field.\n *\n * A `QueryDocumentSnapshot` offers the same API surface as a\n * `DocumentSnapshot`. Since query results contain only existing documents, the\n * `exists` property will always be true and `data()` will never return\n * 'undefined'.\n */\nclass QueryDocumentSnapshot$1 extends DocumentSnapshot$1 {\n    /**\n     * Retrieves all fields in the document as an `Object`.\n     *\n     * @override\n     * @returns An `Object` containing all fields in the document.\n     */\n    data() {\n        return super.data();\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction validateHasExplicitOrderByForLimitToLast(query) {\n    if (query.limitType === \"L\" /* LimitType.Last */ &&\n        query.explicitOrderBy.length === 0) {\n        throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.UNIMPLEMENTED, 'limitToLast() queries require specifying at least one orderBy() clause');\n    }\n}\n/**\n * An `AppliableConstraint` is an abstraction of a constraint that can be applied\n * to a Firestore query.\n */\nclass AppliableConstraint {\n}\n/**\n * A `QueryConstraint` is used to narrow the set of documents returned by a\n * Firestore query. `QueryConstraint`s are created by invoking {@link where},\n * {@link orderBy}, {@link (startAt:1)}, {@link (startAfter:1)}, {@link\n * (endBefore:1)}, {@link (endAt:1)}, {@link limit}, {@link limitToLast} and\n * can then be passed to {@link (query:1)} to create a new query instance that\n * also contains this `QueryConstraint`.\n */\nclass QueryConstraint extends AppliableConstraint {\n}\nfunction query(query, queryConstraint, ...additionalQueryConstraints) {\n    let queryConstraints = [];\n    if (queryConstraint instanceof AppliableConstraint) {\n        queryConstraints.push(queryConstraint);\n    }\n    queryConstraints = queryConstraints.concat(additionalQueryConstraints);\n    validateQueryConstraintArray(queryConstraints);\n    for (const constraint of queryConstraints) {\n        query = constraint._apply(query);\n    }\n    return query;\n}\n/**\n * A `QueryFieldFilterConstraint` is used to narrow the set of documents returned by\n * a Firestore query by filtering on one or more document fields.\n * `QueryFieldFilterConstraint`s are created by invoking {@link where} and can then\n * be passed to {@link (query:1)} to create a new query instance that also contains\n * this `QueryFieldFilterConstraint`.\n */\nclass QueryFieldFilterConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(_field, _op, _value) {\n        super();\n        this._field = _field;\n        this._op = _op;\n        this._value = _value;\n        /** The type of this query constraint */\n        this.type = 'where';\n    }\n    static _create(_field, _op, _value) {\n        return new QueryFieldFilterConstraint(_field, _op, _value);\n    }\n    _apply(query) {\n        const filter = this._parse(query);\n        validateNewFieldFilter(query._query, filter);\n        return new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Q(query.firestore, query.converter, (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.q)(query._query, filter));\n    }\n    _parse(query) {\n        const reader = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(query.firestore);\n        const filter = newQueryFilter(query._query, 'where', reader, query.firestore._databaseId, this._field, this._op, this._value);\n        return filter;\n    }\n}\n/**\n * Creates a {@link QueryFieldFilterConstraint} that enforces that documents\n * must contain the specified field and that the value should satisfy the\n * relation constraint provided.\n *\n * @param fieldPath - The path to compare\n * @param opStr - The operation string (e.g \"&lt;\", \"&lt;=\", \"==\", \"&lt;\",\n *   \"&lt;=\", \"!=\").\n * @param value - The value for comparison\n * @returns The created {@link QueryFieldFilterConstraint}.\n */\nfunction where(fieldPath, opStr, value) {\n    const op = opStr;\n    const field = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.f)('where', fieldPath);\n    return QueryFieldFilterConstraint._create(field, op, value);\n}\n/**\n * A `QueryCompositeFilterConstraint` is used to narrow the set of documents\n * returned by a Firestore query by performing the logical OR or AND of multiple\n * {@link QueryFieldFilterConstraint}s or {@link QueryCompositeFilterConstraint}s.\n * `QueryCompositeFilterConstraint`s are created by invoking {@link or} or\n * {@link and} and can then be passed to {@link (query:1)} to create a new query\n * instance that also contains the `QueryCompositeFilterConstraint`.\n */\nclass QueryCompositeFilterConstraint extends AppliableConstraint {\n    /**\n     * @internal\n     */\n    constructor(\n    /** The type of this query constraint */\n    type, _queryConstraints) {\n        super();\n        this.type = type;\n        this._queryConstraints = _queryConstraints;\n    }\n    static _create(type, _queryConstraints) {\n        return new QueryCompositeFilterConstraint(type, _queryConstraints);\n    }\n    _parse(query) {\n        const parsedFilters = this._queryConstraints\n            .map(queryConstraint => {\n            return queryConstraint._parse(query);\n        })\n            .filter(parsedFilter => parsedFilter.getFilters().length > 0);\n        if (parsedFilters.length === 1) {\n            return parsedFilters[0];\n        }\n        return _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.C.create(parsedFilters, this._getOperator());\n    }\n    _apply(query) {\n        const parsedFilter = this._parse(query);\n        if (parsedFilter.getFilters().length === 0) {\n            // Return the existing query if not adding any more filters (e.g. an empty\n            // composite filter).\n            return query;\n        }\n        validateNewFilter(query._query, parsedFilter);\n        return new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Q(query.firestore, query.converter, (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.q)(query._query, parsedFilter));\n    }\n    _getQueryConstraints() {\n        return this._queryConstraints;\n    }\n    _getOperator() {\n        return this.type === 'and' ? \"and\" /* CompositeOperator.AND */ : \"or\" /* CompositeOperator.OR */;\n    }\n}\n/**\n * Creates a new {@link QueryCompositeFilterConstraint} that is a disjunction of\n * the given filter constraints. A disjunction filter includes a document if it\n * satisfies any of the given filters.\n *\n * @param queryConstraints - Optional. The list of\n * {@link QueryFilterConstraint}s to perform a disjunction for. These must be\n * created with calls to {@link where}, {@link or}, or {@link and}.\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\n */\nfunction or(...queryConstraints) {\n    // Only support QueryFilterConstraints\n    queryConstraints.forEach(queryConstraint => validateQueryFilterConstraint('or', queryConstraint));\n    return QueryCompositeFilterConstraint._create(\"or\" /* CompositeOperator.OR */, queryConstraints);\n}\n/**\n * Creates a new {@link QueryCompositeFilterConstraint} that is a conjunction of\n * the given filter constraints. A conjunction filter includes a document if it\n * satisfies all of the given filters.\n *\n * @param queryConstraints - Optional. The list of\n * {@link QueryFilterConstraint}s to perform a conjunction for. These must be\n * created with calls to {@link where}, {@link or}, or {@link and}.\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\n */\nfunction and(...queryConstraints) {\n    // Only support QueryFilterConstraints\n    queryConstraints.forEach(queryConstraint => validateQueryFilterConstraint('and', queryConstraint));\n    return QueryCompositeFilterConstraint._create(\"and\" /* CompositeOperator.AND */, queryConstraints);\n}\n/**\n * A `QueryOrderByConstraint` is used to sort the set of documents returned by a\n * Firestore query. `QueryOrderByConstraint`s are created by invoking\n * {@link orderBy} and can then be passed to {@link (query:1)} to create a new query\n * instance that also contains this `QueryOrderByConstraint`.\n *\n * Note: Documents that do not contain the orderBy field will not be present in\n * the query result.\n */\nclass QueryOrderByConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(_field, _direction) {\n        super();\n        this._field = _field;\n        this._direction = _direction;\n        /** The type of this query constraint */\n        this.type = 'orderBy';\n    }\n    static _create(_field, _direction) {\n        return new QueryOrderByConstraint(_field, _direction);\n    }\n    _apply(query) {\n        const orderBy = newQueryOrderBy(query._query, this._field, this._direction);\n        return new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Q(query.firestore, query.converter, (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(query._query, orderBy));\n    }\n}\n/**\n * Creates a {@link QueryOrderByConstraint} that sorts the query result by the\n * specified field, optionally in descending order instead of ascending.\n *\n * Note: Documents that do not contain the specified field will not be present\n * in the query result.\n *\n * @param fieldPath - The field to sort by.\n * @param directionStr - Optional direction to sort by ('asc' or 'desc'). If\n * not specified, order will be ascending.\n * @returns The created {@link QueryOrderByConstraint}.\n */\nfunction orderBy(fieldPath, directionStr = 'asc') {\n    const direction = directionStr;\n    const path = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.f)('orderBy', fieldPath);\n    return QueryOrderByConstraint._create(path, direction);\n}\n/**\n * A `QueryLimitConstraint` is used to limit the number of documents returned by\n * a Firestore query.\n * `QueryLimitConstraint`s are created by invoking {@link limit} or\n * {@link limitToLast} and can then be passed to {@link (query:1)} to create a new\n * query instance that also contains this `QueryLimitConstraint`.\n */\nclass QueryLimitConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(\n    /** The type of this query constraint */\n    type, _limit, _limitType) {\n        super();\n        this.type = type;\n        this._limit = _limit;\n        this._limitType = _limitType;\n    }\n    static _create(type, _limit, _limitType) {\n        return new QueryLimitConstraint(type, _limit, _limitType);\n    }\n    _apply(query) {\n        return new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Q(query.firestore, query.converter, (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.g)(query._query, this._limit, this._limitType));\n    }\n}\n/**\n * Creates a {@link QueryLimitConstraint} that only returns the first matching\n * documents.\n *\n * @param limit - The maximum number of items to return.\n * @returns The created {@link QueryLimitConstraint}.\n */\nfunction limit(limit) {\n    (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.v)('limit', limit);\n    return QueryLimitConstraint._create('limit', limit, \"F\" /* LimitType.First */);\n}\n/**\n * Creates a {@link QueryLimitConstraint} that only returns the last matching\n * documents.\n *\n * You must specify at least one `orderBy` clause for `limitToLast` queries,\n * otherwise an exception will be thrown during execution.\n *\n * @param limit - The maximum number of items to return.\n * @returns The created {@link QueryLimitConstraint}.\n */\nfunction limitToLast(limit) {\n    (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.v)('limitToLast', limit);\n    return QueryLimitConstraint._create('limitToLast', limit, \"L\" /* LimitType.Last */);\n}\n/**\n * A `QueryStartAtConstraint` is used to exclude documents from the start of a\n * result set returned by a Firestore query.\n * `QueryStartAtConstraint`s are created by invoking {@link (startAt:1)} or\n * {@link (startAfter:1)} and can then be passed to {@link (query:1)} to create a\n * new query instance that also contains this `QueryStartAtConstraint`.\n */\nclass QueryStartAtConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(\n    /** The type of this query constraint */\n    type, _docOrFields, _inclusive) {\n        super();\n        this.type = type;\n        this._docOrFields = _docOrFields;\n        this._inclusive = _inclusive;\n    }\n    static _create(type, _docOrFields, _inclusive) {\n        return new QueryStartAtConstraint(type, _docOrFields, _inclusive);\n    }\n    _apply(query) {\n        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);\n        return new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Q(query.firestore, query.converter, (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.h)(query._query, bound));\n    }\n}\nfunction startAt(...docOrFields) {\n    return QueryStartAtConstraint._create('startAt', docOrFields, \n    /*inclusive=*/ true);\n}\nfunction startAfter(...docOrFields) {\n    return QueryStartAtConstraint._create('startAfter', docOrFields, \n    /*inclusive=*/ false);\n}\n/**\n * A `QueryEndAtConstraint` is used to exclude documents from the end of a\n * result set returned by a Firestore query.\n * `QueryEndAtConstraint`s are created by invoking {@link (endAt:1)} or\n * {@link (endBefore:1)} and can then be passed to {@link (query:1)} to create a new\n * query instance that also contains this `QueryEndAtConstraint`.\n */\nclass QueryEndAtConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(\n    /** The type of this query constraint */\n    type, _docOrFields, _inclusive) {\n        super();\n        this.type = type;\n        this._docOrFields = _docOrFields;\n        this._inclusive = _inclusive;\n    }\n    static _create(type, _docOrFields, _inclusive) {\n        return new QueryEndAtConstraint(type, _docOrFields, _inclusive);\n    }\n    _apply(query) {\n        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);\n        return new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Q(query.firestore, query.converter, (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.i)(query._query, bound));\n    }\n}\nfunction endBefore(...docOrFields) {\n    return QueryEndAtConstraint._create('endBefore', docOrFields, \n    /*inclusive=*/ false);\n}\nfunction endAt(...docOrFields) {\n    return QueryEndAtConstraint._create('endAt', docOrFields, \n    /*inclusive=*/ true);\n}\n/** Helper function to create a bound from a document or fields */\nfunction newQueryBoundFromDocOrFields(query, methodName, docOrFields, inclusive) {\n    docOrFields[0] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(docOrFields[0]);\n    if (docOrFields[0] instanceof DocumentSnapshot$1) {\n        return newQueryBoundFromDocument(query._query, query.firestore._databaseId, methodName, docOrFields[0]._document, inclusive);\n    }\n    else {\n        const reader = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(query.firestore);\n        return newQueryBoundFromFields(query._query, query.firestore._databaseId, reader, methodName, docOrFields, inclusive);\n    }\n}\nfunction newQueryFilter(query, methodName, dataReader, databaseId, fieldPath, op, value) {\n    let fieldValue;\n    if (fieldPath.isKeyField()) {\n        if (op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ || op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\n            throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, `Invalid Query. You can't perform '${op}' queries on documentId().`);\n        }\n        else if (op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */) {\n            validateDisjunctiveFilterElements(value, op);\n            const referenceList = [];\n            for (const arrayValue of value) {\n                referenceList.push(parseDocumentIdValue(databaseId, query, arrayValue));\n            }\n            fieldValue = { arrayValue: { values: referenceList } };\n        }\n        else {\n            fieldValue = parseDocumentIdValue(databaseId, query, value);\n        }\n    }\n    else {\n        if (op === \"in\" /* Operator.IN */ ||\n            op === \"not-in\" /* Operator.NOT_IN */ ||\n            op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\n            validateDisjunctiveFilterElements(value, op);\n        }\n        fieldValue = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.l)(dataReader, methodName, value, \n        /* allowArrays= */ op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */);\n    }\n    const filter = _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.m.create(fieldPath, op, fieldValue);\n    return filter;\n}\nfunction newQueryOrderBy(query, fieldPath, direction) {\n    if (query.startAt !== null) {\n        throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, 'Invalid query. You must not call startAt() or startAfter() before ' +\n            'calling orderBy().');\n    }\n    if (query.endAt !== null) {\n        throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, 'Invalid query. You must not call endAt() or endBefore() before ' +\n            'calling orderBy().');\n    }\n    const orderBy = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ak(fieldPath, direction);\n    return orderBy;\n}\n/**\n * Create a `Bound` from a query and a document.\n *\n * Note that the `Bound` will always include the key of the document\n * and so only the provided document will compare equal to the returned\n * position.\n *\n * Will throw if the document does not contain all fields of the order by\n * of the query or if any of the fields in the order by are an uncommitted\n * server timestamp.\n */\nfunction newQueryBoundFromDocument(query, databaseId, methodName, doc, inclusive) {\n    if (!doc) {\n        throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ` +\n            `${methodName}().`);\n    }\n    const components = [];\n    // Because people expect to continue/end a query at the exact document\n    // provided, we need to use the implicit sort order rather than the explicit\n    // sort order, because it's guaranteed to contain the document key. That way\n    // the position becomes unambiguous and the query continues/ends exactly at\n    // the provided document. Without the key (by using the explicit sort\n    // orders), multiple documents could match the position, yielding duplicate\n    // results.\n    for (const orderBy of (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.o)(query)) {\n        if (orderBy.field.isKeyField()) {\n            components.push((0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.r)(databaseId, doc.key));\n        }\n        else {\n            const value = doc.data.field(orderBy.field);\n            if ((0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.t)(value)) {\n                throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a ' +\n                    'document for which the field \"' +\n                    orderBy.field +\n                    '\" is an uncommitted server timestamp. (Since the value of ' +\n                    'this field is unknown, you cannot start/end a query with it.)');\n            }\n            else if (value !== null) {\n                components.push(value);\n            }\n            else {\n                const field = orderBy.field.canonicalString();\n                throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a ` +\n                    `document for which the field '${field}' (used as the ` +\n                    `orderBy) does not exist.`);\n            }\n        }\n    }\n    return new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.u(components, inclusive);\n}\n/**\n * Converts a list of field values to a `Bound` for the given query.\n */\nfunction newQueryBoundFromFields(query, databaseId, dataReader, methodName, values, inclusive) {\n    // Use explicit order by's because it has to match the query the user made\n    const orderBy = query.explicitOrderBy;\n    if (values.length > orderBy.length) {\n        throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, `Too many arguments provided to ${methodName}(). ` +\n            `The number of arguments must be less than or equal to the ` +\n            `number of orderBy() clauses`);\n    }\n    const components = [];\n    for (let i = 0; i < values.length; i++) {\n        const rawValue = values[i];\n        const orderByComponent = orderBy[i];\n        if (orderByComponent.field.isKeyField()) {\n            if (typeof rawValue !== 'string') {\n                throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ` +\n                    `${methodName}(), but got a ${typeof rawValue}`);\n            }\n            if (!(0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.w)(query) && rawValue.indexOf('/') !== -1) {\n                throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), ` +\n                    `the value passed to ${methodName}() must be a plain document ID, but ` +\n                    `'${rawValue}' contains a slash.`);\n            }\n            const path = query.path.child(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.R.fromString(rawValue));\n            if (!_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.x.isDocumentKey(path)) {\n                throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by ` +\n                    `documentId(), the value passed to ${methodName}() must result in a ` +\n                    `valid document path, but '${path}' is not because it contains an odd number ` +\n                    `of segments.`);\n            }\n            const key = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.x(path);\n            components.push((0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.r)(databaseId, key));\n        }\n        else {\n            const wrapped = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.l)(dataReader, methodName, rawValue);\n            components.push(wrapped);\n        }\n    }\n    return new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.u(components, inclusive);\n}\n/**\n * Parses the given `documentIdValue` into a `ReferenceValue`, throwing\n * appropriate errors if the value is anything other than a `DocumentReference`\n * or `string`, or if the string is malformed.\n */\nfunction parseDocumentIdValue(databaseId, query, documentIdValue) {\n    documentIdValue = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(documentIdValue);\n    if (typeof documentIdValue === 'string') {\n        if (documentIdValue === '') {\n            throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, 'Invalid query. When querying with documentId(), you ' +\n                'must provide a valid document ID, but it was an empty string.');\n        }\n        if (!(0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.w)(query) && documentIdValue.indexOf('/') !== -1) {\n            throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, `Invalid query. When querying a collection by ` +\n                `documentId(), you must provide a plain document ID, but ` +\n                `'${documentIdValue}' contains a '/' character.`);\n        }\n        const path = query.path.child(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.R.fromString(documentIdValue));\n        if (!_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.x.isDocumentKey(path)) {\n            throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, `Invalid query. When querying a collection group by ` +\n                `documentId(), the value provided must result in a valid document path, ` +\n                `but '${path}' is not because it has an odd number of segments (${path.length}).`);\n        }\n        return (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.r)(databaseId, new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.x(path));\n    }\n    else if (documentIdValue instanceof _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.D) {\n        return (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.r)(databaseId, documentIdValue._key);\n    }\n    else {\n        throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid ` +\n            `string or a DocumentReference, but it was: ` +\n            `${(0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.y)(documentIdValue)}.`);\n    }\n}\n/**\n * Validates that the value passed into a disjunctive filter satisfies all\n * array requirements.\n */\nfunction validateDisjunctiveFilterElements(value, operator) {\n    if (!Array.isArray(value) || value.length === 0) {\n        throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, 'Invalid Query. A non-empty array is required for ' +\n            `'${operator.toString()}' filters.`);\n    }\n}\n/**\n * Given an operator, returns the set of operators that cannot be used with it.\n *\n * This is not a comprehensive check, and this function should be removed in the\n * long term. Validations should occur in the Firestore backend.\n *\n * Operators in a query must adhere to the following set of rules:\n * 1. Only one inequality per query.\n * 2. `NOT_IN` cannot be used with array, disjunctive, or `NOT_EQUAL` operators.\n */\nfunction conflictingOps(op) {\n    switch (op) {\n        case \"!=\" /* Operator.NOT_EQUAL */:\n            return [\"!=\" /* Operator.NOT_EQUAL */, \"not-in\" /* Operator.NOT_IN */];\n        case \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */:\n        case \"in\" /* Operator.IN */:\n            return [\"not-in\" /* Operator.NOT_IN */];\n        case \"not-in\" /* Operator.NOT_IN */:\n            return [\n                \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */,\n                \"in\" /* Operator.IN */,\n                \"not-in\" /* Operator.NOT_IN */,\n                \"!=\" /* Operator.NOT_EQUAL */\n            ];\n        default:\n            return [];\n    }\n}\nfunction validateNewFieldFilter(query, fieldFilter) {\n    const conflictingOp = findOpInsideFilters(query.filters, conflictingOps(fieldFilter.op));\n    if (conflictingOp !== null) {\n        // Special case when it's a duplicate op to give a slightly clearer error message.\n        if (conflictingOp === fieldFilter.op) {\n            throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, 'Invalid query. You cannot use more than one ' +\n                `'${fieldFilter.op.toString()}' filter.`);\n        }\n        else {\n            throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, `Invalid query. You cannot use '${fieldFilter.op.toString()}' filters ` +\n                `with '${conflictingOp.toString()}' filters.`);\n        }\n    }\n}\nfunction validateNewFilter(query, filter) {\n    let testQuery = query;\n    const subFilters = filter.getFlattenedFilters();\n    for (const subFilter of subFilters) {\n        validateNewFieldFilter(testQuery, subFilter);\n        testQuery = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.q)(testQuery, subFilter);\n    }\n}\n// Checks if any of the provided filter operators are included in the given list of filters and\n// returns the first one that is, or null if none are.\nfunction findOpInsideFilters(filters, operators) {\n    for (const filter of filters) {\n        for (const fieldFilter of filter.getFlattenedFilters()) {\n            if (operators.indexOf(fieldFilter.op) >= 0) {\n                return fieldFilter.op;\n            }\n        }\n    }\n    return null;\n}\nfunction validateQueryFilterConstraint(functionName, queryConstraint) {\n    if (!(queryConstraint instanceof QueryFieldFilterConstraint) &&\n        !(queryConstraint instanceof QueryCompositeFilterConstraint)) {\n        throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, `Function ${functionName}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`);\n    }\n}\nfunction validateQueryConstraintArray(queryConstraint) {\n    const compositeFilterCount = queryConstraint.filter(filter => filter instanceof QueryCompositeFilterConstraint).length;\n    const fieldFilterCount = queryConstraint.filter(filter => filter instanceof QueryFieldFilterConstraint).length;\n    if (compositeFilterCount > 1 ||\n        (compositeFilterCount > 0 && fieldFilterCount > 0)) {\n        throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, 'InvalidQuery. When using composite filters, you cannot use ' +\n            'more than one filter at the top level. Consider nesting the multiple ' +\n            'filters within an `and(...)` statement. For example: ' +\n            'change `query(query, where(...), or(...))` to ' +\n            '`query(query, and(where(...), or(...)))`.');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Converts custom model object of type T into `DocumentData` by applying the\n * converter if it exists.\n *\n * This function is used when converting user objects to `DocumentData`\n * because we want to provide the user with a more specific error message if\n * their `set()` or fails due to invalid data originating from a `toFirestore()`\n * call.\n */\nfunction applyFirestoreDataConverter(converter, value, options) {\n    let convertedValue;\n    if (converter) {\n        if (options && (options.merge || options.mergeFields)) {\n            // Cast to `any` in order to satisfy the union type constraint on\n            // toFirestore().\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            convertedValue = converter.toFirestore(value, options);\n        }\n        else {\n            convertedValue = converter.toFirestore(value);\n        }\n    }\n    else {\n        convertedValue = value;\n    }\n    return convertedValue;\n}\nclass LiteUserDataWriter extends _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.A {\n    constructor(firestore) {\n        super();\n        this.firestore = firestore;\n    }\n    convertBytes(bytes) {\n        return new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.B(bytes);\n    }\n    convertReference(name) {\n        const key = this.convertDocumentKey(name, this.firestore._databaseId);\n        return new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.D(this.firestore, /* converter= */ null, key);\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Create an AggregateField object that can be used to compute the sum of\n * a specified field over a range of documents in the result set of a query.\n * @param field - Specifies the field to sum across the result set.\n */\nfunction sum(field) {\n    return new AggregateField('sum', (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.f)('sum', field));\n}\n/**\n * Create an AggregateField object that can be used to compute the average of\n * a specified field over a range of documents in the result set of a query.\n * @param field - Specifies the field to average across the result set.\n */\nfunction average(field) {\n    return new AggregateField('avg', (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.f)('average', field));\n}\n/**\n * Create an AggregateField object that can be used to compute the count of\n * documents in the result set of a query.\n */\nfunction count() {\n    return new AggregateField('count');\n}\n/**\n * Compares two 'AggregateField` instances for equality.\n *\n * @param left - Compare this AggregateField to the `right`.\n * @param right - Compare this AggregateField to the `left`.\n */\nfunction aggregateFieldEqual(left, right) {\n    return (left instanceof AggregateField &&\n        right instanceof AggregateField &&\n        left.aggregateType === right.aggregateType &&\n        left._internalFieldPath?.canonicalString() ===\n            right._internalFieldPath?.canonicalString());\n}\n/**\n * Compares two `AggregateQuerySnapshot` instances for equality.\n *\n * Two `AggregateQuerySnapshot` instances are considered \"equal\" if they have\n * underlying queries that compare equal, and the same data.\n *\n * @param left - The first `AggregateQuerySnapshot` to compare.\n * @param right - The second `AggregateQuerySnapshot` to compare.\n *\n * @returns `true` if the objects are \"equal\", as defined above, or `false`\n * otherwise.\n */\nfunction aggregateQuerySnapshotEqual(left, right) {\n    return ((0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.z)(left.query, right.query) && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.deepEqual)(left.data(), right.data()));\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Calculates the number of documents in the result set of the given query\n * without actually downloading the documents.\n *\n * Using this function to count the documents is efficient because only the\n * final count, not the documents' data, is downloaded. This function can\n * count the documents in cases where the result set is prohibitively large to\n * download entirely (thousands of documents).\n *\n * The result received from the server is presented, unaltered, without\n * considering any local state. That is, documents in the local cache are not\n * taken into consideration, neither are local modifications not yet\n * synchronized with the server. Previously-downloaded results, if any, are not\n * used. Every invocation of this function necessarily involves a round trip to\n * the server.\n *\n * @param query - The query whose result set size is calculated.\n * @returns A Promise that will be resolved with the count; the count can be\n * retrieved from `snapshot.data().count`, where `snapshot` is the\n * `AggregateQuerySnapshot` to which the returned Promise resolves.\n */\nfunction getCountFromServer(query) {\n    const countQuerySpec = {\n        count: count()\n    };\n    return getAggregateFromServer(query, countQuerySpec);\n}\n/**\n * Calculates the specified aggregations over the documents in the result\n * set of the given query without actually downloading the documents.\n *\n * Using this function to perform aggregations is efficient because only the\n * final aggregation values, not the documents' data, are downloaded. This\n * function can perform aggregations of the documents in cases where the result\n * set is prohibitively large to download entirely (thousands of documents).\n *\n * The result received from the server is presented, unaltered, without\n * considering any local state. That is, documents in the local cache are not\n * taken into consideration, neither are local modifications not yet\n * synchronized with the server. Previously-downloaded results, if any, are not\n * used. Every invocation of this function necessarily involves a round trip to\n * the server.\n *\n * @param query - The query whose result set is aggregated over.\n * @param aggregateSpec - An `AggregateSpec` object that specifies the aggregates\n * to perform over the result set. The AggregateSpec specifies aliases for each\n * aggregate, which can be used to retrieve the aggregate result.\n * @example\n * ```typescript\n * const aggregateSnapshot = await getAggregateFromServer(query, {\n *   countOfDocs: count(),\n *   totalHours: sum('hours'),\n *   averageScore: average('score')\n * });\n *\n * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;\n * const totalHours: number = aggregateSnapshot.data().totalHours;\n * const averageScore: number | null = aggregateSnapshot.data().averageScore;\n * ```\n */\nfunction getAggregateFromServer(query, aggregateSpec) {\n    const firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(query.firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n    const client = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G)(firestore);\n    const internalAggregates = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.H)(aggregateSpec, (aggregate, alias) => {\n        return new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.al(alias, aggregate.aggregateType, aggregate._internalFieldPath);\n    });\n    // Run the aggregation and convert the results\n    return (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.I)(client, query._query, internalAggregates).then(aggregateResult => convertToAggregateQuerySnapshot(firestore, query, aggregateResult));\n}\n/**\n * Converts the core aggregation result to an `AggregateQuerySnapshot`\n * that can be returned to the consumer.\n * @param query\n * @param aggregateResult - Core aggregation result\n * @internal\n */\nfunction convertToAggregateQuerySnapshot(firestore, query, aggregateResult) {\n    const userDataWriter = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.J(firestore);\n    const querySnapshot = new AggregateQuerySnapshot(query, userDataWriter, aggregateResult);\n    return querySnapshot;\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryLocalCacheImpl {\n    constructor(settings) {\n        this.kind = 'memory';\n        this._onlineComponentProvider = _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.am.provider;\n        if (settings?.garbageCollector) {\n            this._offlineComponentProvider =\n                settings.garbageCollector._offlineComponentProvider;\n        }\n        else {\n            this._offlineComponentProvider = {\n                build: () => new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.an(undefined)\n            };\n        }\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n}\nclass PersistentLocalCacheImpl {\n    constructor(settings) {\n        this.kind = 'persistent';\n        let tabManager;\n        if (settings?.tabManager) {\n            settings.tabManager._initialize(settings);\n            tabManager = settings.tabManager;\n        }\n        else {\n            tabManager = persistentSingleTabManager(undefined);\n            tabManager._initialize(settings);\n        }\n        this._onlineComponentProvider = tabManager._onlineComponentProvider;\n        this._offlineComponentProvider = tabManager._offlineComponentProvider;\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n}\nclass MemoryEagerGarbageCollectorImpl {\n    constructor() {\n        this.kind = 'memoryEager';\n        this._offlineComponentProvider = _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ao.provider;\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n}\nclass MemoryLruGarbageCollectorImpl {\n    constructor(cacheSize) {\n        this.kind = 'memoryLru';\n        this._offlineComponentProvider = {\n            build: () => new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.an(cacheSize)\n        };\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n}\n/**\n * Creates an instance of `MemoryEagerGarbageCollector`. This is also the\n * default garbage collector unless it is explicitly specified otherwise.\n */\nfunction memoryEagerGarbageCollector() {\n    return new MemoryEagerGarbageCollectorImpl();\n}\n/**\n * Creates an instance of `MemoryLruGarbageCollector`.\n *\n * A target size can be specified as part of the setting parameter. The\n * collector will start deleting documents once the cache size exceeds\n * the given size. The default cache size is 40MB (40 * 1024 * 1024 bytes).\n */\nfunction memoryLruGarbageCollector(settings) {\n    return new MemoryLruGarbageCollectorImpl(settings?.cacheSizeBytes);\n}\n/**\n * Creates an instance of `MemoryLocalCache`. The instance can be set to\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\n */\nfunction memoryLocalCache(settings) {\n    return new MemoryLocalCacheImpl(settings);\n}\n/**\n * Creates an instance of `PersistentLocalCache`. The instance can be set to\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\n *\n * Persistent cache cannot be used in a Node.js environment.\n */\nfunction persistentLocalCache(settings) {\n    return new PersistentLocalCacheImpl(settings);\n}\nclass SingleTabManagerImpl {\n    constructor(forceOwnership) {\n        this.forceOwnership = forceOwnership;\n        this.kind = 'persistentSingleTab';\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n    /**\n     * @internal\n     */\n    _initialize(settings) {\n        this._onlineComponentProvider = _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.am.provider;\n        this._offlineComponentProvider = {\n            build: (onlineComponents) => new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ap(onlineComponents, settings?.cacheSizeBytes, this.forceOwnership)\n        };\n    }\n}\nclass MultiTabManagerImpl {\n    constructor() {\n        this.kind = 'PersistentMultipleTab';\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n    /**\n     * @internal\n     */\n    _initialize(settings) {\n        this._onlineComponentProvider = _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.am.provider;\n        this._offlineComponentProvider = {\n            build: (onlineComponents) => new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aq(onlineComponents, settings?.cacheSizeBytes)\n        };\n    }\n}\n/**\n * Creates an instance of `PersistentSingleTabManager`.\n *\n * @param settings - Configures the created tab manager.\n */\nfunction persistentSingleTabManager(settings) {\n    return new SingleTabManagerImpl(settings?.forceOwnership);\n}\n/**\n * Creates an instance of `PersistentMultipleTabManager`.\n */\nfunction persistentMultipleTabManager() {\n    return new MultiTabManagerImpl();\n}\n\nconst encoder = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.n)();\nfunction lengthPrefixedString(o) {\n    const str = JSON.stringify(o);\n    const l = encoder.encode(str).byteLength;\n    return `${l}${str}`;\n}\n// TODO(wuandy): Ideally, these should use `TestBundleBuilder` above.\nconst meta = {\n    metadata: {\n        id: 'test-bundle',\n        createTime: { seconds: 1577836805, nanos: 6 },\n        version: 1,\n        totalDocuments: 1,\n        totalBytes: 416\n    }\n};\nlengthPrefixedString(meta);\nconst doc1Meta = {\n    documentMetadata: {\n        name: 'projects/test-project/databases/(default)/documents/collectionId/doc1',\n        readTime: { seconds: 5, nanos: 6 },\n        exists: true\n    }\n};\nlengthPrefixedString(doc1Meta);\nconst doc1 = {\n    document: {\n        name: 'projects/test-project/databases/(default)/documents/collectionId/doc1',\n        createTime: { seconds: 1, nanos: 2000000 },\n        updateTime: { seconds: 3, nanos: 4000 },\n        fields: { foo: { stringValue: 'value' }, bar: { integerValue: -42 } }\n    }\n};\nlengthPrefixedString(doc1);\nconst doc2Meta = {\n    documentMetadata: {\n        name: 'projects/test-project/databases/(default)/documents/collectionId/doc2',\n        readTime: { seconds: 5, nanos: 6 },\n        exists: true\n    }\n};\nlengthPrefixedString(doc2Meta);\nconst doc2 = {\n    document: {\n        name: 'projects/test-project/databases/(default)/documents/collectionId/doc2',\n        createTime: { seconds: 1, nanos: 2000000 },\n        updateTime: { seconds: 3, nanos: 4000 },\n        fields: {\n            foo: { stringValue: 'value1' },\n            bar: { integerValue: 42 },\n            emptyArray: { arrayValue: {} },\n            emptyMap: { mapValue: {} }\n        }\n    }\n};\nlengthPrefixedString(doc2);\nconst noDocMeta = {\n    documentMetadata: {\n        name: 'projects/test-project/databases/(default)/documents/collectionId/nodoc',\n        readTime: { seconds: 5, nanos: 6 },\n        exists: false\n    }\n};\nlengthPrefixedString(noDocMeta);\nconst limitQuery = {\n    namedQuery: {\n        name: 'limitQuery',\n        bundledQuery: {\n            parent: 'projects/fireeats-97d5e/databases/(default)/documents',\n            structuredQuery: {\n                from: [{ collectionId: 'node_3.7.5_7Li7XoCjutvNxwD0tpo9' }],\n                orderBy: [{ field: { fieldPath: 'sort' }, direction: 'DESCENDING' }],\n                limit: { 'value': 1 }\n            },\n            limitType: 'FIRST'\n        },\n        readTime: { 'seconds': 1590011379, 'nanos': 191164000 }\n    }\n};\nlengthPrefixedString(limitQuery);\nconst limitToLastQuery = {\n    namedQuery: {\n        name: 'limitToLastQuery',\n        bundledQuery: {\n            parent: 'projects/fireeats-97d5e/databases/(default)/documents',\n            structuredQuery: {\n                from: [{ collectionId: 'node_3.7.5_7Li7XoCjutvNxwD0tpo9' }],\n                orderBy: [{ field: { fieldPath: 'sort' }, direction: 'ASCENDING' }],\n                limit: { 'value': 1 }\n            },\n            limitType: 'LAST'\n        },\n        readTime: { 'seconds': 1590011379, 'nanos': 543063000 }\n    }\n};\nlengthPrefixedString(limitToLastQuery);\n\n/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst BUNDLE_VERSION = 1;\n/**\n * Builds a Firestore data bundle with results from the given document and query snapshots.\n */\nclass BundleBuilder {\n    constructor(firestore, bundleId) {\n        this.firestore = firestore;\n        this.bundleId = bundleId;\n        // Resulting documents for the bundle, keyed by full document path.\n        this.documents = new Map();\n        // Named queries saved in the bundle, keyed by query name.\n        this.namedQueries = new Map();\n        // The latest read time among all bundled documents and queries.\n        this.latestReadTime = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.av(0, 0);\n        this.databaseId = firestore._databaseId;\n        // useProto3Json is true because the objects will be serialized to JSON string\n        // before being written to the bundle buffer.\n        this.serializer = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aw(this.databaseId, \n        /*useProto3Json=*/ true);\n        this.userDataReader = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ax(this.databaseId, true, this.serializer);\n    }\n    /**\n     * Adds data from a DocumentSnapshot to the bundle.\n     * @internal\n     * @param docBundleData - A DocumentSnapshotBundleData containing information from the\n     * DocumentSnapshot. Note we cannot accept a DocumentSnapshot directly due to a circular\n     * dependency error.\n     * @param queryName - The name of the QuerySnapshot if this document is part of a Query.\n     */\n    addBundleDocument(docBundleData, queryName) {\n        const originalDocument = this.documents.get(docBundleData.documentPath);\n        const originalQueries = originalDocument?.metadata.queries;\n        const docReadTime = docBundleData.readTime;\n        const origDocReadTime = !!originalDocument?.metadata\n            .readTime\n            ? (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ay)(originalDocument.metadata.readTime)\n            : null;\n        const neitherHasReadTime = !docReadTime && origDocReadTime == null;\n        const docIsNewer = docReadTime !== undefined &&\n            (origDocReadTime == null || origDocReadTime < docReadTime);\n        if (neitherHasReadTime || docIsNewer) {\n            // Store document.\n            this.documents.set(docBundleData.documentPath, {\n                document: this.toBundleDocument(docBundleData),\n                metadata: {\n                    name: (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.az)(this.serializer, docBundleData.documentKey),\n                    readTime: !!docReadTime\n                        ? (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aA)(this.serializer, docReadTime) // Convert Timestamp to proto format.\n                        : undefined,\n                    exists: docBundleData.documentExists\n                }\n            });\n        }\n        if (docReadTime && docReadTime > this.latestReadTime) {\n            this.latestReadTime = docReadTime;\n        }\n        // Update `queries` to include both original and `queryName`.\n        if (queryName) {\n            const newDocument = this.documents.get(docBundleData.documentPath);\n            newDocument.metadata.queries = originalQueries || [];\n            newDocument.metadata.queries.push(queryName);\n        }\n    }\n    /**\n     * Adds data from a QuerySnapshot to the bundle.\n     * @internal\n     * @param docBundleData - A QuerySnapshotBundleData containing information from the\n     * QuerySnapshot. Note we cannot accept a QuerySnapshot directly due to a circular\n     * dependency error.\n     */\n    addBundleQuery(queryBundleData) {\n        if (this.namedQueries.has(queryBundleData.name)) {\n            throw new Error(`Query name conflict: ${name} has already been added.`);\n        }\n        let latestReadTime = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.av(0, 0);\n        for (const docBundleData of queryBundleData.docBundleDataArray) {\n            this.addBundleDocument(docBundleData, queryBundleData.name);\n            if (docBundleData.readTime && docBundleData.readTime > latestReadTime) {\n                latestReadTime = docBundleData.readTime;\n            }\n        }\n        const queryTarget = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aB)(this.serializer, (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aC)(queryBundleData.query));\n        const bundledQuery = {\n            parent: queryBundleData.parent,\n            structuredQuery: queryTarget.queryTarget.structuredQuery\n        };\n        this.namedQueries.set(queryBundleData.name, {\n            name: queryBundleData.name,\n            bundledQuery,\n            readTime: (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aA)(this.serializer, latestReadTime)\n        });\n    }\n    /**\n     * Convert data from a DocumentSnapshot into the serialized form within a bundle.\n     * @private\n     * @internal\n     * @param docBundleData - a DocumentSnapshotBundleData containing the data required to\n     * serialize a document.\n     */\n    toBundleDocument(docBundleData) {\n        // a parse context is typically used for validating and parsing user data, but in this\n        // case we are using it internally to convert DocumentData to Proto3 JSON\n        const context = this.userDataReader.createContext(4 /* UserDataSource.ArrayArgument */, 'internal toBundledDocument');\n        const proto3Fields = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aD)(docBundleData.documentData, context);\n        return {\n            name: (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.az)(this.serializer, docBundleData.documentKey),\n            fields: proto3Fields.mapValue.fields,\n            updateTime: (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aA)(this.serializer, docBundleData.versionTime),\n            createTime: (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aA)(this.serializer, docBundleData.createdTime)\n        };\n    }\n    /**\n     * Converts a IBundleElement to a Buffer whose content is the length prefixed JSON representation\n     * of the element.\n     * @private\n     * @internal\n     * @param bundleElement - A ProtoBundleElement that is expected to be Proto3 JSON compatible.\n     */\n    lengthPrefixedString(bundleElement) {\n        const str = JSON.stringify(bundleElement);\n        // TODO: it's not ideal to have to re-encode all of these strings multiple times\n        //       It may be more performant to return a UInt8Array that is concatenated to other\n        //       UInt8Arrays instead of returning and concatenating strings and then\n        //       converting the full string to UInt8Array.\n        const l = encoder.encode(str).byteLength;\n        return `${l}${str}`;\n    }\n    /**\n     * Construct a serialized string containing document and query information that has previously\n     * been added to the BundleBuilder through the addBundleDocument and addBundleQuery methods.\n     * @internal\n     */\n    build() {\n        let bundleString = '';\n        for (const namedQuery of this.namedQueries.values()) {\n            bundleString += this.lengthPrefixedString({ namedQuery });\n        }\n        for (const bundledDocument of this.documents.values()) {\n            const documentMetadata = bundledDocument.metadata;\n            bundleString += this.lengthPrefixedString({ documentMetadata });\n            // Write to the bundle if document exists.\n            const document = bundledDocument.document;\n            if (document) {\n                bundleString += this.lengthPrefixedString({ document });\n            }\n        }\n        const metadata = {\n            id: this.bundleId,\n            createTime: (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aA)(this.serializer, this.latestReadTime),\n            version: BUNDLE_VERSION,\n            totalDocuments: this.documents.size,\n            // TODO: it's not ideal to have to re-encode all of these strings multiple times\n            totalBytes: encoder.encode(bundleString).length\n        };\n        // Prepends the metadata element to the bundleBuffer: `bundleBuffer` is the second argument to `Buffer.concat`.\n        bundleString = this.lengthPrefixedString({ metadata }) + bundleString;\n        return bundleString;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction buildDocumentSnapshotJsonBundle(db, document, docData, path) {\n    const builder = new BundleBuilder(db, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.S.newId());\n    builder.addBundleDocument(documentToDocumentSnapshotBundleData(path, docData, document));\n    return builder.build();\n}\nfunction buildQuerySnapshotJsonBundle(db, query, bundleName, parent, paths, docs, documentData) {\n    const docBundleDataArray = [];\n    for (let i = 0; i < docs.length; i++) {\n        docBundleDataArray.push(documentToDocumentSnapshotBundleData(paths[i], documentData[i], docs[i]));\n    }\n    const bundleData = {\n        name: bundleName,\n        query,\n        parent,\n        docBundleDataArray\n    };\n    const builder = new BundleBuilder(db, bundleName);\n    builder.addBundleQuery(bundleData);\n    return builder.build();\n}\n// Formats Document data for bundling a DocumentSnapshot.\nfunction documentToDocumentSnapshotBundleData(path, documentData, document) {\n    return {\n        documentData,\n        documentKey: document.mutableCopy().key,\n        documentPath: path,\n        documentExists: true,\n        createdTime: document.createTime.toTimestamp(),\n        readTime: document.readTime.toTimestamp(),\n        versionTime: document.version.toTimestamp()\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst NOT_SUPPORTED = 'NOT SUPPORTED';\n/**\n * Metadata about a snapshot, describing the state of the snapshot.\n */\nclass SnapshotMetadata {\n    /** @hideconstructor */\n    constructor(hasPendingWrites, fromCache) {\n        this.hasPendingWrites = hasPendingWrites;\n        this.fromCache = fromCache;\n    }\n    /**\n     * Returns true if this `SnapshotMetadata` is equal to the provided one.\n     *\n     * @param other - The `SnapshotMetadata` to compare against.\n     * @returns true if this `SnapshotMetadata` is equal to the provided one.\n     */\n    isEqual(other) {\n        return (this.hasPendingWrites === other.hasPendingWrites &&\n            this.fromCache === other.fromCache);\n    }\n}\n/**\n * A `DocumentSnapshot` contains data read from a document in your Firestore\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\n * get a specific field.\n *\n * For a `DocumentSnapshot` that points to a non-existing document, any data\n * access will return 'undefined'. You can use the `exists()` method to\n * explicitly verify a document's existence.\n */\nclass DocumentSnapshot extends DocumentSnapshot$1 {\n    /** @hideconstructor protected */\n    constructor(_firestore, userDataWriter, key, document, metadata, converter) {\n        super(_firestore, userDataWriter, key, document, converter);\n        this._firestore = _firestore;\n        this._firestoreImpl = _firestore;\n        this.metadata = metadata;\n    }\n    /**\n     * Returns whether or not the data exists. True if the document exists.\n     */\n    exists() {\n        return super.exists();\n    }\n    /**\n     * Retrieves all fields in the document as an `Object`. Returns `undefined` if\n     * the document doesn't exist.\n     *\n     * By default, `serverTimestamp()` values that have not yet been\n     * set to their final value will be returned as `null`. You can override\n     * this by passing an options object.\n     *\n     * @param options - An options object to configure how data is retrieved from\n     * the snapshot (for example the desired behavior for server timestamps that\n     * have not yet been set to their final value).\n     * @returns An `Object` containing all fields in the document or `undefined` if\n     * the document doesn't exist.\n     */\n    data(options = {}) {\n        if (!this._document) {\n            return undefined;\n        }\n        else if (this._converter) {\n            // We only want to use the converter and create a new DocumentSnapshot\n            // if a converter has been provided.\n            const snapshot = new QueryDocumentSnapshot(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, \n            /* converter= */ null);\n            return this._converter.fromFirestore(snapshot, options);\n        }\n        else {\n            return this._userDataWriter.convertValue(this._document.data.value, options.serverTimestamps);\n        }\n    }\n    /**\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\n     * document or field doesn't exist.\n     *\n     * By default, a `serverTimestamp()` that has not yet been set to\n     * its final value will be returned as `null`. You can override this by\n     * passing an options object.\n     *\n     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\n     * field.\n     * @param options - An options object to configure how the field is retrieved\n     * from the snapshot (for example the desired behavior for server timestamps\n     * that have not yet been set to their final value).\n     * @returns The data at the specified field location or undefined if no such\n     * field exists in the document.\n     */\n    // We are using `any` here to avoid an explicit cast by our users.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(fieldPath, options = {}) {\n        if (this._document) {\n            const value = this._document.data.field((0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.f)('DocumentSnapshot.get', fieldPath));\n            if (value !== null) {\n                return this._userDataWriter.convertValue(value, options.serverTimestamps);\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Returns a JSON-serializable representation of this `DocumentSnapshot` instance.\n     *\n     * @returns a JSON representation of this object.  Throws a {@link FirestoreError} if this\n     * `DocumentSnapshot` has pending writes.\n     */\n    toJSON() {\n        if (this.metadata.hasPendingWrites) {\n            throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.FAILED_PRECONDITION, 'DocumentSnapshot.toJSON() attempted to serialize a document with pending writes. ' +\n                'Await waitForPendingWrites() before invoking toJSON().');\n        }\n        const document = this._document;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const result = {};\n        result['type'] = DocumentSnapshot._jsonSchemaVersion;\n        result['bundle'] = '';\n        result['bundleSource'] = 'DocumentSnapshot';\n        result['bundleName'] = this._key.toString();\n        if (!document ||\n            !document.isValidDocument() ||\n            !document.isFoundDocument()) {\n            return result;\n        }\n        const documentData = this._userDataWriter.convertObjectMap(document.data.value.mapValue.fields, 'previous');\n        result['bundle'] = buildDocumentSnapshotJsonBundle(this._firestore, document, documentData, this.ref.path);\n        return result;\n    }\n}\nDocumentSnapshot._jsonSchemaVersion = 'firestore/documentSnapshot/1.0';\nDocumentSnapshot._jsonSchema = {\n    type: (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.p)('string', DocumentSnapshot._jsonSchemaVersion),\n    bundleSource: (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.p)('string', 'DocumentSnapshot'),\n    bundleName: (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.p)('string'),\n    bundle: (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.p)('string')\n};\nfunction documentSnapshotFromJSON(db, json, converter) {\n    if ((0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.K)(json, DocumentSnapshot._jsonSchema)) {\n        if (json.bundle === NOT_SUPPORTED) {\n            throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, 'The provided JSON object was created in a client environment, which is not supported.');\n        }\n        // Parse the bundle data.\n        const serializer = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.L)(db._databaseId);\n        const bundleReader = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.M)(json.bundle, serializer);\n        const elements = bundleReader.getElements();\n        const bundleLoader = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.N(bundleReader.getMetadata(), serializer);\n        for (const element of elements) {\n            bundleLoader.addSizedElement(element);\n        }\n        // Ensure that we have the correct number of documents in the bundle.\n        const bundledDocuments = bundleLoader.documents;\n        if (bundledDocuments.length !== 1) {\n            throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, `Expected bundle data to contain 1 document, but it contains ${bundledDocuments.length} documents.`);\n        }\n        // Build out the internal document data.\n        const document = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.P)(serializer, bundledDocuments[0].document);\n        const documentKey = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.x(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.R.fromString(json.bundleName));\n        // Return the external facing DocumentSnapshot.\n        return new DocumentSnapshot(db, new LiteUserDataWriter(db), documentKey, document, new SnapshotMetadata(\n        /* hasPendingWrites= */ false, \n        /* fromCache= */ false), converter ? converter : null);\n    }\n}\n/**\n * A `QueryDocumentSnapshot` contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\n * specific field.\n *\n * A `QueryDocumentSnapshot` offers the same API surface as a\n * `DocumentSnapshot`. Since query results contain only existing documents, the\n * `exists` property will always be true and `data()` will never return\n * 'undefined'.\n */\nclass QueryDocumentSnapshot extends DocumentSnapshot {\n    /**\n     * Retrieves all fields in the document as an `Object`.\n     *\n     * By default, `serverTimestamp()` values that have not yet been\n     * set to their final value will be returned as `null`. You can override\n     * this by passing an options object.\n     *\n     * @override\n     * @param options - An options object to configure how data is retrieved from\n     * the snapshot (for example the desired behavior for server timestamps that\n     * have not yet been set to their final value).\n     * @returns An `Object` containing all fields in the document.\n     */\n    data(options = {}) {\n        return super.data(options);\n    }\n}\n/**\n * A `QuerySnapshot` contains zero or more `DocumentSnapshot` objects\n * representing the results of a query. The documents can be accessed as an\n * array via the `docs` property or enumerated using the `forEach` method. The\n * number of documents can be determined via the `empty` and `size`\n * properties.\n */\nclass QuerySnapshot {\n    /** @hideconstructor */\n    constructor(_firestore, _userDataWriter, query, _snapshot) {\n        this._firestore = _firestore;\n        this._userDataWriter = _userDataWriter;\n        this._snapshot = _snapshot;\n        this.metadata = new SnapshotMetadata(_snapshot.hasPendingWrites, _snapshot.fromCache);\n        this.query = query;\n    }\n    /** An array of all the documents in the `QuerySnapshot`. */\n    get docs() {\n        const result = [];\n        this.forEach(doc => result.push(doc));\n        return result;\n    }\n    /** The number of documents in the `QuerySnapshot`. */\n    get size() {\n        return this._snapshot.docs.size;\n    }\n    /** True if there are no documents in the `QuerySnapshot`. */\n    get empty() {\n        return this.size === 0;\n    }\n    /**\n     * Enumerates all of the documents in the `QuerySnapshot`.\n     *\n     * @param callback - A callback to be called with a `QueryDocumentSnapshot` for\n     * each document in the snapshot.\n     * @param thisArg - The `this` binding for the callback.\n     */\n    forEach(callback, thisArg) {\n        this._snapshot.docs.forEach(doc => {\n            callback.call(thisArg, new QueryDocumentSnapshot(this._firestore, this._userDataWriter, doc.key, doc, new SnapshotMetadata(this._snapshot.mutatedKeys.has(doc.key), this._snapshot.fromCache), this.query.converter));\n        });\n    }\n    /**\n     * Returns an array of the documents changes since the last snapshot. If this\n     * is the first snapshot, all documents will be in the list as 'added'\n     * changes.\n     *\n     * @param options - `SnapshotListenOptions` that control whether metadata-only\n     * changes (i.e. only `DocumentSnapshot.metadata` changed) should trigger\n     * snapshot events.\n     */\n    docChanges(options = {}) {\n        const includeMetadataChanges = !!options.includeMetadataChanges;\n        if (includeMetadataChanges && this._snapshot.excludesMetadataChanges) {\n            throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, 'To include metadata changes with your document changes, you must ' +\n                'also pass { includeMetadataChanges:true } to onSnapshot().');\n        }\n        if (!this._cachedChanges ||\n            this._cachedChangesIncludeMetadataChanges !== includeMetadataChanges) {\n            this._cachedChanges = changesFromSnapshot(this, includeMetadataChanges);\n            this._cachedChangesIncludeMetadataChanges = includeMetadataChanges;\n        }\n        return this._cachedChanges;\n    }\n    /**\n     * Returns a JSON-serializable representation of this `QuerySnapshot` instance.\n     *\n     * @returns a JSON representation of this object. Throws a {@link FirestoreError} if this\n     * `QuerySnapshot` has pending writes.\n     */\n    toJSON() {\n        if (this.metadata.hasPendingWrites) {\n            throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.FAILED_PRECONDITION, 'QuerySnapshot.toJSON() attempted to serialize a document with pending writes. ' +\n                'Await waitForPendingWrites() before invoking toJSON().');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const result = {};\n        result['type'] = QuerySnapshot._jsonSchemaVersion;\n        result['bundleSource'] = 'QuerySnapshot';\n        result['bundleName'] = _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.S.newId();\n        const databaseId = this._firestore._databaseId.database;\n        const projectId = this._firestore._databaseId.projectId;\n        const parent = `projects/${projectId}/databases/${databaseId}/documents`;\n        const documents = [];\n        const documentData = [];\n        const paths = [];\n        this.docs.forEach(doc => {\n            if (doc._document === null) {\n                return;\n            }\n            documents.push(doc._document);\n            documentData.push(this._userDataWriter.convertObjectMap(doc._document.data.value.mapValue.fields, 'previous'));\n            paths.push(doc.ref.path);\n        });\n        result['bundle'] = buildQuerySnapshotJsonBundle(this._firestore, this.query._query, result['bundleName'], parent, paths, documents, documentData);\n        return result;\n    }\n}\nQuerySnapshot._jsonSchemaVersion = 'firestore/querySnapshot/1.0';\nQuerySnapshot._jsonSchema = {\n    type: (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.p)('string', QuerySnapshot._jsonSchemaVersion),\n    bundleSource: (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.p)('string', 'QuerySnapshot'),\n    bundleName: (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.p)('string'),\n    bundle: (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.p)('string')\n};\nfunction querySnapshotFromJSON(db, json, converter) {\n    if ((0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.K)(json, QuerySnapshot._jsonSchema)) {\n        if (json.bundle === NOT_SUPPORTED) {\n            throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, 'The provided JSON object was created in a client environment, which is not supported.');\n        }\n        // Parse the bundle data.\n        const serializer = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.L)(db._databaseId);\n        const bundleReader = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.M)(json.bundle, serializer);\n        const elements = bundleReader.getElements();\n        const bundleLoader = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.N(bundleReader.getMetadata(), serializer);\n        for (const element of elements) {\n            bundleLoader.addSizedElement(element);\n        }\n        if (bundleLoader.queries.length !== 1) {\n            throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, `Snapshot data expected 1 query but found ${bundleLoader.queries.length} queries.`);\n        }\n        // Create an internal Query object from the named query in the bundle.\n        const query = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.T)(bundleLoader.queries[0].bundledQuery);\n        // Construct the arrays of document data for the query.\n        const bundledDocuments = bundleLoader.documents;\n        let documentSet = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.U();\n        bundledDocuments.map(bundledDocument => {\n            const document = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.P)(serializer, bundledDocument.document);\n            documentSet = documentSet.add(document);\n        });\n        // Create a view snapshot of the query and documents.\n        const viewSnapshot = _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.V.fromInitialDocuments(query, documentSet, (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.W)() /* Zero mutated keys signifies no pending writes. */, \n        /* fromCache= */ false, \n        /* hasCachedResults= */ false);\n        // Create an external Query object, required to construct the QuerySnapshot.\n        const externalQuery = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Q(db, converter ? converter : null, query);\n        // Return a new QuerySnapshot with all of the collected data.\n        return new QuerySnapshot(db, new LiteUserDataWriter(db), externalQuery, viewSnapshot);\n    }\n}\n/** Calculates the array of `DocumentChange`s for a given `ViewSnapshot`. */\nfunction changesFromSnapshot(querySnapshot, includeMetadataChanges) {\n    if (querySnapshot._snapshot.oldDocs.isEmpty()) {\n        let index = 0;\n        return querySnapshot._snapshot.docChanges.map(change => {\n            const doc = new QueryDocumentSnapshot(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);\n            change.doc;\n            return {\n                type: 'added',\n                doc,\n                oldIndex: -1,\n                newIndex: index++\n            };\n        });\n    }\n    else {\n        // A `DocumentSet` that is updated incrementally as changes are applied to use\n        // to lookup the index of a document.\n        let indexTracker = querySnapshot._snapshot.oldDocs;\n        return querySnapshot._snapshot.docChanges\n            .filter(change => includeMetadataChanges || change.type !== 3 /* ChangeType.Metadata */)\n            .map(change => {\n            const doc = new QueryDocumentSnapshot(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);\n            let oldIndex = -1;\n            let newIndex = -1;\n            if (change.type !== 0 /* ChangeType.Added */) {\n                oldIndex = indexTracker.indexOf(change.doc.key);\n                indexTracker = indexTracker.delete(change.doc.key);\n            }\n            if (change.type !== 1 /* ChangeType.Removed */) {\n                indexTracker = indexTracker.add(change.doc);\n                newIndex = indexTracker.indexOf(change.doc.key);\n            }\n            return {\n                type: resultChangeType(change.type),\n                doc,\n                oldIndex,\n                newIndex\n            };\n        });\n    }\n}\nfunction resultChangeType(type) {\n    switch (type) {\n        case 0 /* ChangeType.Added */:\n            return 'added';\n        case 2 /* ChangeType.Modified */:\n        case 3 /* ChangeType.Metadata */:\n            return 'modified';\n        case 1 /* ChangeType.Removed */:\n            return 'removed';\n        default:\n            return (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.X)(0xf03d, { type });\n    }\n}\n// TODO(firestoreexp): Add tests for snapshotEqual with different snapshot\n// metadata\n/**\n * Returns true if the provided snapshots are equal.\n *\n * @param left - A snapshot to compare.\n * @param right - A snapshot to compare.\n * @returns true if the snapshots are equal.\n */\nfunction snapshotEqual(left, right) {\n    if (left instanceof DocumentSnapshot && right instanceof DocumentSnapshot) {\n        return (left._firestore === right._firestore &&\n            left._key.isEqual(right._key) &&\n            (left._document === null\n                ? right._document === null\n                : left._document.isEqual(right._document)) &&\n            left._converter === right._converter);\n    }\n    else if (left instanceof QuerySnapshot && right instanceof QuerySnapshot) {\n        return (left._firestore === right._firestore &&\n            (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.z)(left.query, right.query) &&\n            left.metadata.isEqual(right.metadata) &&\n            left._snapshot.isEqual(right._snapshot));\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_TRANSACTION_OPTIONS = {\n    maxAttempts: 5\n};\nfunction validateTransactionOptions(options) {\n    if (options.maxAttempts < 1) {\n        throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, 'Max attempts must be at least 1');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A write batch, used to perform multiple writes as a single atomic unit.\n *\n * A `WriteBatch` object can be acquired by calling {@link writeBatch}. It\n * provides methods for adding writes to the write batch. None of the writes\n * will be committed (or visible locally) until {@link WriteBatch.commit} is\n * called.\n */\nclass WriteBatch {\n    /** @hideconstructor */\n    constructor(_firestore, _commitHandler) {\n        this._firestore = _firestore;\n        this._commitHandler = _commitHandler;\n        this._mutations = [];\n        this._committed = false;\n        this._dataReader = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(_firestore);\n    }\n    set(documentRef, data, options) {\n        this._verifyNotCommitted();\n        const ref = validateReference(documentRef, this._firestore);\n        const convertedValue = applyFirestoreDataConverter(ref.converter, data, options);\n        const parsed = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Y)(this._dataReader, 'WriteBatch.set', ref._key, convertedValue, ref.converter !== null, options);\n        this._mutations.push(parsed.toMutation(ref._key, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Z.none()));\n        return this;\n    }\n    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {\n        this._verifyNotCommitted();\n        const ref = validateReference(documentRef, this._firestore);\n        // For Compat types, we have to \"extract\" the underlying types before\n        // performing validation.\n        fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(fieldOrUpdateData);\n        let parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__._) {\n            parsed = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.$)(this._dataReader, 'WriteBatch.update', ref._key, fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            parsed = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a0)(this._dataReader, 'WriteBatch.update', ref._key, fieldOrUpdateData);\n        }\n        this._mutations.push(parsed.toMutation(ref._key, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Z.exists(true)));\n        return this;\n    }\n    /**\n     * Deletes the document referred to by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be deleted.\n     * @returns This `WriteBatch` instance. Used for chaining method calls.\n     */\n    delete(documentRef) {\n        this._verifyNotCommitted();\n        const ref = validateReference(documentRef, this._firestore);\n        this._mutations = this._mutations.concat(new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a1(ref._key, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Z.none()));\n        return this;\n    }\n    /**\n     * Commits all of the writes in this write batch as a single atomic unit.\n     *\n     * The result of these writes will only be reflected in document reads that\n     * occur after the returned promise resolves. If the client is offline, the\n     * write fails. If you would like to see local modifications or buffer writes\n     * until the client is online, use the full Firestore SDK.\n     *\n     * @returns A `Promise` resolved once all of the writes in the batch have been\n     * successfully written to the backend as an atomic unit (note that it won't\n     * resolve while you're offline).\n     */\n    commit() {\n        this._verifyNotCommitted();\n        this._committed = true;\n        if (this._mutations.length > 0) {\n            return this._commitHandler(this._mutations);\n        }\n        return Promise.resolve();\n    }\n    _verifyNotCommitted() {\n        if (this._committed) {\n            throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' +\n                'has been called.');\n        }\n    }\n}\nfunction validateReference(documentRef, firestore) {\n    documentRef = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(documentRef);\n    if (documentRef.firestore !== firestore) {\n        throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');\n    }\n    else {\n        return documentRef;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// TODO(mrschmidt) Consider using `BaseTransaction` as the base class in the\n// legacy SDK.\n/**\n * A reference to a transaction.\n *\n * The `Transaction` object passed to a transaction's `updateFunction` provides\n * the methods to read and write data within the transaction context. See\n * {@link runTransaction}.\n */\nclass Transaction$1 {\n    /** @hideconstructor */\n    constructor(_firestore, _transaction) {\n        this._firestore = _firestore;\n        this._transaction = _transaction;\n        this._dataReader = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(_firestore);\n    }\n    /**\n     * Reads the document referenced by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be read.\n     * @returns A `DocumentSnapshot` with the read data.\n     */\n    get(documentRef) {\n        const ref = validateReference(documentRef, this._firestore);\n        const userDataWriter = new LiteUserDataWriter(this._firestore);\n        return this._transaction.lookup([ref._key]).then(docs => {\n            if (!docs || docs.length !== 1) {\n                return (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.X)(0x5de9);\n            }\n            const doc = docs[0];\n            if (doc.isFoundDocument()) {\n                return new DocumentSnapshot$1(this._firestore, userDataWriter, doc.key, doc, ref.converter);\n            }\n            else if (doc.isNoDocument()) {\n                return new DocumentSnapshot$1(this._firestore, userDataWriter, ref._key, null, ref.converter);\n            }\n            else {\n                throw (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.X)(0x4801, {\n                    doc\n                });\n            }\n        });\n    }\n    set(documentRef, value, options) {\n        const ref = validateReference(documentRef, this._firestore);\n        const convertedValue = applyFirestoreDataConverter(ref.converter, value, options);\n        const parsed = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Y)(this._dataReader, 'Transaction.set', ref._key, convertedValue, ref.converter !== null, options);\n        this._transaction.set(ref._key, parsed);\n        return this;\n    }\n    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {\n        const ref = validateReference(documentRef, this._firestore);\n        // For Compat types, we have to \"extract\" the underlying types before\n        // performing validation.\n        fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(fieldOrUpdateData);\n        let parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__._) {\n            parsed = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.$)(this._dataReader, 'Transaction.update', ref._key, fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            parsed = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a0)(this._dataReader, 'Transaction.update', ref._key, fieldOrUpdateData);\n        }\n        this._transaction.update(ref._key, parsed);\n        return this;\n    }\n    /**\n     * Deletes the document referred to by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be deleted.\n     * @returns This `Transaction` instance. Used for chaining method calls.\n     */\n    delete(documentRef) {\n        const ref = validateReference(documentRef, this._firestore);\n        this._transaction.delete(ref._key);\n        return this;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A reference to a transaction.\n *\n * The `Transaction` object passed to a transaction's `updateFunction` provides\n * the methods to read and write data within the transaction context. See\n * {@link runTransaction}.\n */\nclass Transaction extends Transaction$1 {\n    // This class implements the same logic as the Transaction API in the Lite SDK\n    // but is subclassed in order to return its own DocumentSnapshot types.\n    /** @hideconstructor */\n    constructor(_firestore, _transaction) {\n        super(_firestore, _transaction);\n        this._firestore = _firestore;\n    }\n    /**\n     * Reads the document referenced by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be read.\n     * @returns A `DocumentSnapshot` with the read data.\n     */\n    get(documentRef) {\n        const ref = validateReference(documentRef, this._firestore);\n        const userDataWriter = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.J(this._firestore);\n        return super\n            .get(documentRef)\n            .then(liteDocumentSnapshot => new DocumentSnapshot(this._firestore, userDataWriter, ref._key, liteDocumentSnapshot._document, new SnapshotMetadata(\n        /* hasPendingWrites= */ false, \n        /* fromCache= */ false), ref.converter));\n    }\n}\n/**\n * Executes the given `updateFunction` and then attempts to commit the changes\n * applied within the transaction. If any document read within the transaction\n * has changed, Cloud Firestore retries the `updateFunction`. If it fails to\n * commit after 5 attempts, the transaction fails.\n *\n * The maximum number of writes allowed in a single transaction is 500.\n *\n * @param firestore - A reference to the Firestore database to run this\n * transaction against.\n * @param updateFunction - The function to execute within the transaction\n * context.\n * @param options - An options object to configure maximum number of attempts to\n * commit.\n * @returns If the transaction completed successfully or was explicitly aborted\n * (the `updateFunction` returned a failed promise), the promise returned by the\n * `updateFunction `is returned here. Otherwise, if the transaction failed, a\n * rejected promise with the corresponding failure error is returned.\n */\nfunction runTransaction(firestore, updateFunction, options) {\n    firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n    const optionsWithDefaults = {\n        ...DEFAULT_TRANSACTION_OPTIONS,\n        ...options\n    };\n    validateTransactionOptions(optionsWithDefaults);\n    const client = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G)(firestore);\n    return (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a2)(client, internalTransaction => updateFunction(new Transaction(firestore, internalTransaction)), optionsWithDefaults);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isPartialObserver(obj) {\n    return implementsAnyMethods(obj, ['next', 'error', 'complete']);\n}\n/**\n * Returns true if obj is an object and contains at least one of the specified\n * methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n    if (typeof obj !== 'object' || obj === null) {\n        return false;\n    }\n    const object = obj;\n    for (const method of methods) {\n        if (method in object && typeof object[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Reads the document referred to by this `DocumentReference`.\n *\n * Note: `getDoc()` attempts to provide up-to-date data when possible by waiting\n * for data from the server, but it may return cached data or fail if you are\n * offline and the server cannot be reached. To specify this behavior, invoke\n * {@link getDocFromCache} or {@link getDocFromServer}.\n *\n * @param reference - The reference of the document to fetch.\n * @returns A Promise resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nfunction getDoc(reference) {\n    reference = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(reference, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.D);\n    const firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(reference.firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n    const client = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G)(firestore);\n    return (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a3)(client, reference._key).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\n}\n/**\n * Reads the document referred to by this `DocumentReference` from cache.\n * Returns an error if the document is not currently cached.\n *\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nfunction getDocFromCache(reference) {\n    reference = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(reference, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.D);\n    const firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(reference.firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n    const client = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G)(firestore);\n    const userDataWriter = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.J(firestore);\n    return (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a4)(client, reference._key).then(doc => new DocumentSnapshot(firestore, userDataWriter, reference._key, doc, new SnapshotMetadata(doc !== null && doc.hasLocalMutations, \n    /* fromCache= */ true), reference.converter));\n}\n/**\n * Reads the document referred to by this `DocumentReference` from the server.\n * Returns an error if the network is not available.\n *\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nfunction getDocFromServer(reference) {\n    reference = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(reference, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.D);\n    const firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(reference.firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n    const client = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G)(firestore);\n    return (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a3)(client, reference._key, {\n        source: 'server'\n    }).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\n}\n/**\n * Executes the query and returns the results as a `QuerySnapshot`.\n *\n * Note: `getDocs()` attempts to provide up-to-date data when possible by\n * waiting for data from the server, but it may return cached data or fail if\n * you are offline and the server cannot be reached. To specify this behavior,\n * invoke {@link getDocsFromCache} or {@link getDocsFromServer}.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nfunction getDocs(query) {\n    query = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(query, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Q);\n    const firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(query.firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n    const client = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G)(firestore);\n    const userDataWriter = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.J(firestore);\n    validateHasExplicitOrderByForLimitToLast(query._query);\n    return (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a5)(client, query._query).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\n}\n/**\n * Executes the query and returns the results as a `QuerySnapshot` from cache.\n * Returns an empty result set if no documents matching the query are currently\n * cached.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nfunction getDocsFromCache(query) {\n    query = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(query, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Q);\n    const firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(query.firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n    const client = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G)(firestore);\n    const userDataWriter = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.J(firestore);\n    return (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a6)(client, query._query).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\n}\n/**\n * Executes the query and returns the results as a `QuerySnapshot` from the\n * server. Returns an error if the network is not available.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nfunction getDocsFromServer(query) {\n    query = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(query, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Q);\n    const firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(query.firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n    const client = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G)(firestore);\n    const userDataWriter = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.J(firestore);\n    return (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a5)(client, query._query, {\n        source: 'server'\n    }).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\n}\nfunction setDoc(reference, data, options) {\n    reference = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(reference, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.D);\n    const firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(reference.firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n    const convertedValue = applyFirestoreDataConverter(reference.converter, data, options);\n    const dataReader = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(firestore);\n    const parsed = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Y)(dataReader, 'setDoc', reference._key, convertedValue, reference.converter !== null, options);\n    const mutation = parsed.toMutation(reference._key, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Z.none());\n    return executeWrite(firestore, [mutation]);\n}\nfunction updateDoc(reference, fieldOrUpdateData, value, ...moreFieldsAndValues) {\n    reference = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(reference, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.D);\n    const firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(reference.firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n    const dataReader = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(firestore);\n    // For Compat types, we have to \"extract\" the underlying types before\n    // performing validation.\n    fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(fieldOrUpdateData);\n    let parsed;\n    if (typeof fieldOrUpdateData === 'string' ||\n        fieldOrUpdateData instanceof _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__._) {\n        parsed = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.$)(dataReader, 'updateDoc', reference._key, fieldOrUpdateData, value, moreFieldsAndValues);\n    }\n    else {\n        parsed = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a0)(dataReader, 'updateDoc', reference._key, fieldOrUpdateData);\n    }\n    const mutation = parsed.toMutation(reference._key, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Z.exists(true));\n    return executeWrite(firestore, [mutation]);\n}\n/**\n * Deletes the document referred to by the specified `DocumentReference`.\n *\n * @param reference - A reference to the document to delete.\n * @returns A Promise resolved once the document has been successfully\n * deleted from the backend (note that it won't resolve while you're offline).\n */\nfunction deleteDoc(reference) {\n    const firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(reference.firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n    const mutations = [new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a1(reference._key, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Z.none())];\n    return executeWrite(firestore, mutations);\n}\n/**\n * Add a new document to specified `CollectionReference` with the given data,\n * assigning it a document ID automatically.\n *\n * @param reference - A reference to the collection to add this document to.\n * @param data - An Object containing the data for the new document.\n * @returns A `Promise` resolved with a `DocumentReference` pointing to the\n * newly created document after it has been written to the backend (Note that it\n * won't resolve while you're offline).\n */\nfunction addDoc(reference, data) {\n    const firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(reference.firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n    const docRef = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a7)(reference);\n    const convertedValue = applyFirestoreDataConverter(reference.converter, data);\n    const dataReader = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(reference.firestore);\n    const parsed = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Y)(dataReader, 'addDoc', docRef._key, convertedValue, reference.converter !== null, {});\n    const mutation = parsed.toMutation(docRef._key, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Z.exists(false));\n    return executeWrite(firestore, [mutation]).then(() => docRef);\n}\nfunction onSnapshot(reference, ...args) {\n    // onSnapshot for Query or Document.\n    reference = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(reference);\n    let options = {\n        includeMetadataChanges: false,\n        source: 'default'\n    };\n    let currArg = 0;\n    if (typeof args[currArg] === 'object' && !isPartialObserver(args[currArg])) {\n        options = args[currArg++];\n    }\n    const internalOptions = {\n        includeMetadataChanges: options.includeMetadataChanges,\n        source: options.source\n    };\n    if (isPartialObserver(args[currArg])) {\n        const userObserver = args[currArg];\n        args[currArg] = userObserver.next?.bind(userObserver);\n        args[currArg + 1] = userObserver.error?.bind(userObserver);\n        args[currArg + 2] = userObserver.complete?.bind(userObserver);\n    }\n    let observer;\n    let firestore;\n    let internalQuery;\n    if (reference instanceof _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.D) {\n        firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(reference.firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n        internalQuery = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a8)(reference._key.path);\n        observer = {\n            next: snapshot => {\n                if (args[currArg]) {\n                    args[currArg](convertToDocSnapshot(firestore, reference, snapshot));\n                }\n            },\n            error: args[currArg + 1],\n            complete: args[currArg + 2]\n        };\n    }\n    else {\n        const query = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(reference, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.Q);\n        firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(query.firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n        internalQuery = query._query;\n        const userDataWriter = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.J(firestore);\n        observer = {\n            next: snapshot => {\n                if (args[currArg]) {\n                    args[currArg](new QuerySnapshot(firestore, userDataWriter, query, snapshot));\n                }\n            },\n            error: args[currArg + 1],\n            complete: args[currArg + 2]\n        };\n        validateHasExplicitOrderByForLimitToLast(reference._query);\n    }\n    const client = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G)(firestore);\n    return (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.a9)(client, internalQuery, internalOptions, observer);\n}\nfunction onSnapshotResume(reference, snapshotJson, ...args) {\n    const db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getModularInstance)(reference);\n    const json = normalizeSnapshotJsonFields(snapshotJson);\n    if (json.error) {\n        throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, json.error);\n    }\n    let curArg = 0;\n    let options = undefined;\n    if (typeof args[curArg] === 'object' && !isPartialObserver(args[curArg])) {\n        options = args[curArg++];\n    }\n    if (json.bundleSource === 'QuerySnapshot') {\n        let observer = null;\n        if (typeof args[curArg] === 'object' && isPartialObserver(args[curArg])) {\n            const userObserver = args[curArg++];\n            observer = {\n                next: userObserver.next,\n                error: userObserver.error,\n                complete: userObserver.complete\n            };\n        }\n        else {\n            observer = {\n                next: args[curArg++],\n                error: args[curArg++],\n                complete: args[curArg++]\n            };\n        }\n        return onSnapshotQuerySnapshotBundle(db, json, options, observer, args[curArg]);\n    }\n    else if (json.bundleSource === 'DocumentSnapshot') {\n        let observer = null;\n        if (typeof args[curArg] === 'object' && isPartialObserver(args[curArg])) {\n            const userObserver = args[curArg++];\n            observer = {\n                next: userObserver.next,\n                error: userObserver.error,\n                complete: userObserver.complete\n            };\n        }\n        else {\n            observer = {\n                next: args[curArg++],\n                error: args[curArg++],\n                complete: args[curArg++]\n            };\n        }\n        return onSnapshotDocumentSnapshotBundle(db, json, options, observer, args[curArg]);\n    }\n    else {\n        throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, `unsupported bundle source: ${json.bundleSource}`);\n    }\n}\nfunction onSnapshotsInSync(firestore, arg) {\n    firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n    const client = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G)(firestore);\n    const observer = isPartialObserver(arg)\n        ? arg\n        : {\n            next: arg\n        };\n    return (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aa)(client, observer);\n}\n/**\n * Locally writes `mutations` on the async queue.\n * @internal\n */\nfunction executeWrite(firestore, mutations) {\n    const client = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G)(firestore);\n    return (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ab)(client, mutations);\n}\n/**\n * Converts a {@link ViewSnapshot} that contains the single document specified by `ref`\n * to a {@link DocumentSnapshot}.\n */\nfunction convertToDocSnapshot(firestore, ref, snapshot) {\n    const doc = snapshot.docs.get(ref._key);\n    const userDataWriter = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.J(firestore);\n    return new DocumentSnapshot(firestore, userDataWriter, ref._key, doc, new SnapshotMetadata(snapshot.hasPendingWrites, snapshot.fromCache), ref.converter);\n}\n/**\n * Ensures the data required to construct an {@link onSnapshot} listener exist in a `snapshotJson`\n * object that originates from {@link DocumentSnapshot.toJSON} or {@link Querysnapshot.toJSON}. The\n * data is normalized into a typed object.\n *\n * @param snapshotJson - The JSON object that the app provided to {@link onSnapshot}.\n * @returns A normalized object that contains all of the required bundle JSON fields. If\n * {@link snapshotJson} doesn't contain the required fields, or if the fields exist as empty\n * strings, then the {@link snapshotJson.error} field will be a non empty string.\n *\n * @internal\n */\nfunction normalizeSnapshotJsonFields(snapshotJson) {\n    const result = {\n        bundle: '',\n        bundleName: '',\n        bundleSource: ''\n    };\n    const requiredKeys = ['bundle', 'bundleName', 'bundleSource'];\n    for (const key of requiredKeys) {\n        if (!(key in snapshotJson)) {\n            result.error = `snapshotJson missing required field: ${key}`;\n            break;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const value = snapshotJson[key];\n        if (typeof value !== 'string') {\n            result.error = `snapshotJson field '${key}' must be a string.`;\n            break;\n        }\n        if (value.length === 0) {\n            result.error = `snapshotJson field '${key}' cannot be an empty string.`;\n            break;\n        }\n        if (key === 'bundle') {\n            result.bundle = value;\n        }\n        else if (key === 'bundleName') {\n            result.bundleName = value;\n        }\n        else if (key === 'bundleSource') {\n            result.bundleSource = value;\n        }\n    }\n    return result;\n}\n/**\n * Loads the bundle in a separate task and then invokes {@link onSnapshot} with a\n * {@link DocumentReference} for the document in the bundle.\n *\n * @param firestore - The {@link Firestore} instance for the {@link onSnapshot} operation request.\n * @param json - The JSON bundle to load, produced by {@link DocumentSnapshot.toJSON}.\n * @param options - Options controlling the listen behavior.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel the snapshot\n * listener.\n *\n * @internal\n */\nfunction onSnapshotDocumentSnapshotBundle(db, json, options, observer, converter) {\n    let unsubscribed = false;\n    let internalUnsubscribe;\n    const loadTask = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ar)(db, json.bundle);\n    loadTask\n        .then(() => {\n        if (!unsubscribed) {\n            const docReference = new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.D(db, converter ? converter : null, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.x.fromPath(json.bundleName));\n            internalUnsubscribe = onSnapshot(docReference, options ? options : {}, observer);\n        }\n    })\n        .catch(e => {\n        if (observer.error) {\n            observer.error(e);\n        }\n        return () => { };\n    });\n    return () => {\n        if (unsubscribed) {\n            return;\n        }\n        unsubscribed = true;\n        if (internalUnsubscribe) {\n            internalUnsubscribe();\n        }\n    };\n}\n/**\n * Loads the bundle in a separate task and then invokes {@link onSnapshot} with a\n * {@link Query} that represents the Query in the bundle.\n *\n * @param firestore - The {@link Firestore} instance for the {@link onSnapshot} operation request.\n * @param json - The JSON bundle to load, produced by {@link QuerySnapshot.toJSON}.\n * @param options - Options controlling the listen behavior.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel the snapshot\n * listener.\n *\n * @internal\n */\nfunction onSnapshotQuerySnapshotBundle(db, json, options, observer, converter) {\n    let unsubscribed = false;\n    let internalUnsubscribe;\n    const loadTask = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ar)(db, json.bundle);\n    loadTask\n        .then(() => (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.as)(db, json.bundleName))\n        .then(query => {\n        if (query && !unsubscribed) {\n            const realQuery = query;\n            if (converter) {\n                realQuery.withConverter(converter);\n            }\n            internalUnsubscribe = onSnapshot(query, options ? options : {}, observer);\n        }\n    })\n        .catch(e => {\n        if (observer.error) {\n            observer.error(e);\n        }\n        return () => { };\n    });\n    return () => {\n        if (unsubscribed) {\n            return;\n        }\n        unsubscribed = true;\n        if (internalUnsubscribe) {\n            internalUnsubscribe();\n        }\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Creates a write batch, used for performing multiple writes as a single\n * atomic operation. The maximum number of writes allowed in a single {@link WriteBatch}\n * is 500.\n *\n * Unlike transactions, write batches are persisted offline and therefore are\n * preferable when you don't need to condition your writes on read data.\n *\n * @returns A {@link WriteBatch} that can be used to atomically execute multiple\n * writes.\n */\nfunction writeBatch(firestore) {\n    firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n    (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G)(firestore);\n    return new WriteBatch(firestore, mutations => executeWrite(firestore, mutations));\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction setIndexConfiguration(firestore, jsonOrConfiguration) {\n    firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n    const client = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G)(firestore);\n    if (!client._uninitializedComponentsProvider ||\n        client._uninitializedComponentsProvider._offline.kind === 'memory') {\n        // PORTING NOTE: We don't return an error if the user has not enabled\n        // persistence since `enableIndexeddbPersistence()` can fail on the Web.\n        (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ac)('Cannot enable indexes when persistence is disabled');\n        return Promise.resolve();\n    }\n    const parsedIndexes = parseIndexes(jsonOrConfiguration);\n    return (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ad)(client, parsedIndexes);\n}\nfunction parseIndexes(jsonOrConfiguration) {\n    const indexConfiguration = typeof jsonOrConfiguration === 'string'\n        ? tryParseJson(jsonOrConfiguration)\n        : jsonOrConfiguration;\n    const parsedIndexes = [];\n    if (Array.isArray(indexConfiguration.indexes)) {\n        for (const index of indexConfiguration.indexes) {\n            const collectionGroup = tryGetString(index, 'collectionGroup');\n            const segments = [];\n            if (Array.isArray(index.fields)) {\n                for (const field of index.fields) {\n                    const fieldPathString = tryGetString(field, 'fieldPath');\n                    const fieldPath = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ae)('setIndexConfiguration', fieldPathString);\n                    if (field.arrayConfig === 'CONTAINS') {\n                        segments.push(new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.at(fieldPath, 2 /* IndexKind.CONTAINS */));\n                    }\n                    else if (field.order === 'ASCENDING') {\n                        segments.push(new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.at(fieldPath, 0 /* IndexKind.ASCENDING */));\n                    }\n                    else if (field.order === 'DESCENDING') {\n                        segments.push(new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.at(fieldPath, 1 /* IndexKind.DESCENDING */));\n                    }\n                }\n            }\n            parsedIndexes.push(new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.af(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.af.UNKNOWN_ID, collectionGroup, segments, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ag.empty()));\n        }\n    }\n    return parsedIndexes;\n}\nfunction tryParseJson(json) {\n    try {\n        return JSON.parse(json);\n    }\n    catch (e) {\n        throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, 'Failed to parse JSON: ' + e?.message);\n    }\n}\nfunction tryGetString(data, property) {\n    if (typeof data[property] !== 'string') {\n        throw new _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.j(_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.k.INVALID_ARGUMENT, 'Missing string value for: ' + property);\n    }\n    return data[property];\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `PersistentCacheIndexManager` for configuring persistent cache indexes used\n * for local query execution.\n *\n * To use, call `getPersistentCacheIndexManager()` to get an instance.\n */\nclass PersistentCacheIndexManager {\n    /** @hideconstructor */\n    constructor(_firestore) {\n        this._firestore = _firestore;\n        /** A type string to uniquely identify instances of this class. */\n        this.type = 'PersistentCacheIndexManager';\n    }\n}\n/**\n * Returns the PersistentCache Index Manager used by the given `Firestore`\n * object.\n *\n * @returns The `PersistentCacheIndexManager` instance, or `null` if local\n * persistent storage is not in use.\n */\nfunction getPersistentCacheIndexManager(firestore) {\n    firestore = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(firestore, _common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.F);\n    const cachedInstance = persistentCacheIndexManagerByFirestore.get(firestore);\n    if (cachedInstance) {\n        return cachedInstance;\n    }\n    const client = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G)(firestore);\n    if (client._uninitializedComponentsProvider?._offline.kind !== 'persistent') {\n        return null;\n    }\n    const instance = new PersistentCacheIndexManager(firestore);\n    persistentCacheIndexManagerByFirestore.set(firestore, instance);\n    return instance;\n}\n/**\n * Enables the SDK to create persistent cache indexes automatically for local\n * query execution when the SDK believes cache indexes can help improve\n * performance.\n *\n * This feature is disabled by default.\n */\nfunction enablePersistentCacheIndexAutoCreation(indexManager) {\n    setPersistentCacheIndexAutoCreationEnabled(indexManager, true);\n}\n/**\n * Stops creating persistent cache indexes automatically for local query\n * execution. The indexes which have been created by calling\n * `enablePersistentCacheIndexAutoCreation()` still take effect.\n */\nfunction disablePersistentCacheIndexAutoCreation(indexManager) {\n    setPersistentCacheIndexAutoCreationEnabled(indexManager, false);\n}\n/**\n * Removes all persistent cache indexes.\n *\n * Please note this function will also deletes indexes generated by\n * `setIndexConfiguration()`, which is deprecated.\n */\nfunction deleteAllPersistentCacheIndexes(indexManager) {\n    const client = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G)(indexManager._firestore);\n    const promise = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ah)(client);\n    promise\n        .then(_ => (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ai)('deleting all persistent cache indexes succeeded'))\n        .catch(error => (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ac)('deleting all persistent cache indexes failed', error));\n}\nfunction setPersistentCacheIndexAutoCreationEnabled(indexManager, isEnabled) {\n    const client = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.G)(indexManager._firestore);\n    const promise = (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.aj)(client, isEnabled);\n    promise\n        .then(_ => (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ai)(`setting persistent cache index auto creation ` +\n        `isEnabled=${isEnabled} succeeded`))\n        .catch(error => (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.ac)(`setting persistent cache index auto creation ` +\n        `isEnabled=${isEnabled} failed`, error));\n}\n/**\n * Maps `Firestore` instances to their corresponding\n * `PersistentCacheIndexManager` instances.\n *\n * Use a `WeakMap` so that the mapping will be automatically dropped when the\n * `Firestore` instance is garbage collected. This emulates a private member\n * as described in https://goo.gle/454yvug.\n */\nconst persistentCacheIndexManagerByFirestore = new WeakMap();\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Testing hooks for use by Firestore's integration test suite to reach into the\n * SDK internals to validate logic and behavior that is not visible from the\n * public API surface.\n *\n * @internal\n */\nclass TestingHooks {\n    constructor() {\n        throw new Error('instances of this class should not be created');\n    }\n    /**\n     * Registers a callback to be notified when an existence filter mismatch\n     * occurs in the Watch listen stream.\n     *\n     * The relative order in which callbacks are notified is unspecified; do not\n     * rely on any particular ordering. If a given callback is registered multiple\n     * times then it will be notified multiple times, once per registration.\n     *\n     * @param callback - the callback to invoke upon existence filter mismatch.\n     *\n     * @returns a function that, when called, unregisters the given callback; only\n     * the first invocation of the returned function does anything; all subsequent\n     * invocations do nothing.\n     */\n    static onExistenceFilterMismatch(callback) {\n        return TestingHooksSpiImpl.instance.onExistenceFilterMismatch(callback);\n    }\n}\n/**\n * The implementation of `TestingHooksSpi`.\n */\nclass TestingHooksSpiImpl {\n    constructor() {\n        this.existenceFilterMismatchCallbacksById = new Map();\n    }\n    static get instance() {\n        if (!testingHooksSpiImplInstance) {\n            testingHooksSpiImplInstance = new TestingHooksSpiImpl();\n            (0,_common_270e6a50_node_mjs__WEBPACK_IMPORTED_MODULE_2__.au)(testingHooksSpiImplInstance);\n        }\n        return testingHooksSpiImplInstance;\n    }\n    notifyOnExistenceFilterMismatch(info) {\n        this.existenceFilterMismatchCallbacksById.forEach(callback => callback(info));\n    }\n    onExistenceFilterMismatch(callback) {\n        const id = Symbol();\n        const callbacks = this.existenceFilterMismatchCallbacksById;\n        callbacks.set(id, callback);\n        return () => callbacks.delete(id);\n    }\n}\nlet testingHooksSpiImplInstance = null;\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nregisterFirestore('node');\n\n\n//# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BmaXJlYmFzZStmaXJlc3RvcmVANC4xMS4wX0BmaXJlYmFzZSthcHBAMC4xNC44L25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZmlyZXN0b3JlL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlGO0FBQ2pDO0FBQ3l4RTtBQUNqbEM7QUFDenJDO0FBQ2Q7QUFDdkI7QUFDWjtBQUNFO0FBQ087QUFDSzs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBYSxDQUFDLHNEQUFXO0FBQzdCLElBQUksaUVBQWtCLEtBQUssMERBQVMsNEJBQTRCLG1EQUFtRDtBQUNuSDtBQUNBLHNDQUFzQyx3REFBUyxLQUFLLHdEQUErQiw4Q0FBOEMsd0RBQTZCLG9EQUFvRCw0REFBaUI7QUFDbk8scUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSw4REFBZTtBQUNuQjtBQUNBLElBQUksOERBQWU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0RBQVc7QUFDekMsd0JBQXdCO0FBQ3hCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3REFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsNERBQXFCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQWMsQ0FBQyx3REFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxZQUFZO0FBQzVFLElBQUksY0FBYyxHQUFHLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHO0FBQ2xFLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLFlBQVksR0FBRyxtQkFBbUI7QUFDekUsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3REFBSyxtQ0FBbUMsNERBQW9CO0FBQy9FO0FBQ0E7QUFDQSx1QkFBdUIsNERBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtDQUFrQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRLGVBQWU7QUFDeEUsVUFBVTtBQUNWO0FBQ0EseUJBQXlCLGlDQUFpQztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNERBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlDQUFpQyxNQUFNLHFDQUFxQztBQUNoRiw4REFBOEQsVUFBVTtBQUN4RSxJQUFJLFdBQVcsMkJBQTJCLGlCQUFpQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQUssbUNBQW1DLDREQUFvQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0NBQXNDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0QkFBNEI7QUFDaEMsMEJBQTBCLFlBQVksR0FBRyxTQUFTLE1BQU0sVUFBVTtBQUNsRSwrQkFBK0IscUNBQXFDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNDQUFzQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEJBQTRCO0FBQ2hDLDBCQUEwQixZQUFZLEdBQUcsU0FBUyxNQUFNLFVBQVU7QUFDbEUsK0JBQStCLHFDQUFxQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGVBQWUsMkJBQTJCLGlCQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQUssbUNBQW1DLDREQUFxQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNERBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsYUFBYTtBQUNqRSxJQUFJLG1CQUFtQiwyQkFBMkIsaUJBQWlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3REFBSyxtQ0FBbUMsNERBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0EsSUFBSSw0REFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0EsSUFBSSw0REFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQkFBbUI7QUFDekUsSUFBSSxzQkFBc0IsMkJBQTJCLGlCQUFpQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3REFBSyxtQ0FBbUMsNERBQWdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRSxJQUFJLHFCQUFxQiwyQkFBMkIsaUJBQWlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdEQUFLLG1DQUFtQyw0REFBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0VBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3REFBYyxDQUFDLHdEQUFJLHdEQUF3RCxHQUFHO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBZTtBQUNwQztBQUNBO0FBQ0EsbUJBQW1CLHdEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdEQUFjLENBQUMsd0RBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdEQUFjLENBQUMsd0RBQUk7QUFDckM7QUFDQTtBQUNBLHdCQUF3Qix5REFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQWMsQ0FBQyx3REFBSTtBQUNyQyxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDREQUFzQjtBQUNoRDtBQUNBLDRCQUE0Qiw0REFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQWlCO0FBQ2pDLDBCQUEwQix3REFBYyxDQUFDLHdEQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdEQUFjLENBQUMsd0RBQUk7QUFDN0MscURBQXFELE1BQU07QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdEQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQWMsQ0FBQyx3REFBSSxxREFBcUQsV0FBVztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0RBQWMsQ0FBQyx3REFBSTtBQUM3Qyx1QkFBdUIsV0FBVyxnQkFBZ0IsZ0JBQWdCO0FBQ2xFO0FBQ0EsaUJBQWlCLDREQUFzQjtBQUN2QywwQkFBMEIsd0RBQWMsQ0FBQyx3REFBSTtBQUM3QywyQ0FBMkMsV0FBVztBQUN0RCx3QkFBd0IsU0FBUztBQUNqQztBQUNBLDBDQUEwQyx3REFBWTtBQUN0RCxpQkFBaUIsd0RBQVc7QUFDNUIsMEJBQTBCLHdEQUFjLENBQUMsd0RBQUk7QUFDN0MseURBQXlELFdBQVc7QUFDcEUsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBLDRCQUE0Qix3REFBVztBQUN2Qyw0QkFBNEIsNERBQVE7QUFDcEM7QUFDQTtBQUNBLDRCQUE0Qiw0REFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxlQUFlLHdEQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtFQUFrQjtBQUN4QztBQUNBO0FBQ0Esc0JBQXNCLHdEQUFjLENBQUMsd0RBQUk7QUFDekM7QUFDQTtBQUNBLGFBQWEsNERBQXNCO0FBQ25DLHNCQUFzQix3REFBYyxDQUFDLHdEQUFJO0FBQ3pDO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBLHNDQUFzQyx3REFBWTtBQUNsRCxhQUFhLHdEQUFXO0FBQ3hCLHNCQUFzQix3REFBYyxDQUFDLHdEQUFJO0FBQ3pDO0FBQ0Esd0JBQXdCLEtBQUsscURBQXFELFlBQVk7QUFDOUY7QUFDQSxlQUFlLDREQUFRLGlCQUFpQix3REFBVztBQUNuRDtBQUNBLHdDQUF3Qyx3REFBaUI7QUFDekQsZUFBZSw0REFBUTtBQUN2QjtBQUNBO0FBQ0Esa0JBQWtCLHdEQUFjLENBQUMsd0RBQUk7QUFDckM7QUFDQSxlQUFlLDREQUFnQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3REFBYyxDQUFDLHdEQUFJO0FBQ3JDLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3REFBYyxDQUFDLHdEQUFJO0FBQ3pDLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBLHNCQUFzQix3REFBYyxDQUFDLHdEQUFJLHFEQUFxRCwwQkFBMEI7QUFDeEgseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDREQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdEQUFjLENBQUMsd0RBQUksK0JBQStCLGFBQWE7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQWMsQ0FBQyx3REFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0RBQXNCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdEQUFpQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDREQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0REFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUFVLDZCQUE2Qix5REFBUztBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0REFBSSxrQkFBa0Isd0RBQVM7QUFDckQsbUJBQW1CLDREQUF5QjtBQUM1QywrQkFBK0IsNERBQVU7QUFDekMsbUJBQW1CLHlEQUFhO0FBQ2hDLEtBQUs7QUFDTDtBQUNBLFdBQVcsNERBQWdDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3REFBaUI7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHlEQUF1QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseURBQW1DO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlEQUE4QjtBQUN2RTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5REFBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5REFBdUI7QUFDL0Q7QUFDQSw2Q0FBNkMseURBQWlDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5REFBdUI7QUFDL0Q7QUFDQSw2Q0FBNkMseURBQWdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLDREQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRSxFQUFFLElBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQsc0JBQXNCLHlCQUF5QjtBQUMvQyxrQkFBa0IsT0FBTyxzQkFBc0IsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRCxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQyxtQkFBbUIsa0JBQWtCO0FBQ3JDLDBCQUEwQixnQkFBZ0I7QUFDMUMsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBaUQ7QUFDMUUsNEJBQTRCLFNBQVMsbUJBQW1CLDJCQUEyQjtBQUNuRix5QkFBeUI7QUFDekIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQWlEO0FBQzFFLDRCQUE0QixTQUFTLG1CQUFtQiwwQkFBMEI7QUFDbEYseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseURBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlEQUFtQjtBQUNqRDtBQUNBLGtDQUFrQyx5REFBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZEQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2REFBTTtBQUNoQztBQUNBLDBCQUEwQiw2REFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0EsaUNBQWlDLHlEQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2REFBYSxrQkFBa0IsNkRBQWE7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkRBQVc7QUFDakMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2REFBVztBQUN4QztBQUNBLGtCQUFrQiw2REFBTTtBQUN4QjtBQUNBLHdCQUF3Qiw2REFBVztBQUNuQyx3QkFBd0IsNkRBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsRUFBRSxFQUFFLElBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGtCQUFrQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2REFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsVUFBVTtBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx3REFBTTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0Esb0RBQW9ELDREQUFxQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsc0JBQXNCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFjLENBQUMsd0RBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0REFBUTtBQUNsQixrQkFBa0IsNERBQVE7QUFDMUIsZ0JBQWdCLDREQUFRO0FBQ3hCLFlBQVksNERBQVE7QUFDcEI7QUFDQTtBQUNBLFFBQVEsNERBQVk7QUFDcEI7QUFDQSxzQkFBc0Isd0RBQWMsQ0FBQyx3REFBSTtBQUN6QztBQUNBO0FBQ0EsMkJBQTJCLDREQUFhO0FBQ3hDLDZCQUE2Qiw0REFBc0I7QUFDbkQ7QUFDQSxpQ0FBaUMsd0RBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFjLENBQUMsd0RBQUksa0ZBQWtGLHlCQUF5QjtBQUNwSjtBQUNBO0FBQ0EseUJBQXlCLDREQUFZO0FBQ3JDLGdDQUFnQyx3REFBVyxDQUFDLHdEQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQWMsQ0FBQyx3REFBSTtBQUN6Qyw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usc0JBQXNCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFjLENBQUMsd0RBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdEQUFNO0FBQ3JDO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVSxhQUFhLFdBQVc7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0REFBUTtBQUNsQixrQkFBa0IsNERBQVE7QUFDMUIsZ0JBQWdCLDREQUFRO0FBQ3hCLFlBQVksNERBQVE7QUFDcEI7QUFDQTtBQUNBLFFBQVEsNERBQVk7QUFDcEI7QUFDQSxzQkFBc0Isd0RBQWMsQ0FBQyx3REFBSTtBQUN6QztBQUNBO0FBQ0EsMkJBQTJCLDREQUFhO0FBQ3hDLDZCQUE2Qiw0REFBc0I7QUFDbkQ7QUFDQSxpQ0FBaUMsd0RBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQWMsQ0FBQyx3REFBSSwrREFBK0QsNkJBQTZCO0FBQ3JJO0FBQ0E7QUFDQSxzQkFBc0IsNERBQWdCO0FBQ3RDO0FBQ0E7QUFDQSw4QkFBOEIsd0RBQVc7QUFDekM7QUFDQSw2QkFBNkIsNERBQVk7QUFDekM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw2QkFBNkIsd0RBQVksMENBQTBDLDREQUFjO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3REFBSztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0REFBSSxXQUFXLE1BQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdEQUFjLENBQUMsd0RBQUk7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxpQkFBaUI7QUFDdEU7QUFDQSxpREFBaUQseUJBQXlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0REFBWTtBQUNuQyx5REFBeUQsd0RBQVk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQWtCO0FBQzlDO0FBQ0E7QUFDQSx5Q0FBeUMsd0RBQVM7QUFDbEQscUJBQXFCLDREQUFrQjtBQUN2QztBQUNBO0FBQ0EscUJBQXFCLDZEQUFlO0FBQ3BDO0FBQ0EseURBQXlELHdEQUFZO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx3QkFBd0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQseURBQWMsV0FBVyx3REFBWTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQWMsQ0FBQyx3REFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtFQUFrQjtBQUNwQztBQUNBLGtCQUFrQix3REFBYyxDQUFDLHdEQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBaUI7QUFDNUM7QUFDQTtBQUNBLHNEQUFzRCx3QkFBd0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0REFBSTtBQUMxQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0REFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRUFBa0I7QUFDOUM7QUFDQTtBQUNBLHlDQUF5Qyx3REFBUztBQUNsRCxxQkFBcUIsNERBQWtCO0FBQ3ZDO0FBQ0E7QUFDQSxxQkFBcUIsNkRBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx3QkFBd0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsd0JBQXdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3REFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFJLFlBQVksd0RBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0REFBeUI7QUFDNUMsV0FBVyw2REFBMEI7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUJBQXVCLElBQUksdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBSSxZQUFZLHdEQUFpQjtBQUNqRCxzQkFBc0IsNERBQUksc0JBQXNCLHdEQUFTO0FBQ3pELG1CQUFtQiw0REFBeUI7QUFDNUMsV0FBVyw2REFBNkM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFJLFlBQVksd0RBQWlCO0FBQ2pELHNCQUFzQiw0REFBSSxzQkFBc0Isd0RBQVM7QUFDekQsbUJBQW1CLDREQUF5QjtBQUM1QywrQkFBK0Isd0RBQWlCO0FBQ2hELFdBQVcsNkRBQXdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFJLFlBQVksd0RBQWlCO0FBQ2pELHNCQUFzQiw0REFBSSxzQkFBc0Isd0RBQVM7QUFDekQsbUJBQW1CLDREQUF5QjtBQUM1QyxXQUFXLDZEQUE2QztBQUN4RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCLElBQUksd0JBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0REFBSSxRQUFRLHdEQUFLO0FBQzdCLHNCQUFzQiw0REFBSSxrQkFBa0Isd0RBQVM7QUFDckQsbUJBQW1CLDREQUF5QjtBQUM1QywrQkFBK0Isd0RBQWlCO0FBQ2hEO0FBQ0EsV0FBVyw2REFBOEM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0REFBSSxRQUFRLHdEQUFLO0FBQzdCLHNCQUFzQiw0REFBSSxrQkFBa0Isd0RBQVM7QUFDckQsbUJBQW1CLDREQUF5QjtBQUM1QywrQkFBK0Isd0RBQWlCO0FBQ2hELFdBQVcsNkRBQXlDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUFJLFFBQVEsd0RBQUs7QUFDN0Isc0JBQXNCLDREQUFJLGtCQUFrQix3REFBUztBQUNyRCxtQkFBbUIsNERBQXlCO0FBQzVDLCtCQUErQix3REFBaUI7QUFDaEQsV0FBVyw2REFBOEM7QUFDekQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQiw0REFBSSxZQUFZLHdEQUFpQjtBQUNqRCxzQkFBc0IsNERBQUksc0JBQXNCLHdEQUFTO0FBQ3pEO0FBQ0EsdUJBQXVCLDREQUFpQjtBQUN4QyxtQkFBbUIsNERBQVk7QUFDL0IsdURBQXVELHdEQUFZO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBSSxZQUFZLHdEQUFpQjtBQUNqRCxzQkFBc0IsNERBQUksc0JBQXNCLHdEQUFTO0FBQ3pELHVCQUF1Qiw0REFBaUI7QUFDeEM7QUFDQTtBQUNBLHdCQUF3QixrRUFBa0I7QUFDMUM7QUFDQTtBQUNBLHFDQUFxQyx3REFBUztBQUM5QyxpQkFBaUIsNERBQWtCO0FBQ25DO0FBQ0E7QUFDQSxpQkFBaUIsNkRBQWU7QUFDaEM7QUFDQSx1REFBdUQsd0RBQVk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNERBQUksc0JBQXNCLHdEQUFTO0FBQ3pELDJCQUEyQix5REFBYyxpQkFBaUIsd0RBQVk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNERBQUksc0JBQXNCLHdEQUFTO0FBQ3pELG1CQUFtQiw2REFBRztBQUN0QjtBQUNBLHVCQUF1Qiw0REFBaUI7QUFDeEMsbUJBQW1CLDREQUFZLG9GQUFvRjtBQUNuSCxvREFBb0Qsd0RBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3REFBaUI7QUFDOUMsb0JBQW9CLDREQUFJLHNCQUFzQix3REFBUztBQUN2RCx3QkFBd0IsNkRBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDREQUFJLFlBQVksd0RBQUs7QUFDM0Msb0JBQW9CLDREQUFJLGtCQUFrQix3REFBUztBQUNuRDtBQUNBLG1DQUFtQyx3REFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDREQUF5QjtBQUM1QyxXQUFXLDZEQUFxQjtBQUNoQztBQUNBO0FBQ0EsZUFBZSxrRUFBa0I7QUFDakM7QUFDQTtBQUNBLGtCQUFrQix3REFBYyxDQUFDLHdEQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3REFBYyxDQUFDLHdEQUFJLGlEQUFpRCxrQkFBa0I7QUFDeEc7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFJLFlBQVksd0RBQVM7QUFDekMsbUJBQW1CLDREQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2REFBeUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDREQUF5QjtBQUM1QyxXQUFXLDZEQUFvQjtBQUMvQjtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsU0FBUyx1QkFBdUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdEQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0JBQWtCO0FBQ2hFLGdDQUFnQywrQkFBK0IsSUFBSSwyQkFBMkI7QUFDOUY7QUFDQTtBQUNBLG1FQUFtRSxpQkFBaUI7QUFDcEY7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QixzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxJQUFJO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsa0JBQWtCO0FBQzNFLElBQUkseUJBQXlCO0FBQzdCO0FBQ0EsMkJBQTJCLGlCQUFpQixrQkFBa0Isa0JBQWtCO0FBQ2hGLHVEQUF1RCw4QkFBOEI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZEQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3REFBaUIsbUNBQW1DLHdEQUFXO0FBQ3BHLGlGQUFpRjtBQUNqRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsa0JBQWtCO0FBQzNFLElBQUksYUFBYTtBQUNqQjtBQUNBLDJCQUEyQixpQkFBaUIsa0JBQWtCLGtCQUFrQjtBQUNoRix1REFBdUQsMkJBQTJCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2REFBVTtBQUMvQjtBQUNBLG9CQUFvQiw2REFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBSSxZQUFZLHdEQUFTO0FBQ3pDLElBQUksNERBQXlCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBSSxZQUFZLHdEQUFTO0FBQ3pDLG1CQUFtQiw0REFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2REFBb0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNkRBQStCO0FBQ3JFO0FBQ0EsMENBQTBDLHlEQUFZO0FBQ3REO0FBQ0E7QUFDQSwwQ0FBMEMseURBQVk7QUFDdEQ7QUFDQTtBQUNBLDBDQUEwQyx5REFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseURBQVUsQ0FBQyx5REFBVSx3Q0FBd0MseURBQVU7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdEQUFjLENBQUMsd0RBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQWMsQ0FBQyx3REFBSTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBSSxZQUFZLHdEQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDREQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDREQUF5QjtBQUM1QyxvQkFBb0IsNkRBQW9DO0FBQ3hEO0FBQ0EsbUJBQW1CLDZEQUFRO0FBQzNCLHdCQUF3Qiw2REFBTztBQUMvQjtBQUNBO0FBQ0EsbUJBQW1CLDREQUF5QjtBQUM1QyxvQkFBb0IsNkRBQXlEO0FBQzdFO0FBQ0EsbUJBQW1CLDZEQUFRO0FBQzNCLHFCQUFxQixXQUFXO0FBQ2hDLHdCQUF3Qiw2REFBTztBQUMvQixxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkRBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcXFDO0FBQ3JxQyIsInNvdXJjZXMiOlsiL1VzZXJzL3Rob21hc2h1bGloYW4vUHJvamVjdHMvVFJSL1RSUi1BUFAvbm9kZV9tb2R1bGVzLy5wbnBtL0BmaXJlYmFzZStmaXJlc3RvcmVANC4xMS4wX0BmaXJlYmFzZSthcHBAMC4xNC44L25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZmlyZXN0b3JlL2Rpc3QvaW5kZXgubm9kZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX3JlZ2lzdGVyQ29tcG9uZW50LCByZWdpc3RlclZlcnNpb24sIFNES19WRVJTSU9OIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IEEgYXMgQWJzdHJhY3RVc2VyRGF0YVdyaXRlciwgQiBhcyBCeXRlcywgRCBhcyBEb2N1bWVudFJlZmVyZW5jZSwgbiBhcyBuZXdUZXh0RW5jb2RlciwgcCBhcyBwcm9wZXJ0eSwgcyBhcyBzZXRTREtWZXJzaW9uLCBGIGFzIEZpcmVzdG9yZSwgYSBhcyBGaXJlYmFzZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyLCBiIGFzIEZpcmViYXNlQXBwQ2hlY2tUb2tlblByb3ZpZGVyLCBkIGFzIGRhdGFiYXNlSWRGcm9tQXBwLCBPIGFzIE9iamVjdFZhbHVlLCBRIGFzIFF1ZXJ5LCBxIGFzIHF1ZXJ5V2l0aEFkZGVkRmlsdGVyLCBjIGFzIG5ld1VzZXJEYXRhUmVhZGVyLCBmIGFzIGZpZWxkUGF0aEZyb21Bcmd1bWVudCwgQyBhcyBDb21wb3NpdGVGaWx0ZXIsIGUgYXMgcXVlcnlXaXRoQWRkZWRPcmRlckJ5LCBnIGFzIHF1ZXJ5V2l0aExpbWl0LCB2IGFzIHZhbGlkYXRlUG9zaXRpdmVOdW1iZXIsIGggYXMgcXVlcnlXaXRoU3RhcnRBdCwgaSBhcyBxdWVyeVdpdGhFbmRBdCwgaiBhcyBGaXJlc3RvcmVFcnJvciwgayBhcyBDb2RlLCBsIGFzIHBhcnNlUXVlcnlWYWx1ZSwgbSBhcyBGaWVsZEZpbHRlciwgbyBhcyBxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5LCByIGFzIHJlZlZhbHVlLCB0IGFzIGlzU2VydmVyVGltZXN0YW1wLCB1IGFzIEJvdW5kLCB3IGFzIGlzQ29sbGVjdGlvbkdyb3VwUXVlcnksIFIgYXMgUmVzb3VyY2VQYXRoLCB4IGFzIERvY3VtZW50S2V5LCB5IGFzIHZhbHVlRGVzY3JpcHRpb24sIHogYXMgcXVlcnlFcXVhbCwgRSBhcyBjYXN0LCBHIGFzIGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQsIEggYXMgbWFwVG9BcnJheSwgSSBhcyBmaXJlc3RvcmVDbGllbnRSdW5BZ2dyZWdhdGVRdWVyeSwgSiBhcyBFeHBVc2VyRGF0YVdyaXRlciwgSyBhcyB2YWxpZGF0ZUpTT04sIEwgYXMgbmV3U2VyaWFsaXplciwgTSBhcyBjcmVhdGVCdW5kbGVSZWFkZXJTeW5jLCBOIGFzIEJ1bmRsZUxvYWRlciwgUCBhcyBmcm9tRG9jdW1lbnQsIFMgYXMgQXV0b0lkLCBUIGFzIGZyb21CdW5kbGVkUXVlcnksIFUgYXMgRG9jdW1lbnRTZXQsIFYgYXMgVmlld1NuYXBzaG90LCBXIGFzIGRvY3VtZW50S2V5U2V0LCBYIGFzIGZhaWwsIFkgYXMgcGFyc2VTZXREYXRhLCBaIGFzIFByZWNvbmRpdGlvbiwgXyBhcyBGaWVsZFBhdGgsICQgYXMgcGFyc2VVcGRhdGVWYXJhcmdzLCBhMCBhcyBwYXJzZVVwZGF0ZURhdGEsIGExIGFzIERlbGV0ZU11dGF0aW9uLCBhMiBhcyBmaXJlc3RvcmVDbGllbnRUcmFuc2FjdGlvbiwgYTMgYXMgZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRWaWFTbmFwc2hvdExpc3RlbmVyLCBhNCBhcyBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudEZyb21Mb2NhbENhY2hlLCBhNSBhcyBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNWaWFTbmFwc2hvdExpc3RlbmVyLCBhNiBhcyBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNGcm9tTG9jYWxDYWNoZSwgYTcgYXMgZG9jLCBhOCBhcyBuZXdRdWVyeUZvclBhdGgsIGE5IGFzIGZpcmVzdG9yZUNsaWVudExpc3RlbiwgYWEgYXMgZmlyZXN0b3JlQ2xpZW50QWRkU25hcHNob3RzSW5TeW5jTGlzdGVuZXIsIGFiIGFzIGZpcmVzdG9yZUNsaWVudFdyaXRlLCBhYyBhcyBsb2dXYXJuLCBhZCBhcyBmaXJlc3RvcmVDbGllbnRTZXRJbmRleENvbmZpZ3VyYXRpb24sIGFlIGFzIGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcsIGFmIGFzIEZpZWxkSW5kZXgsIGFnIGFzIEluZGV4U3RhdGUsIGFoIGFzIGZpcmVzdG9yZUNsaWVudERlbGV0ZUFsbEZpZWxkSW5kZXhlcywgYWkgYXMgbG9nRGVidWcsIGFqIGFzIGZpcmVzdG9yZUNsaWVudFNldFBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZCwgYWsgYXMgT3JkZXJCeSwgYWwgYXMgQWdncmVnYXRlSW1wbCwgYW0gYXMgT25saW5lQ29tcG9uZW50UHJvdmlkZXIsIGFuIGFzIExydUdjTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLCBhbyBhcyBNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIsIGFwIGFzIEluZGV4ZWREYk9mZmxpbmVDb21wb25lbnRQcm92aWRlciwgYXEgYXMgTXVsdGlUYWJPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIsIGFyIGFzIGxvYWRCdW5kbGUsIGFzIGFzIG5hbWVkUXVlcnksIGF0IGFzIEluZGV4U2VnbWVudCwgYXUgYXMgc2V0VGVzdGluZ0hvb2tzU3BpLCBhdiBhcyBUaW1lc3RhbXAsIGF3IGFzIEpzb25Qcm90b1NlcmlhbGl6ZXIsIGF4IGFzIFVzZXJEYXRhUmVhZGVyLCBheSBhcyBmcm9tVGltZXN0YW1wLCBheiBhcyB0b05hbWUsIGFBIGFzIHRvVGltZXN0YW1wLCBhQiBhcyB0b1F1ZXJ5VGFyZ2V0LCBhQyBhcyBxdWVyeVRvVGFyZ2V0LCBhRCBhcyBwYXJzZU9iamVjdCB9IGZyb20gJy4vY29tbW9uLTI3MGU2YTUwLm5vZGUubWpzJztcbmV4cG9ydCB7IEEgYXMgQWJzdHJhY3RVc2VyRGF0YVdyaXRlciwgQiBhcyBCeXRlcywgYUUgYXMgQ0FDSEVfU0laRV9VTkxJTUlURUQsIGFGIGFzIENvbGxlY3Rpb25SZWZlcmVuY2UsIEQgYXMgRG9jdW1lbnRSZWZlcmVuY2UsIF8gYXMgRmllbGRQYXRoLCBhRyBhcyBGaWVsZFZhbHVlLCBGIGFzIEZpcmVzdG9yZSwgaiBhcyBGaXJlc3RvcmVFcnJvciwgYUggYXMgR2VvUG9pbnQsIGFJIGFzIExvYWRCdW5kbGVUYXNrLCBRIGFzIFF1ZXJ5LCBhdiBhcyBUaW1lc3RhbXAsIGFKIGFzIFZlY3RvclZhbHVlLCBTIGFzIF9BdXRvSWQsIGFLIGFzIF9CeXRlU3RyaW5nLCBhTCBhcyBfRGF0YWJhc2VJZCwgeCBhcyBfRG9jdW1lbnRLZXksIGFNIGFzIF9FbXB0eUFwcENoZWNrVG9rZW5Qcm92aWRlciwgYU4gYXMgX0VtcHR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIsIGFPIGFzIF9GaWVsZFBhdGgsIEUgYXMgX2Nhc3QsIGFQIGFzIF9kZWJ1Z0Fzc2VydCwgYVEgYXMgX2ludGVybmFsQWdncmVnYXRpb25RdWVyeVRvUHJvdG9SdW5BZ2dyZWdhdGlvblF1ZXJ5UmVxdWVzdCwgYVIgYXMgX2ludGVybmFsUXVlcnlUb1Byb3RvUXVlcnlUYXJnZXQsIGFTIGFzIF9pc0Jhc2U2NEF2YWlsYWJsZSwgYWMgYXMgX2xvZ1dhcm4sIGFUIGFzIF92YWxpZGF0ZUlzTm90VXNlZFRvZ2V0aGVyLCBhVSBhcyBhcnJheVJlbW92ZSwgYVYgYXMgYXJyYXlVbmlvbiwgYVcgYXMgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZSwgYVggYXMgY29sbGVjdGlvbiwgYVkgYXMgY29sbGVjdGlvbkdyb3VwLCBhWiBhcyBjb25uZWN0RmlyZXN0b3JlRW11bGF0b3IsIGFfIGFzIGRlbGV0ZUZpZWxkLCBhJCBhcyBkaXNhYmxlTmV0d29yaywgYTcgYXMgZG9jLCBiMCBhcyBkb2N1bWVudElkLCBiMSBhcyBlbmFibGVJbmRleGVkRGJQZXJzaXN0ZW5jZSwgYjIgYXMgZW5hYmxlTXVsdGlUYWJJbmRleGVkRGJQZXJzaXN0ZW5jZSwgYjMgYXMgZW5hYmxlTmV0d29yaywgRyBhcyBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkLCBiNCBhcyBnZXRGaXJlc3RvcmUsIGI1IGFzIGluY3JlbWVudCwgYjYgYXMgaW5pdGlhbGl6ZUZpcmVzdG9yZSwgYXIgYXMgbG9hZEJ1bmRsZSwgYXMgYXMgbmFtZWRRdWVyeSwgeiBhcyBxdWVyeUVxdWFsLCBiNyBhcyByZWZFcXVhbCwgYjggYXMgc2VydmVyVGltZXN0YW1wLCBiOSBhcyBzZXRMb2dMZXZlbCwgYmEgYXMgdGVybWluYXRlLCBiYiBhcyB2ZWN0b3IsIGJjIGFzIHdhaXRGb3JQZW5kaW5nV3JpdGVzIH0gZnJvbSAnLi9jb21tb24tMjcwZTZhNTAubm9kZS5tanMnO1xuaW1wb3J0IHsgZ2V0TW9kdWxhckluc3RhbmNlLCBkZWVwRXF1YWwgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgJ0BmaXJlYmFzZS93ZWJjaGFubmVsLXdyYXBwZXIvYmxvb20tYmxvYic7XG5pbXBvcnQgJ0BmaXJlYmFzZS9sb2dnZXInO1xuaW1wb3J0ICd1dGlsJztcbmltcG9ydCAnY3J5cHRvJztcbmltcG9ydCAnQGdycGMvZ3JwYy1qcyc7XG5pbXBvcnQgJ0BncnBjL3Byb3RvLWxvYWRlcic7XG5cbmNvbnN0IG5hbWUkMSA9IFwiQGZpcmViYXNlL2ZpcmVzdG9yZVwiO1xuY29uc3QgdmVyc2lvbiA9IFwiNC4xMS4wXCI7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiByZWdpc3RlckZpcmVzdG9yZSh2YXJpYW50LCB1c2VGZXRjaFN0cmVhbXMgPSB0cnVlKSB7XG4gICAgc2V0U0RLVmVyc2lvbihTREtfVkVSU0lPTik7XG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2ZpcmVzdG9yZScsIChjb250YWluZXIsIHsgaW5zdGFuY2VJZGVudGlmaWVyOiBkYXRhYmFzZUlkLCBvcHRpb25zOiBzZXR0aW5ncyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgIGNvbnN0IGZpcmVzdG9yZUluc3RhbmNlID0gbmV3IEZpcmVzdG9yZShuZXcgRmlyZWJhc2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlcihjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2F1dGgtaW50ZXJuYWwnKSksIG5ldyBGaXJlYmFzZUFwcENoZWNrVG9rZW5Qcm92aWRlcihhcHAsIGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwLWNoZWNrLWludGVybmFsJykpLCBkYXRhYmFzZUlkRnJvbUFwcChhcHAsIGRhdGFiYXNlSWQpLCBhcHApO1xuICAgICAgICBzZXR0aW5ncyA9IHsgdXNlRmV0Y2hTdHJlYW1zLCAuLi5zZXR0aW5ncyB9O1xuICAgICAgICBmaXJlc3RvcmVJbnN0YW5jZS5fc2V0U2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgICByZXR1cm4gZmlyZXN0b3JlSW5zdGFuY2U7XG4gICAgfSwgJ1BVQkxJQycpLnNldE11bHRpcGxlSW5zdGFuY2VzKHRydWUpKTtcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSQxLCB2ZXJzaW9uLCB2YXJpYW50KTtcbiAgICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc20sIGNqcywgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cbiAgICByZWdpc3RlclZlcnNpb24obmFtZSQxLCB2ZXJzaW9uLCAnZXNtMjAyMCcpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFnZ3JlZ2F0aW9uIHRoYXQgY2FuIGJlIHBlcmZvcm1lZCBieSBGaXJlc3RvcmUuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbmNsYXNzIEFnZ3JlZ2F0ZUZpZWxkIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgQWdncmVnYXRlRmllbGQ8VD5cbiAgICAgKiBAcGFyYW0gYWdncmVnYXRlVHlwZSAtIFNwZWNpZmllcyB0aGUgdHlwZSBvZiBhZ2dyZWdhdGlvbiBvcGVyYXRpb24gdG8gcGVyZm9ybS5cbiAgICAgKiBAcGFyYW0gX2ludGVybmFsRmllbGRQYXRoIC0gT3B0aW9uYWxseSBzcGVjaWZpZXMgdGhlIGZpZWxkIHRoYXQgaXMgYWdncmVnYXRlZC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZ2dyZWdhdGVUeXBlID0gJ2NvdW50JywgX2ludGVybmFsRmllbGRQYXRoKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsRmllbGRQYXRoID0gX2ludGVybmFsRmllbGRQYXRoO1xuICAgICAgICAvKiogQSB0eXBlIHN0cmluZyB0byB1bmlxdWVseSBpZGVudGlmeSBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcy4gKi9cbiAgICAgICAgdGhpcy50eXBlID0gJ0FnZ3JlZ2F0ZUZpZWxkJztcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVUeXBlID0gYWdncmVnYXRlVHlwZTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSByZXN1bHRzIG9mIGV4ZWN1dGluZyBhbiBhZ2dyZWdhdGlvbiBxdWVyeS5cbiAqL1xuY2xhc3MgQWdncmVnYXRlUXVlcnlTbmFwc2hvdCB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihxdWVyeSwgX3VzZXJEYXRhV3JpdGVyLCBfZGF0YSkge1xuICAgICAgICB0aGlzLl91c2VyRGF0YVdyaXRlciA9IF91c2VyRGF0YVdyaXRlcjtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgICAgICAvKiogQSB0eXBlIHN0cmluZyB0byB1bmlxdWVseSBpZGVudGlmeSBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcy4gKi9cbiAgICAgICAgdGhpcy50eXBlID0gJ0FnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgdGhlIGFnZ3JlZ2F0aW9ucyBwZXJmb3JtZWQgb3ZlciB0aGUgdW5kZXJseWluZ1xuICAgICAqIHF1ZXJ5LlxuICAgICAqXG4gICAgICogVGhlIGtleXMgb2YgdGhlIHJldHVybmVkIG9iamVjdCB3aWxsIGJlIHRoZSBzYW1lIGFzIHRob3NlIG9mIHRoZVxuICAgICAqIGBBZ2dyZWdhdGVTcGVjYCBvYmplY3Qgc3BlY2lmaWVkIHRvIHRoZSBhZ2dyZWdhdGlvbiBtZXRob2QsIGFuZCB0aGUgdmFsdWVzXG4gICAgICogd2lsbCBiZSB0aGUgY29ycmVzcG9uZGluZyBhZ2dyZWdhdGlvbiByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0cyBvZiB0aGUgYWdncmVnYXRpb25zIHBlcmZvcm1lZCBvdmVyIHRoZSB1bmRlcmx5aW5nXG4gICAgICogcXVlcnkuXG4gICAgICovXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhV3JpdGVyLmNvbnZlcnRPYmplY3RNYXAodGhpcy5fZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIGZpZWxkcyBpbiB0aGUgc25hcHNob3QgYXMgYSBwcm90byB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgc25hcHNob3QuXG4gICAgICovXG4gICAgX2ZpZWxkc1Byb3RvKCkge1xuICAgICAgICAvLyBXcmFwIGRhdGEgaW4gYW4gT2JqZWN0VmFsdWUgdG8gY2xvbmUgaXQuXG4gICAgICAgIGNvbnN0IGRhdGFDbG9uZSA9IG5ldyBPYmplY3RWYWx1ZSh7XG4gICAgICAgICAgICBtYXBWYWx1ZTogeyBmaWVsZHM6IHRoaXMuX2RhdGEgfVxuICAgICAgICB9KS5jbG9uZSgpO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGNsb25lZCB2YWx1ZSB0byBwcmV2ZW50IG1hbmlwdWxhdGlvbiBvZiB0aGUgU25hcHNob3QncyBkYXRhXG4gICAgICAgIHJldHVybiBkYXRhQ2xvbmUudmFsdWUubWFwVmFsdWUuZmllbGRzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBgRG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbnMgZGF0YSByZWFkIGZyb20gYSBkb2N1bWVudCBpbiB5b3VyIEZpcmVzdG9yZVxuICogZGF0YWJhc2UuIFRoZSBkYXRhIGNhbiBiZSBleHRyYWN0ZWQgd2l0aCBgLmRhdGEoKWAgb3IgYC5nZXQoPGZpZWxkPilgIHRvXG4gKiBnZXQgYSBzcGVjaWZpYyBmaWVsZC5cbiAqXG4gKiBGb3IgYSBgRG9jdW1lbnRTbmFwc2hvdGAgdGhhdCBwb2ludHMgdG8gYSBub24tZXhpc3RpbmcgZG9jdW1lbnQsIGFueSBkYXRhXG4gKiBhY2Nlc3Mgd2lsbCByZXR1cm4gJ3VuZGVmaW5lZCcuIFlvdSBjYW4gdXNlIHRoZSBgZXhpc3RzKClgIG1ldGhvZCB0b1xuICogZXhwbGljaXRseSB2ZXJpZnkgYSBkb2N1bWVudCdzIGV4aXN0ZW5jZS5cbiAqL1xuY2xhc3MgRG9jdW1lbnRTbmFwc2hvdCQxIHtcbiAgICAvLyBOb3RlOiBUaGlzIGNsYXNzIGlzIHN0cmlwcGVkIGRvd24gdmVyc2lvbiBvZiB0aGUgRG9jdW1lbnRTbmFwc2hvdCBpblxuICAgIC8vIHRoZSBsZWdhY3kgU0RLLiBUaGUgY2hhbmdlcyBhcmU6XG4gICAgLy8gLSBObyBzdXBwb3J0IGZvciBTbmFwc2hvdE1ldGFkYXRhLlxuICAgIC8vIC0gTm8gc3VwcG9ydCBmb3IgU25hcHNob3RPcHRpb25zLlxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yIHByb3RlY3RlZCAqL1xuICAgIGNvbnN0cnVjdG9yKF9maXJlc3RvcmUsIF91c2VyRGF0YVdyaXRlciwgX2tleSwgX2RvY3VtZW50LCBfY29udmVydGVyKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XG4gICAgICAgIHRoaXMuX3VzZXJEYXRhV3JpdGVyID0gX3VzZXJEYXRhV3JpdGVyO1xuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IF9kb2N1bWVudDtcbiAgICAgICAgdGhpcy5fY29udmVydGVyID0gX2NvbnZlcnRlcjtcbiAgICB9XG4gICAgLyoqIFByb3BlcnR5IG9mIHRoZSBgRG9jdW1lbnRTbmFwc2hvdGAgdGhhdCBwcm92aWRlcyB0aGUgZG9jdW1lbnQncyBJRC4gKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXkucGF0aC5sYXN0U2VnbWVudCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYERvY3VtZW50UmVmZXJlbmNlYCBmb3IgdGhlIGRvY3VtZW50IGluY2x1ZGVkIGluIHRoZSBgRG9jdW1lbnRTbmFwc2hvdGAuXG4gICAgICovXG4gICAgZ2V0IHJlZigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFJlZmVyZW5jZSh0aGlzLl9maXJlc3RvcmUsIHRoaXMuX2NvbnZlcnRlciwgdGhpcy5fa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbmFscyB3aGV0aGVyIG9yIG5vdCB0aGUgZG9jdW1lbnQgYXQgdGhlIHNuYXBzaG90J3MgbG9jYXRpb24gZXhpc3RzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZG9jdW1lbnQgZXhpc3RzLlxuICAgICAqL1xuICAgIGV4aXN0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50ICE9PSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgYXMgYW4gYE9iamVjdGAuIFJldHVybnMgYHVuZGVmaW5lZGAgaWZcbiAgICAgKiB0aGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgb3IgYHVuZGVmaW5lZGBcbiAgICAgKiBpZiB0aGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdC5cbiAgICAgKi9cbiAgICBkYXRhKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2RvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2NvbnZlcnRlcikge1xuICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHVzZSB0aGUgY29udmVydGVyIGFuZCBjcmVhdGUgYSBuZXcgRG9jdW1lbnRTbmFwc2hvdFxuICAgICAgICAgICAgLy8gaWYgYSBjb252ZXJ0ZXIgaGFzIGJlZW4gcHJvdmlkZWQuXG4gICAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IG5ldyBRdWVyeURvY3VtZW50U25hcHNob3QkMSh0aGlzLl9maXJlc3RvcmUsIHRoaXMuX3VzZXJEYXRhV3JpdGVyLCB0aGlzLl9rZXksIHRoaXMuX2RvY3VtZW50LCBcbiAgICAgICAgICAgIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydGVyLmZyb21GaXJlc3RvcmUoc25hcHNob3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhV3JpdGVyLmNvbnZlcnRWYWx1ZSh0aGlzLl9kb2N1bWVudC5kYXRhLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogUmV0cmlldmVzIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IGFzIGEgcHJvdG8gVmFsdWUuIFJldHVybnMgYHVuZGVmaW5lZGAgaWZcbiAgICAgKiB0aGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgb3IgYHVuZGVmaW5lZGBcbiAgICAgKiBpZiB0aGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdC5cbiAgICAgKi9cbiAgICBfZmllbGRzUHJvdG8oKSB7XG4gICAgICAgIC8vIFJldHVybiBhIGNsb25lZCB2YWx1ZSB0byBwcmV2ZW50IG1hbmlwdWxhdGlvbiBvZiB0aGUgU25hcHNob3QncyBkYXRhXG4gICAgICAgIHJldHVybiB0aGlzLl9kb2N1bWVudD8uZGF0YS5jbG9uZSgpLnZhbHVlLm1hcFZhbHVlLmZpZWxkcyA/PyB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZmllbGQgc3BlY2lmaWVkIGJ5IGBmaWVsZFBhdGhgLiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZVxuICAgICAqIGRvY3VtZW50IG9yIGZpZWxkIGRvZXNuJ3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGRQYXRoIC0gVGhlIHBhdGggKGZvciBleGFtcGxlICdmb28nIG9yICdmb28uYmFyJykgdG8gYSBzcGVjaWZpY1xuICAgICAqIGZpZWxkLlxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIGF0IHRoZSBzcGVjaWZpZWQgZmllbGQgbG9jYXRpb24gb3IgdW5kZWZpbmVkIGlmIG5vIHN1Y2hcbiAgICAgKiBmaWVsZCBleGlzdHMgaW4gdGhlIGRvY3VtZW50LlxuICAgICAqL1xuICAgIC8vIFdlIGFyZSB1c2luZyBgYW55YCBoZXJlIHRvIGF2b2lkIGFuIGV4cGxpY2l0IGNhc3QgYnkgb3VyIHVzZXJzLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZ2V0KGZpZWxkUGF0aCkge1xuICAgICAgICBpZiAodGhpcy5fZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZG9jdW1lbnQuZGF0YS5maWVsZChmaWVsZFBhdGhGcm9tQXJndW1lbnQoJ0RvY3VtZW50U25hcHNob3QuZ2V0JywgZmllbGRQYXRoKSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlckRhdGFXcml0ZXIuY29udmVydFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogQSBgUXVlcnlEb2N1bWVudFNuYXBzaG90YCBjb250YWlucyBkYXRhIHJlYWQgZnJvbSBhIGRvY3VtZW50IGluIHlvdXJcbiAqIEZpcmVzdG9yZSBkYXRhYmFzZSBhcyBwYXJ0IG9mIGEgcXVlcnkuIFRoZSBkb2N1bWVudCBpcyBndWFyYW50ZWVkIHRvIGV4aXN0XG4gKiBhbmQgaXRzIGRhdGEgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGAuZGF0YSgpYCBvciBgLmdldCg8ZmllbGQ+KWAgdG8gZ2V0IGFcbiAqIHNwZWNpZmljIGZpZWxkLlxuICpcbiAqIEEgYFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdGAgb2ZmZXJzIHRoZSBzYW1lIEFQSSBzdXJmYWNlIGFzIGFcbiAqIGBEb2N1bWVudFNuYXBzaG90YC4gU2luY2UgcXVlcnkgcmVzdWx0cyBjb250YWluIG9ubHkgZXhpc3RpbmcgZG9jdW1lbnRzLCB0aGVcbiAqIGBleGlzdHNgIHByb3BlcnR5IHdpbGwgYWx3YXlzIGJlIHRydWUgYW5kIGBkYXRhKClgIHdpbGwgbmV2ZXIgcmV0dXJuXG4gKiAndW5kZWZpbmVkJy5cbiAqL1xuY2xhc3MgUXVlcnlEb2N1bWVudFNuYXBzaG90JDEgZXh0ZW5kcyBEb2N1bWVudFNuYXBzaG90JDEge1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudCBhcyBhbiBgT2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRhdGEoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUhhc0V4cGxpY2l0T3JkZXJCeUZvckxpbWl0VG9MYXN0KHF1ZXJ5KSB7XG4gICAgaWYgKHF1ZXJ5LmxpbWl0VHlwZSA9PT0gXCJMXCIgLyogTGltaXRUeXBlLkxhc3QgKi8gJiZcbiAgICAgICAgcXVlcnkuZXhwbGljaXRPcmRlckJ5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTklNUExFTUVOVEVELCAnbGltaXRUb0xhc3QoKSBxdWVyaWVzIHJlcXVpcmUgc3BlY2lmeWluZyBhdCBsZWFzdCBvbmUgb3JkZXJCeSgpIGNsYXVzZScpO1xuICAgIH1cbn1cbi8qKlxuICogQW4gYEFwcGxpYWJsZUNvbnN0cmFpbnRgIGlzIGFuIGFic3RyYWN0aW9uIG9mIGEgY29uc3RyYWludCB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gKiB0byBhIEZpcmVzdG9yZSBxdWVyeS5cbiAqL1xuY2xhc3MgQXBwbGlhYmxlQ29uc3RyYWludCB7XG59XG4vKipcbiAqIEEgYFF1ZXJ5Q29uc3RyYWludGAgaXMgdXNlZCB0byBuYXJyb3cgdGhlIHNldCBvZiBkb2N1bWVudHMgcmV0dXJuZWQgYnkgYVxuICogRmlyZXN0b3JlIHF1ZXJ5LiBgUXVlcnlDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIHdoZXJlfSxcbiAqIHtAbGluayBvcmRlckJ5fSwge0BsaW5rIChzdGFydEF0OjEpfSwge0BsaW5rIChzdGFydEFmdGVyOjEpfSwge0BsaW5rXG4gKiAoZW5kQmVmb3JlOjEpfSwge0BsaW5rIChlbmRBdDoxKX0sIHtAbGluayBsaW1pdH0sIHtAbGluayBsaW1pdFRvTGFzdH0gYW5kXG4gKiBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGEgbmV3IHF1ZXJ5IGluc3RhbmNlIHRoYXRcbiAqIGFsc28gY29udGFpbnMgdGhpcyBgUXVlcnlDb25zdHJhaW50YC5cbiAqL1xuY2xhc3MgUXVlcnlDb25zdHJhaW50IGV4dGVuZHMgQXBwbGlhYmxlQ29uc3RyYWludCB7XG59XG5mdW5jdGlvbiBxdWVyeShxdWVyeSwgcXVlcnlDb25zdHJhaW50LCAuLi5hZGRpdGlvbmFsUXVlcnlDb25zdHJhaW50cykge1xuICAgIGxldCBxdWVyeUNvbnN0cmFpbnRzID0gW107XG4gICAgaWYgKHF1ZXJ5Q29uc3RyYWludCBpbnN0YW5jZW9mIEFwcGxpYWJsZUNvbnN0cmFpbnQpIHtcbiAgICAgICAgcXVlcnlDb25zdHJhaW50cy5wdXNoKHF1ZXJ5Q29uc3RyYWludCk7XG4gICAgfVxuICAgIHF1ZXJ5Q29uc3RyYWludHMgPSBxdWVyeUNvbnN0cmFpbnRzLmNvbmNhdChhZGRpdGlvbmFsUXVlcnlDb25zdHJhaW50cyk7XG4gICAgdmFsaWRhdGVRdWVyeUNvbnN0cmFpbnRBcnJheShxdWVyeUNvbnN0cmFpbnRzKTtcbiAgICBmb3IgKGNvbnN0IGNvbnN0cmFpbnQgb2YgcXVlcnlDb25zdHJhaW50cykge1xuICAgICAgICBxdWVyeSA9IGNvbnN0cmFpbnQuX2FwcGx5KHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5O1xufVxuLyoqXG4gKiBBIGBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludGAgaXMgdXNlZCB0byBuYXJyb3cgdGhlIHNldCBvZiBkb2N1bWVudHMgcmV0dXJuZWQgYnlcbiAqIGEgRmlyZXN0b3JlIHF1ZXJ5IGJ5IGZpbHRlcmluZyBvbiBvbmUgb3IgbW9yZSBkb2N1bWVudCBmaWVsZHMuXG4gKiBgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgd2hlcmV9IGFuZCBjYW4gdGhlblxuICogYmUgcGFzc2VkIHRvIHtAbGluayAocXVlcnk6MSl9IHRvIGNyZWF0ZSBhIG5ldyBxdWVyeSBpbnN0YW5jZSB0aGF0IGFsc28gY29udGFpbnNcbiAqIHRoaXMgYFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50YC5cbiAqL1xuY2xhc3MgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9maWVsZCwgX29wLCBfdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZmllbGQgPSBfZmllbGQ7XG4gICAgICAgIHRoaXMuX29wID0gX29wO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnd2hlcmUnO1xuICAgIH1cbiAgICBzdGF0aWMgX2NyZWF0ZShfZmllbGQsIF9vcCwgX3ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnQoX2ZpZWxkLCBfb3AsIF92YWx1ZSk7XG4gICAgfVxuICAgIF9hcHBseShxdWVyeSkge1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9wYXJzZShxdWVyeSk7XG4gICAgICAgIHZhbGlkYXRlTmV3RmllbGRGaWx0ZXIocXVlcnkuX3F1ZXJ5LCBmaWx0ZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhBZGRlZEZpbHRlcihxdWVyeS5fcXVlcnksIGZpbHRlcikpO1xuICAgIH1cbiAgICBfcGFyc2UocXVlcnkpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIocXVlcnkuZmlyZXN0b3JlKTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0gbmV3UXVlcnlGaWx0ZXIocXVlcnkuX3F1ZXJ5LCAnd2hlcmUnLCByZWFkZXIsIHF1ZXJ5LmZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgdGhpcy5fZmllbGQsIHRoaXMuX29wLCB0aGlzLl92YWx1ZSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50fSB0aGF0IGVuZm9yY2VzIHRoYXQgZG9jdW1lbnRzXG4gKiBtdXN0IGNvbnRhaW4gdGhlIHNwZWNpZmllZCBmaWVsZCBhbmQgdGhhdCB0aGUgdmFsdWUgc2hvdWxkIHNhdGlzZnkgdGhlXG4gKiByZWxhdGlvbiBjb25zdHJhaW50IHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSBmaWVsZFBhdGggLSBUaGUgcGF0aCB0byBjb21wYXJlXG4gKiBAcGFyYW0gb3BTdHIgLSBUaGUgb3BlcmF0aW9uIHN0cmluZyAoZS5nIFwiJmx0O1wiLCBcIiZsdDs9XCIsIFwiPT1cIiwgXCImbHQ7XCIsXG4gKiAgIFwiJmx0Oz1cIiwgXCIhPVwiKS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBmb3IgY29tcGFyaXNvblxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQge0BsaW5rIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50fS5cbiAqL1xuZnVuY3Rpb24gd2hlcmUoZmllbGRQYXRoLCBvcFN0ciwgdmFsdWUpIHtcbiAgICBjb25zdCBvcCA9IG9wU3RyO1xuICAgIGNvbnN0IGZpZWxkID0gZmllbGRQYXRoRnJvbUFyZ3VtZW50KCd3aGVyZScsIGZpZWxkUGF0aCk7XG4gICAgcmV0dXJuIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50Ll9jcmVhdGUoZmllbGQsIG9wLCB2YWx1ZSk7XG59XG4vKipcbiAqIEEgYFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludGAgaXMgdXNlZCB0byBuYXJyb3cgdGhlIHNldCBvZiBkb2N1bWVudHNcbiAqIHJldHVybmVkIGJ5IGEgRmlyZXN0b3JlIHF1ZXJ5IGJ5IHBlcmZvcm1pbmcgdGhlIGxvZ2ljYWwgT1Igb3IgQU5EIG9mIG11bHRpcGxlXG4gKiB7QGxpbmsgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnR9cyBvciB7QGxpbmsgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50fXMuXG4gKiBgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIG9yfSBvclxuICoge0BsaW5rIGFuZH0gYW5kIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYSBuZXcgcXVlcnlcbiAqIGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWlucyB0aGUgYFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludGAuXG4gKi9cbmNsYXNzIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCBleHRlbmRzIEFwcGxpYWJsZUNvbnN0cmFpbnQge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cbiAgICB0eXBlLCBfcXVlcnlDb25zdHJhaW50cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9xdWVyeUNvbnN0cmFpbnRzID0gX3F1ZXJ5Q29uc3RyYWludHM7XG4gICAgfVxuICAgIHN0YXRpYyBfY3JlYXRlKHR5cGUsIF9xdWVyeUNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50KHR5cGUsIF9xdWVyeUNvbnN0cmFpbnRzKTtcbiAgICB9XG4gICAgX3BhcnNlKHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEZpbHRlcnMgPSB0aGlzLl9xdWVyeUNvbnN0cmFpbnRzXG4gICAgICAgICAgICAubWFwKHF1ZXJ5Q29uc3RyYWludCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnlDb25zdHJhaW50Ll9wYXJzZShxdWVyeSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKHBhcnNlZEZpbHRlciA9PiBwYXJzZWRGaWx0ZXIuZ2V0RmlsdGVycygpLmxlbmd0aCA+IDApO1xuICAgICAgICBpZiAocGFyc2VkRmlsdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRGaWx0ZXJzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKHBhcnNlZEZpbHRlcnMsIHRoaXMuX2dldE9wZXJhdG9yKCkpO1xuICAgIH1cbiAgICBfYXBwbHkocXVlcnkpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkRmlsdGVyID0gdGhpcy5fcGFyc2UocXVlcnkpO1xuICAgICAgICBpZiAocGFyc2VkRmlsdGVyLmdldEZpbHRlcnMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgZXhpc3RpbmcgcXVlcnkgaWYgbm90IGFkZGluZyBhbnkgbW9yZSBmaWx0ZXJzIChlLmcuIGFuIGVtcHR5XG4gICAgICAgICAgICAvLyBjb21wb3NpdGUgZmlsdGVyKS5cbiAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZU5ld0ZpbHRlcihxdWVyeS5fcXVlcnksIHBhcnNlZEZpbHRlcik7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkocXVlcnkuZmlyZXN0b3JlLCBxdWVyeS5jb252ZXJ0ZXIsIHF1ZXJ5V2l0aEFkZGVkRmlsdGVyKHF1ZXJ5Ll9xdWVyeSwgcGFyc2VkRmlsdGVyKSk7XG4gICAgfVxuICAgIF9nZXRRdWVyeUNvbnN0cmFpbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnlDb25zdHJhaW50cztcbiAgICB9XG4gICAgX2dldE9wZXJhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnYW5kJyA/IFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovIDogXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50fSB0aGF0IGlzIGEgZGlzanVuY3Rpb24gb2ZcbiAqIHRoZSBnaXZlbiBmaWx0ZXIgY29uc3RyYWludHMuIEEgZGlzanVuY3Rpb24gZmlsdGVyIGluY2x1ZGVzIGEgZG9jdW1lbnQgaWYgaXRcbiAqIHNhdGlzZmllcyBhbnkgb2YgdGhlIGdpdmVuIGZpbHRlcnMuXG4gKlxuICogQHBhcmFtIHF1ZXJ5Q29uc3RyYWludHMgLSBPcHRpb25hbC4gVGhlIGxpc3Qgb2ZcbiAqIHtAbGluayBRdWVyeUZpbHRlckNvbnN0cmFpbnR9cyB0byBwZXJmb3JtIGEgZGlzanVuY3Rpb24gZm9yLiBUaGVzZSBtdXN0IGJlXG4gKiBjcmVhdGVkIHdpdGggY2FsbHMgdG8ge0BsaW5rIHdoZXJlfSwge0BsaW5rIG9yfSwgb3Ige0BsaW5rIGFuZH0uXG4gKiBAcmV0dXJucyBUaGUgbmV3bHkgY3JlYXRlZCB7QGxpbmsgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50fS5cbiAqL1xuZnVuY3Rpb24gb3IoLi4ucXVlcnlDb25zdHJhaW50cykge1xuICAgIC8vIE9ubHkgc3VwcG9ydCBRdWVyeUZpbHRlckNvbnN0cmFpbnRzXG4gICAgcXVlcnlDb25zdHJhaW50cy5mb3JFYWNoKHF1ZXJ5Q29uc3RyYWludCA9PiB2YWxpZGF0ZVF1ZXJ5RmlsdGVyQ29uc3RyYWludCgnb3InLCBxdWVyeUNvbnN0cmFpbnQpKTtcbiAgICByZXR1cm4gUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50Ll9jcmVhdGUoXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovLCBxdWVyeUNvbnN0cmFpbnRzKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50fSB0aGF0IGlzIGEgY29uanVuY3Rpb24gb2ZcbiAqIHRoZSBnaXZlbiBmaWx0ZXIgY29uc3RyYWludHMuIEEgY29uanVuY3Rpb24gZmlsdGVyIGluY2x1ZGVzIGEgZG9jdW1lbnQgaWYgaXRcbiAqIHNhdGlzZmllcyBhbGwgb2YgdGhlIGdpdmVuIGZpbHRlcnMuXG4gKlxuICogQHBhcmFtIHF1ZXJ5Q29uc3RyYWludHMgLSBPcHRpb25hbC4gVGhlIGxpc3Qgb2ZcbiAqIHtAbGluayBRdWVyeUZpbHRlckNvbnN0cmFpbnR9cyB0byBwZXJmb3JtIGEgY29uanVuY3Rpb24gZm9yLiBUaGVzZSBtdXN0IGJlXG4gKiBjcmVhdGVkIHdpdGggY2FsbHMgdG8ge0BsaW5rIHdoZXJlfSwge0BsaW5rIG9yfSwgb3Ige0BsaW5rIGFuZH0uXG4gKiBAcmV0dXJucyBUaGUgbmV3bHkgY3JlYXRlZCB7QGxpbmsgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50fS5cbiAqL1xuZnVuY3Rpb24gYW5kKC4uLnF1ZXJ5Q29uc3RyYWludHMpIHtcbiAgICAvLyBPbmx5IHN1cHBvcnQgUXVlcnlGaWx0ZXJDb25zdHJhaW50c1xuICAgIHF1ZXJ5Q29uc3RyYWludHMuZm9yRWFjaChxdWVyeUNvbnN0cmFpbnQgPT4gdmFsaWRhdGVRdWVyeUZpbHRlckNvbnN0cmFpbnQoJ2FuZCcsIHF1ZXJ5Q29uc3RyYWludCkpO1xuICAgIHJldHVybiBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnQuX2NyZWF0ZShcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLywgcXVlcnlDb25zdHJhaW50cyk7XG59XG4vKipcbiAqIEEgYFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnRgIGlzIHVzZWQgdG8gc29ydCB0aGUgc2V0IG9mIGRvY3VtZW50cyByZXR1cm5lZCBieSBhXG4gKiBGaXJlc3RvcmUgcXVlcnkuIGBRdWVyeU9yZGVyQnlDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmdcbiAqIHtAbGluayBvcmRlckJ5fSBhbmQgY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayAocXVlcnk6MSl9IHRvIGNyZWF0ZSBhIG5ldyBxdWVyeVxuICogaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnRgLlxuICpcbiAqIE5vdGU6IERvY3VtZW50cyB0aGF0IGRvIG5vdCBjb250YWluIHRoZSBvcmRlckJ5IGZpZWxkIHdpbGwgbm90IGJlIHByZXNlbnQgaW5cbiAqIHRoZSBxdWVyeSByZXN1bHQuXG4gKi9cbmNsYXNzIFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9maWVsZCwgX2RpcmVjdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9maWVsZCA9IF9maWVsZDtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gX2RpcmVjdGlvbjtcbiAgICAgICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnb3JkZXJCeSc7XG4gICAgfVxuICAgIHN0YXRpYyBfY3JlYXRlKF9maWVsZCwgX2RpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnQoX2ZpZWxkLCBfZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgX2FwcGx5KHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IG9yZGVyQnkgPSBuZXdRdWVyeU9yZGVyQnkocXVlcnkuX3F1ZXJ5LCB0aGlzLl9maWVsZCwgdGhpcy5fZGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShxdWVyeS5maXJlc3RvcmUsIHF1ZXJ5LmNvbnZlcnRlciwgcXVlcnlXaXRoQWRkZWRPcmRlckJ5KHF1ZXJ5Ll9xdWVyeSwgb3JkZXJCeSkpO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBRdWVyeU9yZGVyQnlDb25zdHJhaW50fSB0aGF0IHNvcnRzIHRoZSBxdWVyeSByZXN1bHQgYnkgdGhlXG4gKiBzcGVjaWZpZWQgZmllbGQsIG9wdGlvbmFsbHkgaW4gZGVzY2VuZGluZyBvcmRlciBpbnN0ZWFkIG9mIGFzY2VuZGluZy5cbiAqXG4gKiBOb3RlOiBEb2N1bWVudHMgdGhhdCBkbyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIGZpZWxkIHdpbGwgbm90IGJlIHByZXNlbnRcbiAqIGluIHRoZSBxdWVyeSByZXN1bHQuXG4gKlxuICogQHBhcmFtIGZpZWxkUGF0aCAtIFRoZSBmaWVsZCB0byBzb3J0IGJ5LlxuICogQHBhcmFtIGRpcmVjdGlvblN0ciAtIE9wdGlvbmFsIGRpcmVjdGlvbiB0byBzb3J0IGJ5ICgnYXNjJyBvciAnZGVzYycpLiBJZlxuICogbm90IHNwZWNpZmllZCwgb3JkZXIgd2lsbCBiZSBhc2NlbmRpbmcuXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCB7QGxpbmsgUXVlcnlPcmRlckJ5Q29uc3RyYWludH0uXG4gKi9cbmZ1bmN0aW9uIG9yZGVyQnkoZmllbGRQYXRoLCBkaXJlY3Rpb25TdHIgPSAnYXNjJykge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cjtcbiAgICBjb25zdCBwYXRoID0gZmllbGRQYXRoRnJvbUFyZ3VtZW50KCdvcmRlckJ5JywgZmllbGRQYXRoKTtcbiAgICByZXR1cm4gUXVlcnlPcmRlckJ5Q29uc3RyYWludC5fY3JlYXRlKHBhdGgsIGRpcmVjdGlvbik7XG59XG4vKipcbiAqIEEgYFF1ZXJ5TGltaXRDb25zdHJhaW50YCBpcyB1c2VkIHRvIGxpbWl0IHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHJldHVybmVkIGJ5XG4gKiBhIEZpcmVzdG9yZSBxdWVyeS5cbiAqIGBRdWVyeUxpbWl0Q29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nIHtAbGluayBsaW1pdH0gb3JcbiAqIHtAbGluayBsaW1pdFRvTGFzdH0gYW5kIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYSBuZXdcbiAqIHF1ZXJ5IGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeUxpbWl0Q29uc3RyYWludGAuXG4gKi9cbmNsYXNzIFF1ZXJ5TGltaXRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBxdWVyeSBjb25zdHJhaW50ICovXG4gICAgdHlwZSwgX2xpbWl0LCBfbGltaXRUeXBlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX2xpbWl0ID0gX2xpbWl0O1xuICAgICAgICB0aGlzLl9saW1pdFR5cGUgPSBfbGltaXRUeXBlO1xuICAgIH1cbiAgICBzdGF0aWMgX2NyZWF0ZSh0eXBlLCBfbGltaXQsIF9saW1pdFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUxpbWl0Q29uc3RyYWludCh0eXBlLCBfbGltaXQsIF9saW1pdFR5cGUpO1xuICAgIH1cbiAgICBfYXBwbHkocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShxdWVyeS5maXJlc3RvcmUsIHF1ZXJ5LmNvbnZlcnRlciwgcXVlcnlXaXRoTGltaXQocXVlcnkuX3F1ZXJ5LCB0aGlzLl9saW1pdCwgdGhpcy5fbGltaXRUeXBlKSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFF1ZXJ5TGltaXRDb25zdHJhaW50fSB0aGF0IG9ubHkgcmV0dXJucyB0aGUgZmlyc3QgbWF0Y2hpbmdcbiAqIGRvY3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdG8gcmV0dXJuLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQge0BsaW5rIFF1ZXJ5TGltaXRDb25zdHJhaW50fS5cbiAqL1xuZnVuY3Rpb24gbGltaXQobGltaXQpIHtcbiAgICB2YWxpZGF0ZVBvc2l0aXZlTnVtYmVyKCdsaW1pdCcsIGxpbWl0KTtcbiAgICByZXR1cm4gUXVlcnlMaW1pdENvbnN0cmFpbnQuX2NyZWF0ZSgnbGltaXQnLCBsaW1pdCwgXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBRdWVyeUxpbWl0Q29uc3RyYWludH0gdGhhdCBvbmx5IHJldHVybnMgdGhlIGxhc3QgbWF0Y2hpbmdcbiAqIGRvY3VtZW50cy5cbiAqXG4gKiBZb3UgbXVzdCBzcGVjaWZ5IGF0IGxlYXN0IG9uZSBgb3JkZXJCeWAgY2xhdXNlIGZvciBgbGltaXRUb0xhc3RgIHF1ZXJpZXMsXG4gKiBvdGhlcndpc2UgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIGR1cmluZyBleGVjdXRpb24uXG4gKlxuICogQHBhcmFtIGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIHJldHVybi5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHtAbGluayBRdWVyeUxpbWl0Q29uc3RyYWludH0uXG4gKi9cbmZ1bmN0aW9uIGxpbWl0VG9MYXN0KGxpbWl0KSB7XG4gICAgdmFsaWRhdGVQb3NpdGl2ZU51bWJlcignbGltaXRUb0xhc3QnLCBsaW1pdCk7XG4gICAgcmV0dXJuIFF1ZXJ5TGltaXRDb25zdHJhaW50Ll9jcmVhdGUoJ2xpbWl0VG9MYXN0JywgbGltaXQsIFwiTFwiIC8qIExpbWl0VHlwZS5MYXN0ICovKTtcbn1cbi8qKlxuICogQSBgUXVlcnlTdGFydEF0Q29uc3RyYWludGAgaXMgdXNlZCB0byBleGNsdWRlIGRvY3VtZW50cyBmcm9tIHRoZSBzdGFydCBvZiBhXG4gKiByZXN1bHQgc2V0IHJldHVybmVkIGJ5IGEgRmlyZXN0b3JlIHF1ZXJ5LlxuICogYFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgKHN0YXJ0QXQ6MSl9IG9yXG4gKiB7QGxpbmsgKHN0YXJ0QWZ0ZXI6MSl9IGFuZCBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGFcbiAqIG5ldyBxdWVyeSBpbnN0YW5jZSB0aGF0IGFsc28gY29udGFpbnMgdGhpcyBgUXVlcnlTdGFydEF0Q29uc3RyYWludGAuXG4gKi9cbmNsYXNzIFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cbiAgICB0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5fZG9jT3JGaWVsZHMgPSBfZG9jT3JGaWVsZHM7XG4gICAgICAgIHRoaXMuX2luY2x1c2l2ZSA9IF9pbmNsdXNpdmU7XG4gICAgfVxuICAgIHN0YXRpYyBfY3JlYXRlKHR5cGUsIF9kb2NPckZpZWxkcywgX2luY2x1c2l2ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQodHlwZSwgX2RvY09yRmllbGRzLCBfaW5jbHVzaXZlKTtcbiAgICB9XG4gICAgX2FwcGx5KHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IGJvdW5kID0gbmV3UXVlcnlCb3VuZEZyb21Eb2NPckZpZWxkcyhxdWVyeSwgdGhpcy50eXBlLCB0aGlzLl9kb2NPckZpZWxkcywgdGhpcy5faW5jbHVzaXZlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShxdWVyeS5maXJlc3RvcmUsIHF1ZXJ5LmNvbnZlcnRlciwgcXVlcnlXaXRoU3RhcnRBdChxdWVyeS5fcXVlcnksIGJvdW5kKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RhcnRBdCguLi5kb2NPckZpZWxkcykge1xuICAgIHJldHVybiBRdWVyeVN0YXJ0QXRDb25zdHJhaW50Ll9jcmVhdGUoJ3N0YXJ0QXQnLCBkb2NPckZpZWxkcywgXG4gICAgLyppbmNsdXNpdmU9Ki8gdHJ1ZSk7XG59XG5mdW5jdGlvbiBzdGFydEFmdGVyKC4uLmRvY09yRmllbGRzKSB7XG4gICAgcmV0dXJuIFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQuX2NyZWF0ZSgnc3RhcnRBZnRlcicsIGRvY09yRmllbGRzLCBcbiAgICAvKmluY2x1c2l2ZT0qLyBmYWxzZSk7XG59XG4vKipcbiAqIEEgYFF1ZXJ5RW5kQXRDb25zdHJhaW50YCBpcyB1c2VkIHRvIGV4Y2x1ZGUgZG9jdW1lbnRzIGZyb20gdGhlIGVuZCBvZiBhXG4gKiByZXN1bHQgc2V0IHJldHVybmVkIGJ5IGEgRmlyZXN0b3JlIHF1ZXJ5LlxuICogYFF1ZXJ5RW5kQXRDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIChlbmRBdDoxKX0gb3JcbiAqIHtAbGluayAoZW5kQmVmb3JlOjEpfSBhbmQgY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayAocXVlcnk6MSl9IHRvIGNyZWF0ZSBhIG5ld1xuICogcXVlcnkgaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5RW5kQXRDb25zdHJhaW50YC5cbiAqL1xuY2xhc3MgUXVlcnlFbmRBdENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cbiAgICB0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5fZG9jT3JGaWVsZHMgPSBfZG9jT3JGaWVsZHM7XG4gICAgICAgIHRoaXMuX2luY2x1c2l2ZSA9IF9pbmNsdXNpdmU7XG4gICAgfVxuICAgIHN0YXRpYyBfY3JlYXRlKHR5cGUsIF9kb2NPckZpZWxkcywgX2luY2x1c2l2ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5RW5kQXRDb25zdHJhaW50KHR5cGUsIF9kb2NPckZpZWxkcywgX2luY2x1c2l2ZSk7XG4gICAgfVxuICAgIF9hcHBseShxdWVyeSkge1xuICAgICAgICBjb25zdCBib3VuZCA9IG5ld1F1ZXJ5Qm91bmRGcm9tRG9jT3JGaWVsZHMocXVlcnksIHRoaXMudHlwZSwgdGhpcy5fZG9jT3JGaWVsZHMsIHRoaXMuX2luY2x1c2l2ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkocXVlcnkuZmlyZXN0b3JlLCBxdWVyeS5jb252ZXJ0ZXIsIHF1ZXJ5V2l0aEVuZEF0KHF1ZXJ5Ll9xdWVyeSwgYm91bmQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbmRCZWZvcmUoLi4uZG9jT3JGaWVsZHMpIHtcbiAgICByZXR1cm4gUXVlcnlFbmRBdENvbnN0cmFpbnQuX2NyZWF0ZSgnZW5kQmVmb3JlJywgZG9jT3JGaWVsZHMsIFxuICAgIC8qaW5jbHVzaXZlPSovIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIGVuZEF0KC4uLmRvY09yRmllbGRzKSB7XG4gICAgcmV0dXJuIFF1ZXJ5RW5kQXRDb25zdHJhaW50Ll9jcmVhdGUoJ2VuZEF0JywgZG9jT3JGaWVsZHMsIFxuICAgIC8qaW5jbHVzaXZlPSovIHRydWUpO1xufVxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBib3VuZCBmcm9tIGEgZG9jdW1lbnQgb3IgZmllbGRzICovXG5mdW5jdGlvbiBuZXdRdWVyeUJvdW5kRnJvbURvY09yRmllbGRzKHF1ZXJ5LCBtZXRob2ROYW1lLCBkb2NPckZpZWxkcywgaW5jbHVzaXZlKSB7XG4gICAgZG9jT3JGaWVsZHNbMF0gPSBnZXRNb2R1bGFySW5zdGFuY2UoZG9jT3JGaWVsZHNbMF0pO1xuICAgIGlmIChkb2NPckZpZWxkc1swXSBpbnN0YW5jZW9mIERvY3VtZW50U25hcHNob3QkMSkge1xuICAgICAgICByZXR1cm4gbmV3UXVlcnlCb3VuZEZyb21Eb2N1bWVudChxdWVyeS5fcXVlcnksIHF1ZXJ5LmZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgbWV0aG9kTmFtZSwgZG9jT3JGaWVsZHNbMF0uX2RvY3VtZW50LCBpbmNsdXNpdmUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIocXVlcnkuZmlyZXN0b3JlKTtcbiAgICAgICAgcmV0dXJuIG5ld1F1ZXJ5Qm91bmRGcm9tRmllbGRzKHF1ZXJ5Ll9xdWVyeSwgcXVlcnkuZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCByZWFkZXIsIG1ldGhvZE5hbWUsIGRvY09yRmllbGRzLCBpbmNsdXNpdmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld1F1ZXJ5RmlsdGVyKHF1ZXJ5LCBtZXRob2ROYW1lLCBkYXRhUmVhZGVyLCBkYXRhYmFzZUlkLCBmaWVsZFBhdGgsIG9wLCB2YWx1ZSkge1xuICAgIGxldCBmaWVsZFZhbHVlO1xuICAgIGlmIChmaWVsZFBhdGguaXNLZXlGaWVsZCgpKSB7XG4gICAgICAgIGlmIChvcCA9PT0gXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovIHx8IG9wID09PSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgUXVlcnkuIFlvdSBjYW4ndCBwZXJmb3JtICcke29wfScgcXVlcmllcyBvbiBkb2N1bWVudElkKCkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3AgPT09IFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLyB8fCBvcCA9PT0gXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8pIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRGlzanVuY3RpdmVGaWx0ZXJFbGVtZW50cyh2YWx1ZSwgb3ApO1xuICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlTGlzdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhcnJheVZhbHVlIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlTGlzdC5wdXNoKHBhcnNlRG9jdW1lbnRJZFZhbHVlKGRhdGFiYXNlSWQsIHF1ZXJ5LCBhcnJheVZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWVsZFZhbHVlID0geyBhcnJheVZhbHVlOiB7IHZhbHVlczogcmVmZXJlbmNlTGlzdCB9IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWVsZFZhbHVlID0gcGFyc2VEb2N1bWVudElkVmFsdWUoZGF0YWJhc2VJZCwgcXVlcnksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9wID09PSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8gfHxcbiAgICAgICAgICAgIG9wID09PSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLyB8fFxuICAgICAgICAgICAgb3AgPT09IFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZURpc2p1bmN0aXZlRmlsdGVyRWxlbWVudHModmFsdWUsIG9wKTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZFZhbHVlID0gcGFyc2VRdWVyeVZhbHVlKGRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIHZhbHVlLCBcbiAgICAgICAgLyogYWxsb3dBcnJheXM9ICovIG9wID09PSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8gfHwgb3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovKTtcbiAgICB9XG4gICAgY29uc3QgZmlsdGVyID0gRmllbGRGaWx0ZXIuY3JlYXRlKGZpZWxkUGF0aCwgb3AsIGZpZWxkVmFsdWUpO1xuICAgIHJldHVybiBmaWx0ZXI7XG59XG5mdW5jdGlvbiBuZXdRdWVyeU9yZGVyQnkocXVlcnksIGZpZWxkUGF0aCwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKHF1ZXJ5LnN0YXJ0QXQgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ludmFsaWQgcXVlcnkuIFlvdSBtdXN0IG5vdCBjYWxsIHN0YXJ0QXQoKSBvciBzdGFydEFmdGVyKCkgYmVmb3JlICcgK1xuICAgICAgICAgICAgJ2NhbGxpbmcgb3JkZXJCeSgpLicpO1xuICAgIH1cbiAgICBpZiAocXVlcnkuZW5kQXQgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ludmFsaWQgcXVlcnkuIFlvdSBtdXN0IG5vdCBjYWxsIGVuZEF0KCkgb3IgZW5kQmVmb3JlKCkgYmVmb3JlICcgK1xuICAgICAgICAgICAgJ2NhbGxpbmcgb3JkZXJCeSgpLicpO1xuICAgIH1cbiAgICBjb25zdCBvcmRlckJ5ID0gbmV3IE9yZGVyQnkoZmllbGRQYXRoLCBkaXJlY3Rpb24pO1xuICAgIHJldHVybiBvcmRlckJ5O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBgQm91bmRgIGZyb20gYSBxdWVyeSBhbmQgYSBkb2N1bWVudC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGBCb3VuZGAgd2lsbCBhbHdheXMgaW5jbHVkZSB0aGUga2V5IG9mIHRoZSBkb2N1bWVudFxuICogYW5kIHNvIG9ubHkgdGhlIHByb3ZpZGVkIGRvY3VtZW50IHdpbGwgY29tcGFyZSBlcXVhbCB0byB0aGUgcmV0dXJuZWRcbiAqIHBvc2l0aW9uLlxuICpcbiAqIFdpbGwgdGhyb3cgaWYgdGhlIGRvY3VtZW50IGRvZXMgbm90IGNvbnRhaW4gYWxsIGZpZWxkcyBvZiB0aGUgb3JkZXIgYnlcbiAqIG9mIHRoZSBxdWVyeSBvciBpZiBhbnkgb2YgdGhlIGZpZWxkcyBpbiB0aGUgb3JkZXIgYnkgYXJlIGFuIHVuY29tbWl0dGVkXG4gKiBzZXJ2ZXIgdGltZXN0YW1wLlxuICovXG5mdW5jdGlvbiBuZXdRdWVyeUJvdW5kRnJvbURvY3VtZW50KHF1ZXJ5LCBkYXRhYmFzZUlkLCBtZXRob2ROYW1lLCBkb2MsIGluY2x1c2l2ZSkge1xuICAgIGlmICghZG9jKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLk5PVF9GT1VORCwgYENhbid0IHVzZSBhIERvY3VtZW50U25hcHNob3QgdGhhdCBkb2Vzbid0IGV4aXN0IGZvciBgICtcbiAgICAgICAgICAgIGAke21ldGhvZE5hbWV9KCkuYCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBbXTtcbiAgICAvLyBCZWNhdXNlIHBlb3BsZSBleHBlY3QgdG8gY29udGludWUvZW5kIGEgcXVlcnkgYXQgdGhlIGV4YWN0IGRvY3VtZW50XG4gICAgLy8gcHJvdmlkZWQsIHdlIG5lZWQgdG8gdXNlIHRoZSBpbXBsaWNpdCBzb3J0IG9yZGVyIHJhdGhlciB0aGFuIHRoZSBleHBsaWNpdFxuICAgIC8vIHNvcnQgb3JkZXIsIGJlY2F1c2UgaXQncyBndWFyYW50ZWVkIHRvIGNvbnRhaW4gdGhlIGRvY3VtZW50IGtleS4gVGhhdCB3YXlcbiAgICAvLyB0aGUgcG9zaXRpb24gYmVjb21lcyB1bmFtYmlndW91cyBhbmQgdGhlIHF1ZXJ5IGNvbnRpbnVlcy9lbmRzIGV4YWN0bHkgYXRcbiAgICAvLyB0aGUgcHJvdmlkZWQgZG9jdW1lbnQuIFdpdGhvdXQgdGhlIGtleSAoYnkgdXNpbmcgdGhlIGV4cGxpY2l0IHNvcnRcbiAgICAvLyBvcmRlcnMpLCBtdWx0aXBsZSBkb2N1bWVudHMgY291bGQgbWF0Y2ggdGhlIHBvc2l0aW9uLCB5aWVsZGluZyBkdXBsaWNhdGVcbiAgICAvLyByZXN1bHRzLlxuICAgIGZvciAoY29uc3Qgb3JkZXJCeSBvZiBxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5KHF1ZXJ5KSkge1xuICAgICAgICBpZiAob3JkZXJCeS5maWVsZC5pc0tleUZpZWxkKCkpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChyZWZWYWx1ZShkYXRhYmFzZUlkLCBkb2Mua2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvYy5kYXRhLmZpZWxkKG9yZGVyQnkuZmllbGQpO1xuICAgICAgICAgICAgaWYgKGlzU2VydmVyVGltZXN0YW1wKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIHF1ZXJ5LiBZb3UgYXJlIHRyeWluZyB0byBzdGFydCBvciBlbmQgYSBxdWVyeSB1c2luZyBhICcgK1xuICAgICAgICAgICAgICAgICAgICAnZG9jdW1lbnQgZm9yIHdoaWNoIHRoZSBmaWVsZCBcIicgK1xuICAgICAgICAgICAgICAgICAgICBvcmRlckJ5LmZpZWxkICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIGlzIGFuIHVuY29tbWl0dGVkIHNlcnZlciB0aW1lc3RhbXAuIChTaW5jZSB0aGUgdmFsdWUgb2YgJyArXG4gICAgICAgICAgICAgICAgICAgICd0aGlzIGZpZWxkIGlzIHVua25vd24sIHlvdSBjYW5ub3Qgc3RhcnQvZW5kIGEgcXVlcnkgd2l0aCBpdC4pJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IG9yZGVyQnkuZmllbGQuY2Fub25pY2FsU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIFlvdSBhcmUgdHJ5aW5nIHRvIHN0YXJ0IG9yIGVuZCBhIHF1ZXJ5IHVzaW5nIGEgYCArXG4gICAgICAgICAgICAgICAgICAgIGBkb2N1bWVudCBmb3Igd2hpY2ggdGhlIGZpZWxkICcke2ZpZWxkfScgKHVzZWQgYXMgdGhlIGAgK1xuICAgICAgICAgICAgICAgICAgICBgb3JkZXJCeSkgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCb3VuZChjb21wb25lbnRzLCBpbmNsdXNpdmUpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGxpc3Qgb2YgZmllbGQgdmFsdWVzIHRvIGEgYEJvdW5kYCBmb3IgdGhlIGdpdmVuIHF1ZXJ5LlxuICovXG5mdW5jdGlvbiBuZXdRdWVyeUJvdW5kRnJvbUZpZWxkcyhxdWVyeSwgZGF0YWJhc2VJZCwgZGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgdmFsdWVzLCBpbmNsdXNpdmUpIHtcbiAgICAvLyBVc2UgZXhwbGljaXQgb3JkZXIgYnkncyBiZWNhdXNlIGl0IGhhcyB0byBtYXRjaCB0aGUgcXVlcnkgdGhlIHVzZXIgbWFkZVxuICAgIGNvbnN0IG9yZGVyQnkgPSBxdWVyeS5leHBsaWNpdE9yZGVyQnk7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPiBvcmRlckJ5Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgVG9vIG1hbnkgYXJndW1lbnRzIHByb3ZpZGVkIHRvICR7bWV0aG9kTmFtZX0oKS4gYCArXG4gICAgICAgICAgICBgVGhlIG51bWJlciBvZiBhcmd1bWVudHMgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGAgK1xuICAgICAgICAgICAgYG51bWJlciBvZiBvcmRlckJ5KCkgY2xhdXNlc2ApO1xuICAgIH1cbiAgICBjb25zdCBjb21wb25lbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmF3VmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIGNvbnN0IG9yZGVyQnlDb21wb25lbnQgPSBvcmRlckJ5W2ldO1xuICAgICAgICBpZiAob3JkZXJCeUNvbXBvbmVudC5maWVsZC5pc0tleUZpZWxkKCkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmF3VmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIEV4cGVjdGVkIGEgc3RyaW5nIGZvciBkb2N1bWVudCBJRCBpbiBgICtcbiAgICAgICAgICAgICAgICAgICAgYCR7bWV0aG9kTmFtZX0oKSwgYnV0IGdvdCBhICR7dHlwZW9mIHJhd1ZhbHVlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0NvbGxlY3Rpb25Hcm91cFF1ZXJ5KHF1ZXJ5KSAmJiByYXdWYWx1ZS5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIFdoZW4gcXVlcnlpbmcgYSBjb2xsZWN0aW9uIGFuZCBvcmRlcmluZyBieSBkb2N1bWVudElkKCksIGAgK1xuICAgICAgICAgICAgICAgICAgICBgdGhlIHZhbHVlIHBhc3NlZCB0byAke21ldGhvZE5hbWV9KCkgbXVzdCBiZSBhIHBsYWluIGRvY3VtZW50IElELCBidXQgYCArXG4gICAgICAgICAgICAgICAgICAgIGAnJHtyYXdWYWx1ZX0nIGNvbnRhaW5zIGEgc2xhc2guYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gcXVlcnkucGF0aC5jaGlsZChSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhyYXdWYWx1ZSkpO1xuICAgICAgICAgICAgaWYgKCFEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIFdoZW4gcXVlcnlpbmcgYSBjb2xsZWN0aW9uIGdyb3VwIGFuZCBvcmRlcmluZyBieSBgICtcbiAgICAgICAgICAgICAgICAgICAgYGRvY3VtZW50SWQoKSwgdGhlIHZhbHVlIHBhc3NlZCB0byAke21ldGhvZE5hbWV9KCkgbXVzdCByZXN1bHQgaW4gYSBgICtcbiAgICAgICAgICAgICAgICAgICAgYHZhbGlkIGRvY3VtZW50IHBhdGgsIGJ1dCAnJHtwYXRofScgaXMgbm90IGJlY2F1c2UgaXQgY29udGFpbnMgYW4gb2RkIG51bWJlciBgICtcbiAgICAgICAgICAgICAgICAgICAgYG9mIHNlZ21lbnRzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmV3IERvY3VtZW50S2V5KHBhdGgpO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHJlZlZhbHVlKGRhdGFiYXNlSWQsIGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlZCA9IHBhcnNlUXVlcnlWYWx1ZShkYXRhUmVhZGVyLCBtZXRob2ROYW1lLCByYXdWYWx1ZSk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnB1c2god3JhcHBlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCb3VuZChjb21wb25lbnRzLCBpbmNsdXNpdmUpO1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIGBkb2N1bWVudElkVmFsdWVgIGludG8gYSBgUmVmZXJlbmNlVmFsdWVgLCB0aHJvd2luZ1xuICogYXBwcm9wcmlhdGUgZXJyb3JzIGlmIHRoZSB2YWx1ZSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGEgYERvY3VtZW50UmVmZXJlbmNlYFxuICogb3IgYHN0cmluZ2AsIG9yIGlmIHRoZSBzdHJpbmcgaXMgbWFsZm9ybWVkLlxuICovXG5mdW5jdGlvbiBwYXJzZURvY3VtZW50SWRWYWx1ZShkYXRhYmFzZUlkLCBxdWVyeSwgZG9jdW1lbnRJZFZhbHVlKSB7XG4gICAgZG9jdW1lbnRJZFZhbHVlID0gZ2V0TW9kdWxhckluc3RhbmNlKGRvY3VtZW50SWRWYWx1ZSk7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudElkVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkb2N1bWVudElkVmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyB3aXRoIGRvY3VtZW50SWQoKSwgeW91ICcgK1xuICAgICAgICAgICAgICAgICdtdXN0IHByb3ZpZGUgYSB2YWxpZCBkb2N1bWVudCBJRCwgYnV0IGl0IHdhcyBhbiBlbXB0eSBzdHJpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0NvbGxlY3Rpb25Hcm91cFF1ZXJ5KHF1ZXJ5KSAmJiBkb2N1bWVudElkVmFsdWUuaW5kZXhPZignLycpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIFdoZW4gcXVlcnlpbmcgYSBjb2xsZWN0aW9uIGJ5IGAgK1xuICAgICAgICAgICAgICAgIGBkb2N1bWVudElkKCksIHlvdSBtdXN0IHByb3ZpZGUgYSBwbGFpbiBkb2N1bWVudCBJRCwgYnV0IGAgK1xuICAgICAgICAgICAgICAgIGAnJHtkb2N1bWVudElkVmFsdWV9JyBjb250YWlucyBhICcvJyBjaGFyYWN0ZXIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aCA9IHF1ZXJ5LnBhdGguY2hpbGQoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcoZG9jdW1lbnRJZFZhbHVlKSk7XG4gICAgICAgIGlmICghRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShwYXRoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIFdoZW4gcXVlcnlpbmcgYSBjb2xsZWN0aW9uIGdyb3VwIGJ5IGAgK1xuICAgICAgICAgICAgICAgIGBkb2N1bWVudElkKCksIHRoZSB2YWx1ZSBwcm92aWRlZCBtdXN0IHJlc3VsdCBpbiBhIHZhbGlkIGRvY3VtZW50IHBhdGgsIGAgK1xuICAgICAgICAgICAgICAgIGBidXQgJyR7cGF0aH0nIGlzIG5vdCBiZWNhdXNlIGl0IGhhcyBhbiBvZGQgbnVtYmVyIG9mIHNlZ21lbnRzICgke3BhdGgubGVuZ3RofSkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZlZhbHVlKGRhdGFiYXNlSWQsIG5ldyBEb2N1bWVudEtleShwYXRoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvY3VtZW50SWRWYWx1ZSBpbnN0YW5jZW9mIERvY3VtZW50UmVmZXJlbmNlKSB7XG4gICAgICAgIHJldHVybiByZWZWYWx1ZShkYXRhYmFzZUlkLCBkb2N1bWVudElkVmFsdWUuX2tleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyB3aXRoIGRvY3VtZW50SWQoKSwgeW91IG11c3QgcHJvdmlkZSBhIHZhbGlkIGAgK1xuICAgICAgICAgICAgYHN0cmluZyBvciBhIERvY3VtZW50UmVmZXJlbmNlLCBidXQgaXQgd2FzOiBgICtcbiAgICAgICAgICAgIGAke3ZhbHVlRGVzY3JpcHRpb24oZG9jdW1lbnRJZFZhbHVlKX0uYCk7XG4gICAgfVxufVxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgcGFzc2VkIGludG8gYSBkaXNqdW5jdGl2ZSBmaWx0ZXIgc2F0aXNmaWVzIGFsbFxuICogYXJyYXkgcmVxdWlyZW1lbnRzLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZURpc2p1bmN0aXZlRmlsdGVyRWxlbWVudHModmFsdWUsIG9wZXJhdG9yKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ludmFsaWQgUXVlcnkuIEEgbm9uLWVtcHR5IGFycmF5IGlzIHJlcXVpcmVkIGZvciAnICtcbiAgICAgICAgICAgIGAnJHtvcGVyYXRvci50b1N0cmluZygpfScgZmlsdGVycy5gKTtcbiAgICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIG9wZXJhdG9yLCByZXR1cm5zIHRoZSBzZXQgb2Ygb3BlcmF0b3JzIHRoYXQgY2Fubm90IGJlIHVzZWQgd2l0aCBpdC5cbiAqXG4gKiBUaGlzIGlzIG5vdCBhIGNvbXByZWhlbnNpdmUgY2hlY2ssIGFuZCB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSByZW1vdmVkIGluIHRoZVxuICogbG9uZyB0ZXJtLiBWYWxpZGF0aW9ucyBzaG91bGQgb2NjdXIgaW4gdGhlIEZpcmVzdG9yZSBiYWNrZW5kLlxuICpcbiAqIE9wZXJhdG9ycyBpbiBhIHF1ZXJ5IG11c3QgYWRoZXJlIHRvIHRoZSBmb2xsb3dpbmcgc2V0IG9mIHJ1bGVzOlxuICogMS4gT25seSBvbmUgaW5lcXVhbGl0eSBwZXIgcXVlcnkuXG4gKiAyLiBgTk9UX0lOYCBjYW5ub3QgYmUgdXNlZCB3aXRoIGFycmF5LCBkaXNqdW5jdGl2ZSwgb3IgYE5PVF9FUVVBTGAgb3BlcmF0b3JzLlxuICovXG5mdW5jdGlvbiBjb25mbGljdGluZ09wcyhvcCkge1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgY2FzZSBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovOlxuICAgICAgICAgICAgcmV0dXJuIFtcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovLCBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqL107XG4gICAgICAgIGNhc2UgXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi86XG4gICAgICAgIGNhc2UgXCJpblwiIC8qIE9wZXJhdG9yLklOICovOlxuICAgICAgICAgICAgcmV0dXJuIFtcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqL107XG4gICAgICAgIGNhc2UgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi86XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovLFxuICAgICAgICAgICAgICAgIFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLyxcbiAgICAgICAgICAgICAgICBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLyxcbiAgICAgICAgICAgICAgICBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovXG4gICAgICAgICAgICBdO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTmV3RmllbGRGaWx0ZXIocXVlcnksIGZpZWxkRmlsdGVyKSB7XG4gICAgY29uc3QgY29uZmxpY3RpbmdPcCA9IGZpbmRPcEluc2lkZUZpbHRlcnMocXVlcnkuZmlsdGVycywgY29uZmxpY3RpbmdPcHMoZmllbGRGaWx0ZXIub3ApKTtcbiAgICBpZiAoY29uZmxpY3RpbmdPcCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2Ugd2hlbiBpdCdzIGEgZHVwbGljYXRlIG9wIHRvIGdpdmUgYSBzbGlnaHRseSBjbGVhcmVyIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgIGlmIChjb25mbGljdGluZ09wID09PSBmaWVsZEZpbHRlci5vcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ludmFsaWQgcXVlcnkuIFlvdSBjYW5ub3QgdXNlIG1vcmUgdGhhbiBvbmUgJyArXG4gICAgICAgICAgICAgICAgYCcke2ZpZWxkRmlsdGVyLm9wLnRvU3RyaW5nKCl9JyBmaWx0ZXIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gWW91IGNhbm5vdCB1c2UgJyR7ZmllbGRGaWx0ZXIub3AudG9TdHJpbmcoKX0nIGZpbHRlcnMgYCArXG4gICAgICAgICAgICAgICAgYHdpdGggJyR7Y29uZmxpY3RpbmdPcC50b1N0cmluZygpfScgZmlsdGVycy5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTmV3RmlsdGVyKHF1ZXJ5LCBmaWx0ZXIpIHtcbiAgICBsZXQgdGVzdFF1ZXJ5ID0gcXVlcnk7XG4gICAgY29uc3Qgc3ViRmlsdGVycyA9IGZpbHRlci5nZXRGbGF0dGVuZWRGaWx0ZXJzKCk7XG4gICAgZm9yIChjb25zdCBzdWJGaWx0ZXIgb2Ygc3ViRmlsdGVycykge1xuICAgICAgICB2YWxpZGF0ZU5ld0ZpZWxkRmlsdGVyKHRlc3RRdWVyeSwgc3ViRmlsdGVyKTtcbiAgICAgICAgdGVzdFF1ZXJ5ID0gcXVlcnlXaXRoQWRkZWRGaWx0ZXIodGVzdFF1ZXJ5LCBzdWJGaWx0ZXIpO1xuICAgIH1cbn1cbi8vIENoZWNrcyBpZiBhbnkgb2YgdGhlIHByb3ZpZGVkIGZpbHRlciBvcGVyYXRvcnMgYXJlIGluY2x1ZGVkIGluIHRoZSBnaXZlbiBsaXN0IG9mIGZpbHRlcnMgYW5kXG4vLyByZXR1cm5zIHRoZSBmaXJzdCBvbmUgdGhhdCBpcywgb3IgbnVsbCBpZiBub25lIGFyZS5cbmZ1bmN0aW9uIGZpbmRPcEluc2lkZUZpbHRlcnMoZmlsdGVycywgb3BlcmF0b3JzKSB7XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgZmlsdGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkRmlsdGVyIG9mIGZpbHRlci5nZXRGbGF0dGVuZWRGaWx0ZXJzKCkpIHtcbiAgICAgICAgICAgIGlmIChvcGVyYXRvcnMuaW5kZXhPZihmaWVsZEZpbHRlci5vcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZEZpbHRlci5vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUXVlcnlGaWx0ZXJDb25zdHJhaW50KGZ1bmN0aW9uTmFtZSwgcXVlcnlDb25zdHJhaW50KSB7XG4gICAgaWYgKCEocXVlcnlDb25zdHJhaW50IGluc3RhbmNlb2YgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnQpICYmXG4gICAgICAgICEocXVlcnlDb25zdHJhaW50IGluc3RhbmNlb2YgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgRnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9KCkgcmVxdWlyZXMgQXBwbGlhYmxlQ29uc3RyYWludHMgY3JlYXRlZCB3aXRoIGEgY2FsbCB0byAnd2hlcmUoLi4uKScsICdvciguLi4pJywgb3IgJ2FuZCguLi4pJy5gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVF1ZXJ5Q29uc3RyYWludEFycmF5KHF1ZXJ5Q29uc3RyYWludCkge1xuICAgIGNvbnN0IGNvbXBvc2l0ZUZpbHRlckNvdW50ID0gcXVlcnlDb25zdHJhaW50LmZpbHRlcihmaWx0ZXIgPT4gZmlsdGVyIGluc3RhbmNlb2YgUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50KS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRGaWx0ZXJDb3VudCA9IHF1ZXJ5Q29uc3RyYWludC5maWx0ZXIoZmlsdGVyID0+IGZpbHRlciBpbnN0YW5jZW9mIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50KS5sZW5ndGg7XG4gICAgaWYgKGNvbXBvc2l0ZUZpbHRlckNvdW50ID4gMSB8fFxuICAgICAgICAoY29tcG9zaXRlRmlsdGVyQ291bnQgPiAwICYmIGZpZWxkRmlsdGVyQ291bnQgPiAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZFF1ZXJ5LiBXaGVuIHVzaW5nIGNvbXBvc2l0ZSBmaWx0ZXJzLCB5b3UgY2Fubm90IHVzZSAnICtcbiAgICAgICAgICAgICdtb3JlIHRoYW4gb25lIGZpbHRlciBhdCB0aGUgdG9wIGxldmVsLiBDb25zaWRlciBuZXN0aW5nIHRoZSBtdWx0aXBsZSAnICtcbiAgICAgICAgICAgICdmaWx0ZXJzIHdpdGhpbiBhbiBgYW5kKC4uLilgIHN0YXRlbWVudC4gRm9yIGV4YW1wbGU6ICcgK1xuICAgICAgICAgICAgJ2NoYW5nZSBgcXVlcnkocXVlcnksIHdoZXJlKC4uLiksIG9yKC4uLikpYCB0byAnICtcbiAgICAgICAgICAgICdgcXVlcnkocXVlcnksIGFuZCh3aGVyZSguLi4pLCBvciguLi4pKSlgLicpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ29udmVydHMgY3VzdG9tIG1vZGVsIG9iamVjdCBvZiB0eXBlIFQgaW50byBgRG9jdW1lbnREYXRhYCBieSBhcHBseWluZyB0aGVcbiAqIGNvbnZlcnRlciBpZiBpdCBleGlzdHMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHdoZW4gY29udmVydGluZyB1c2VyIG9iamVjdHMgdG8gYERvY3VtZW50RGF0YWBcbiAqIGJlY2F1c2Ugd2Ugd2FudCB0byBwcm92aWRlIHRoZSB1c2VyIHdpdGggYSBtb3JlIHNwZWNpZmljIGVycm9yIG1lc3NhZ2UgaWZcbiAqIHRoZWlyIGBzZXQoKWAgb3IgZmFpbHMgZHVlIHRvIGludmFsaWQgZGF0YSBvcmlnaW5hdGluZyBmcm9tIGEgYHRvRmlyZXN0b3JlKClgXG4gKiBjYWxsLlxuICovXG5mdW5jdGlvbiBhcHBseUZpcmVzdG9yZURhdGFDb252ZXJ0ZXIoY29udmVydGVyLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGxldCBjb252ZXJ0ZWRWYWx1ZTtcbiAgICBpZiAoY29udmVydGVyKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIChvcHRpb25zLm1lcmdlIHx8IG9wdGlvbnMubWVyZ2VGaWVsZHMpKSB7XG4gICAgICAgICAgICAvLyBDYXN0IHRvIGBhbnlgIGluIG9yZGVyIHRvIHNhdGlzZnkgdGhlIHVuaW9uIHR5cGUgY29uc3RyYWludCBvblxuICAgICAgICAgICAgLy8gdG9GaXJlc3RvcmUoKS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBjb252ZXJ0ZWRWYWx1ZSA9IGNvbnZlcnRlci50b0ZpcmVzdG9yZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb252ZXJ0ZWRWYWx1ZSA9IGNvbnZlcnRlci50b0ZpcmVzdG9yZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnZlcnRlZFZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0ZWRWYWx1ZTtcbn1cbmNsYXNzIExpdGVVc2VyRGF0YVdyaXRlciBleHRlbmRzIEFic3RyYWN0VXNlckRhdGFXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpcmVzdG9yZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpcmVzdG9yZSA9IGZpcmVzdG9yZTtcbiAgICB9XG4gICAgY29udmVydEJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnl0ZXMoYnl0ZXMpO1xuICAgIH1cbiAgICBjb252ZXJ0UmVmZXJlbmNlKG5hbWUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5jb252ZXJ0RG9jdW1lbnRLZXkobmFtZSwgdGhpcy5maXJlc3RvcmUuX2RhdGFiYXNlSWQpO1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHRoaXMuZmlyZXN0b3JlLCAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIGtleSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDcmVhdGUgYW4gQWdncmVnYXRlRmllbGQgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgc3VtIG9mXG4gKiBhIHNwZWNpZmllZCBmaWVsZCBvdmVyIGEgcmFuZ2Ugb2YgZG9jdW1lbnRzIGluIHRoZSByZXN1bHQgc2V0IG9mIGEgcXVlcnkuXG4gKiBAcGFyYW0gZmllbGQgLSBTcGVjaWZpZXMgdGhlIGZpZWxkIHRvIHN1bSBhY3Jvc3MgdGhlIHJlc3VsdCBzZXQuXG4gKi9cbmZ1bmN0aW9uIHN1bShmaWVsZCkge1xuICAgIHJldHVybiBuZXcgQWdncmVnYXRlRmllbGQoJ3N1bScsIGZpZWxkUGF0aEZyb21Bcmd1bWVudCgnc3VtJywgZmllbGQpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIEFnZ3JlZ2F0ZUZpZWxkIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGF2ZXJhZ2Ugb2ZcbiAqIGEgc3BlY2lmaWVkIGZpZWxkIG92ZXIgYSByYW5nZSBvZiBkb2N1bWVudHMgaW4gdGhlIHJlc3VsdCBzZXQgb2YgYSBxdWVyeS5cbiAqIEBwYXJhbSBmaWVsZCAtIFNwZWNpZmllcyB0aGUgZmllbGQgdG8gYXZlcmFnZSBhY3Jvc3MgdGhlIHJlc3VsdCBzZXQuXG4gKi9cbmZ1bmN0aW9uIGF2ZXJhZ2UoZmllbGQpIHtcbiAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0ZUZpZWxkKCdhdmcnLCBmaWVsZFBhdGhGcm9tQXJndW1lbnQoJ2F2ZXJhZ2UnLCBmaWVsZCkpO1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gQWdncmVnYXRlRmllbGQgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgY291bnQgb2ZcbiAqIGRvY3VtZW50cyBpbiB0aGUgcmVzdWx0IHNldCBvZiBhIHF1ZXJ5LlxuICovXG5mdW5jdGlvbiBjb3VudCgpIHtcbiAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0ZUZpZWxkKCdjb3VudCcpO1xufVxuLyoqXG4gKiBDb21wYXJlcyB0d28gJ0FnZ3JlZ2F0ZUZpZWxkYCBpbnN0YW5jZXMgZm9yIGVxdWFsaXR5LlxuICpcbiAqIEBwYXJhbSBsZWZ0IC0gQ29tcGFyZSB0aGlzIEFnZ3JlZ2F0ZUZpZWxkIHRvIHRoZSBgcmlnaHRgLlxuICogQHBhcmFtIHJpZ2h0IC0gQ29tcGFyZSB0aGlzIEFnZ3JlZ2F0ZUZpZWxkIHRvIHRoZSBgbGVmdGAuXG4gKi9cbmZ1bmN0aW9uIGFnZ3JlZ2F0ZUZpZWxkRXF1YWwobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gKGxlZnQgaW5zdGFuY2VvZiBBZ2dyZWdhdGVGaWVsZCAmJlxuICAgICAgICByaWdodCBpbnN0YW5jZW9mIEFnZ3JlZ2F0ZUZpZWxkICYmXG4gICAgICAgIGxlZnQuYWdncmVnYXRlVHlwZSA9PT0gcmlnaHQuYWdncmVnYXRlVHlwZSAmJlxuICAgICAgICBsZWZ0Ll9pbnRlcm5hbEZpZWxkUGF0aD8uY2Fub25pY2FsU3RyaW5nKCkgPT09XG4gICAgICAgICAgICByaWdodC5faW50ZXJuYWxGaWVsZFBhdGg/LmNhbm9uaWNhbFN0cmluZygpKTtcbn1cbi8qKlxuICogQ29tcGFyZXMgdHdvIGBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90YCBpbnN0YW5jZXMgZm9yIGVxdWFsaXR5LlxuICpcbiAqIFR3byBgQWdncmVnYXRlUXVlcnlTbmFwc2hvdGAgaW5zdGFuY2VzIGFyZSBjb25zaWRlcmVkIFwiZXF1YWxcIiBpZiB0aGV5IGhhdmVcbiAqIHVuZGVybHlpbmcgcXVlcmllcyB0aGF0IGNvbXBhcmUgZXF1YWwsIGFuZCB0aGUgc2FtZSBkYXRhLlxuICpcbiAqIEBwYXJhbSBsZWZ0IC0gVGhlIGZpcnN0IGBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90YCB0byBjb21wYXJlLlxuICogQHBhcmFtIHJpZ2h0IC0gVGhlIHNlY29uZCBgQWdncmVnYXRlUXVlcnlTbmFwc2hvdGAgdG8gY29tcGFyZS5cbiAqXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIFwiZXF1YWxcIiwgYXMgZGVmaW5lZCBhYm92ZSwgb3IgYGZhbHNlYFxuICogb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBhZ2dyZWdhdGVRdWVyeVNuYXBzaG90RXF1YWwobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gKHF1ZXJ5RXF1YWwobGVmdC5xdWVyeSwgcmlnaHQucXVlcnkpICYmIGRlZXBFcXVhbChsZWZ0LmRhdGEoKSwgcmlnaHQuZGF0YSgpKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgaW4gdGhlIHJlc3VsdCBzZXQgb2YgdGhlIGdpdmVuIHF1ZXJ5XG4gKiB3aXRob3V0IGFjdHVhbGx5IGRvd25sb2FkaW5nIHRoZSBkb2N1bWVudHMuXG4gKlxuICogVXNpbmcgdGhpcyBmdW5jdGlvbiB0byBjb3VudCB0aGUgZG9jdW1lbnRzIGlzIGVmZmljaWVudCBiZWNhdXNlIG9ubHkgdGhlXG4gKiBmaW5hbCBjb3VudCwgbm90IHRoZSBkb2N1bWVudHMnIGRhdGEsIGlzIGRvd25sb2FkZWQuIFRoaXMgZnVuY3Rpb24gY2FuXG4gKiBjb3VudCB0aGUgZG9jdW1lbnRzIGluIGNhc2VzIHdoZXJlIHRoZSByZXN1bHQgc2V0IGlzIHByb2hpYml0aXZlbHkgbGFyZ2UgdG9cbiAqIGRvd25sb2FkIGVudGlyZWx5ICh0aG91c2FuZHMgb2YgZG9jdW1lbnRzKS5cbiAqXG4gKiBUaGUgcmVzdWx0IHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBpcyBwcmVzZW50ZWQsIHVuYWx0ZXJlZCwgd2l0aG91dFxuICogY29uc2lkZXJpbmcgYW55IGxvY2FsIHN0YXRlLiBUaGF0IGlzLCBkb2N1bWVudHMgaW4gdGhlIGxvY2FsIGNhY2hlIGFyZSBub3RcbiAqIHRha2VuIGludG8gY29uc2lkZXJhdGlvbiwgbmVpdGhlciBhcmUgbG9jYWwgbW9kaWZpY2F0aW9ucyBub3QgeWV0XG4gKiBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgc2VydmVyLiBQcmV2aW91c2x5LWRvd25sb2FkZWQgcmVzdWx0cywgaWYgYW55LCBhcmUgbm90XG4gKiB1c2VkLiBFdmVyeSBpbnZvY2F0aW9uIG9mIHRoaXMgZnVuY3Rpb24gbmVjZXNzYXJpbHkgaW52b2x2ZXMgYSByb3VuZCB0cmlwIHRvXG4gKiB0aGUgc2VydmVyLlxuICpcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB3aG9zZSByZXN1bHQgc2V0IHNpemUgaXMgY2FsY3VsYXRlZC5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgY291bnQ7IHRoZSBjb3VudCBjYW4gYmVcbiAqIHJldHJpZXZlZCBmcm9tIGBzbmFwc2hvdC5kYXRhKCkuY291bnRgLCB3aGVyZSBgc25hcHNob3RgIGlzIHRoZVxuICogYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgIHRvIHdoaWNoIHRoZSByZXR1cm5lZCBQcm9taXNlIHJlc29sdmVzLlxuICovXG5mdW5jdGlvbiBnZXRDb3VudEZyb21TZXJ2ZXIocXVlcnkpIHtcbiAgICBjb25zdCBjb3VudFF1ZXJ5U3BlYyA9IHtcbiAgICAgICAgY291bnQ6IGNvdW50KClcbiAgICB9O1xuICAgIHJldHVybiBnZXRBZ2dyZWdhdGVGcm9tU2VydmVyKHF1ZXJ5LCBjb3VudFF1ZXJ5U3BlYyk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNwZWNpZmllZCBhZ2dyZWdhdGlvbnMgb3ZlciB0aGUgZG9jdW1lbnRzIGluIHRoZSByZXN1bHRcbiAqIHNldCBvZiB0aGUgZ2l2ZW4gcXVlcnkgd2l0aG91dCBhY3R1YWxseSBkb3dubG9hZGluZyB0aGUgZG9jdW1lbnRzLlxuICpcbiAqIFVzaW5nIHRoaXMgZnVuY3Rpb24gdG8gcGVyZm9ybSBhZ2dyZWdhdGlvbnMgaXMgZWZmaWNpZW50IGJlY2F1c2Ugb25seSB0aGVcbiAqIGZpbmFsIGFnZ3JlZ2F0aW9uIHZhbHVlcywgbm90IHRoZSBkb2N1bWVudHMnIGRhdGEsIGFyZSBkb3dubG9hZGVkLiBUaGlzXG4gKiBmdW5jdGlvbiBjYW4gcGVyZm9ybSBhZ2dyZWdhdGlvbnMgb2YgdGhlIGRvY3VtZW50cyBpbiBjYXNlcyB3aGVyZSB0aGUgcmVzdWx0XG4gKiBzZXQgaXMgcHJvaGliaXRpdmVseSBsYXJnZSB0byBkb3dubG9hZCBlbnRpcmVseSAodGhvdXNhbmRzIG9mIGRvY3VtZW50cykuXG4gKlxuICogVGhlIHJlc3VsdCByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgaXMgcHJlc2VudGVkLCB1bmFsdGVyZWQsIHdpdGhvdXRcbiAqIGNvbnNpZGVyaW5nIGFueSBsb2NhbCBzdGF0ZS4gVGhhdCBpcywgZG9jdW1lbnRzIGluIHRoZSBsb2NhbCBjYWNoZSBhcmUgbm90XG4gKiB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb24sIG5laXRoZXIgYXJlIGxvY2FsIG1vZGlmaWNhdGlvbnMgbm90IHlldFxuICogc3luY2hyb25pemVkIHdpdGggdGhlIHNlcnZlci4gUHJldmlvdXNseS1kb3dubG9hZGVkIHJlc3VsdHMsIGlmIGFueSwgYXJlIG5vdFxuICogdXNlZC4gRXZlcnkgaW52b2NhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIG5lY2Vzc2FyaWx5IGludm9sdmVzIGEgcm91bmQgdHJpcCB0b1xuICogdGhlIHNlcnZlci5cbiAqXG4gKiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkgd2hvc2UgcmVzdWx0IHNldCBpcyBhZ2dyZWdhdGVkIG92ZXIuXG4gKiBAcGFyYW0gYWdncmVnYXRlU3BlYyAtIEFuIGBBZ2dyZWdhdGVTcGVjYCBvYmplY3QgdGhhdCBzcGVjaWZpZXMgdGhlIGFnZ3JlZ2F0ZXNcbiAqIHRvIHBlcmZvcm0gb3ZlciB0aGUgcmVzdWx0IHNldC4gVGhlIEFnZ3JlZ2F0ZVNwZWMgc3BlY2lmaWVzIGFsaWFzZXMgZm9yIGVhY2hcbiAqIGFnZ3JlZ2F0ZSwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmV0cmlldmUgdGhlIGFnZ3JlZ2F0ZSByZXN1bHQuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgYWdncmVnYXRlU25hcHNob3QgPSBhd2FpdCBnZXRBZ2dyZWdhdGVGcm9tU2VydmVyKHF1ZXJ5LCB7XG4gKiAgIGNvdW50T2ZEb2NzOiBjb3VudCgpLFxuICogICB0b3RhbEhvdXJzOiBzdW0oJ2hvdXJzJyksXG4gKiAgIGF2ZXJhZ2VTY29yZTogYXZlcmFnZSgnc2NvcmUnKVxuICogfSk7XG4gKlxuICogY29uc3QgY291bnRPZkRvY3M6IG51bWJlciA9IGFnZ3JlZ2F0ZVNuYXBzaG90LmRhdGEoKS5jb3VudE9mRG9jcztcbiAqIGNvbnN0IHRvdGFsSG91cnM6IG51bWJlciA9IGFnZ3JlZ2F0ZVNuYXBzaG90LmRhdGEoKS50b3RhbEhvdXJzO1xuICogY29uc3QgYXZlcmFnZVNjb3JlOiBudW1iZXIgfCBudWxsID0gYWdncmVnYXRlU25hcHNob3QuZGF0YSgpLmF2ZXJhZ2VTY29yZTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBnZXRBZ2dyZWdhdGVGcm9tU2VydmVyKHF1ZXJ5LCBhZ2dyZWdhdGVTcGVjKSB7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGNvbnN0IGludGVybmFsQWdncmVnYXRlcyA9IG1hcFRvQXJyYXkoYWdncmVnYXRlU3BlYywgKGFnZ3JlZ2F0ZSwgYWxpYXMpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGVJbXBsKGFsaWFzLCBhZ2dyZWdhdGUuYWdncmVnYXRlVHlwZSwgYWdncmVnYXRlLl9pbnRlcm5hbEZpZWxkUGF0aCk7XG4gICAgfSk7XG4gICAgLy8gUnVuIHRoZSBhZ2dyZWdhdGlvbiBhbmQgY29udmVydCB0aGUgcmVzdWx0c1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRSdW5BZ2dyZWdhdGVRdWVyeShjbGllbnQsIHF1ZXJ5Ll9xdWVyeSwgaW50ZXJuYWxBZ2dyZWdhdGVzKS50aGVuKGFnZ3JlZ2F0ZVJlc3VsdCA9PiBjb252ZXJ0VG9BZ2dyZWdhdGVRdWVyeVNuYXBzaG90KGZpcmVzdG9yZSwgcXVlcnksIGFnZ3JlZ2F0ZVJlc3VsdCkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgY29yZSBhZ2dyZWdhdGlvbiByZXN1bHQgdG8gYW4gYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgXG4gKiB0aGF0IGNhbiBiZSByZXR1cm5lZCB0byB0aGUgY29uc3VtZXIuXG4gKiBAcGFyYW0gcXVlcnlcbiAqIEBwYXJhbSBhZ2dyZWdhdGVSZXN1bHQgLSBDb3JlIGFnZ3JlZ2F0aW9uIHJlc3VsdFxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb0FnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCBxdWVyeSwgYWdncmVnYXRlUmVzdWx0KSB7XG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gbmV3IEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QocXVlcnksIHVzZXJEYXRhV3JpdGVyLCBhZ2dyZWdhdGVSZXN1bHQpO1xuICAgIHJldHVybiBxdWVyeVNuYXBzaG90O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTWVtb3J5TG9jYWxDYWNoZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdtZW1vcnknO1xuICAgICAgICB0aGlzLl9vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IE9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnByb3ZpZGVyO1xuICAgICAgICBpZiAoc2V0dGluZ3M/LmdhcmJhZ2VDb2xsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX29mZmxpbmVDb21wb25lbnRQcm92aWRlciA9XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZ2FyYmFnZUNvbGxlY3Rvci5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyID0ge1xuICAgICAgICAgICAgICAgIGJ1aWxkOiAoKSA9PiBuZXcgTHJ1R2NNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIodW5kZWZpbmVkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQ6IHRoaXMua2luZCB9O1xuICAgIH1cbn1cbmNsYXNzIFBlcnNpc3RlbnRMb2NhbENhY2hlSW1wbCB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5raW5kID0gJ3BlcnNpc3RlbnQnO1xuICAgICAgICBsZXQgdGFiTWFuYWdlcjtcbiAgICAgICAgaWYgKHNldHRpbmdzPy50YWJNYW5hZ2VyKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy50YWJNYW5hZ2VyLl9pbml0aWFsaXplKHNldHRpbmdzKTtcbiAgICAgICAgICAgIHRhYk1hbmFnZXIgPSBzZXR0aW5ncy50YWJNYW5hZ2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFiTWFuYWdlciA9IHBlcnNpc3RlbnRTaW5nbGVUYWJNYW5hZ2VyKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB0YWJNYW5hZ2VyLl9pbml0aWFsaXplKHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IHRhYk1hbmFnZXIuX29ubGluZUNvbXBvbmVudFByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSB0YWJNYW5hZ2VyLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXI7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsga2luZDogdGhpcy5raW5kIH07XG4gICAgfVxufVxuY2xhc3MgTWVtb3J5RWFnZXJHYXJiYWdlQ29sbGVjdG9ySW1wbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdtZW1vcnlFYWdlcic7XG4gICAgICAgIHRoaXMuX29mZmxpbmVDb21wb25lbnRQcm92aWRlciA9IE1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlci5wcm92aWRlcjtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBraW5kOiB0aGlzLmtpbmQgfTtcbiAgICB9XG59XG5jbGFzcyBNZW1vcnlMcnVHYXJiYWdlQ29sbGVjdG9ySW1wbCB7XG4gICAgY29uc3RydWN0b3IoY2FjaGVTaXplKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdtZW1vcnlMcnUnO1xuICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSB7XG4gICAgICAgICAgICBidWlsZDogKCkgPT4gbmV3IExydUdjTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKGNhY2hlU2l6ZSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBraW5kOiB0aGlzLmtpbmQgfTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYE1lbW9yeUVhZ2VyR2FyYmFnZUNvbGxlY3RvcmAuIFRoaXMgaXMgYWxzbyB0aGVcbiAqIGRlZmF1bHQgZ2FyYmFnZSBjb2xsZWN0b3IgdW5sZXNzIGl0IGlzIGV4cGxpY2l0bHkgc3BlY2lmaWVkIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gbWVtb3J5RWFnZXJHYXJiYWdlQ29sbGVjdG9yKCkge1xuICAgIHJldHVybiBuZXcgTWVtb3J5RWFnZXJHYXJiYWdlQ29sbGVjdG9ySW1wbCgpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBNZW1vcnlMcnVHYXJiYWdlQ29sbGVjdG9yYC5cbiAqXG4gKiBBIHRhcmdldCBzaXplIGNhbiBiZSBzcGVjaWZpZWQgYXMgcGFydCBvZiB0aGUgc2V0dGluZyBwYXJhbWV0ZXIuIFRoZVxuICogY29sbGVjdG9yIHdpbGwgc3RhcnQgZGVsZXRpbmcgZG9jdW1lbnRzIG9uY2UgdGhlIGNhY2hlIHNpemUgZXhjZWVkc1xuICogdGhlIGdpdmVuIHNpemUuIFRoZSBkZWZhdWx0IGNhY2hlIHNpemUgaXMgNDBNQiAoNDAgKiAxMDI0ICogMTAyNCBieXRlcykuXG4gKi9cbmZ1bmN0aW9uIG1lbW9yeUxydUdhcmJhZ2VDb2xsZWN0b3Ioc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IE1lbW9yeUxydUdhcmJhZ2VDb2xsZWN0b3JJbXBsKHNldHRpbmdzPy5jYWNoZVNpemVCeXRlcyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYE1lbW9yeUxvY2FsQ2FjaGVgLiBUaGUgaW5zdGFuY2UgY2FuIGJlIHNldCB0b1xuICogYEZpcmVzdG9yZVNldHRpbmdzLmNhY2hlYCB0byB0ZWxsIHRoZSBTREsgd2hpY2ggY2FjaGUgbGF5ZXIgdG8gdXNlLlxuICovXG5mdW5jdGlvbiBtZW1vcnlMb2NhbENhY2hlKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBNZW1vcnlMb2NhbENhY2hlSW1wbChzZXR0aW5ncyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYFBlcnNpc3RlbnRMb2NhbENhY2hlYC4gVGhlIGluc3RhbmNlIGNhbiBiZSBzZXQgdG9cbiAqIGBGaXJlc3RvcmVTZXR0aW5ncy5jYWNoZWAgdG8gdGVsbCB0aGUgU0RLIHdoaWNoIGNhY2hlIGxheWVyIHRvIHVzZS5cbiAqXG4gKiBQZXJzaXN0ZW50IGNhY2hlIGNhbm5vdCBiZSB1c2VkIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudC5cbiAqL1xuZnVuY3Rpb24gcGVyc2lzdGVudExvY2FsQ2FjaGUoc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IFBlcnNpc3RlbnRMb2NhbENhY2hlSW1wbChzZXR0aW5ncyk7XG59XG5jbGFzcyBTaW5nbGVUYWJNYW5hZ2VySW1wbCB7XG4gICAgY29uc3RydWN0b3IoZm9yY2VPd25lcnNoaXApIHtcbiAgICAgICAgdGhpcy5mb3JjZU93bmVyc2hpcCA9IGZvcmNlT3duZXJzaGlwO1xuICAgICAgICB0aGlzLmtpbmQgPSAncGVyc2lzdGVudFNpbmdsZVRhYic7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsga2luZDogdGhpcy5raW5kIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9pbml0aWFsaXplKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuX29ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gT25saW5lQ29tcG9uZW50UHJvdmlkZXIucHJvdmlkZXI7XG4gICAgICAgIHRoaXMuX29mZmxpbmVDb21wb25lbnRQcm92aWRlciA9IHtcbiAgICAgICAgICAgIGJ1aWxkOiAob25saW5lQ29tcG9uZW50cykgPT4gbmV3IEluZGV4ZWREYk9mZmxpbmVDb21wb25lbnRQcm92aWRlcihvbmxpbmVDb21wb25lbnRzLCBzZXR0aW5ncz8uY2FjaGVTaXplQnl0ZXMsIHRoaXMuZm9yY2VPd25lcnNoaXApXG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgTXVsdGlUYWJNYW5hZ2VySW1wbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdQZXJzaXN0ZW50TXVsdGlwbGVUYWInO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQ6IHRoaXMua2luZCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZShzZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IE9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSB7XG4gICAgICAgICAgICBidWlsZDogKG9ubGluZUNvbXBvbmVudHMpID0+IG5ldyBNdWx0aVRhYk9mZmxpbmVDb21wb25lbnRQcm92aWRlcihvbmxpbmVDb21wb25lbnRzLCBzZXR0aW5ncz8uY2FjaGVTaXplQnl0ZXMpXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBQZXJzaXN0ZW50U2luZ2xlVGFiTWFuYWdlcmAuXG4gKlxuICogQHBhcmFtIHNldHRpbmdzIC0gQ29uZmlndXJlcyB0aGUgY3JlYXRlZCB0YWIgbWFuYWdlci5cbiAqL1xuZnVuY3Rpb24gcGVyc2lzdGVudFNpbmdsZVRhYk1hbmFnZXIoc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IFNpbmdsZVRhYk1hbmFnZXJJbXBsKHNldHRpbmdzPy5mb3JjZU93bmVyc2hpcCk7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYFBlcnNpc3RlbnRNdWx0aXBsZVRhYk1hbmFnZXJgLlxuICovXG5mdW5jdGlvbiBwZXJzaXN0ZW50TXVsdGlwbGVUYWJNYW5hZ2VyKCkge1xuICAgIHJldHVybiBuZXcgTXVsdGlUYWJNYW5hZ2VySW1wbCgpO1xufVxuXG5jb25zdCBlbmNvZGVyID0gbmV3VGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIGxlbmd0aFByZWZpeGVkU3RyaW5nKG8pIHtcbiAgICBjb25zdCBzdHIgPSBKU09OLnN0cmluZ2lmeShvKTtcbiAgICBjb25zdCBsID0gZW5jb2Rlci5lbmNvZGUoc3RyKS5ieXRlTGVuZ3RoO1xuICAgIHJldHVybiBgJHtsfSR7c3RyfWA7XG59XG4vLyBUT0RPKHd1YW5keSk6IElkZWFsbHksIHRoZXNlIHNob3VsZCB1c2UgYFRlc3RCdW5kbGVCdWlsZGVyYCBhYm92ZS5cbmNvbnN0IG1ldGEgPSB7XG4gICAgbWV0YWRhdGE6IHtcbiAgICAgICAgaWQ6ICd0ZXN0LWJ1bmRsZScsXG4gICAgICAgIGNyZWF0ZVRpbWU6IHsgc2Vjb25kczogMTU3NzgzNjgwNSwgbmFub3M6IDYgfSxcbiAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgdG90YWxEb2N1bWVudHM6IDEsXG4gICAgICAgIHRvdGFsQnl0ZXM6IDQxNlxuICAgIH1cbn07XG5sZW5ndGhQcmVmaXhlZFN0cmluZyhtZXRhKTtcbmNvbnN0IGRvYzFNZXRhID0ge1xuICAgIGRvY3VtZW50TWV0YWRhdGE6IHtcbiAgICAgICAgbmFtZTogJ3Byb2plY3RzL3Rlc3QtcHJvamVjdC9kYXRhYmFzZXMvKGRlZmF1bHQpL2RvY3VtZW50cy9jb2xsZWN0aW9uSWQvZG9jMScsXG4gICAgICAgIHJlYWRUaW1lOiB7IHNlY29uZHM6IDUsIG5hbm9zOiA2IH0sXG4gICAgICAgIGV4aXN0czogdHJ1ZVxuICAgIH1cbn07XG5sZW5ndGhQcmVmaXhlZFN0cmluZyhkb2MxTWV0YSk7XG5jb25zdCBkb2MxID0ge1xuICAgIGRvY3VtZW50OiB7XG4gICAgICAgIG5hbWU6ICdwcm9qZWN0cy90ZXN0LXByb2plY3QvZGF0YWJhc2VzLyhkZWZhdWx0KS9kb2N1bWVudHMvY29sbGVjdGlvbklkL2RvYzEnLFxuICAgICAgICBjcmVhdGVUaW1lOiB7IHNlY29uZHM6IDEsIG5hbm9zOiAyMDAwMDAwIH0sXG4gICAgICAgIHVwZGF0ZVRpbWU6IHsgc2Vjb25kczogMywgbmFub3M6IDQwMDAgfSxcbiAgICAgICAgZmllbGRzOiB7IGZvbzogeyBzdHJpbmdWYWx1ZTogJ3ZhbHVlJyB9LCBiYXI6IHsgaW50ZWdlclZhbHVlOiAtNDIgfSB9XG4gICAgfVxufTtcbmxlbmd0aFByZWZpeGVkU3RyaW5nKGRvYzEpO1xuY29uc3QgZG9jMk1ldGEgPSB7XG4gICAgZG9jdW1lbnRNZXRhZGF0YToge1xuICAgICAgICBuYW1lOiAncHJvamVjdHMvdGVzdC1wcm9qZWN0L2RhdGFiYXNlcy8oZGVmYXVsdCkvZG9jdW1lbnRzL2NvbGxlY3Rpb25JZC9kb2MyJyxcbiAgICAgICAgcmVhZFRpbWU6IHsgc2Vjb25kczogNSwgbmFub3M6IDYgfSxcbiAgICAgICAgZXhpc3RzOiB0cnVlXG4gICAgfVxufTtcbmxlbmd0aFByZWZpeGVkU3RyaW5nKGRvYzJNZXRhKTtcbmNvbnN0IGRvYzIgPSB7XG4gICAgZG9jdW1lbnQ6IHtcbiAgICAgICAgbmFtZTogJ3Byb2plY3RzL3Rlc3QtcHJvamVjdC9kYXRhYmFzZXMvKGRlZmF1bHQpL2RvY3VtZW50cy9jb2xsZWN0aW9uSWQvZG9jMicsXG4gICAgICAgIGNyZWF0ZVRpbWU6IHsgc2Vjb25kczogMSwgbmFub3M6IDIwMDAwMDAgfSxcbiAgICAgICAgdXBkYXRlVGltZTogeyBzZWNvbmRzOiAzLCBuYW5vczogNDAwMCB9LFxuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIGZvbzogeyBzdHJpbmdWYWx1ZTogJ3ZhbHVlMScgfSxcbiAgICAgICAgICAgIGJhcjogeyBpbnRlZ2VyVmFsdWU6IDQyIH0sXG4gICAgICAgICAgICBlbXB0eUFycmF5OiB7IGFycmF5VmFsdWU6IHt9IH0sXG4gICAgICAgICAgICBlbXB0eU1hcDogeyBtYXBWYWx1ZToge30gfVxuICAgICAgICB9XG4gICAgfVxufTtcbmxlbmd0aFByZWZpeGVkU3RyaW5nKGRvYzIpO1xuY29uc3Qgbm9Eb2NNZXRhID0ge1xuICAgIGRvY3VtZW50TWV0YWRhdGE6IHtcbiAgICAgICAgbmFtZTogJ3Byb2plY3RzL3Rlc3QtcHJvamVjdC9kYXRhYmFzZXMvKGRlZmF1bHQpL2RvY3VtZW50cy9jb2xsZWN0aW9uSWQvbm9kb2MnLFxuICAgICAgICByZWFkVGltZTogeyBzZWNvbmRzOiA1LCBuYW5vczogNiB9LFxuICAgICAgICBleGlzdHM6IGZhbHNlXG4gICAgfVxufTtcbmxlbmd0aFByZWZpeGVkU3RyaW5nKG5vRG9jTWV0YSk7XG5jb25zdCBsaW1pdFF1ZXJ5ID0ge1xuICAgIG5hbWVkUXVlcnk6IHtcbiAgICAgICAgbmFtZTogJ2xpbWl0UXVlcnknLFxuICAgICAgICBidW5kbGVkUXVlcnk6IHtcbiAgICAgICAgICAgIHBhcmVudDogJ3Byb2plY3RzL2ZpcmVlYXRzLTk3ZDVlL2RhdGFiYXNlcy8oZGVmYXVsdCkvZG9jdW1lbnRzJyxcbiAgICAgICAgICAgIHN0cnVjdHVyZWRRdWVyeToge1xuICAgICAgICAgICAgICAgIGZyb206IFt7IGNvbGxlY3Rpb25JZDogJ25vZGVfMy43LjVfN0xpN1hvQ2p1dHZOeHdEMHRwbzknIH1dLFxuICAgICAgICAgICAgICAgIG9yZGVyQnk6IFt7IGZpZWxkOiB7IGZpZWxkUGF0aDogJ3NvcnQnIH0sIGRpcmVjdGlvbjogJ0RFU0NFTkRJTkcnIH1dLFxuICAgICAgICAgICAgICAgIGxpbWl0OiB7ICd2YWx1ZSc6IDEgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbWl0VHlwZTogJ0ZJUlNUJ1xuICAgICAgICB9LFxuICAgICAgICByZWFkVGltZTogeyAnc2Vjb25kcyc6IDE1OTAwMTEzNzksICduYW5vcyc6IDE5MTE2NDAwMCB9XG4gICAgfVxufTtcbmxlbmd0aFByZWZpeGVkU3RyaW5nKGxpbWl0UXVlcnkpO1xuY29uc3QgbGltaXRUb0xhc3RRdWVyeSA9IHtcbiAgICBuYW1lZFF1ZXJ5OiB7XG4gICAgICAgIG5hbWU6ICdsaW1pdFRvTGFzdFF1ZXJ5JyxcbiAgICAgICAgYnVuZGxlZFF1ZXJ5OiB7XG4gICAgICAgICAgICBwYXJlbnQ6ICdwcm9qZWN0cy9maXJlZWF0cy05N2Q1ZS9kYXRhYmFzZXMvKGRlZmF1bHQpL2RvY3VtZW50cycsXG4gICAgICAgICAgICBzdHJ1Y3R1cmVkUXVlcnk6IHtcbiAgICAgICAgICAgICAgICBmcm9tOiBbeyBjb2xsZWN0aW9uSWQ6ICdub2RlXzMuNy41XzdMaTdYb0NqdXR2Tnh3RDB0cG85JyB9XSxcbiAgICAgICAgICAgICAgICBvcmRlckJ5OiBbeyBmaWVsZDogeyBmaWVsZFBhdGg6ICdzb3J0JyB9LCBkaXJlY3Rpb246ICdBU0NFTkRJTkcnIH1dLFxuICAgICAgICAgICAgICAgIGxpbWl0OiB7ICd2YWx1ZSc6IDEgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbWl0VHlwZTogJ0xBU1QnXG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRUaW1lOiB7ICdzZWNvbmRzJzogMTU5MDAxMTM3OSwgJ25hbm9zJzogNTQzMDYzMDAwIH1cbiAgICB9XG59O1xubGVuZ3RoUHJlZml4ZWRTdHJpbmcobGltaXRUb0xhc3RRdWVyeSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBCVU5ETEVfVkVSU0lPTiA9IDE7XG4vKipcbiAqIEJ1aWxkcyBhIEZpcmVzdG9yZSBkYXRhIGJ1bmRsZSB3aXRoIHJlc3VsdHMgZnJvbSB0aGUgZ2l2ZW4gZG9jdW1lbnQgYW5kIHF1ZXJ5IHNuYXBzaG90cy5cbiAqL1xuY2xhc3MgQnVuZGxlQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlLCBidW5kbGVJZCkge1xuICAgICAgICB0aGlzLmZpcmVzdG9yZSA9IGZpcmVzdG9yZTtcbiAgICAgICAgdGhpcy5idW5kbGVJZCA9IGJ1bmRsZUlkO1xuICAgICAgICAvLyBSZXN1bHRpbmcgZG9jdW1lbnRzIGZvciB0aGUgYnVuZGxlLCBrZXllZCBieSBmdWxsIGRvY3VtZW50IHBhdGguXG4gICAgICAgIHRoaXMuZG9jdW1lbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBOYW1lZCBxdWVyaWVzIHNhdmVkIGluIHRoZSBidW5kbGUsIGtleWVkIGJ5IHF1ZXJ5IG5hbWUuXG4gICAgICAgIHRoaXMubmFtZWRRdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBUaGUgbGF0ZXN0IHJlYWQgdGltZSBhbW9uZyBhbGwgYnVuZGxlZCBkb2N1bWVudHMgYW5kIHF1ZXJpZXMuXG4gICAgICAgIHRoaXMubGF0ZXN0UmVhZFRpbWUgPSBuZXcgVGltZXN0YW1wKDAsIDApO1xuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBmaXJlc3RvcmUuX2RhdGFiYXNlSWQ7XG4gICAgICAgIC8vIHVzZVByb3RvM0pzb24gaXMgdHJ1ZSBiZWNhdXNlIHRoZSBvYmplY3RzIHdpbGwgYmUgc2VyaWFsaXplZCB0byBKU09OIHN0cmluZ1xuICAgICAgICAvLyBiZWZvcmUgYmVpbmcgd3JpdHRlbiB0byB0aGUgYnVuZGxlIGJ1ZmZlci5cbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gbmV3IEpzb25Qcm90b1NlcmlhbGl6ZXIodGhpcy5kYXRhYmFzZUlkLCBcbiAgICAgICAgLyp1c2VQcm90bzNKc29uPSovIHRydWUpO1xuICAgICAgICB0aGlzLnVzZXJEYXRhUmVhZGVyID0gbmV3IFVzZXJEYXRhUmVhZGVyKHRoaXMuZGF0YWJhc2VJZCwgdHJ1ZSwgdGhpcy5zZXJpYWxpemVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBkYXRhIGZyb20gYSBEb2N1bWVudFNuYXBzaG90IHRvIHRoZSBidW5kbGUuXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIGRvY0J1bmRsZURhdGEgLSBBIERvY3VtZW50U25hcHNob3RCdW5kbGVEYXRhIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gZnJvbSB0aGVcbiAgICAgKiBEb2N1bWVudFNuYXBzaG90LiBOb3RlIHdlIGNhbm5vdCBhY2NlcHQgYSBEb2N1bWVudFNuYXBzaG90IGRpcmVjdGx5IGR1ZSB0byBhIGNpcmN1bGFyXG4gICAgICogZGVwZW5kZW5jeSBlcnJvci5cbiAgICAgKiBAcGFyYW0gcXVlcnlOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIFF1ZXJ5U25hcHNob3QgaWYgdGhpcyBkb2N1bWVudCBpcyBwYXJ0IG9mIGEgUXVlcnkuXG4gICAgICovXG4gICAgYWRkQnVuZGxlRG9jdW1lbnQoZG9jQnVuZGxlRGF0YSwgcXVlcnlOYW1lKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50cy5nZXQoZG9jQnVuZGxlRGF0YS5kb2N1bWVudFBhdGgpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbFF1ZXJpZXMgPSBvcmlnaW5hbERvY3VtZW50Py5tZXRhZGF0YS5xdWVyaWVzO1xuICAgICAgICBjb25zdCBkb2NSZWFkVGltZSA9IGRvY0J1bmRsZURhdGEucmVhZFRpbWU7XG4gICAgICAgIGNvbnN0IG9yaWdEb2NSZWFkVGltZSA9ICEhb3JpZ2luYWxEb2N1bWVudD8ubWV0YWRhdGFcbiAgICAgICAgICAgIC5yZWFkVGltZVxuICAgICAgICAgICAgPyBmcm9tVGltZXN0YW1wKG9yaWdpbmFsRG9jdW1lbnQubWV0YWRhdGEucmVhZFRpbWUpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGNvbnN0IG5laXRoZXJIYXNSZWFkVGltZSA9ICFkb2NSZWFkVGltZSAmJiBvcmlnRG9jUmVhZFRpbWUgPT0gbnVsbDtcbiAgICAgICAgY29uc3QgZG9jSXNOZXdlciA9IGRvY1JlYWRUaW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvcmlnRG9jUmVhZFRpbWUgPT0gbnVsbCB8fCBvcmlnRG9jUmVhZFRpbWUgPCBkb2NSZWFkVGltZSk7XG4gICAgICAgIGlmIChuZWl0aGVySGFzUmVhZFRpbWUgfHwgZG9jSXNOZXdlcikge1xuICAgICAgICAgICAgLy8gU3RvcmUgZG9jdW1lbnQuXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50cy5zZXQoZG9jQnVuZGxlRGF0YS5kb2N1bWVudFBhdGgsIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudDogdGhpcy50b0J1bmRsZURvY3VtZW50KGRvY0J1bmRsZURhdGEpLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRvTmFtZSh0aGlzLnNlcmlhbGl6ZXIsIGRvY0J1bmRsZURhdGEuZG9jdW1lbnRLZXkpLFxuICAgICAgICAgICAgICAgICAgICByZWFkVGltZTogISFkb2NSZWFkVGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0b1RpbWVzdGFtcCh0aGlzLnNlcmlhbGl6ZXIsIGRvY1JlYWRUaW1lKSAvLyBDb252ZXJ0IFRpbWVzdGFtcCB0byBwcm90byBmb3JtYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RzOiBkb2NCdW5kbGVEYXRhLmRvY3VtZW50RXhpc3RzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY1JlYWRUaW1lICYmIGRvY1JlYWRUaW1lID4gdGhpcy5sYXRlc3RSZWFkVGltZSkge1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RSZWFkVGltZSA9IGRvY1JlYWRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBgcXVlcmllc2AgdG8gaW5jbHVkZSBib3RoIG9yaWdpbmFsIGFuZCBgcXVlcnlOYW1lYC5cbiAgICAgICAgaWYgKHF1ZXJ5TmFtZSkge1xuICAgICAgICAgICAgY29uc3QgbmV3RG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50cy5nZXQoZG9jQnVuZGxlRGF0YS5kb2N1bWVudFBhdGgpO1xuICAgICAgICAgICAgbmV3RG9jdW1lbnQubWV0YWRhdGEucXVlcmllcyA9IG9yaWdpbmFsUXVlcmllcyB8fCBbXTtcbiAgICAgICAgICAgIG5ld0RvY3VtZW50Lm1ldGFkYXRhLnF1ZXJpZXMucHVzaChxdWVyeU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgZGF0YSBmcm9tIGEgUXVlcnlTbmFwc2hvdCB0byB0aGUgYnVuZGxlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSBkb2NCdW5kbGVEYXRhIC0gQSBRdWVyeVNuYXBzaG90QnVuZGxlRGF0YSBjb250YWluaW5nIGluZm9ybWF0aW9uIGZyb20gdGhlXG4gICAgICogUXVlcnlTbmFwc2hvdC4gTm90ZSB3ZSBjYW5ub3QgYWNjZXB0IGEgUXVlcnlTbmFwc2hvdCBkaXJlY3RseSBkdWUgdG8gYSBjaXJjdWxhclxuICAgICAqIGRlcGVuZGVuY3kgZXJyb3IuXG4gICAgICovXG4gICAgYWRkQnVuZGxlUXVlcnkocXVlcnlCdW5kbGVEYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWVkUXVlcmllcy5oYXMocXVlcnlCdW5kbGVEYXRhLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFF1ZXJ5IG5hbWUgY29uZmxpY3Q6ICR7bmFtZX0gaGFzIGFscmVhZHkgYmVlbiBhZGRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGF0ZXN0UmVhZFRpbWUgPSBuZXcgVGltZXN0YW1wKDAsIDApO1xuICAgICAgICBmb3IgKGNvbnN0IGRvY0J1bmRsZURhdGEgb2YgcXVlcnlCdW5kbGVEYXRhLmRvY0J1bmRsZURhdGFBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5hZGRCdW5kbGVEb2N1bWVudChkb2NCdW5kbGVEYXRhLCBxdWVyeUJ1bmRsZURhdGEubmFtZSk7XG4gICAgICAgICAgICBpZiAoZG9jQnVuZGxlRGF0YS5yZWFkVGltZSAmJiBkb2NCdW5kbGVEYXRhLnJlYWRUaW1lID4gbGF0ZXN0UmVhZFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsYXRlc3RSZWFkVGltZSA9IGRvY0J1bmRsZURhdGEucmVhZFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcnlUYXJnZXQgPSB0b1F1ZXJ5VGFyZ2V0KHRoaXMuc2VyaWFsaXplciwgcXVlcnlUb1RhcmdldChxdWVyeUJ1bmRsZURhdGEucXVlcnkpKTtcbiAgICAgICAgY29uc3QgYnVuZGxlZFF1ZXJ5ID0ge1xuICAgICAgICAgICAgcGFyZW50OiBxdWVyeUJ1bmRsZURhdGEucGFyZW50LFxuICAgICAgICAgICAgc3RydWN0dXJlZFF1ZXJ5OiBxdWVyeVRhcmdldC5xdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uYW1lZFF1ZXJpZXMuc2V0KHF1ZXJ5QnVuZGxlRGF0YS5uYW1lLCB7XG4gICAgICAgICAgICBuYW1lOiBxdWVyeUJ1bmRsZURhdGEubmFtZSxcbiAgICAgICAgICAgIGJ1bmRsZWRRdWVyeSxcbiAgICAgICAgICAgIHJlYWRUaW1lOiB0b1RpbWVzdGFtcCh0aGlzLnNlcmlhbGl6ZXIsIGxhdGVzdFJlYWRUaW1lKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBkYXRhIGZyb20gYSBEb2N1bWVudFNuYXBzaG90IGludG8gdGhlIHNlcmlhbGl6ZWQgZm9ybSB3aXRoaW4gYSBidW5kbGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gZG9jQnVuZGxlRGF0YSAtIGEgRG9jdW1lbnRTbmFwc2hvdEJ1bmRsZURhdGEgY29udGFpbmluZyB0aGUgZGF0YSByZXF1aXJlZCB0b1xuICAgICAqIHNlcmlhbGl6ZSBhIGRvY3VtZW50LlxuICAgICAqL1xuICAgIHRvQnVuZGxlRG9jdW1lbnQoZG9jQnVuZGxlRGF0YSkge1xuICAgICAgICAvLyBhIHBhcnNlIGNvbnRleHQgaXMgdHlwaWNhbGx5IHVzZWQgZm9yIHZhbGlkYXRpbmcgYW5kIHBhcnNpbmcgdXNlciBkYXRhLCBidXQgaW4gdGhpc1xuICAgICAgICAvLyBjYXNlIHdlIGFyZSB1c2luZyBpdCBpbnRlcm5hbGx5IHRvIGNvbnZlcnQgRG9jdW1lbnREYXRhIHRvIFByb3RvMyBKU09OXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLnVzZXJEYXRhUmVhZGVyLmNyZWF0ZUNvbnRleHQoNCAvKiBVc2VyRGF0YVNvdXJjZS5BcnJheUFyZ3VtZW50ICovLCAnaW50ZXJuYWwgdG9CdW5kbGVkRG9jdW1lbnQnKTtcbiAgICAgICAgY29uc3QgcHJvdG8zRmllbGRzID0gcGFyc2VPYmplY3QoZG9jQnVuZGxlRGF0YS5kb2N1bWVudERhdGEsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdG9OYW1lKHRoaXMuc2VyaWFsaXplciwgZG9jQnVuZGxlRGF0YS5kb2N1bWVudEtleSksXG4gICAgICAgICAgICBmaWVsZHM6IHByb3RvM0ZpZWxkcy5tYXBWYWx1ZS5maWVsZHMsXG4gICAgICAgICAgICB1cGRhdGVUaW1lOiB0b1RpbWVzdGFtcCh0aGlzLnNlcmlhbGl6ZXIsIGRvY0J1bmRsZURhdGEudmVyc2lvblRpbWUpLFxuICAgICAgICAgICAgY3JlYXRlVGltZTogdG9UaW1lc3RhbXAodGhpcy5zZXJpYWxpemVyLCBkb2NCdW5kbGVEYXRhLmNyZWF0ZWRUaW1lKVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIElCdW5kbGVFbGVtZW50IHRvIGEgQnVmZmVyIHdob3NlIGNvbnRlbnQgaXMgdGhlIGxlbmd0aCBwcmVmaXhlZCBKU09OIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gYnVuZGxlRWxlbWVudCAtIEEgUHJvdG9CdW5kbGVFbGVtZW50IHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgUHJvdG8zIEpTT04gY29tcGF0aWJsZS5cbiAgICAgKi9cbiAgICBsZW5ndGhQcmVmaXhlZFN0cmluZyhidW5kbGVFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHN0ciA9IEpTT04uc3RyaW5naWZ5KGJ1bmRsZUVsZW1lbnQpO1xuICAgICAgICAvLyBUT0RPOiBpdCdzIG5vdCBpZGVhbCB0byBoYXZlIHRvIHJlLWVuY29kZSBhbGwgb2YgdGhlc2Ugc3RyaW5ncyBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAvLyAgICAgICBJdCBtYXkgYmUgbW9yZSBwZXJmb3JtYW50IHRvIHJldHVybiBhIFVJbnQ4QXJyYXkgdGhhdCBpcyBjb25jYXRlbmF0ZWQgdG8gb3RoZXJcbiAgICAgICAgLy8gICAgICAgVUludDhBcnJheXMgaW5zdGVhZCBvZiByZXR1cm5pbmcgYW5kIGNvbmNhdGVuYXRpbmcgc3RyaW5ncyBhbmQgdGhlblxuICAgICAgICAvLyAgICAgICBjb252ZXJ0aW5nIHRoZSBmdWxsIHN0cmluZyB0byBVSW50OEFycmF5LlxuICAgICAgICBjb25zdCBsID0gZW5jb2Rlci5lbmNvZGUoc3RyKS5ieXRlTGVuZ3RoO1xuICAgICAgICByZXR1cm4gYCR7bH0ke3N0cn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBzZXJpYWxpemVkIHN0cmluZyBjb250YWluaW5nIGRvY3VtZW50IGFuZCBxdWVyeSBpbmZvcm1hdGlvbiB0aGF0IGhhcyBwcmV2aW91c2x5XG4gICAgICogYmVlbiBhZGRlZCB0byB0aGUgQnVuZGxlQnVpbGRlciB0aHJvdWdoIHRoZSBhZGRCdW5kbGVEb2N1bWVudCBhbmQgYWRkQnVuZGxlUXVlcnkgbWV0aG9kcy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBidWlsZCgpIHtcbiAgICAgICAgbGV0IGJ1bmRsZVN0cmluZyA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWVkUXVlcnkgb2YgdGhpcy5uYW1lZFF1ZXJpZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGJ1bmRsZVN0cmluZyArPSB0aGlzLmxlbmd0aFByZWZpeGVkU3RyaW5nKHsgbmFtZWRRdWVyeSB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGJ1bmRsZWREb2N1bWVudCBvZiB0aGlzLmRvY3VtZW50cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRNZXRhZGF0YSA9IGJ1bmRsZWREb2N1bWVudC5tZXRhZGF0YTtcbiAgICAgICAgICAgIGJ1bmRsZVN0cmluZyArPSB0aGlzLmxlbmd0aFByZWZpeGVkU3RyaW5nKHsgZG9jdW1lbnRNZXRhZGF0YSB9KTtcbiAgICAgICAgICAgIC8vIFdyaXRlIHRvIHRoZSBidW5kbGUgaWYgZG9jdW1lbnQgZXhpc3RzLlxuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBidW5kbGVkRG9jdW1lbnQuZG9jdW1lbnQ7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICBidW5kbGVTdHJpbmcgKz0gdGhpcy5sZW5ndGhQcmVmaXhlZFN0cmluZyh7IGRvY3VtZW50IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuYnVuZGxlSWQsXG4gICAgICAgICAgICBjcmVhdGVUaW1lOiB0b1RpbWVzdGFtcCh0aGlzLnNlcmlhbGl6ZXIsIHRoaXMubGF0ZXN0UmVhZFRpbWUpLFxuICAgICAgICAgICAgdmVyc2lvbjogQlVORExFX1ZFUlNJT04sXG4gICAgICAgICAgICB0b3RhbERvY3VtZW50czogdGhpcy5kb2N1bWVudHMuc2l6ZSxcbiAgICAgICAgICAgIC8vIFRPRE86IGl0J3Mgbm90IGlkZWFsIHRvIGhhdmUgdG8gcmUtZW5jb2RlIGFsbCBvZiB0aGVzZSBzdHJpbmdzIG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgICB0b3RhbEJ5dGVzOiBlbmNvZGVyLmVuY29kZShidW5kbGVTdHJpbmcpLmxlbmd0aFxuICAgICAgICB9O1xuICAgICAgICAvLyBQcmVwZW5kcyB0aGUgbWV0YWRhdGEgZWxlbWVudCB0byB0aGUgYnVuZGxlQnVmZmVyOiBgYnVuZGxlQnVmZmVyYCBpcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBCdWZmZXIuY29uY2F0YC5cbiAgICAgICAgYnVuZGxlU3RyaW5nID0gdGhpcy5sZW5ndGhQcmVmaXhlZFN0cmluZyh7IG1ldGFkYXRhIH0pICsgYnVuZGxlU3RyaW5nO1xuICAgICAgICByZXR1cm4gYnVuZGxlU3RyaW5nO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRG9jdW1lbnRTbmFwc2hvdEpzb25CdW5kbGUoZGIsIGRvY3VtZW50LCBkb2NEYXRhLCBwYXRoKSB7XG4gICAgY29uc3QgYnVpbGRlciA9IG5ldyBCdW5kbGVCdWlsZGVyKGRiLCBBdXRvSWQubmV3SWQoKSk7XG4gICAgYnVpbGRlci5hZGRCdW5kbGVEb2N1bWVudChkb2N1bWVudFRvRG9jdW1lbnRTbmFwc2hvdEJ1bmRsZURhdGEocGF0aCwgZG9jRGF0YSwgZG9jdW1lbnQpKTtcbiAgICByZXR1cm4gYnVpbGRlci5idWlsZCgpO1xufVxuZnVuY3Rpb24gYnVpbGRRdWVyeVNuYXBzaG90SnNvbkJ1bmRsZShkYiwgcXVlcnksIGJ1bmRsZU5hbWUsIHBhcmVudCwgcGF0aHMsIGRvY3MsIGRvY3VtZW50RGF0YSkge1xuICAgIGNvbnN0IGRvY0J1bmRsZURhdGFBcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9jcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkb2NCdW5kbGVEYXRhQXJyYXkucHVzaChkb2N1bWVudFRvRG9jdW1lbnRTbmFwc2hvdEJ1bmRsZURhdGEocGF0aHNbaV0sIGRvY3VtZW50RGF0YVtpXSwgZG9jc1tpXSkpO1xuICAgIH1cbiAgICBjb25zdCBidW5kbGVEYXRhID0ge1xuICAgICAgICBuYW1lOiBidW5kbGVOYW1lLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBkb2NCdW5kbGVEYXRhQXJyYXlcbiAgICB9O1xuICAgIGNvbnN0IGJ1aWxkZXIgPSBuZXcgQnVuZGxlQnVpbGRlcihkYiwgYnVuZGxlTmFtZSk7XG4gICAgYnVpbGRlci5hZGRCdW5kbGVRdWVyeShidW5kbGVEYXRhKTtcbiAgICByZXR1cm4gYnVpbGRlci5idWlsZCgpO1xufVxuLy8gRm9ybWF0cyBEb2N1bWVudCBkYXRhIGZvciBidW5kbGluZyBhIERvY3VtZW50U25hcHNob3QuXG5mdW5jdGlvbiBkb2N1bWVudFRvRG9jdW1lbnRTbmFwc2hvdEJ1bmRsZURhdGEocGF0aCwgZG9jdW1lbnREYXRhLCBkb2N1bWVudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRvY3VtZW50RGF0YSxcbiAgICAgICAgZG9jdW1lbnRLZXk6IGRvY3VtZW50Lm11dGFibGVDb3B5KCkua2V5LFxuICAgICAgICBkb2N1bWVudFBhdGg6IHBhdGgsXG4gICAgICAgIGRvY3VtZW50RXhpc3RzOiB0cnVlLFxuICAgICAgICBjcmVhdGVkVGltZTogZG9jdW1lbnQuY3JlYXRlVGltZS50b1RpbWVzdGFtcCgpLFxuICAgICAgICByZWFkVGltZTogZG9jdW1lbnQucmVhZFRpbWUudG9UaW1lc3RhbXAoKSxcbiAgICAgICAgdmVyc2lvblRpbWU6IGRvY3VtZW50LnZlcnNpb24udG9UaW1lc3RhbXAoKVxuICAgIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBOT1RfU1VQUE9SVEVEID0gJ05PVCBTVVBQT1JURUQnO1xuLyoqXG4gKiBNZXRhZGF0YSBhYm91dCBhIHNuYXBzaG90LCBkZXNjcmliaW5nIHRoZSBzdGF0ZSBvZiB0aGUgc25hcHNob3QuXG4gKi9cbmNsYXNzIFNuYXBzaG90TWV0YWRhdGEge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoaGFzUGVuZGluZ1dyaXRlcywgZnJvbUNhY2hlKSB7XG4gICAgICAgIHRoaXMuaGFzUGVuZGluZ1dyaXRlcyA9IGhhc1BlbmRpbmdXcml0ZXM7XG4gICAgICAgIHRoaXMuZnJvbUNhY2hlID0gZnJvbUNhY2hlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgU25hcHNob3RNZXRhZGF0YWAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBgU25hcHNob3RNZXRhZGF0YWAgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBgU25hcHNob3RNZXRhZGF0YWAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKi9cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5oYXNQZW5kaW5nV3JpdGVzID09PSBvdGhlci5oYXNQZW5kaW5nV3JpdGVzICYmXG4gICAgICAgICAgICB0aGlzLmZyb21DYWNoZSA9PT0gb3RoZXIuZnJvbUNhY2hlKTtcbiAgICB9XG59XG4vKipcbiAqIEEgYERvY3VtZW50U25hcHNob3RgIGNvbnRhaW5zIGRhdGEgcmVhZCBmcm9tIGEgZG9jdW1lbnQgaW4geW91ciBGaXJlc3RvcmVcbiAqIGRhdGFiYXNlLiBUaGUgZGF0YSBjYW4gYmUgZXh0cmFjdGVkIHdpdGggYC5kYXRhKClgIG9yIGAuZ2V0KDxmaWVsZD4pYCB0b1xuICogZ2V0IGEgc3BlY2lmaWMgZmllbGQuXG4gKlxuICogRm9yIGEgYERvY3VtZW50U25hcHNob3RgIHRoYXQgcG9pbnRzIHRvIGEgbm9uLWV4aXN0aW5nIGRvY3VtZW50LCBhbnkgZGF0YVxuICogYWNjZXNzIHdpbGwgcmV0dXJuICd1bmRlZmluZWQnLiBZb3UgY2FuIHVzZSB0aGUgYGV4aXN0cygpYCBtZXRob2QgdG9cbiAqIGV4cGxpY2l0bHkgdmVyaWZ5IGEgZG9jdW1lbnQncyBleGlzdGVuY2UuXG4gKi9cbmNsYXNzIERvY3VtZW50U25hcHNob3QgZXh0ZW5kcyBEb2N1bWVudFNuYXBzaG90JDEge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yIHByb3RlY3RlZCAqL1xuICAgIGNvbnN0cnVjdG9yKF9maXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCBrZXksIGRvY3VtZW50LCBtZXRhZGF0YSwgY29udmVydGVyKSB7XG4gICAgICAgIHN1cGVyKF9maXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCBrZXksIGRvY3VtZW50LCBjb252ZXJ0ZXIpO1xuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xuICAgICAgICB0aGlzLl9maXJlc3RvcmVJbXBsID0gX2ZpcmVzdG9yZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBkYXRhIGV4aXN0cy4gVHJ1ZSBpZiB0aGUgZG9jdW1lbnQgZXhpc3RzLlxuICAgICAqL1xuICAgIGV4aXN0cygpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmV4aXN0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgYXMgYW4gYE9iamVjdGAuIFJldHVybnMgYHVuZGVmaW5lZGAgaWZcbiAgICAgKiB0aGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdC5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIGBzZXJ2ZXJUaW1lc3RhbXAoKWAgdmFsdWVzIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW5cbiAgICAgKiBzZXQgdG8gdGhlaXIgZmluYWwgdmFsdWUgd2lsbCBiZSByZXR1cm5lZCBhcyBgbnVsbGAuIFlvdSBjYW4gb3ZlcnJpZGVcbiAgICAgKiB0aGlzIGJ5IHBhc3NpbmcgYW4gb3B0aW9ucyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRvIGNvbmZpZ3VyZSBob3cgZGF0YSBpcyByZXRyaWV2ZWQgZnJvbVxuICAgICAqIHRoZSBzbmFwc2hvdCAoZm9yIGV4YW1wbGUgdGhlIGRlc2lyZWQgYmVoYXZpb3IgZm9yIHNlcnZlciB0aW1lc3RhbXBzIHRoYXRcbiAgICAgKiBoYXZlIG5vdCB5ZXQgYmVlbiBzZXQgdG8gdGhlaXIgZmluYWwgdmFsdWUpLlxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgb3IgYHVuZGVmaW5lZGAgaWZcbiAgICAgKiB0aGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdC5cbiAgICAgKi9cbiAgICBkYXRhKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoIXRoaXMuX2RvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2NvbnZlcnRlcikge1xuICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHVzZSB0aGUgY29udmVydGVyIGFuZCBjcmVhdGUgYSBuZXcgRG9jdW1lbnRTbmFwc2hvdFxuICAgICAgICAgICAgLy8gaWYgYSBjb252ZXJ0ZXIgaGFzIGJlZW4gcHJvdmlkZWQuXG4gICAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IG5ldyBRdWVyeURvY3VtZW50U25hcHNob3QodGhpcy5fZmlyZXN0b3JlLCB0aGlzLl91c2VyRGF0YVdyaXRlciwgdGhpcy5fa2V5LCB0aGlzLl9kb2N1bWVudCwgdGhpcy5tZXRhZGF0YSwgXG4gICAgICAgICAgICAvKiBjb252ZXJ0ZXI9ICovIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRlci5mcm9tRmlyZXN0b3JlKHNuYXBzaG90LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91c2VyRGF0YVdyaXRlci5jb252ZXJ0VmFsdWUodGhpcy5fZG9jdW1lbnQuZGF0YS52YWx1ZSwgb3B0aW9ucy5zZXJ2ZXJUaW1lc3RhbXBzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGZpZWxkIHNwZWNpZmllZCBieSBgZmllbGRQYXRoYC4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGVcbiAgICAgKiBkb2N1bWVudCBvciBmaWVsZCBkb2Vzbid0IGV4aXN0LlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgYSBgc2VydmVyVGltZXN0YW1wKClgIHRoYXQgaGFzIG5vdCB5ZXQgYmVlbiBzZXQgdG9cbiAgICAgKiBpdHMgZmluYWwgdmFsdWUgd2lsbCBiZSByZXR1cm5lZCBhcyBgbnVsbGAuIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBieVxuICAgICAqIHBhc3NpbmcgYW4gb3B0aW9ucyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGRQYXRoIC0gVGhlIHBhdGggKGZvciBleGFtcGxlICdmb28nIG9yICdmb28uYmFyJykgdG8gYSBzcGVjaWZpY1xuICAgICAqIGZpZWxkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9ucyBvYmplY3QgdG8gY29uZmlndXJlIGhvdyB0aGUgZmllbGQgaXMgcmV0cmlldmVkXG4gICAgICogZnJvbSB0aGUgc25hcHNob3QgKGZvciBleGFtcGxlIHRoZSBkZXNpcmVkIGJlaGF2aW9yIGZvciBzZXJ2ZXIgdGltZXN0YW1wc1xuICAgICAqIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW4gc2V0IHRvIHRoZWlyIGZpbmFsIHZhbHVlKS5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGF0YSBhdCB0aGUgc3BlY2lmaWVkIGZpZWxkIGxvY2F0aW9uIG9yIHVuZGVmaW5lZCBpZiBubyBzdWNoXG4gICAgICogZmllbGQgZXhpc3RzIGluIHRoZSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICAvLyBXZSBhcmUgdXNpbmcgYGFueWAgaGVyZSB0byBhdm9pZCBhbiBleHBsaWNpdCBjYXN0IGJ5IG91ciB1c2Vycy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGdldChmaWVsZFBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAodGhpcy5fZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZG9jdW1lbnQuZGF0YS5maWVsZChmaWVsZFBhdGhGcm9tQXJndW1lbnQoJ0RvY3VtZW50U25hcHNob3QuZ2V0JywgZmllbGRQYXRoKSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlckRhdGFXcml0ZXIuY29udmVydFZhbHVlKHZhbHVlLCBvcHRpb25zLnNlcnZlclRpbWVzdGFtcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGBEb2N1bWVudFNuYXBzaG90YCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC4gIFRocm93cyBhIHtAbGluayBGaXJlc3RvcmVFcnJvcn0gaWYgdGhpc1xuICAgICAqIGBEb2N1bWVudFNuYXBzaG90YCBoYXMgcGVuZGluZyB3cml0ZXMuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YS5oYXNQZW5kaW5nV3JpdGVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnRG9jdW1lbnRTbmFwc2hvdC50b0pTT04oKSBhdHRlbXB0ZWQgdG8gc2VyaWFsaXplIGEgZG9jdW1lbnQgd2l0aCBwZW5kaW5nIHdyaXRlcy4gJyArXG4gICAgICAgICAgICAgICAgJ0F3YWl0IHdhaXRGb3JQZW5kaW5nV3JpdGVzKCkgYmVmb3JlIGludm9raW5nIHRvSlNPTigpLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5fZG9jdW1lbnQ7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICByZXN1bHRbJ3R5cGUnXSA9IERvY3VtZW50U25hcHNob3QuX2pzb25TY2hlbWFWZXJzaW9uO1xuICAgICAgICByZXN1bHRbJ2J1bmRsZSddID0gJyc7XG4gICAgICAgIHJlc3VsdFsnYnVuZGxlU291cmNlJ10gPSAnRG9jdW1lbnRTbmFwc2hvdCc7XG4gICAgICAgIHJlc3VsdFsnYnVuZGxlTmFtZSddID0gdGhpcy5fa2V5LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICghZG9jdW1lbnQgfHxcbiAgICAgICAgICAgICFkb2N1bWVudC5pc1ZhbGlkRG9jdW1lbnQoKSB8fFxuICAgICAgICAgICAgIWRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvY3VtZW50RGF0YSA9IHRoaXMuX3VzZXJEYXRhV3JpdGVyLmNvbnZlcnRPYmplY3RNYXAoZG9jdW1lbnQuZGF0YS52YWx1ZS5tYXBWYWx1ZS5maWVsZHMsICdwcmV2aW91cycpO1xuICAgICAgICByZXN1bHRbJ2J1bmRsZSddID0gYnVpbGREb2N1bWVudFNuYXBzaG90SnNvbkJ1bmRsZSh0aGlzLl9maXJlc3RvcmUsIGRvY3VtZW50LCBkb2N1bWVudERhdGEsIHRoaXMucmVmLnBhdGgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbkRvY3VtZW50U25hcHNob3QuX2pzb25TY2hlbWFWZXJzaW9uID0gJ2ZpcmVzdG9yZS9kb2N1bWVudFNuYXBzaG90LzEuMCc7XG5Eb2N1bWVudFNuYXBzaG90Ll9qc29uU2NoZW1hID0ge1xuICAgIHR5cGU6IHByb3BlcnR5KCdzdHJpbmcnLCBEb2N1bWVudFNuYXBzaG90Ll9qc29uU2NoZW1hVmVyc2lvbiksXG4gICAgYnVuZGxlU291cmNlOiBwcm9wZXJ0eSgnc3RyaW5nJywgJ0RvY3VtZW50U25hcHNob3QnKSxcbiAgICBidW5kbGVOYW1lOiBwcm9wZXJ0eSgnc3RyaW5nJyksXG4gICAgYnVuZGxlOiBwcm9wZXJ0eSgnc3RyaW5nJylcbn07XG5mdW5jdGlvbiBkb2N1bWVudFNuYXBzaG90RnJvbUpTT04oZGIsIGpzb24sIGNvbnZlcnRlcikge1xuICAgIGlmICh2YWxpZGF0ZUpTT04oanNvbiwgRG9jdW1lbnRTbmFwc2hvdC5fanNvblNjaGVtYSkpIHtcbiAgICAgICAgaWYgKGpzb24uYnVuZGxlID09PSBOT1RfU1VQUE9SVEVEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVGhlIHByb3ZpZGVkIEpTT04gb2JqZWN0IHdhcyBjcmVhdGVkIGluIGEgY2xpZW50IGVudmlyb25tZW50LCB3aGljaCBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlIHRoZSBidW5kbGUgZGF0YS5cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplciA9IG5ld1NlcmlhbGl6ZXIoZGIuX2RhdGFiYXNlSWQpO1xuICAgICAgICBjb25zdCBidW5kbGVSZWFkZXIgPSBjcmVhdGVCdW5kbGVSZWFkZXJTeW5jKGpzb24uYnVuZGxlLCBzZXJpYWxpemVyKTtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBidW5kbGVSZWFkZXIuZ2V0RWxlbWVudHMoKTtcbiAgICAgICAgY29uc3QgYnVuZGxlTG9hZGVyID0gbmV3IEJ1bmRsZUxvYWRlcihidW5kbGVSZWFkZXIuZ2V0TWV0YWRhdGEoKSwgc2VyaWFsaXplcik7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgYnVuZGxlTG9hZGVyLmFkZFNpemVkRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIHRoZSBjb3JyZWN0IG51bWJlciBvZiBkb2N1bWVudHMgaW4gdGhlIGJ1bmRsZS5cbiAgICAgICAgY29uc3QgYnVuZGxlZERvY3VtZW50cyA9IGJ1bmRsZUxvYWRlci5kb2N1bWVudHM7XG4gICAgICAgIGlmIChidW5kbGVkRG9jdW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEV4cGVjdGVkIGJ1bmRsZSBkYXRhIHRvIGNvbnRhaW4gMSBkb2N1bWVudCwgYnV0IGl0IGNvbnRhaW5zICR7YnVuZGxlZERvY3VtZW50cy5sZW5ndGh9IGRvY3VtZW50cy5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCBvdXQgdGhlIGludGVybmFsIGRvY3VtZW50IGRhdGEuXG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZnJvbURvY3VtZW50KHNlcmlhbGl6ZXIsIGJ1bmRsZWREb2N1bWVudHNbMF0uZG9jdW1lbnQpO1xuICAgICAgICBjb25zdCBkb2N1bWVudEtleSA9IG5ldyBEb2N1bWVudEtleShSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhqc29uLmJ1bmRsZU5hbWUpKTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBleHRlcm5hbCBmYWNpbmcgRG9jdW1lbnRTbmFwc2hvdC5cbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFNuYXBzaG90KGRiLCBuZXcgTGl0ZVVzZXJEYXRhV3JpdGVyKGRiKSwgZG9jdW1lbnRLZXksIGRvY3VtZW50LCBuZXcgU25hcHNob3RNZXRhZGF0YShcbiAgICAgICAgLyogaGFzUGVuZGluZ1dyaXRlcz0gKi8gZmFsc2UsIFxuICAgICAgICAvKiBmcm9tQ2FjaGU9ICovIGZhbHNlKSwgY29udmVydGVyID8gY29udmVydGVyIDogbnVsbCk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGBRdWVyeURvY3VtZW50U25hcHNob3RgIGNvbnRhaW5zIGRhdGEgcmVhZCBmcm9tIGEgZG9jdW1lbnQgaW4geW91clxuICogRmlyZXN0b3JlIGRhdGFiYXNlIGFzIHBhcnQgb2YgYSBxdWVyeS4gVGhlIGRvY3VtZW50IGlzIGd1YXJhbnRlZWQgdG8gZXhpc3RcbiAqIGFuZCBpdHMgZGF0YSBjYW4gYmUgZXh0cmFjdGVkIHdpdGggYC5kYXRhKClgIG9yIGAuZ2V0KDxmaWVsZD4pYCB0byBnZXQgYVxuICogc3BlY2lmaWMgZmllbGQuXG4gKlxuICogQSBgUXVlcnlEb2N1bWVudFNuYXBzaG90YCBvZmZlcnMgdGhlIHNhbWUgQVBJIHN1cmZhY2UgYXMgYVxuICogYERvY3VtZW50U25hcHNob3RgLiBTaW5jZSBxdWVyeSByZXN1bHRzIGNvbnRhaW4gb25seSBleGlzdGluZyBkb2N1bWVudHMsIHRoZVxuICogYGV4aXN0c2AgcHJvcGVydHkgd2lsbCBhbHdheXMgYmUgdHJ1ZSBhbmQgYGRhdGEoKWAgd2lsbCBuZXZlciByZXR1cm5cbiAqICd1bmRlZmluZWQnLlxuICovXG5jbGFzcyBRdWVyeURvY3VtZW50U25hcHNob3QgZXh0ZW5kcyBEb2N1bWVudFNuYXBzaG90IHtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgYXMgYW4gYE9iamVjdGAuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBgc2VydmVyVGltZXN0YW1wKClgIHZhbHVlcyB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gICAgICogc2V0IHRvIHRoZWlyIGZpbmFsIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgYXMgYG51bGxgLiBZb3UgY2FuIG92ZXJyaWRlXG4gICAgICogdGhpcyBieSBwYXNzaW5nIGFuIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdCB0byBjb25maWd1cmUgaG93IGRhdGEgaXMgcmV0cmlldmVkIGZyb21cbiAgICAgKiB0aGUgc25hcHNob3QgKGZvciBleGFtcGxlIHRoZSBkZXNpcmVkIGJlaGF2aW9yIGZvciBzZXJ2ZXIgdGltZXN0YW1wcyB0aGF0XG4gICAgICogaGF2ZSBub3QgeWV0IGJlZW4gc2V0IHRvIHRoZWlyIGZpbmFsIHZhbHVlKS5cbiAgICAgKiBAcmV0dXJucyBBbiBgT2JqZWN0YCBjb250YWluaW5nIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGRhdGEob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBzdXBlci5kYXRhKG9wdGlvbnMpO1xuICAgIH1cbn1cbi8qKlxuICogQSBgUXVlcnlTbmFwc2hvdGAgY29udGFpbnMgemVybyBvciBtb3JlIGBEb2N1bWVudFNuYXBzaG90YCBvYmplY3RzXG4gKiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdHMgb2YgYSBxdWVyeS4gVGhlIGRvY3VtZW50cyBjYW4gYmUgYWNjZXNzZWQgYXMgYW5cbiAqIGFycmF5IHZpYSB0aGUgYGRvY3NgIHByb3BlcnR5IG9yIGVudW1lcmF0ZWQgdXNpbmcgdGhlIGBmb3JFYWNoYCBtZXRob2QuIFRoZVxuICogbnVtYmVyIG9mIGRvY3VtZW50cyBjYW4gYmUgZGV0ZXJtaW5lZCB2aWEgdGhlIGBlbXB0eWAgYW5kIGBzaXplYFxuICogcHJvcGVydGllcy5cbiAqL1xuY2xhc3MgUXVlcnlTbmFwc2hvdCB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlLCBfdXNlckRhdGFXcml0ZXIsIHF1ZXJ5LCBfc25hcHNob3QpIHtcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlID0gX2ZpcmVzdG9yZTtcbiAgICAgICAgdGhpcy5fdXNlckRhdGFXcml0ZXIgPSBfdXNlckRhdGFXcml0ZXI7XG4gICAgICAgIHRoaXMuX3NuYXBzaG90ID0gX3NuYXBzaG90O1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbmV3IFNuYXBzaG90TWV0YWRhdGEoX3NuYXBzaG90Lmhhc1BlbmRpbmdXcml0ZXMsIF9zbmFwc2hvdC5mcm9tQ2FjaGUpO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgfVxuICAgIC8qKiBBbiBhcnJheSBvZiBhbGwgdGhlIGRvY3VtZW50cyBpbiB0aGUgYFF1ZXJ5U25hcHNob3RgLiAqL1xuICAgIGdldCBkb2NzKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGRvYyA9PiByZXN1bHQucHVzaChkb2MpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqIFRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIGluIHRoZSBgUXVlcnlTbmFwc2hvdGAuICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zbmFwc2hvdC5kb2NzLnNpemU7XG4gICAgfVxuICAgIC8qKiBUcnVlIGlmIHRoZXJlIGFyZSBubyBkb2N1bWVudHMgaW4gdGhlIGBRdWVyeVNuYXBzaG90YC4gKi9cbiAgICBnZXQgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVudW1lcmF0ZXMgYWxsIG9mIHRoZSBkb2N1bWVudHMgaW4gdGhlIGBRdWVyeVNuYXBzaG90YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdpdGggYSBgUXVlcnlEb2N1bWVudFNuYXBzaG90YCBmb3JcbiAgICAgKiBlYWNoIGRvY3VtZW50IGluIHRoZSBzbmFwc2hvdC5cbiAgICAgKiBAcGFyYW0gdGhpc0FyZyAtIFRoZSBgdGhpc2AgYmluZGluZyBmb3IgdGhlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgdGhpcy5fc25hcHNob3QuZG9jcy5mb3JFYWNoKGRvYyA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIG5ldyBRdWVyeURvY3VtZW50U25hcHNob3QodGhpcy5fZmlyZXN0b3JlLCB0aGlzLl91c2VyRGF0YVdyaXRlciwgZG9jLmtleSwgZG9jLCBuZXcgU25hcHNob3RNZXRhZGF0YSh0aGlzLl9zbmFwc2hvdC5tdXRhdGVkS2V5cy5oYXMoZG9jLmtleSksIHRoaXMuX3NuYXBzaG90LmZyb21DYWNoZSksIHRoaXMucXVlcnkuY29udmVydGVyKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBkb2N1bWVudHMgY2hhbmdlcyBzaW5jZSB0aGUgbGFzdCBzbmFwc2hvdC4gSWYgdGhpc1xuICAgICAqIGlzIHRoZSBmaXJzdCBzbmFwc2hvdCwgYWxsIGRvY3VtZW50cyB3aWxsIGJlIGluIHRoZSBsaXN0IGFzICdhZGRlZCdcbiAgICAgKiBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBgU25hcHNob3RMaXN0ZW5PcHRpb25zYCB0aGF0IGNvbnRyb2wgd2hldGhlciBtZXRhZGF0YS1vbmx5XG4gICAgICogY2hhbmdlcyAoaS5lLiBvbmx5IGBEb2N1bWVudFNuYXBzaG90Lm1ldGFkYXRhYCBjaGFuZ2VkKSBzaG91bGQgdHJpZ2dlclxuICAgICAqIHNuYXBzaG90IGV2ZW50cy5cbiAgICAgKi9cbiAgICBkb2NDaGFuZ2VzKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzID0gISFvcHRpb25zLmluY2x1ZGVNZXRhZGF0YUNoYW5nZXM7XG4gICAgICAgIGlmIChpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzICYmIHRoaXMuX3NuYXBzaG90LmV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVG8gaW5jbHVkZSBtZXRhZGF0YSBjaGFuZ2VzIHdpdGggeW91ciBkb2N1bWVudCBjaGFuZ2VzLCB5b3UgbXVzdCAnICtcbiAgICAgICAgICAgICAgICAnYWxzbyBwYXNzIHsgaW5jbHVkZU1ldGFkYXRhQ2hhbmdlczp0cnVlIH0gdG8gb25TbmFwc2hvdCgpLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVkQ2hhbmdlcyB8fFxuICAgICAgICAgICAgdGhpcy5fY2FjaGVkQ2hhbmdlc0luY2x1ZGVNZXRhZGF0YUNoYW5nZXMgIT09IGluY2x1ZGVNZXRhZGF0YUNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZENoYW5nZXMgPSBjaGFuZ2VzRnJvbVNuYXBzaG90KHRoaXMsIGluY2x1ZGVNZXRhZGF0YUNoYW5nZXMpO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkQ2hhbmdlc0luY2x1ZGVNZXRhZGF0YUNoYW5nZXMgPSBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRDaGFuZ2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBgUXVlcnlTbmFwc2hvdGAgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuIFRocm93cyBhIHtAbGluayBGaXJlc3RvcmVFcnJvcn0gaWYgdGhpc1xuICAgICAqIGBRdWVyeVNuYXBzaG90YCBoYXMgcGVuZGluZyB3cml0ZXMuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YS5oYXNQZW5kaW5nV3JpdGVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnUXVlcnlTbmFwc2hvdC50b0pTT04oKSBhdHRlbXB0ZWQgdG8gc2VyaWFsaXplIGEgZG9jdW1lbnQgd2l0aCBwZW5kaW5nIHdyaXRlcy4gJyArXG4gICAgICAgICAgICAgICAgJ0F3YWl0IHdhaXRGb3JQZW5kaW5nV3JpdGVzKCkgYmVmb3JlIGludm9raW5nIHRvSlNPTigpLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICByZXN1bHRbJ3R5cGUnXSA9IFF1ZXJ5U25hcHNob3QuX2pzb25TY2hlbWFWZXJzaW9uO1xuICAgICAgICByZXN1bHRbJ2J1bmRsZVNvdXJjZSddID0gJ1F1ZXJ5U25hcHNob3QnO1xuICAgICAgICByZXN1bHRbJ2J1bmRsZU5hbWUnXSA9IEF1dG9JZC5uZXdJZCgpO1xuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gdGhpcy5fZmlyZXN0b3JlLl9kYXRhYmFzZUlkLmRhdGFiYXNlO1xuICAgICAgICBjb25zdCBwcm9qZWN0SWQgPSB0aGlzLl9maXJlc3RvcmUuX2RhdGFiYXNlSWQucHJvamVjdElkO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBgcHJvamVjdHMvJHtwcm9qZWN0SWR9L2RhdGFiYXNlcy8ke2RhdGFiYXNlSWR9L2RvY3VtZW50c2A7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50cyA9IFtdO1xuICAgICAgICBjb25zdCBkb2N1bWVudERhdGEgPSBbXTtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICAgICAgdGhpcy5kb2NzLmZvckVhY2goZG9jID0+IHtcbiAgICAgICAgICAgIGlmIChkb2MuX2RvY3VtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9jdW1lbnRzLnB1c2goZG9jLl9kb2N1bWVudCk7XG4gICAgICAgICAgICBkb2N1bWVudERhdGEucHVzaCh0aGlzLl91c2VyRGF0YVdyaXRlci5jb252ZXJ0T2JqZWN0TWFwKGRvYy5fZG9jdW1lbnQuZGF0YS52YWx1ZS5tYXBWYWx1ZS5maWVsZHMsICdwcmV2aW91cycpKTtcbiAgICAgICAgICAgIHBhdGhzLnB1c2goZG9jLnJlZi5wYXRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdFsnYnVuZGxlJ10gPSBidWlsZFF1ZXJ5U25hcHNob3RKc29uQnVuZGxlKHRoaXMuX2ZpcmVzdG9yZSwgdGhpcy5xdWVyeS5fcXVlcnksIHJlc3VsdFsnYnVuZGxlTmFtZSddLCBwYXJlbnQsIHBhdGhzLCBkb2N1bWVudHMsIGRvY3VtZW50RGF0YSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuUXVlcnlTbmFwc2hvdC5fanNvblNjaGVtYVZlcnNpb24gPSAnZmlyZXN0b3JlL3F1ZXJ5U25hcHNob3QvMS4wJztcblF1ZXJ5U25hcHNob3QuX2pzb25TY2hlbWEgPSB7XG4gICAgdHlwZTogcHJvcGVydHkoJ3N0cmluZycsIFF1ZXJ5U25hcHNob3QuX2pzb25TY2hlbWFWZXJzaW9uKSxcbiAgICBidW5kbGVTb3VyY2U6IHByb3BlcnR5KCdzdHJpbmcnLCAnUXVlcnlTbmFwc2hvdCcpLFxuICAgIGJ1bmRsZU5hbWU6IHByb3BlcnR5KCdzdHJpbmcnKSxcbiAgICBidW5kbGU6IHByb3BlcnR5KCdzdHJpbmcnKVxufTtcbmZ1bmN0aW9uIHF1ZXJ5U25hcHNob3RGcm9tSlNPTihkYiwganNvbiwgY29udmVydGVyKSB7XG4gICAgaWYgKHZhbGlkYXRlSlNPTihqc29uLCBRdWVyeVNuYXBzaG90Ll9qc29uU2NoZW1hKSkge1xuICAgICAgICBpZiAoanNvbi5idW5kbGUgPT09IE5PVF9TVVBQT1JURUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdUaGUgcHJvdmlkZWQgSlNPTiBvYmplY3Qgd2FzIGNyZWF0ZWQgaW4gYSBjbGllbnQgZW52aXJvbm1lbnQsIHdoaWNoIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2UgdGhlIGJ1bmRsZSBkYXRhLlxuICAgICAgICBjb25zdCBzZXJpYWxpemVyID0gbmV3U2VyaWFsaXplcihkYi5fZGF0YWJhc2VJZCk7XG4gICAgICAgIGNvbnN0IGJ1bmRsZVJlYWRlciA9IGNyZWF0ZUJ1bmRsZVJlYWRlclN5bmMoanNvbi5idW5kbGUsIHNlcmlhbGl6ZXIpO1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGJ1bmRsZVJlYWRlci5nZXRFbGVtZW50cygpO1xuICAgICAgICBjb25zdCBidW5kbGVMb2FkZXIgPSBuZXcgQnVuZGxlTG9hZGVyKGJ1bmRsZVJlYWRlci5nZXRNZXRhZGF0YSgpLCBzZXJpYWxpemVyKTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBidW5kbGVMb2FkZXIuYWRkU2l6ZWRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidW5kbGVMb2FkZXIucXVlcmllcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBTbmFwc2hvdCBkYXRhIGV4cGVjdGVkIDEgcXVlcnkgYnV0IGZvdW5kICR7YnVuZGxlTG9hZGVyLnF1ZXJpZXMubGVuZ3RofSBxdWVyaWVzLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhbiBpbnRlcm5hbCBRdWVyeSBvYmplY3QgZnJvbSB0aGUgbmFtZWQgcXVlcnkgaW4gdGhlIGJ1bmRsZS5cbiAgICAgICAgY29uc3QgcXVlcnkgPSBmcm9tQnVuZGxlZFF1ZXJ5KGJ1bmRsZUxvYWRlci5xdWVyaWVzWzBdLmJ1bmRsZWRRdWVyeSk7XG4gICAgICAgIC8vIENvbnN0cnVjdCB0aGUgYXJyYXlzIG9mIGRvY3VtZW50IGRhdGEgZm9yIHRoZSBxdWVyeS5cbiAgICAgICAgY29uc3QgYnVuZGxlZERvY3VtZW50cyA9IGJ1bmRsZUxvYWRlci5kb2N1bWVudHM7XG4gICAgICAgIGxldCBkb2N1bWVudFNldCA9IG5ldyBEb2N1bWVudFNldCgpO1xuICAgICAgICBidW5kbGVkRG9jdW1lbnRzLm1hcChidW5kbGVkRG9jdW1lbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBmcm9tRG9jdW1lbnQoc2VyaWFsaXplciwgYnVuZGxlZERvY3VtZW50LmRvY3VtZW50KTtcbiAgICAgICAgICAgIGRvY3VtZW50U2V0ID0gZG9jdW1lbnRTZXQuYWRkKGRvY3VtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENyZWF0ZSBhIHZpZXcgc25hcHNob3Qgb2YgdGhlIHF1ZXJ5IGFuZCBkb2N1bWVudHMuXG4gICAgICAgIGNvbnN0IHZpZXdTbmFwc2hvdCA9IFZpZXdTbmFwc2hvdC5mcm9tSW5pdGlhbERvY3VtZW50cyhxdWVyeSwgZG9jdW1lbnRTZXQsIGRvY3VtZW50S2V5U2V0KCkgLyogWmVybyBtdXRhdGVkIGtleXMgc2lnbmlmaWVzIG5vIHBlbmRpbmcgd3JpdGVzLiAqLywgXG4gICAgICAgIC8qIGZyb21DYWNoZT0gKi8gZmFsc2UsIFxuICAgICAgICAvKiBoYXNDYWNoZWRSZXN1bHRzPSAqLyBmYWxzZSk7XG4gICAgICAgIC8vIENyZWF0ZSBhbiBleHRlcm5hbCBRdWVyeSBvYmplY3QsIHJlcXVpcmVkIHRvIGNvbnN0cnVjdCB0aGUgUXVlcnlTbmFwc2hvdC5cbiAgICAgICAgY29uc3QgZXh0ZXJuYWxRdWVyeSA9IG5ldyBRdWVyeShkYiwgY29udmVydGVyID8gY29udmVydGVyIDogbnVsbCwgcXVlcnkpO1xuICAgICAgICAvLyBSZXR1cm4gYSBuZXcgUXVlcnlTbmFwc2hvdCB3aXRoIGFsbCBvZiB0aGUgY29sbGVjdGVkIGRhdGEuXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlTbmFwc2hvdChkYiwgbmV3IExpdGVVc2VyRGF0YVdyaXRlcihkYiksIGV4dGVybmFsUXVlcnksIHZpZXdTbmFwc2hvdCk7XG4gICAgfVxufVxuLyoqIENhbGN1bGF0ZXMgdGhlIGFycmF5IG9mIGBEb2N1bWVudENoYW5nZWBzIGZvciBhIGdpdmVuIGBWaWV3U25hcHNob3RgLiAqL1xuZnVuY3Rpb24gY2hhbmdlc0Zyb21TbmFwc2hvdChxdWVyeVNuYXBzaG90LCBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzKSB7XG4gICAgaWYgKHF1ZXJ5U25hcHNob3QuX3NuYXBzaG90Lm9sZERvY3MuaXNFbXB0eSgpKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHJldHVybiBxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5kb2NDaGFuZ2VzLm1hcChjaGFuZ2UgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9jID0gbmV3IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdChxdWVyeVNuYXBzaG90Ll9maXJlc3RvcmUsIHF1ZXJ5U25hcHNob3QuX3VzZXJEYXRhV3JpdGVyLCBjaGFuZ2UuZG9jLmtleSwgY2hhbmdlLmRvYywgbmV3IFNuYXBzaG90TWV0YWRhdGEocXVlcnlTbmFwc2hvdC5fc25hcHNob3QubXV0YXRlZEtleXMuaGFzKGNoYW5nZS5kb2Mua2V5KSwgcXVlcnlTbmFwc2hvdC5fc25hcHNob3QuZnJvbUNhY2hlKSwgcXVlcnlTbmFwc2hvdC5xdWVyeS5jb252ZXJ0ZXIpO1xuICAgICAgICAgICAgY2hhbmdlLmRvYztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZGVkJyxcbiAgICAgICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICAgICAgb2xkSW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgIG5ld0luZGV4OiBpbmRleCsrXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEEgYERvY3VtZW50U2V0YCB0aGF0IGlzIHVwZGF0ZWQgaW5jcmVtZW50YWxseSBhcyBjaGFuZ2VzIGFyZSBhcHBsaWVkIHRvIHVzZVxuICAgICAgICAvLyB0byBsb29rdXAgdGhlIGluZGV4IG9mIGEgZG9jdW1lbnQuXG4gICAgICAgIGxldCBpbmRleFRyYWNrZXIgPSBxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5vbGREb2NzO1xuICAgICAgICByZXR1cm4gcXVlcnlTbmFwc2hvdC5fc25hcHNob3QuZG9jQ2hhbmdlc1xuICAgICAgICAgICAgLmZpbHRlcihjaGFuZ2UgPT4gaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyB8fCBjaGFuZ2UudHlwZSAhPT0gMyAvKiBDaGFuZ2VUeXBlLk1ldGFkYXRhICovKVxuICAgICAgICAgICAgLm1hcChjaGFuZ2UgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9jID0gbmV3IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdChxdWVyeVNuYXBzaG90Ll9maXJlc3RvcmUsIHF1ZXJ5U25hcHNob3QuX3VzZXJEYXRhV3JpdGVyLCBjaGFuZ2UuZG9jLmtleSwgY2hhbmdlLmRvYywgbmV3IFNuYXBzaG90TWV0YWRhdGEocXVlcnlTbmFwc2hvdC5fc25hcHNob3QubXV0YXRlZEtleXMuaGFzKGNoYW5nZS5kb2Mua2V5KSwgcXVlcnlTbmFwc2hvdC5fc25hcHNob3QuZnJvbUNhY2hlKSwgcXVlcnlTbmFwc2hvdC5xdWVyeS5jb252ZXJ0ZXIpO1xuICAgICAgICAgICAgbGV0IG9sZEluZGV4ID0gLTE7XG4gICAgICAgICAgICBsZXQgbmV3SW5kZXggPSAtMTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2UudHlwZSAhPT0gMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovKSB7XG4gICAgICAgICAgICAgICAgb2xkSW5kZXggPSBpbmRleFRyYWNrZXIuaW5kZXhPZihjaGFuZ2UuZG9jLmtleSk7XG4gICAgICAgICAgICAgICAgaW5kZXhUcmFja2VyID0gaW5kZXhUcmFja2VyLmRlbGV0ZShjaGFuZ2UuZG9jLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlLnR5cGUgIT09IDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhUcmFja2VyID0gaW5kZXhUcmFja2VyLmFkZChjaGFuZ2UuZG9jKTtcbiAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGluZGV4VHJhY2tlci5pbmRleE9mKGNoYW5nZS5kb2Mua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogcmVzdWx0Q2hhbmdlVHlwZShjaGFuZ2UudHlwZSksXG4gICAgICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAgICAgIG9sZEluZGV4LFxuICAgICAgICAgICAgICAgIG5ld0luZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXN1bHRDaGFuZ2VUeXBlKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi86XG4gICAgICAgICAgICByZXR1cm4gJ2FkZGVkJztcbiAgICAgICAgY2FzZSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi86XG4gICAgICAgIGNhc2UgMyAvKiBDaGFuZ2VUeXBlLk1ldGFkYXRhICovOlxuICAgICAgICAgICAgcmV0dXJuICdtb2RpZmllZCc7XG4gICAgICAgIGNhc2UgMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi86XG4gICAgICAgICAgICByZXR1cm4gJ3JlbW92ZWQnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoMHhmMDNkLCB7IHR5cGUgfSk7XG4gICAgfVxufVxuLy8gVE9ETyhmaXJlc3RvcmVleHApOiBBZGQgdGVzdHMgZm9yIHNuYXBzaG90RXF1YWwgd2l0aCBkaWZmZXJlbnQgc25hcHNob3Rcbi8vIG1ldGFkYXRhXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgc25hcHNob3RzIGFyZSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0gbGVmdCAtIEEgc25hcHNob3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSByaWdodCAtIEEgc25hcHNob3QgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHNuYXBzaG90cyBhcmUgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHNuYXBzaG90RXF1YWwobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdCBpbnN0YW5jZW9mIERvY3VtZW50U25hcHNob3QgJiYgcmlnaHQgaW5zdGFuY2VvZiBEb2N1bWVudFNuYXBzaG90KSB7XG4gICAgICAgIHJldHVybiAobGVmdC5fZmlyZXN0b3JlID09PSByaWdodC5fZmlyZXN0b3JlICYmXG4gICAgICAgICAgICBsZWZ0Ll9rZXkuaXNFcXVhbChyaWdodC5fa2V5KSAmJlxuICAgICAgICAgICAgKGxlZnQuX2RvY3VtZW50ID09PSBudWxsXG4gICAgICAgICAgICAgICAgPyByaWdodC5fZG9jdW1lbnQgPT09IG51bGxcbiAgICAgICAgICAgICAgICA6IGxlZnQuX2RvY3VtZW50LmlzRXF1YWwocmlnaHQuX2RvY3VtZW50KSkgJiZcbiAgICAgICAgICAgIGxlZnQuX2NvbnZlcnRlciA9PT0gcmlnaHQuX2NvbnZlcnRlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlZnQgaW5zdGFuY2VvZiBRdWVyeVNuYXBzaG90ICYmIHJpZ2h0IGluc3RhbmNlb2YgUXVlcnlTbmFwc2hvdCkge1xuICAgICAgICByZXR1cm4gKGxlZnQuX2ZpcmVzdG9yZSA9PT0gcmlnaHQuX2ZpcmVzdG9yZSAmJlxuICAgICAgICAgICAgcXVlcnlFcXVhbChsZWZ0LnF1ZXJ5LCByaWdodC5xdWVyeSkgJiZcbiAgICAgICAgICAgIGxlZnQubWV0YWRhdGEuaXNFcXVhbChyaWdodC5tZXRhZGF0YSkgJiZcbiAgICAgICAgICAgIGxlZnQuX3NuYXBzaG90LmlzRXF1YWwocmlnaHQuX3NuYXBzaG90KSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERFRkFVTFRfVFJBTlNBQ1RJT05fT1BUSU9OUyA9IHtcbiAgICBtYXhBdHRlbXB0czogNVxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlVHJhbnNhY3Rpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5tYXhBdHRlbXB0cyA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ01heCBhdHRlbXB0cyBtdXN0IGJlIGF0IGxlYXN0IDEnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgd3JpdGUgYmF0Y2gsIHVzZWQgdG8gcGVyZm9ybSBtdWx0aXBsZSB3cml0ZXMgYXMgYSBzaW5nbGUgYXRvbWljIHVuaXQuXG4gKlxuICogQSBgV3JpdGVCYXRjaGAgb2JqZWN0IGNhbiBiZSBhY3F1aXJlZCBieSBjYWxsaW5nIHtAbGluayB3cml0ZUJhdGNofS4gSXRcbiAqIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGFkZGluZyB3cml0ZXMgdG8gdGhlIHdyaXRlIGJhdGNoLiBOb25lIG9mIHRoZSB3cml0ZXNcbiAqIHdpbGwgYmUgY29tbWl0dGVkIChvciB2aXNpYmxlIGxvY2FsbHkpIHVudGlsIHtAbGluayBXcml0ZUJhdGNoLmNvbW1pdH0gaXNcbiAqIGNhbGxlZC5cbiAqL1xuY2xhc3MgV3JpdGVCYXRjaCB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlLCBfY29tbWl0SGFuZGxlcikge1xuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xuICAgICAgICB0aGlzLl9jb21taXRIYW5kbGVyID0gX2NvbW1pdEhhbmRsZXI7XG4gICAgICAgIHRoaXMuX211dGF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9jb21taXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKF9maXJlc3RvcmUpO1xuICAgIH1cbiAgICBzZXQoZG9jdW1lbnRSZWYsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5Tm90Q29tbWl0dGVkKCk7XG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGFwcGx5RmlyZXN0b3JlRGF0YUNvbnZlcnRlcihyZWYuY29udmVydGVyLCBkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTZXREYXRhKHRoaXMuX2RhdGFSZWFkZXIsICdXcml0ZUJhdGNoLnNldCcsIHJlZi5fa2V5LCBjb252ZXJ0ZWRWYWx1ZSwgcmVmLmNvbnZlcnRlciAhPT0gbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX211dGF0aW9ucy5wdXNoKHBhcnNlZC50b011dGF0aW9uKHJlZi5fa2V5LCBQcmVjb25kaXRpb24ubm9uZSgpKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1cGRhdGUoZG9jdW1lbnRSZWYsIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgLi4ubW9yZUZpZWxkc0FuZFZhbHVlcykge1xuICAgICAgICB0aGlzLl92ZXJpZnlOb3RDb21taXR0ZWQoKTtcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XG4gICAgICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXG4gICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cbiAgICAgICAgZmllbGRPclVwZGF0ZURhdGEgPSBnZXRNb2R1bGFySW5zdGFuY2UoZmllbGRPclVwZGF0ZURhdGEpO1xuICAgICAgICBsZXQgcGFyc2VkO1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkT3JVcGRhdGVEYXRhID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgZmllbGRPclVwZGF0ZURhdGEgaW5zdGFuY2VvZiBGaWVsZFBhdGgpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlVXBkYXRlVmFyYXJncyh0aGlzLl9kYXRhUmVhZGVyLCAnV3JpdGVCYXRjaC51cGRhdGUnLCByZWYuX2tleSwgZmllbGRPclVwZGF0ZURhdGEsIHZhbHVlLCBtb3JlRmllbGRzQW5kVmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlVXBkYXRlRGF0YSh0aGlzLl9kYXRhUmVhZGVyLCAnV3JpdGVCYXRjaC51cGRhdGUnLCByZWYuX2tleSwgZmllbGRPclVwZGF0ZURhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX211dGF0aW9ucy5wdXNoKHBhcnNlZC50b011dGF0aW9uKHJlZi5fa2V5LCBQcmVjb25kaXRpb24uZXhpc3RzKHRydWUpKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBkb2N1bWVudCByZWZlcnJlZCB0byBieSB0aGUgcHJvdmlkZWQge0BsaW5rIERvY3VtZW50UmVmZXJlbmNlfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb2N1bWVudFJlZiAtIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0byBiZSBkZWxldGVkLlxuICAgICAqIEByZXR1cm5zIFRoaXMgYFdyaXRlQmF0Y2hgIGluc3RhbmNlLiBVc2VkIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgZGVsZXRlKGRvY3VtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3ZlcmlmeU5vdENvbW1pdHRlZCgpO1xuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcbiAgICAgICAgdGhpcy5fbXV0YXRpb25zID0gdGhpcy5fbXV0YXRpb25zLmNvbmNhdChuZXcgRGVsZXRlTXV0YXRpb24ocmVmLl9rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbW1pdHMgYWxsIG9mIHRoZSB3cml0ZXMgaW4gdGhpcyB3cml0ZSBiYXRjaCBhcyBhIHNpbmdsZSBhdG9taWMgdW5pdC5cbiAgICAgKlxuICAgICAqIFRoZSByZXN1bHQgb2YgdGhlc2Ugd3JpdGVzIHdpbGwgb25seSBiZSByZWZsZWN0ZWQgaW4gZG9jdW1lbnQgcmVhZHMgdGhhdFxuICAgICAqIG9jY3VyIGFmdGVyIHRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzLiBJZiB0aGUgY2xpZW50IGlzIG9mZmxpbmUsIHRoZVxuICAgICAqIHdyaXRlIGZhaWxzLiBJZiB5b3Ugd291bGQgbGlrZSB0byBzZWUgbG9jYWwgbW9kaWZpY2F0aW9ucyBvciBidWZmZXIgd3JpdGVzXG4gICAgICogdW50aWwgdGhlIGNsaWVudCBpcyBvbmxpbmUsIHVzZSB0aGUgZnVsbCBGaXJlc3RvcmUgU0RLLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBgUHJvbWlzZWAgcmVzb2x2ZWQgb25jZSBhbGwgb2YgdGhlIHdyaXRlcyBpbiB0aGUgYmF0Y2ggaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4gdG8gdGhlIGJhY2tlbmQgYXMgYW4gYXRvbWljIHVuaXQgKG5vdGUgdGhhdCBpdCB3b24ndFxuICAgICAqIHJlc29sdmUgd2hpbGUgeW91J3JlIG9mZmxpbmUpLlxuICAgICAqL1xuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5Tm90Q29tbWl0dGVkKCk7XG4gICAgICAgIHRoaXMuX2NvbW1pdHRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9tdXRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1pdEhhbmRsZXIodGhpcy5fbXV0YXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIF92ZXJpZnlOb3RDb21taXR0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21taXR0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdBIHdyaXRlIGJhdGNoIGNhbiBubyBsb25nZXIgYmUgdXNlZCBhZnRlciBjb21taXQoKSAnICtcbiAgICAgICAgICAgICAgICAnaGFzIGJlZW4gY2FsbGVkLicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIGZpcmVzdG9yZSkge1xuICAgIGRvY3VtZW50UmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKGRvY3VtZW50UmVmKTtcbiAgICBpZiAoZG9jdW1lbnRSZWYuZmlyZXN0b3JlICE9PSBmaXJlc3RvcmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1Byb3ZpZGVkIGRvY3VtZW50IHJlZmVyZW5jZSBpcyBmcm9tIGEgZGlmZmVyZW50IEZpcmVzdG9yZSBpbnN0YW5jZS4nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudFJlZjtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBUT0RPKG1yc2NobWlkdCkgQ29uc2lkZXIgdXNpbmcgYEJhc2VUcmFuc2FjdGlvbmAgYXMgdGhlIGJhc2UgY2xhc3MgaW4gdGhlXG4vLyBsZWdhY3kgU0RLLlxuLyoqXG4gKiBBIHJlZmVyZW5jZSB0byBhIHRyYW5zYWN0aW9uLlxuICpcbiAqIFRoZSBgVHJhbnNhY3Rpb25gIG9iamVjdCBwYXNzZWQgdG8gYSB0cmFuc2FjdGlvbidzIGB1cGRhdGVGdW5jdGlvbmAgcHJvdmlkZXNcbiAqIHRoZSBtZXRob2RzIHRvIHJlYWQgYW5kIHdyaXRlIGRhdGEgd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBjb250ZXh0LiBTZWVcbiAqIHtAbGluayBydW5UcmFuc2FjdGlvbn0uXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uJDEge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSwgX3RyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gX3RyYW5zYWN0aW9uO1xuICAgICAgICB0aGlzLl9kYXRhUmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIoX2ZpcmVzdG9yZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcmVuY2VkIGJ5IHRoZSBwcm92aWRlZCB7QGxpbmsgRG9jdW1lbnRSZWZlcmVuY2V9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50UmVmIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGJlIHJlYWQuXG4gICAgICogQHJldHVybnMgQSBgRG9jdW1lbnRTbmFwc2hvdGAgd2l0aCB0aGUgcmVhZCBkYXRhLlxuICAgICAqL1xuICAgIGdldChkb2N1bWVudFJlZikge1xuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcbiAgICAgICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgTGl0ZVVzZXJEYXRhV3JpdGVyKHRoaXMuX2ZpcmVzdG9yZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbi5sb29rdXAoW3JlZi5fa2V5XSkudGhlbihkb2NzID0+IHtcbiAgICAgICAgICAgIGlmICghZG9jcyB8fCBkb2NzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKDB4NWRlOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkb2MgPSBkb2NzWzBdO1xuICAgICAgICAgICAgaWYgKGRvYy5pc0ZvdW5kRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRTbmFwc2hvdCQxKHRoaXMuX2ZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIGRvYy5rZXksIGRvYywgcmVmLmNvbnZlcnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb2MuaXNOb0RvY3VtZW50KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50U25hcHNob3QkMSh0aGlzLl9maXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCByZWYuX2tleSwgbnVsbCwgcmVmLmNvbnZlcnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBmYWlsKDB4NDgwMSwge1xuICAgICAgICAgICAgICAgICAgICBkb2NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldChkb2N1bWVudFJlZiwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZFZhbHVlID0gYXBwbHlGaXJlc3RvcmVEYXRhQ29udmVydGVyKHJlZi5jb252ZXJ0ZXIsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTZXREYXRhKHRoaXMuX2RhdGFSZWFkZXIsICdUcmFuc2FjdGlvbi5zZXQnLCByZWYuX2tleSwgY29udmVydGVkVmFsdWUsIHJlZi5jb252ZXJ0ZXIgIT09IG51bGwsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbi5zZXQocmVmLl9rZXksIHBhcnNlZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1cGRhdGUoZG9jdW1lbnRSZWYsIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgLi4ubW9yZUZpZWxkc0FuZFZhbHVlcykge1xuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcbiAgICAgICAgLy8gRm9yIENvbXBhdCB0eXBlcywgd2UgaGF2ZSB0byBcImV4dHJhY3RcIiB0aGUgdW5kZXJseWluZyB0eXBlcyBiZWZvcmVcbiAgICAgICAgLy8gcGVyZm9ybWluZyB2YWxpZGF0aW9uLlxuICAgICAgICBmaWVsZE9yVXBkYXRlRGF0YSA9IGdldE1vZHVsYXJJbnN0YW5jZShmaWVsZE9yVXBkYXRlRGF0YSk7XG4gICAgICAgIGxldCBwYXJzZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRPclVwZGF0ZURhdGEgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICBmaWVsZE9yVXBkYXRlRGF0YSBpbnN0YW5jZW9mIEZpZWxkUGF0aCkge1xuICAgICAgICAgICAgcGFyc2VkID0gcGFyc2VVcGRhdGVWYXJhcmdzKHRoaXMuX2RhdGFSZWFkZXIsICdUcmFuc2FjdGlvbi51cGRhdGUnLCByZWYuX2tleSwgZmllbGRPclVwZGF0ZURhdGEsIHZhbHVlLCBtb3JlRmllbGRzQW5kVmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlVXBkYXRlRGF0YSh0aGlzLl9kYXRhUmVhZGVyLCAnVHJhbnNhY3Rpb24udXBkYXRlJywgcmVmLl9rZXksIGZpZWxkT3JVcGRhdGVEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbi51cGRhdGUocmVmLl9rZXksIHBhcnNlZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBkb2N1bWVudCByZWZlcnJlZCB0byBieSB0aGUgcHJvdmlkZWQge0BsaW5rIERvY3VtZW50UmVmZXJlbmNlfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb2N1bWVudFJlZiAtIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0byBiZSBkZWxldGVkLlxuICAgICAqIEByZXR1cm5zIFRoaXMgYFRyYW5zYWN0aW9uYCBpbnN0YW5jZS4gVXNlZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuICAgIGRlbGV0ZShkb2N1bWVudFJlZikge1xuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24uZGVsZXRlKHJlZi5fa2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIHJlZmVyZW5jZSB0byBhIHRyYW5zYWN0aW9uLlxuICpcbiAqIFRoZSBgVHJhbnNhY3Rpb25gIG9iamVjdCBwYXNzZWQgdG8gYSB0cmFuc2FjdGlvbidzIGB1cGRhdGVGdW5jdGlvbmAgcHJvdmlkZXNcbiAqIHRoZSBtZXRob2RzIHRvIHJlYWQgYW5kIHdyaXRlIGRhdGEgd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBjb250ZXh0LiBTZWVcbiAqIHtAbGluayBydW5UcmFuc2FjdGlvbn0uXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uIGV4dGVuZHMgVHJhbnNhY3Rpb24kMSB7XG4gICAgLy8gVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHRoZSBzYW1lIGxvZ2ljIGFzIHRoZSBUcmFuc2FjdGlvbiBBUEkgaW4gdGhlIExpdGUgU0RLXG4gICAgLy8gYnV0IGlzIHN1YmNsYXNzZWQgaW4gb3JkZXIgdG8gcmV0dXJuIGl0cyBvd24gRG9jdW1lbnRTbmFwc2hvdCB0eXBlcy5cbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xuICAgIGNvbnN0cnVjdG9yKF9maXJlc3RvcmUsIF90cmFuc2FjdGlvbikge1xuICAgICAgICBzdXBlcihfZmlyZXN0b3JlLCBfdHJhbnNhY3Rpb24pO1xuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgZG9jdW1lbnQgcmVmZXJlbmNlZCBieSB0aGUgcHJvdmlkZWQge0BsaW5rIERvY3VtZW50UmVmZXJlbmNlfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb2N1bWVudFJlZiAtIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0byBiZSByZWFkLlxuICAgICAqIEByZXR1cm5zIEEgYERvY3VtZW50U25hcHNob3RgIHdpdGggdGhlIHJlYWQgZGF0YS5cbiAgICAgKi9cbiAgICBnZXQoZG9jdW1lbnRSZWYpIHtcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XG4gICAgICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKHRoaXMuX2ZpcmVzdG9yZSk7XG4gICAgICAgIHJldHVybiBzdXBlclxuICAgICAgICAgICAgLmdldChkb2N1bWVudFJlZilcbiAgICAgICAgICAgIC50aGVuKGxpdGVEb2N1bWVudFNuYXBzaG90ID0+IG5ldyBEb2N1bWVudFNuYXBzaG90KHRoaXMuX2ZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIHJlZi5fa2V5LCBsaXRlRG9jdW1lbnRTbmFwc2hvdC5fZG9jdW1lbnQsIG5ldyBTbmFwc2hvdE1ldGFkYXRhKFxuICAgICAgICAvKiBoYXNQZW5kaW5nV3JpdGVzPSAqLyBmYWxzZSwgXG4gICAgICAgIC8qIGZyb21DYWNoZT0gKi8gZmFsc2UpLCByZWYuY29udmVydGVyKSk7XG4gICAgfVxufVxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgZ2l2ZW4gYHVwZGF0ZUZ1bmN0aW9uYCBhbmQgdGhlbiBhdHRlbXB0cyB0byBjb21taXQgdGhlIGNoYW5nZXNcbiAqIGFwcGxpZWQgd2l0aGluIHRoZSB0cmFuc2FjdGlvbi4gSWYgYW55IGRvY3VtZW50IHJlYWQgd2l0aGluIHRoZSB0cmFuc2FjdGlvblxuICogaGFzIGNoYW5nZWQsIENsb3VkIEZpcmVzdG9yZSByZXRyaWVzIHRoZSBgdXBkYXRlRnVuY3Rpb25gLiBJZiBpdCBmYWlscyB0b1xuICogY29tbWl0IGFmdGVyIDUgYXR0ZW1wdHMsIHRoZSB0cmFuc2FjdGlvbiBmYWlscy5cbiAqXG4gKiBUaGUgbWF4aW11bSBudW1iZXIgb2Ygd3JpdGVzIGFsbG93ZWQgaW4gYSBzaW5nbGUgdHJhbnNhY3Rpb24gaXMgNTAwLlxuICpcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBBIHJlZmVyZW5jZSB0byB0aGUgRmlyZXN0b3JlIGRhdGFiYXNlIHRvIHJ1biB0aGlzXG4gKiB0cmFuc2FjdGlvbiBhZ2FpbnN0LlxuICogQHBhcmFtIHVwZGF0ZUZ1bmN0aW9uIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2l0aGluIHRoZSB0cmFuc2FjdGlvblxuICogY29udGV4dC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9ucyBvYmplY3QgdG8gY29uZmlndXJlIG1heGltdW0gbnVtYmVyIG9mIGF0dGVtcHRzIHRvXG4gKiBjb21taXQuXG4gKiBAcmV0dXJucyBJZiB0aGUgdHJhbnNhY3Rpb24gY29tcGxldGVkIHN1Y2Nlc3NmdWxseSBvciB3YXMgZXhwbGljaXRseSBhYm9ydGVkXG4gKiAodGhlIGB1cGRhdGVGdW5jdGlvbmAgcmV0dXJuZWQgYSBmYWlsZWQgcHJvbWlzZSksIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoZVxuICogYHVwZGF0ZUZ1bmN0aW9uIGBpcyByZXR1cm5lZCBoZXJlLiBPdGhlcndpc2UsIGlmIHRoZSB0cmFuc2FjdGlvbiBmYWlsZWQsIGFcbiAqIHJlamVjdGVkIHByb21pc2Ugd2l0aCB0aGUgY29ycmVzcG9uZGluZyBmYWlsdXJlIGVycm9yIGlzIHJldHVybmVkLlxuICovXG5mdW5jdGlvbiBydW5UcmFuc2FjdGlvbihmaXJlc3RvcmUsIHVwZGF0ZUZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3Qgb3B0aW9uc1dpdGhEZWZhdWx0cyA9IHtcbiAgICAgICAgLi4uREVGQVVMVF9UUkFOU0FDVElPTl9PUFRJT05TLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICB2YWxpZGF0ZVRyYW5zYWN0aW9uT3B0aW9ucyhvcHRpb25zV2l0aERlZmF1bHRzKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudFRyYW5zYWN0aW9uKGNsaWVudCwgaW50ZXJuYWxUcmFuc2FjdGlvbiA9PiB1cGRhdGVGdW5jdGlvbihuZXcgVHJhbnNhY3Rpb24oZmlyZXN0b3JlLCBpbnRlcm5hbFRyYW5zYWN0aW9uKSksIG9wdGlvbnNXaXRoRGVmYXVsdHMpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gaXNQYXJ0aWFsT2JzZXJ2ZXIob2JqKSB7XG4gICAgcmV0dXJuIGltcGxlbWVudHNBbnlNZXRob2RzKG9iaiwgWyduZXh0JywgJ2Vycm9yJywgJ2NvbXBsZXRlJ10pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGFuIG9iamVjdCBhbmQgY29udGFpbnMgYXQgbGVhc3Qgb25lIG9mIHRoZSBzcGVjaWZpZWRcbiAqIG1ldGhvZHMuXG4gKi9cbmZ1bmN0aW9uIGltcGxlbWVudHNBbnlNZXRob2RzKG9iaiwgbWV0aG9kcykge1xuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvYmplY3QgPSBvYmo7XG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xuICAgICAgICBpZiAobWV0aG9kIGluIG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmVhZHMgdGhlIGRvY3VtZW50IHJlZmVycmVkIHRvIGJ5IHRoaXMgYERvY3VtZW50UmVmZXJlbmNlYC5cbiAqXG4gKiBOb3RlOiBgZ2V0RG9jKClgIGF0dGVtcHRzIHRvIHByb3ZpZGUgdXAtdG8tZGF0ZSBkYXRhIHdoZW4gcG9zc2libGUgYnkgd2FpdGluZ1xuICogZm9yIGRhdGEgZnJvbSB0aGUgc2VydmVyLCBidXQgaXQgbWF5IHJldHVybiBjYWNoZWQgZGF0YSBvciBmYWlsIGlmIHlvdSBhcmVcbiAqIG9mZmxpbmUgYW5kIHRoZSBzZXJ2ZXIgY2Fubm90IGJlIHJlYWNoZWQuIFRvIHNwZWNpZnkgdGhpcyBiZWhhdmlvciwgaW52b2tlXG4gKiB7QGxpbmsgZ2V0RG9jRnJvbUNhY2hlfSBvciB7QGxpbmsgZ2V0RG9jRnJvbVNlcnZlcn0uXG4gKlxuICogQHBhcmFtIHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2Ugb2YgdGhlIGRvY3VtZW50IHRvIGZldGNoLlxuICogQHJldHVybnMgQSBQcm9taXNlIHJlc29sdmVkIHdpdGggYSBgRG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbmluZyB0aGVcbiAqIGN1cnJlbnQgZG9jdW1lbnQgY29udGVudHMuXG4gKi9cbmZ1bmN0aW9uIGdldERvYyhyZWZlcmVuY2UpIHtcbiAgICByZWZlcmVuY2UgPSBjYXN0KHJlZmVyZW5jZSwgRG9jdW1lbnRSZWZlcmVuY2UpO1xuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocmVmZXJlbmNlLmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50VmlhU25hcHNob3RMaXN0ZW5lcihjbGllbnQsIHJlZmVyZW5jZS5fa2V5KS50aGVuKHNuYXBzaG90ID0+IGNvbnZlcnRUb0RvY1NuYXBzaG90KGZpcmVzdG9yZSwgcmVmZXJlbmNlLCBzbmFwc2hvdCkpO1xufVxuLyoqXG4gKiBSZWFkcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhpcyBgRG9jdW1lbnRSZWZlcmVuY2VgIGZyb20gY2FjaGUuXG4gKiBSZXR1cm5zIGFuIGVycm9yIGlmIHRoZSBkb2N1bWVudCBpcyBub3QgY3VycmVudGx5IGNhY2hlZC5cbiAqXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCByZXNvbHZlZCB3aXRoIGEgYERvY3VtZW50U25hcHNob3RgIGNvbnRhaW5pbmcgdGhlXG4gKiBjdXJyZW50IGRvY3VtZW50IGNvbnRlbnRzLlxuICovXG5mdW5jdGlvbiBnZXREb2NGcm9tQ2FjaGUocmVmZXJlbmNlKSB7XG4gICAgcmVmZXJlbmNlID0gY2FzdChyZWZlcmVuY2UsIERvY3VtZW50UmVmZXJlbmNlKTtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKGZpcmVzdG9yZSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50RnJvbUxvY2FsQ2FjaGUoY2xpZW50LCByZWZlcmVuY2UuX2tleSkudGhlbihkb2MgPT4gbmV3IERvY3VtZW50U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcmVmZXJlbmNlLl9rZXksIGRvYywgbmV3IFNuYXBzaG90TWV0YWRhdGEoZG9jICE9PSBudWxsICYmIGRvYy5oYXNMb2NhbE11dGF0aW9ucywgXG4gICAgLyogZnJvbUNhY2hlPSAqLyB0cnVlKSwgcmVmZXJlbmNlLmNvbnZlcnRlcikpO1xufVxuLyoqXG4gKiBSZWFkcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhpcyBgRG9jdW1lbnRSZWZlcmVuY2VgIGZyb20gdGhlIHNlcnZlci5cbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgdGhlIG5ldHdvcmsgaXMgbm90IGF2YWlsYWJsZS5cbiAqXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCByZXNvbHZlZCB3aXRoIGEgYERvY3VtZW50U25hcHNob3RgIGNvbnRhaW5pbmcgdGhlXG4gKiBjdXJyZW50IGRvY3VtZW50IGNvbnRlbnRzLlxuICovXG5mdW5jdGlvbiBnZXREb2NGcm9tU2VydmVyKHJlZmVyZW5jZSkge1xuICAgIHJlZmVyZW5jZSA9IGNhc3QocmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSk7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRWaWFTbmFwc2hvdExpc3RlbmVyKGNsaWVudCwgcmVmZXJlbmNlLl9rZXksIHtcbiAgICAgICAgc291cmNlOiAnc2VydmVyJ1xuICAgIH0pLnRoZW4oc25hcHNob3QgPT4gY29udmVydFRvRG9jU25hcHNob3QoZmlyZXN0b3JlLCByZWZlcmVuY2UsIHNuYXBzaG90KSk7XG59XG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cyBhcyBhIGBRdWVyeVNuYXBzaG90YC5cbiAqXG4gKiBOb3RlOiBgZ2V0RG9jcygpYCBhdHRlbXB0cyB0byBwcm92aWRlIHVwLXRvLWRhdGUgZGF0YSB3aGVuIHBvc3NpYmxlIGJ5XG4gKiB3YWl0aW5nIGZvciBkYXRhIGZyb20gdGhlIHNlcnZlciwgYnV0IGl0IG1heSByZXR1cm4gY2FjaGVkIGRhdGEgb3IgZmFpbCBpZlxuICogeW91IGFyZSBvZmZsaW5lIGFuZCB0aGUgc2VydmVyIGNhbm5vdCBiZSByZWFjaGVkLiBUbyBzcGVjaWZ5IHRoaXMgYmVoYXZpb3IsXG4gKiBpbnZva2Uge0BsaW5rIGdldERvY3NGcm9tQ2FjaGV9IG9yIHtAbGluayBnZXREb2NzRnJvbVNlcnZlcn0uXG4gKlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdHMgb2YgdGhlIHF1ZXJ5LlxuICovXG5mdW5jdGlvbiBnZXREb2NzKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBjYXN0KHF1ZXJ5LCBRdWVyeSk7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKGZpcmVzdG9yZSk7XG4gICAgdmFsaWRhdGVIYXNFeHBsaWNpdE9yZGVyQnlGb3JMaW1pdFRvTGFzdChxdWVyeS5fcXVlcnkpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNWaWFTbmFwc2hvdExpc3RlbmVyKGNsaWVudCwgcXVlcnkuX3F1ZXJ5KS50aGVuKHNuYXBzaG90ID0+IG5ldyBRdWVyeVNuYXBzaG90KGZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIHF1ZXJ5LCBzbmFwc2hvdCkpO1xufVxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnkgYW5kIHJldHVybnMgdGhlIHJlc3VsdHMgYXMgYSBgUXVlcnlTbmFwc2hvdGAgZnJvbSBjYWNoZS5cbiAqIFJldHVybnMgYW4gZW1wdHkgcmVzdWx0IHNldCBpZiBubyBkb2N1bWVudHMgbWF0Y2hpbmcgdGhlIHF1ZXJ5IGFyZSBjdXJyZW50bHlcbiAqIGNhY2hlZC5cbiAqXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiB0aGUgcXVlcnkuXG4gKi9cbmZ1bmN0aW9uIGdldERvY3NGcm9tQ2FjaGUocXVlcnkpIHtcbiAgICBxdWVyeSA9IGNhc3QocXVlcnksIFF1ZXJ5KTtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHF1ZXJ5LmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRzRnJvbUxvY2FsQ2FjaGUoY2xpZW50LCBxdWVyeS5fcXVlcnkpLnRoZW4oc25hcHNob3QgPT4gbmV3IFF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcXVlcnksIHNuYXBzaG90KSk7XG59XG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cyBhcyBhIGBRdWVyeVNuYXBzaG90YCBmcm9tIHRoZVxuICogc2VydmVyLiBSZXR1cm5zIGFuIGVycm9yIGlmIHRoZSBuZXR3b3JrIGlzIG5vdCBhdmFpbGFibGUuXG4gKlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdHMgb2YgdGhlIHF1ZXJ5LlxuICovXG5mdW5jdGlvbiBnZXREb2NzRnJvbVNlcnZlcihxdWVyeSkge1xuICAgIHF1ZXJ5ID0gY2FzdChxdWVyeSwgUXVlcnkpO1xuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocXVlcnkuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcihmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNWaWFTbmFwc2hvdExpc3RlbmVyKGNsaWVudCwgcXVlcnkuX3F1ZXJ5LCB7XG4gICAgICAgIHNvdXJjZTogJ3NlcnZlcidcbiAgICB9KS50aGVuKHNuYXBzaG90ID0+IG5ldyBRdWVyeVNuYXBzaG90KGZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIHF1ZXJ5LCBzbmFwc2hvdCkpO1xufVxuZnVuY3Rpb24gc2V0RG9jKHJlZmVyZW5jZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIHJlZmVyZW5jZSA9IGNhc3QocmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSk7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGNvbnZlcnRlZFZhbHVlID0gYXBwbHlGaXJlc3RvcmVEYXRhQ29udmVydGVyKHJlZmVyZW5jZS5jb252ZXJ0ZXIsIGRhdGEsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRhdGFSZWFkZXIgPSBuZXdVc2VyRGF0YVJlYWRlcihmaXJlc3RvcmUpO1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2V0RGF0YShkYXRhUmVhZGVyLCAnc2V0RG9jJywgcmVmZXJlbmNlLl9rZXksIGNvbnZlcnRlZFZhbHVlLCByZWZlcmVuY2UuY29udmVydGVyICE9PSBudWxsLCBvcHRpb25zKTtcbiAgICBjb25zdCBtdXRhdGlvbiA9IHBhcnNlZC50b011dGF0aW9uKHJlZmVyZW5jZS5fa2V5LCBQcmVjb25kaXRpb24ubm9uZSgpKTtcbiAgICByZXR1cm4gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgW211dGF0aW9uXSk7XG59XG5mdW5jdGlvbiB1cGRhdGVEb2MocmVmZXJlbmNlLCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIC4uLm1vcmVGaWVsZHNBbmRWYWx1ZXMpIHtcbiAgICByZWZlcmVuY2UgPSBjYXN0KHJlZmVyZW5jZSwgRG9jdW1lbnRSZWZlcmVuY2UpO1xuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocmVmZXJlbmNlLmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBkYXRhUmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIoZmlyZXN0b3JlKTtcbiAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxuICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cbiAgICBmaWVsZE9yVXBkYXRlRGF0YSA9IGdldE1vZHVsYXJJbnN0YW5jZShmaWVsZE9yVXBkYXRlRGF0YSk7XG4gICAgbGV0IHBhcnNlZDtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JVcGRhdGVEYXRhID09PSAnc3RyaW5nJyB8fFxuICAgICAgICBmaWVsZE9yVXBkYXRlRGF0YSBpbnN0YW5jZW9mIEZpZWxkUGF0aCkge1xuICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZVZhcmFyZ3MoZGF0YVJlYWRlciwgJ3VwZGF0ZURvYycsIHJlZmVyZW5jZS5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIG1vcmVGaWVsZHNBbmRWYWx1ZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyc2VkID0gcGFyc2VVcGRhdGVEYXRhKGRhdGFSZWFkZXIsICd1cGRhdGVEb2MnLCByZWZlcmVuY2UuX2tleSwgZmllbGRPclVwZGF0ZURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBtdXRhdGlvbiA9IHBhcnNlZC50b011dGF0aW9uKHJlZmVyZW5jZS5fa2V5LCBQcmVjb25kaXRpb24uZXhpc3RzKHRydWUpKTtcbiAgICByZXR1cm4gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgW211dGF0aW9uXSk7XG59XG4vKipcbiAqIERlbGV0ZXMgdGhlIGRvY3VtZW50IHJlZmVycmVkIHRvIGJ5IHRoZSBzcGVjaWZpZWQgYERvY3VtZW50UmVmZXJlbmNlYC5cbiAqXG4gKiBAcGFyYW0gcmVmZXJlbmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGRlbGV0ZS5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSByZXNvbHZlZCBvbmNlIHRoZSBkb2N1bWVudCBoYXMgYmVlbiBzdWNjZXNzZnVsbHlcbiAqIGRlbGV0ZWQgZnJvbSB0aGUgYmFja2VuZCAobm90ZSB0aGF0IGl0IHdvbid0IHJlc29sdmUgd2hpbGUgeW91J3JlIG9mZmxpbmUpLlxuICovXG5mdW5jdGlvbiBkZWxldGVEb2MocmVmZXJlbmNlKSB7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IG11dGF0aW9ucyA9IFtuZXcgRGVsZXRlTXV0YXRpb24ocmVmZXJlbmNlLl9rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpXTtcbiAgICByZXR1cm4gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgbXV0YXRpb25zKTtcbn1cbi8qKlxuICogQWRkIGEgbmV3IGRvY3VtZW50IHRvIHNwZWNpZmllZCBgQ29sbGVjdGlvblJlZmVyZW5jZWAgd2l0aCB0aGUgZ2l2ZW4gZGF0YSxcbiAqIGFzc2lnbmluZyBpdCBhIGRvY3VtZW50IElEIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogQHBhcmFtIHJlZmVyZW5jZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjb2xsZWN0aW9uIHRvIGFkZCB0aGlzIGRvY3VtZW50IHRvLlxuICogQHBhcmFtIGRhdGEgLSBBbiBPYmplY3QgY29udGFpbmluZyB0aGUgZGF0YSBmb3IgdGhlIG5ldyBkb2N1bWVudC5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHJlc29sdmVkIHdpdGggYSBgRG9jdW1lbnRSZWZlcmVuY2VgIHBvaW50aW5nIHRvIHRoZVxuICogbmV3bHkgY3JlYXRlZCBkb2N1bWVudCBhZnRlciBpdCBoYXMgYmVlbiB3cml0dGVuIHRvIHRoZSBiYWNrZW5kIChOb3RlIHRoYXQgaXRcbiAqIHdvbid0IHJlc29sdmUgd2hpbGUgeW91J3JlIG9mZmxpbmUpLlxuICovXG5mdW5jdGlvbiBhZGREb2MocmVmZXJlbmNlLCBkYXRhKSB7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGRvY1JlZiA9IGRvYyhyZWZlcmVuY2UpO1xuICAgIGNvbnN0IGNvbnZlcnRlZFZhbHVlID0gYXBwbHlGaXJlc3RvcmVEYXRhQ29udmVydGVyKHJlZmVyZW5jZS5jb252ZXJ0ZXIsIGRhdGEpO1xuICAgIGNvbnN0IGRhdGFSZWFkZXIgPSBuZXdVc2VyRGF0YVJlYWRlcihyZWZlcmVuY2UuZmlyZXN0b3JlKTtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVNldERhdGEoZGF0YVJlYWRlciwgJ2FkZERvYycsIGRvY1JlZi5fa2V5LCBjb252ZXJ0ZWRWYWx1ZSwgcmVmZXJlbmNlLmNvbnZlcnRlciAhPT0gbnVsbCwge30pO1xuICAgIGNvbnN0IG11dGF0aW9uID0gcGFyc2VkLnRvTXV0YXRpb24oZG9jUmVmLl9rZXksIFByZWNvbmRpdGlvbi5leGlzdHMoZmFsc2UpKTtcbiAgICByZXR1cm4gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgW211dGF0aW9uXSkudGhlbigoKSA9PiBkb2NSZWYpO1xufVxuZnVuY3Rpb24gb25TbmFwc2hvdChyZWZlcmVuY2UsIC4uLmFyZ3MpIHtcbiAgICAvLyBvblNuYXBzaG90IGZvciBRdWVyeSBvciBEb2N1bWVudC5cbiAgICByZWZlcmVuY2UgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmZXJlbmNlKTtcbiAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgaW5jbHVkZU1ldGFkYXRhQ2hhbmdlczogZmFsc2UsXG4gICAgICAgIHNvdXJjZTogJ2RlZmF1bHQnXG4gICAgfTtcbiAgICBsZXQgY3VyckFyZyA9IDA7XG4gICAgaWYgKHR5cGVvZiBhcmdzW2N1cnJBcmddID09PSAnb2JqZWN0JyAmJiAhaXNQYXJ0aWFsT2JzZXJ2ZXIoYXJnc1tjdXJyQXJnXSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZ3NbY3VyckFyZysrXTtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJuYWxPcHRpb25zID0ge1xuICAgICAgICBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzOiBvcHRpb25zLmluY2x1ZGVNZXRhZGF0YUNoYW5nZXMsXG4gICAgICAgIHNvdXJjZTogb3B0aW9ucy5zb3VyY2VcbiAgICB9O1xuICAgIGlmIChpc1BhcnRpYWxPYnNlcnZlcihhcmdzW2N1cnJBcmddKSkge1xuICAgICAgICBjb25zdCB1c2VyT2JzZXJ2ZXIgPSBhcmdzW2N1cnJBcmddO1xuICAgICAgICBhcmdzW2N1cnJBcmddID0gdXNlck9ic2VydmVyLm5leHQ/LmJpbmQodXNlck9ic2VydmVyKTtcbiAgICAgICAgYXJnc1tjdXJyQXJnICsgMV0gPSB1c2VyT2JzZXJ2ZXIuZXJyb3I/LmJpbmQodXNlck9ic2VydmVyKTtcbiAgICAgICAgYXJnc1tjdXJyQXJnICsgMl0gPSB1c2VyT2JzZXJ2ZXIuY29tcGxldGU/LmJpbmQodXNlck9ic2VydmVyKTtcbiAgICB9XG4gICAgbGV0IG9ic2VydmVyO1xuICAgIGxldCBmaXJlc3RvcmU7XG4gICAgbGV0IGludGVybmFsUXVlcnk7XG4gICAgaWYgKHJlZmVyZW5jZSBpbnN0YW5jZW9mIERvY3VtZW50UmVmZXJlbmNlKSB7XG4gICAgICAgIGZpcmVzdG9yZSA9IGNhc3QocmVmZXJlbmNlLmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICAgICAgaW50ZXJuYWxRdWVyeSA9IG5ld1F1ZXJ5Rm9yUGF0aChyZWZlcmVuY2UuX2tleS5wYXRoKTtcbiAgICAgICAgb2JzZXJ2ZXIgPSB7XG4gICAgICAgICAgICBuZXh0OiBzbmFwc2hvdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbY3VyckFyZ10pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tjdXJyQXJnXShjb252ZXJ0VG9Eb2NTbmFwc2hvdChmaXJlc3RvcmUsIHJlZmVyZW5jZSwgc25hcHNob3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGFyZ3NbY3VyckFyZyArIDFdLFxuICAgICAgICAgICAgY29tcGxldGU6IGFyZ3NbY3VyckFyZyArIDJdXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBxdWVyeSA9IGNhc3QocmVmZXJlbmNlLCBRdWVyeSk7XG4gICAgICAgIGZpcmVzdG9yZSA9IGNhc3QocXVlcnkuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgICAgICBpbnRlcm5hbFF1ZXJ5ID0gcXVlcnkuX3F1ZXJ5O1xuICAgICAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcihmaXJlc3RvcmUpO1xuICAgICAgICBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgIG5leHQ6IHNuYXBzaG90ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnc1tjdXJyQXJnXSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW2N1cnJBcmddKG5ldyBRdWVyeVNuYXBzaG90KGZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIHF1ZXJ5LCBzbmFwc2hvdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogYXJnc1tjdXJyQXJnICsgMV0sXG4gICAgICAgICAgICBjb21wbGV0ZTogYXJnc1tjdXJyQXJnICsgMl1cbiAgICAgICAgfTtcbiAgICAgICAgdmFsaWRhdGVIYXNFeHBsaWNpdE9yZGVyQnlGb3JMaW1pdFRvTGFzdChyZWZlcmVuY2UuX3F1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRMaXN0ZW4oY2xpZW50LCBpbnRlcm5hbFF1ZXJ5LCBpbnRlcm5hbE9wdGlvbnMsIG9ic2VydmVyKTtcbn1cbmZ1bmN0aW9uIG9uU25hcHNob3RSZXN1bWUocmVmZXJlbmNlLCBzbmFwc2hvdEpzb24sIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBkYiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWZlcmVuY2UpO1xuICAgIGNvbnN0IGpzb24gPSBub3JtYWxpemVTbmFwc2hvdEpzb25GaWVsZHMoc25hcHNob3RKc29uKTtcbiAgICBpZiAoanNvbi5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBqc29uLmVycm9yKTtcbiAgICB9XG4gICAgbGV0IGN1ckFyZyA9IDA7XG4gICAgbGV0IG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiBhcmdzW2N1ckFyZ10gPT09ICdvYmplY3QnICYmICFpc1BhcnRpYWxPYnNlcnZlcihhcmdzW2N1ckFyZ10pKSB7XG4gICAgICAgIG9wdGlvbnMgPSBhcmdzW2N1ckFyZysrXTtcbiAgICB9XG4gICAgaWYgKGpzb24uYnVuZGxlU291cmNlID09PSAnUXVlcnlTbmFwc2hvdCcpIHtcbiAgICAgICAgbGV0IG9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2N1ckFyZ10gPT09ICdvYmplY3QnICYmIGlzUGFydGlhbE9ic2VydmVyKGFyZ3NbY3VyQXJnXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJPYnNlcnZlciA9IGFyZ3NbY3VyQXJnKytdO1xuICAgICAgICAgICAgb2JzZXJ2ZXIgPSB7XG4gICAgICAgICAgICAgICAgbmV4dDogdXNlck9ic2VydmVyLm5leHQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHVzZXJPYnNlcnZlci5lcnJvcixcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogdXNlck9ic2VydmVyLmNvbXBsZXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JzZXJ2ZXIgPSB7XG4gICAgICAgICAgICAgICAgbmV4dDogYXJnc1tjdXJBcmcrK10sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGFyZ3NbY3VyQXJnKytdLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBhcmdzW2N1ckFyZysrXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb25TbmFwc2hvdFF1ZXJ5U25hcHNob3RCdW5kbGUoZGIsIGpzb24sIG9wdGlvbnMsIG9ic2VydmVyLCBhcmdzW2N1ckFyZ10pO1xuICAgIH1cbiAgICBlbHNlIGlmIChqc29uLmJ1bmRsZVNvdXJjZSA9PT0gJ0RvY3VtZW50U25hcHNob3QnKSB7XG4gICAgICAgIGxldCBvYnNlcnZlciA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1tjdXJBcmddID09PSAnb2JqZWN0JyAmJiBpc1BhcnRpYWxPYnNlcnZlcihhcmdzW2N1ckFyZ10pKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyT2JzZXJ2ZXIgPSBhcmdzW2N1ckFyZysrXTtcbiAgICAgICAgICAgIG9ic2VydmVyID0ge1xuICAgICAgICAgICAgICAgIG5leHQ6IHVzZXJPYnNlcnZlci5uZXh0LFxuICAgICAgICAgICAgICAgIGVycm9yOiB1c2VyT2JzZXJ2ZXIuZXJyb3IsXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IHVzZXJPYnNlcnZlci5jb21wbGV0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ic2VydmVyID0ge1xuICAgICAgICAgICAgICAgIG5leHQ6IGFyZ3NbY3VyQXJnKytdLFxuICAgICAgICAgICAgICAgIGVycm9yOiBhcmdzW2N1ckFyZysrXSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogYXJnc1tjdXJBcmcrK11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9uU25hcHNob3REb2N1bWVudFNuYXBzaG90QnVuZGxlKGRiLCBqc29uLCBvcHRpb25zLCBvYnNlcnZlciwgYXJnc1tjdXJBcmddKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGB1bnN1cHBvcnRlZCBidW5kbGUgc291cmNlOiAke2pzb24uYnVuZGxlU291cmNlfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG9uU25hcHNob3RzSW5TeW5jKGZpcmVzdG9yZSwgYXJnKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gaXNQYXJ0aWFsT2JzZXJ2ZXIoYXJnKVxuICAgICAgICA/IGFyZ1xuICAgICAgICA6IHtcbiAgICAgICAgICAgIG5leHQ6IGFyZ1xuICAgICAgICB9O1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRBZGRTbmFwc2hvdHNJblN5bmNMaXN0ZW5lcihjbGllbnQsIG9ic2VydmVyKTtcbn1cbi8qKlxuICogTG9jYWxseSB3cml0ZXMgYG11dGF0aW9uc2Agb24gdGhlIGFzeW5jIHF1ZXVlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVXcml0ZShmaXJlc3RvcmUsIG11dGF0aW9ucykge1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50V3JpdGUoY2xpZW50LCBtdXRhdGlvbnMpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBWaWV3U25hcHNob3R9IHRoYXQgY29udGFpbnMgdGhlIHNpbmdsZSBkb2N1bWVudCBzcGVjaWZpZWQgYnkgYHJlZmBcbiAqIHRvIGEge0BsaW5rIERvY3VtZW50U25hcHNob3R9LlxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9Eb2NTbmFwc2hvdChmaXJlc3RvcmUsIHJlZiwgc25hcHNob3QpIHtcbiAgICBjb25zdCBkb2MgPSBzbmFwc2hvdC5kb2NzLmdldChyZWYuX2tleSk7XG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcbiAgICByZXR1cm4gbmV3IERvY3VtZW50U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcmVmLl9rZXksIGRvYywgbmV3IFNuYXBzaG90TWV0YWRhdGEoc25hcHNob3QuaGFzUGVuZGluZ1dyaXRlcywgc25hcHNob3QuZnJvbUNhY2hlKSwgcmVmLmNvbnZlcnRlcik7XG59XG4vKipcbiAqIEVuc3VyZXMgdGhlIGRhdGEgcmVxdWlyZWQgdG8gY29uc3RydWN0IGFuIHtAbGluayBvblNuYXBzaG90fSBsaXN0ZW5lciBleGlzdCBpbiBhIGBzbmFwc2hvdEpzb25gXG4gKiBvYmplY3QgdGhhdCBvcmlnaW5hdGVzIGZyb20ge0BsaW5rIERvY3VtZW50U25hcHNob3QudG9KU09OfSBvciB7QGxpbmsgUXVlcnlzbmFwc2hvdC50b0pTT059LiBUaGVcbiAqIGRhdGEgaXMgbm9ybWFsaXplZCBpbnRvIGEgdHlwZWQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBzbmFwc2hvdEpzb24gLSBUaGUgSlNPTiBvYmplY3QgdGhhdCB0aGUgYXBwIHByb3ZpZGVkIHRvIHtAbGluayBvblNuYXBzaG90fS5cbiAqIEByZXR1cm5zIEEgbm9ybWFsaXplZCBvYmplY3QgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIHJlcXVpcmVkIGJ1bmRsZSBKU09OIGZpZWxkcy4gSWZcbiAqIHtAbGluayBzbmFwc2hvdEpzb259IGRvZXNuJ3QgY29udGFpbiB0aGUgcmVxdWlyZWQgZmllbGRzLCBvciBpZiB0aGUgZmllbGRzIGV4aXN0IGFzIGVtcHR5XG4gKiBzdHJpbmdzLCB0aGVuIHRoZSB7QGxpbmsgc25hcHNob3RKc29uLmVycm9yfSBmaWVsZCB3aWxsIGJlIGEgbm9uIGVtcHR5IHN0cmluZy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplU25hcHNob3RKc29uRmllbGRzKHNuYXBzaG90SnNvbikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgYnVuZGxlOiAnJyxcbiAgICAgICAgYnVuZGxlTmFtZTogJycsXG4gICAgICAgIGJ1bmRsZVNvdXJjZTogJydcbiAgICB9O1xuICAgIGNvbnN0IHJlcXVpcmVkS2V5cyA9IFsnYnVuZGxlJywgJ2J1bmRsZU5hbWUnLCAnYnVuZGxlU291cmNlJ107XG4gICAgZm9yIChjb25zdCBrZXkgb2YgcmVxdWlyZWRLZXlzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBzbmFwc2hvdEpzb24pKSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IgPSBgc25hcHNob3RKc29uIG1pc3NpbmcgcmVxdWlyZWQgZmllbGQ6ICR7a2V5fWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHNuYXBzaG90SnNvbltrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gYHNuYXBzaG90SnNvbiBmaWVsZCAnJHtrZXl9JyBtdXN0IGJlIGEgc3RyaW5nLmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IgPSBgc25hcHNob3RKc29uIGZpZWxkICcke2tleX0nIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmcuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09ICdidW5kbGUnKSB7XG4gICAgICAgICAgICByZXN1bHQuYnVuZGxlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnYnVuZGxlTmFtZScpIHtcbiAgICAgICAgICAgIHJlc3VsdC5idW5kbGVOYW1lID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnYnVuZGxlU291cmNlJykge1xuICAgICAgICAgICAgcmVzdWx0LmJ1bmRsZVNvdXJjZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIExvYWRzIHRoZSBidW5kbGUgaW4gYSBzZXBhcmF0ZSB0YXNrIGFuZCB0aGVuIGludm9rZXMge0BsaW5rIG9uU25hcHNob3R9IHdpdGggYVxuICoge0BsaW5rIERvY3VtZW50UmVmZXJlbmNlfSBmb3IgdGhlIGRvY3VtZW50IGluIHRoZSBidW5kbGUuXG4gKlxuICogQHBhcmFtIGZpcmVzdG9yZSAtIFRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSBmb3IgdGhlIHtAbGluayBvblNuYXBzaG90fSBvcGVyYXRpb24gcmVxdWVzdC5cbiAqIEBwYXJhbSBqc29uIC0gVGhlIEpTT04gYnVuZGxlIHRvIGxvYWQsIHByb2R1Y2VkIGJ5IHtAbGluayBEb2N1bWVudFNuYXBzaG90LnRvSlNPTn0uXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgY29udHJvbGxpbmcgdGhlIGxpc3RlbiBiZWhhdmlvci5cbiAqIEBwYXJhbSBvYnNlcnZlciAtIEEgc2luZ2xlIG9iamVjdCBjb250YWluaW5nIGBuZXh0YCBhbmQgYGVycm9yYCBjYWxsYmFja3MuXG4gKiBAcGFyYW0gY29udmVydGVyIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHRoYXQgY29udmVydHMgb2JqZWN0cyBmcm9tIEZpcmVzdG9yZSBiZWZvcmUgdGhlIG9uTmV4dFxuICogbGlzdGVuZXIgaXMgaW52b2tlZC5cbiAqIEByZXR1cm5zIEFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB0byBjYW5jZWwgdGhlIHNuYXBzaG90XG4gKiBsaXN0ZW5lci5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gb25TbmFwc2hvdERvY3VtZW50U25hcHNob3RCdW5kbGUoZGIsIGpzb24sIG9wdGlvbnMsIG9ic2VydmVyLCBjb252ZXJ0ZXIpIHtcbiAgICBsZXQgdW5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgbGV0IGludGVybmFsVW5zdWJzY3JpYmU7XG4gICAgY29uc3QgbG9hZFRhc2sgPSBsb2FkQnVuZGxlKGRiLCBqc29uLmJ1bmRsZSk7XG4gICAgbG9hZFRhc2tcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoIXVuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgY29uc3QgZG9jUmVmZXJlbmNlID0gbmV3IERvY3VtZW50UmVmZXJlbmNlKGRiLCBjb252ZXJ0ZXIgPyBjb252ZXJ0ZXIgOiBudWxsLCBEb2N1bWVudEtleS5mcm9tUGF0aChqc29uLmJ1bmRsZU5hbWUpKTtcbiAgICAgICAgICAgIGludGVybmFsVW5zdWJzY3JpYmUgPSBvblNuYXBzaG90KGRvY1JlZmVyZW5jZSwgb3B0aW9ucyA/IG9wdGlvbnMgOiB7fSwgb2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICBpZiAob2JzZXJ2ZXIuZXJyb3IpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7IH07XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKHVuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHVuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIGlmIChpbnRlcm5hbFVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICBpbnRlcm5hbFVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBMb2FkcyB0aGUgYnVuZGxlIGluIGEgc2VwYXJhdGUgdGFzayBhbmQgdGhlbiBpbnZva2VzIHtAbGluayBvblNuYXBzaG90fSB3aXRoIGFcbiAqIHtAbGluayBRdWVyeX0gdGhhdCByZXByZXNlbnRzIHRoZSBRdWVyeSBpbiB0aGUgYnVuZGxlLlxuICpcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgZm9yIHRoZSB7QGxpbmsgb25TbmFwc2hvdH0gb3BlcmF0aW9uIHJlcXVlc3QuXG4gKiBAcGFyYW0ganNvbiAtIFRoZSBKU09OIGJ1bmRsZSB0byBsb2FkLCBwcm9kdWNlZCBieSB7QGxpbmsgUXVlcnlTbmFwc2hvdC50b0pTT059LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGNvbnRyb2xsaW5nIHRoZSBsaXN0ZW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0gb2JzZXJ2ZXIgLSBBIHNpbmdsZSBvYmplY3QgY29udGFpbmluZyBgbmV4dGAgYW5kIGBlcnJvcmAgY2FsbGJhY2tzLlxuICogQHBhcmFtIGNvbnZlcnRlciAtIEFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGNvbnZlcnRzIG9iamVjdHMgZnJvbSBGaXJlc3RvcmUgYmVmb3JlIHRoZSBvbk5leHRcbiAqIGxpc3RlbmVyIGlzIGludm9rZWQuXG4gKiBAcmV0dXJucyBBbiB1bnN1YnNjcmliZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgdG8gY2FuY2VsIHRoZSBzbmFwc2hvdFxuICogbGlzdGVuZXIuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG9uU25hcHNob3RRdWVyeVNuYXBzaG90QnVuZGxlKGRiLCBqc29uLCBvcHRpb25zLCBvYnNlcnZlciwgY29udmVydGVyKSB7XG4gICAgbGV0IHVuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgIGxldCBpbnRlcm5hbFVuc3Vic2NyaWJlO1xuICAgIGNvbnN0IGxvYWRUYXNrID0gbG9hZEJ1bmRsZShkYiwganNvbi5idW5kbGUpO1xuICAgIGxvYWRUYXNrXG4gICAgICAgIC50aGVuKCgpID0+IG5hbWVkUXVlcnkoZGIsIGpzb24uYnVuZGxlTmFtZSkpXG4gICAgICAgIC50aGVuKHF1ZXJ5ID0+IHtcbiAgICAgICAgaWYgKHF1ZXJ5ICYmICF1bnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWxRdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgaWYgKGNvbnZlcnRlcikge1xuICAgICAgICAgICAgICAgIHJlYWxRdWVyeS53aXRoQ29udmVydGVyKGNvbnZlcnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnRlcm5hbFVuc3Vic2NyaWJlID0gb25TbmFwc2hvdChxdWVyeSwgb3B0aW9ucyA/IG9wdGlvbnMgOiB7fSwgb2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICBpZiAob2JzZXJ2ZXIuZXJyb3IpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7IH07XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKHVuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHVuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIGlmIChpbnRlcm5hbFVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICBpbnRlcm5hbFVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGEgd3JpdGUgYmF0Y2gsIHVzZWQgZm9yIHBlcmZvcm1pbmcgbXVsdGlwbGUgd3JpdGVzIGFzIGEgc2luZ2xlXG4gKiBhdG9taWMgb3BlcmF0aW9uLiBUaGUgbWF4aW11bSBudW1iZXIgb2Ygd3JpdGVzIGFsbG93ZWQgaW4gYSBzaW5nbGUge0BsaW5rIFdyaXRlQmF0Y2h9XG4gKiBpcyA1MDAuXG4gKlxuICogVW5saWtlIHRyYW5zYWN0aW9ucywgd3JpdGUgYmF0Y2hlcyBhcmUgcGVyc2lzdGVkIG9mZmxpbmUgYW5kIHRoZXJlZm9yZSBhcmVcbiAqIHByZWZlcmFibGUgd2hlbiB5b3UgZG9uJ3QgbmVlZCB0byBjb25kaXRpb24geW91ciB3cml0ZXMgb24gcmVhZCBkYXRhLlxuICpcbiAqIEByZXR1cm5zIEEge0BsaW5rIFdyaXRlQmF0Y2h9IHRoYXQgY2FuIGJlIHVzZWQgdG8gYXRvbWljYWxseSBleGVjdXRlIG11bHRpcGxlXG4gKiB3cml0ZXMuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlQmF0Y2goZmlyZXN0b3JlKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBuZXcgV3JpdGVCYXRjaChmaXJlc3RvcmUsIG11dGF0aW9ucyA9PiBleGVjdXRlV3JpdGUoZmlyZXN0b3JlLCBtdXRhdGlvbnMpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIHNldEluZGV4Q29uZmlndXJhdGlvbihmaXJlc3RvcmUsIGpzb25PckNvbmZpZ3VyYXRpb24pIHtcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgaWYgKCFjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIgfHxcbiAgICAgICAgY2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyLl9vZmZsaW5lLmtpbmQgPT09ICdtZW1vcnknKSB7XG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogV2UgZG9uJ3QgcmV0dXJuIGFuIGVycm9yIGlmIHRoZSB1c2VyIGhhcyBub3QgZW5hYmxlZFxuICAgICAgICAvLyBwZXJzaXN0ZW5jZSBzaW5jZSBgZW5hYmxlSW5kZXhlZGRiUGVyc2lzdGVuY2UoKWAgY2FuIGZhaWwgb24gdGhlIFdlYi5cbiAgICAgICAgbG9nV2FybignQ2Fubm90IGVuYWJsZSBpbmRleGVzIHdoZW4gcGVyc2lzdGVuY2UgaXMgZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRJbmRleGVzID0gcGFyc2VJbmRleGVzKGpzb25PckNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRTZXRJbmRleENvbmZpZ3VyYXRpb24oY2xpZW50LCBwYXJzZWRJbmRleGVzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSW5kZXhlcyhqc29uT3JDb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgaW5kZXhDb25maWd1cmF0aW9uID0gdHlwZW9mIGpzb25PckNvbmZpZ3VyYXRpb24gPT09ICdzdHJpbmcnXG4gICAgICAgID8gdHJ5UGFyc2VKc29uKGpzb25PckNvbmZpZ3VyYXRpb24pXG4gICAgICAgIDoganNvbk9yQ29uZmlndXJhdGlvbjtcbiAgICBjb25zdCBwYXJzZWRJbmRleGVzID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5kZXhDb25maWd1cmF0aW9uLmluZGV4ZXMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhDb25maWd1cmF0aW9uLmluZGV4ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25Hcm91cCA9IHRyeUdldFN0cmluZyhpbmRleCwgJ2NvbGxlY3Rpb25Hcm91cCcpO1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluZGV4LmZpZWxkcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGluZGV4LmZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFBhdGhTdHJpbmcgPSB0cnlHZXRTdHJpbmcoZmllbGQsICdmaWVsZFBhdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRQYXRoID0gZmllbGRQYXRoRnJvbURvdFNlcGFyYXRlZFN0cmluZygnc2V0SW5kZXhDb25maWd1cmF0aW9uJywgZmllbGRQYXRoU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLmFycmF5Q29uZmlnID09PSAnQ09OVEFJTlMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBJbmRleFNlZ21lbnQoZmllbGRQYXRoLCAyIC8qIEluZGV4S2luZC5DT05UQUlOUyAqLykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLm9yZGVyID09PSAnQVNDRU5ESU5HJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChuZXcgSW5kZXhTZWdtZW50KGZpZWxkUGF0aCwgMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQub3JkZXIgPT09ICdERVNDRU5ESU5HJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChuZXcgSW5kZXhTZWdtZW50KGZpZWxkUGF0aCwgMSAvKiBJbmRleEtpbmQuREVTQ0VORElORyAqLykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VkSW5kZXhlcy5wdXNoKG5ldyBGaWVsZEluZGV4KEZpZWxkSW5kZXguVU5LTk9XTl9JRCwgY29sbGVjdGlvbkdyb3VwLCBzZWdtZW50cywgSW5kZXhTdGF0ZS5lbXB0eSgpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZEluZGV4ZXM7XG59XG5mdW5jdGlvbiB0cnlQYXJzZUpzb24oanNvbikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnRmFpbGVkIHRvIHBhcnNlIEpTT046ICcgKyBlPy5tZXNzYWdlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cnlHZXRTdHJpbmcoZGF0YSwgcHJvcGVydHkpIHtcbiAgICBpZiAodHlwZW9mIGRhdGFbcHJvcGVydHldICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnTWlzc2luZyBzdHJpbmcgdmFsdWUgZm9yOiAnICsgcHJvcGVydHkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVtwcm9wZXJ0eV07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgYFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcmAgZm9yIGNvbmZpZ3VyaW5nIHBlcnNpc3RlbnQgY2FjaGUgaW5kZXhlcyB1c2VkXG4gKiBmb3IgbG9jYWwgcXVlcnkgZXhlY3V0aW9uLlxuICpcbiAqIFRvIHVzZSwgY2FsbCBgZ2V0UGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyKClgIHRvIGdldCBhbiBpbnN0YW5jZS5cbiAqL1xuY2xhc3MgUGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyIHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xuICAgIGNvbnN0cnVjdG9yKF9maXJlc3RvcmUpIHtcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlID0gX2ZpcmVzdG9yZTtcbiAgICAgICAgLyoqIEEgdHlwZSBzdHJpbmcgdG8gdW5pcXVlbHkgaWRlbnRpZnkgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MuICovXG4gICAgICAgIHRoaXMudHlwZSA9ICdQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXInO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0aGUgUGVyc2lzdGVudENhY2hlIEluZGV4IE1hbmFnZXIgdXNlZCBieSB0aGUgZ2l2ZW4gYEZpcmVzdG9yZWBcbiAqIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgYFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcmAgaW5zdGFuY2UsIG9yIGBudWxsYCBpZiBsb2NhbFxuICogcGVyc2lzdGVudCBzdG9yYWdlIGlzIG5vdCBpbiB1c2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcihmaXJlc3RvcmUpIHtcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjYWNoZWRJbnN0YW5jZSA9IHBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlckJ5RmlyZXN0b3JlLmdldChmaXJlc3RvcmUpO1xuICAgIGlmIChjYWNoZWRJbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gY2FjaGVkSW5zdGFuY2U7XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICBpZiAoY2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyPy5fb2ZmbGluZS5raW5kICE9PSAncGVyc2lzdGVudCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcihmaXJlc3RvcmUpO1xuICAgIHBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlckJ5RmlyZXN0b3JlLnNldChmaXJlc3RvcmUsIGluc3RhbmNlKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG4vKipcbiAqIEVuYWJsZXMgdGhlIFNESyB0byBjcmVhdGUgcGVyc2lzdGVudCBjYWNoZSBpbmRleGVzIGF1dG9tYXRpY2FsbHkgZm9yIGxvY2FsXG4gKiBxdWVyeSBleGVjdXRpb24gd2hlbiB0aGUgU0RLIGJlbGlldmVzIGNhY2hlIGluZGV4ZXMgY2FuIGhlbHAgaW1wcm92ZVxuICogcGVyZm9ybWFuY2UuXG4gKlxuICogVGhpcyBmZWF0dXJlIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQuXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZVBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uKGluZGV4TWFuYWdlcikge1xuICAgIHNldFBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZChpbmRleE1hbmFnZXIsIHRydWUpO1xufVxuLyoqXG4gKiBTdG9wcyBjcmVhdGluZyBwZXJzaXN0ZW50IGNhY2hlIGluZGV4ZXMgYXV0b21hdGljYWxseSBmb3IgbG9jYWwgcXVlcnlcbiAqIGV4ZWN1dGlvbi4gVGhlIGluZGV4ZXMgd2hpY2ggaGF2ZSBiZWVuIGNyZWF0ZWQgYnkgY2FsbGluZ1xuICogYGVuYWJsZVBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uKClgIHN0aWxsIHRha2UgZWZmZWN0LlxuICovXG5mdW5jdGlvbiBkaXNhYmxlUGVyc2lzdGVudENhY2hlSW5kZXhBdXRvQ3JlYXRpb24oaW5kZXhNYW5hZ2VyKSB7XG4gICAgc2V0UGVyc2lzdGVudENhY2hlSW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkKGluZGV4TWFuYWdlciwgZmFsc2UpO1xufVxuLyoqXG4gKiBSZW1vdmVzIGFsbCBwZXJzaXN0ZW50IGNhY2hlIGluZGV4ZXMuXG4gKlxuICogUGxlYXNlIG5vdGUgdGhpcyBmdW5jdGlvbiB3aWxsIGFsc28gZGVsZXRlcyBpbmRleGVzIGdlbmVyYXRlZCBieVxuICogYHNldEluZGV4Q29uZmlndXJhdGlvbigpYCwgd2hpY2ggaXMgZGVwcmVjYXRlZC5cbiAqL1xuZnVuY3Rpb24gZGVsZXRlQWxsUGVyc2lzdGVudENhY2hlSW5kZXhlcyhpbmRleE1hbmFnZXIpIHtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGluZGV4TWFuYWdlci5fZmlyZXN0b3JlKTtcbiAgICBjb25zdCBwcm9taXNlID0gZmlyZXN0b3JlQ2xpZW50RGVsZXRlQWxsRmllbGRJbmRleGVzKGNsaWVudCk7XG4gICAgcHJvbWlzZVxuICAgICAgICAudGhlbihfID0+IGxvZ0RlYnVnKCdkZWxldGluZyBhbGwgcGVyc2lzdGVudCBjYWNoZSBpbmRleGVzIHN1Y2NlZWRlZCcpKVxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4gbG9nV2FybignZGVsZXRpbmcgYWxsIHBlcnNpc3RlbnQgY2FjaGUgaW5kZXhlcyBmYWlsZWQnLCBlcnJvcikpO1xufVxuZnVuY3Rpb24gc2V0UGVyc2lzdGVudENhY2hlSW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkKGluZGV4TWFuYWdlciwgaXNFbmFibGVkKSB7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChpbmRleE1hbmFnZXIuX2ZpcmVzdG9yZSk7XG4gICAgY29uc3QgcHJvbWlzZSA9IGZpcmVzdG9yZUNsaWVudFNldFBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZChjbGllbnQsIGlzRW5hYmxlZCk7XG4gICAgcHJvbWlzZVxuICAgICAgICAudGhlbihfID0+IGxvZ0RlYnVnKGBzZXR0aW5nIHBlcnNpc3RlbnQgY2FjaGUgaW5kZXggYXV0byBjcmVhdGlvbiBgICtcbiAgICAgICAgYGlzRW5hYmxlZD0ke2lzRW5hYmxlZH0gc3VjY2VlZGVkYCkpXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiBsb2dXYXJuKGBzZXR0aW5nIHBlcnNpc3RlbnQgY2FjaGUgaW5kZXggYXV0byBjcmVhdGlvbiBgICtcbiAgICAgICAgYGlzRW5hYmxlZD0ke2lzRW5hYmxlZH0gZmFpbGVkYCwgZXJyb3IpKTtcbn1cbi8qKlxuICogTWFwcyBgRmlyZXN0b3JlYCBpbnN0YW5jZXMgdG8gdGhlaXIgY29ycmVzcG9uZGluZ1xuICogYFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcmAgaW5zdGFuY2VzLlxuICpcbiAqIFVzZSBhIGBXZWFrTWFwYCBzbyB0aGF0IHRoZSBtYXBwaW5nIHdpbGwgYmUgYXV0b21hdGljYWxseSBkcm9wcGVkIHdoZW4gdGhlXG4gKiBgRmlyZXN0b3JlYCBpbnN0YW5jZSBpcyBnYXJiYWdlIGNvbGxlY3RlZC4gVGhpcyBlbXVsYXRlcyBhIHByaXZhdGUgbWVtYmVyXG4gKiBhcyBkZXNjcmliZWQgaW4gaHR0cHM6Ly9nb28uZ2xlLzQ1NHl2dWcuXG4gKi9cbmNvbnN0IHBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlckJ5RmlyZXN0b3JlID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGVzdGluZyBob29rcyBmb3IgdXNlIGJ5IEZpcmVzdG9yZSdzIGludGVncmF0aW9uIHRlc3Qgc3VpdGUgdG8gcmVhY2ggaW50byB0aGVcbiAqIFNESyBpbnRlcm5hbHMgdG8gdmFsaWRhdGUgbG9naWMgYW5kIGJlaGF2aW9yIHRoYXQgaXMgbm90IHZpc2libGUgZnJvbSB0aGVcbiAqIHB1YmxpYyBBUEkgc3VyZmFjZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgVGVzdGluZ0hvb2tzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIGNyZWF0ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgbm90aWZpZWQgd2hlbiBhbiBleGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoXG4gICAgICogb2NjdXJzIGluIHRoZSBXYXRjaCBsaXN0ZW4gc3RyZWFtLlxuICAgICAqXG4gICAgICogVGhlIHJlbGF0aXZlIG9yZGVyIGluIHdoaWNoIGNhbGxiYWNrcyBhcmUgbm90aWZpZWQgaXMgdW5zcGVjaWZpZWQ7IGRvIG5vdFxuICAgICAqIHJlbHkgb24gYW55IHBhcnRpY3VsYXIgb3JkZXJpbmcuIElmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgcmVnaXN0ZXJlZCBtdWx0aXBsZVxuICAgICAqIHRpbWVzIHRoZW4gaXQgd2lsbCBiZSBub3RpZmllZCBtdWx0aXBsZSB0aW1lcywgb25jZSBwZXIgcmVnaXN0cmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gdGhlIGNhbGxiYWNrIHRvIGludm9rZSB1cG9uIGV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2guXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCB1bnJlZ2lzdGVycyB0aGUgZ2l2ZW4gY2FsbGJhY2s7IG9ubHlcbiAgICAgKiB0aGUgZmlyc3QgaW52b2NhdGlvbiBvZiB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gZG9lcyBhbnl0aGluZzsgYWxsIHN1YnNlcXVlbnRcbiAgICAgKiBpbnZvY2F0aW9ucyBkbyBub3RoaW5nLlxuICAgICAqL1xuICAgIHN0YXRpYyBvbkV4aXN0ZW5jZUZpbHRlck1pc21hdGNoKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBUZXN0aW5nSG9va3NTcGlJbXBsLmluc3RhbmNlLm9uRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2goY2FsbGJhY2spO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIGltcGxlbWVudGF0aW9uIG9mIGBUZXN0aW5nSG9va3NTcGlgLlxuICovXG5jbGFzcyBUZXN0aW5nSG9va3NTcGlJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5leGlzdGVuY2VGaWx0ZXJNaXNtYXRjaENhbGxiYWNrc0J5SWQgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgaW5zdGFuY2UoKSB7XG4gICAgICAgIGlmICghdGVzdGluZ0hvb2tzU3BpSW1wbEluc3RhbmNlKSB7XG4gICAgICAgICAgICB0ZXN0aW5nSG9va3NTcGlJbXBsSW5zdGFuY2UgPSBuZXcgVGVzdGluZ0hvb2tzU3BpSW1wbCgpO1xuICAgICAgICAgICAgc2V0VGVzdGluZ0hvb2tzU3BpKHRlc3RpbmdIb29rc1NwaUltcGxJbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlc3RpbmdIb29rc1NwaUltcGxJbnN0YW5jZTtcbiAgICB9XG4gICAgbm90aWZ5T25FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaChpbmZvKSB7XG4gICAgICAgIHRoaXMuZXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hDYWxsYmFja3NCeUlkLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soaW5mbykpO1xuICAgIH1cbiAgICBvbkV4aXN0ZW5jZUZpbHRlck1pc21hdGNoKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGlkID0gU3ltYm9sKCk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuZXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hDYWxsYmFja3NCeUlkO1xuICAgICAgICBjYWxsYmFja3Muc2V0KGlkLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiBjYWxsYmFja3MuZGVsZXRlKGlkKTtcbiAgICB9XG59XG5sZXQgdGVzdGluZ0hvb2tzU3BpSW1wbEluc3RhbmNlID0gbnVsbDtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnJlZ2lzdGVyRmlyZXN0b3JlKCdub2RlJyk7XG5cbmV4cG9ydCB7IEFnZ3JlZ2F0ZUZpZWxkLCBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90LCBEb2N1bWVudFNuYXBzaG90LCBQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXIsIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCwgUXVlcnlDb25zdHJhaW50LCBRdWVyeURvY3VtZW50U25hcHNob3QsIFF1ZXJ5RW5kQXRDb25zdHJhaW50LCBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludCwgUXVlcnlMaW1pdENvbnN0cmFpbnQsIFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnQsIFF1ZXJ5U25hcHNob3QsIFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQsIFNuYXBzaG90TWV0YWRhdGEsIFRyYW5zYWN0aW9uLCBXcml0ZUJhdGNoLCBUZXN0aW5nSG9va3MgYXMgX1Rlc3RpbmdIb29rcywgYWRkRG9jLCBhZ2dyZWdhdGVGaWVsZEVxdWFsLCBhZ2dyZWdhdGVRdWVyeVNuYXBzaG90RXF1YWwsIGFuZCwgYXZlcmFnZSwgY291bnQsIGRlbGV0ZUFsbFBlcnNpc3RlbnRDYWNoZUluZGV4ZXMsIGRlbGV0ZURvYywgZGlzYWJsZVBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uLCBkb2N1bWVudFNuYXBzaG90RnJvbUpTT04sIGVuYWJsZVBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uLCBlbmRBdCwgZW5kQmVmb3JlLCBleGVjdXRlV3JpdGUsIGdldEFnZ3JlZ2F0ZUZyb21TZXJ2ZXIsIGdldENvdW50RnJvbVNlcnZlciwgZ2V0RG9jLCBnZXREb2NGcm9tQ2FjaGUsIGdldERvY0Zyb21TZXJ2ZXIsIGdldERvY3MsIGdldERvY3NGcm9tQ2FjaGUsIGdldERvY3NGcm9tU2VydmVyLCBnZXRQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXIsIGxpbWl0LCBsaW1pdFRvTGFzdCwgbWVtb3J5RWFnZXJHYXJiYWdlQ29sbGVjdG9yLCBtZW1vcnlMb2NhbENhY2hlLCBtZW1vcnlMcnVHYXJiYWdlQ29sbGVjdG9yLCBvblNuYXBzaG90LCBvblNuYXBzaG90UmVzdW1lLCBvblNuYXBzaG90c0luU3luYywgb3IsIG9yZGVyQnksIHBlcnNpc3RlbnRMb2NhbENhY2hlLCBwZXJzaXN0ZW50TXVsdGlwbGVUYWJNYW5hZ2VyLCBwZXJzaXN0ZW50U2luZ2xlVGFiTWFuYWdlciwgcXVlcnksIHF1ZXJ5U25hcHNob3RGcm9tSlNPTiwgcnVuVHJhbnNhY3Rpb24sIHNldERvYywgc2V0SW5kZXhDb25maWd1cmF0aW9uLCBzbmFwc2hvdEVxdWFsLCBzdGFydEFmdGVyLCBzdGFydEF0LCBzdW0sIHVwZGF0ZURvYywgd2hlcmUsIHdyaXRlQmF0Y2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@firebase+firestore@4.11.0_@firebase+app@0.14.8/node_modules/@firebase/firestore/dist/index.node.mjs\n");

/***/ })

};
;